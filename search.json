[{"title":"有道云笔记导出为markdown","path":"/posts/11491.html","content":"有道云笔记作为一款常用的云端笔记工具，承载了我们大量的资料和创作。然而，其在内容复制、文章目录显示等方面的一些限制，有时会给我们的使用带来不便。为了更自由地管理和迁移我的笔记，我找到了将笔记导出为通用 Markdown 格式的方法。 本文将介绍两种行之有效的方法： 油猴脚本：适合单篇笔记的即时导出，尤其适用于那些经常需要修改和分享的文章。 Python 脚本：一个功能强大的批量导出方案，适合一次性备份或迁移全部笔记。 方法一：使用油猴脚本（单篇、即时导出） 这个方法通过在浏览器中安装一个简单的脚本，为你的有道云笔记分享页面增加一个“导出为 MD”的按钮，实现一键下载。 1. 安装油猴（Tampermonkey）扩展 油猴是一款强大的浏览器扩展，它允许用户运行自定义脚本来增强网页功能。 Chrome 浏览器: 篡改猴 - Chrome 应用商店 Edge 浏览器: 篡改猴 - Microsoft Edge 扩展 国内备用地址: 篡改猴 - Crx 搜搜 国内用户建议选择第二个或第三个链接进行安装 2. 导入导出脚本 安装好油猴扩展后，你有两种方式来导入脚本 方式 A：直接安装 (推荐) 直接点击下方链接即可一键安装： - 国外 点击此处安装脚本 - 国内 点击此处安装脚本 方式 B：手动创建 (备用方案) 如果无法访问上述链接，请按以下步骤手动创建脚本： 在浏览器右上角找到“篡改猴”扩展图标，点击它，然后选择“添加新脚本”。 在打开的编辑器页面中，清空所有默认内容，然后将下面的完整代码粘贴进去。 按下 Ctrl + S 保存脚本，即可完成安装。 脚本代码： // ==UserScript==// @name 有道云笔记导出为markdown// @name:en Youdao Note Exporter to Markdown// @namespace https://github.com/your-username/youdao-note-exporter// @version 3.0// @description 在有道云笔记分享页面添加一个按钮，用于将笔记内容导出为Markdown文件。智能识别富文本和Markdown两种页面类型并进行相应处理。// @description:en Add a button on Youdao Note share pages to export content as a Markdown file. Intelligently handles both rich text and Markdown note types.// @author SkyForever// @match https://share.note.youdao.com/*// @match https://note.youdao.com/ynoteshare/*// @grant none// @license MIT// @downloadURL https://update.greasyfork.org/scripts/550754/%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E4%B8%BAmarkdown.user.js// @updateURL https://update.greasyfork.org/scripts/550754/%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E4%B8%BAmarkdown.meta.js// ==/UserScript==(function () use strict; // --- 富文本解析模块 (旧版页面) --- const richTextParser = parseNode: function (node) if (node.nodeType === 3) return node.textContent; if (node.nodeType !== 1) return ; let innerMarkdown = Array.from(node.childNodes) .map((child) = this.parseNode(child)) .join(); const isBold = node.style.fontWeight === bold || node.classList.contains(bold); if (isBold innerMarkdown.trim() !== ) if (!innerMarkdown.startsWith(**) !innerMarkdown.endsWith(**)) innerMarkdown = `**$innerMarkdown**`; if (node.tagName.toLowerCase() === a node.hasAttribute(href)) return `[$innerMarkdown]($node.getAttribute(href))`; if (node.tagName.toLowerCase() === br) return ; return innerMarkdown; , convertHeading: function (block) const level = parseInt(block.dataset.headingLevel.replace(h, ), 10); return `$#.repeat(level) $this.parseNode(block).trim()`; , convertParagraph: function (block) const text = this.parseNode(block).trim(); return text === (block.innerHTML.includes(nbsp;) || block.textContent.trim() === ) ? : text; , convertImage: function (block) const img = block.querySelector(img); return img ? `![image]($img.getAttribute(src))` : ; , convertListItem: function (block) const li = block.querySelector(li); if (!li) return null; const text = this.parseNode(li).trim(); let prefix = * ; const placeholder = block.querySelector(.item-list-placeholder); let indent = ; if (placeholder placeholder.style.left) const left = parseInt(placeholder.style.left, 10); if (left 0) indent = .repeat(Math.round(left / 28)); if (block.hasAttribute(start)) prefix = `$placeholder ? placeholder.textContent.trim() : 1. `; return `$indent$prefix$text`; , convertCodeBlock: function (block) const langElement = block.querySelector(.change-language .css-u30aqu); const lang = langElement ? langElement.textContent.trim().toLowerCase() : ; const codeLines = Array.from( block.querySelectorAll(pre[data-block-type=code-line]) ).map((pre) = pre.textContent); return `\\`\\`\\`$lang $codeLines.join( ) \\`\\`\\``; , run: function (editor) const blocks = Array.from(editor.children); const markdownLines = []; blocks.forEach((block) = let mdLine = null; const blockType = block.dataset.blockType; if (block.tagName.toLowerCase() === ul blockType === list-item) mdLine = this.convertListItem(block); else switch (blockType) case heading: mdLine = this.convertHeading(block); break; case paragraph: mdLine = this.convertParagraph(block); break; case image: mdLine = this.convertImage(block); break; case code: mdLine = this.convertCodeBlock(block); break; default: if (block.textContent block.textContent.trim()) mdLine = this.parseNode(block); break; if (mdLine !== null) markdownLines.push(mdLine); ); return formatMarkdownOutput(markdownLines); , ; // --- Markdown 原生页面解析模块 (新版页面) --- const markdownParser = // 由于是原生Markdown渲染，直接从HTML标签转换 run: function (editor) const TurndownService = window.TurndownService || (function () // 内联一个简化的turndown版本或提示用户安装 alert( Turndown library not found. Please add `@require https://unpkg.com/turndown/dist/turndown.js` to the script header. ); return function () this.turndown = (text) = text; ; )(); const turndownService = new TurndownService( codeBlockStyle: fenced ); return turndownService.turndown(editor.innerHTML); , ; /** * 格式化Markdown输出，处理换行 */ function formatMarkdownOutput(lines) let fullMarkdown = ; for (let i = 0; i lines.length; i++) if (lines[i].trim() === (i === 0 || lines[i - 1].trim() === )) continue; fullMarkdown += lines[i]; const isCurrentList = /^((\\s*[-*]|\\s*\\d+\\.)\\s)/.test(lines[i]); const isNextList = i + 1 lines.length /^((\\s*[-*]|\\s*\\d+\\.)\\s)/.test(lines[i + 1]); fullMarkdown += isCurrentList isNextList ? : ; return fullMarkdown.trim(); /** * 主导出函数 */ function exportToMarkdown() const iframe = document.getElementById(content-body); if (!iframe) alert(错误：未找到笔记内容的iframe框架！); return; const iframeDoc = iframe.contentDocument || iframe.contentWindow.document; if (!iframeDoc) alert(错误：无法访问iframe的文档内容！); return; let markdownContent = ; const noteTitle = document.querySelector(.file-name)?.title || youdao-note; // 判断页面类型 if (iframeDoc.querySelector(.bulb-editor-inner)) // 旧版富文本 console.log(检测到富文本笔记，使用富文本解析器。); const editor = iframeDoc.querySelector(.bulb-editor-inner); markdownContent = richTextParser.run(editor); else if (iframeDoc.querySelector(.markdown-body)) // 新版Markdown console.log(检测到Markdown笔记，使用Turndown解析器。); // 动态加载turndown库 loadScript(https://unpkg.com/turndown/dist/turndown.js, () = const editor = iframeDoc.querySelector(.markdown-body); markdownContent = markdownParser.run(editor); downloadMarkdown(markdownContent, noteTitle); ); return; // 异步执行，直接返回 else alert(错误：未识别的笔记类型或内容未加载！); return; downloadMarkdown(markdownContent, noteTitle); /** * 统一的下载处理函数 */ function downloadMarkdown(content, title) const safeFilename = title.replace(/[\\\\/:*?|]/g, -).replace(/\\s+/g, _) || youdao-note; downloadFile(content, `$safeFilename.md`); /** * 下载文件工具函数 */ function downloadFile(content, filename) const blob = new Blob([content], type: text/markdown;charset=utf-8 ); const url = URL.createObjectURL(blob); const a = document.createElement(a); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); /** * 动态加载外部JS脚本 */ function loadScript(url, callback) if (window.TurndownService) // 如果已加载，直接回调 callback(); return; const script = document.createElement(script); script.src = url; script.onload = callback; script.onerror = () = alert(加载Turndown库失败，请检查网络连接或脚本设置。); document.head.appendChild(script); /** * 在页面上创建并添加导出按钮 */ function addExportButton() if (document.getElementById(export-md-button)) return; const button = document.createElement(button); button.id = export-md-button; button.textContent = 导出为MD; button.style.position = fixed; button.style.bottom = 20px; button.style.right = 20px; button.style.zIndex = 9999; button.style.padding = 10px 15px; button.style.backgroundColor = #4CAF50; button.style.color = white; button.style.border = none; button.style.borderRadius = 5px; button.style.cursor = pointer; button.style.fontSize = 14px; button.style.boxShadow = 0 2px 5px rgba(0,0,0,0.2); button.addEventListener( mouseover, () = (button.style.backgroundColor = #45a049) ); button.addEventListener( mouseout, () = (button.style.backgroundColor = #4CAF50) ); button.addEventListener(click, exportToMarkdown); document.body.appendChild(button); // 使用MutationObserver来监控DOM变化，确保iframe加载后能及时添加按钮 const observer = new MutationObserver((mutations, obs) = const iframe = document.getElementById(content-body); if (iframe) const iframeDoc = iframe.contentDocument || iframe.contentWindow.document; if ( iframeDoc (iframeDoc.querySelector(.bulb-editor-inner) || iframeDoc.querySelector(.markdown-body)) ) addExportButton(); obs.disconnect(); // 找到后停止观察 ); observer.observe(document.body, childList: true, subtree: true, );)(); 3. 开始使用 完成以上步骤后，打开任意一篇有道云笔记的分享链接。你会发现页面右下角出现了一个绿色的“导出为 MD”按钮。点击它，当前笔记就会被自动转换为 .md 文件并下载到本地。 方法二：使用 Python 脚本（批量、完整备份） 当你需要导出大量笔记，或者希望进行一次完整的本地备份时，使用由 Github 里其他大佬编写的 Python 脚本会是更高效的选择 1. 准备环境并下载项目 首先，确保你的电脑上安装了 Git 和 Python 3 安装 Git: 可参考 廖雪峰 Git 教程 进行安装。 安装 Python: 可参考 廖雪峰 Python 教程 进行安装 然后，打开命令行工具（如 Terminal 或 PowerShell），克隆项目代码： git clone https://github.com/chunxingque/youdaonote-pull.gitcd youdaonote-pull 2. 安装项目依赖 进入项目目录后，使用 pip 安装所需的依赖库。 Windows: pip install -r requirements.txt macOS / Linux: pip3 install -r requirements.txt 提示：建议使用虚拟环境（如 venv）来管理项目依赖，以避免与系统全局环境冲突。 3. 配置登录 Cookies 由于有道云笔记的登录机制更新，该脚本目前不支持账号密码登录，需要通过配置 Cookies 来获取访问权限。 获取 Cookies 的便捷方法： 手动在开发者工具中寻找 Cookies 字段既繁琐又容易出错。你可以使用以下 JavaScript 脚本快速生成所需的 JSON 配置。 在浏览器中登录你的有道云笔记网页版。 按 F12 打开开发者工具，切换到 Network (网络) 标签页。 刷新页面，找到一个主请求（通常是第一个），在 Headers (标头) 下找到 Request Headers (请求标头) 中的 Cookie 字段，并复制其完整的字符串值。 切换到 Console (控制台) 标签页，粘贴以下代码，并将 '这里把上图Cookie属性的值丢进来' 替换为你刚刚复制的字符串，然后按回车 var tmp_cookie = 这里把上图Cookie属性的值丢进来;function getCookies() var cookies = tmp_cookie.split(;); var result = []; for (var i = 0; i cookies.length; i++) var cookie = cookies[i].trim(); var parts = cookie.split(=); var name = parts[0]; var value = parts[1]; if ( name === YNOTE_CSTK || name === YNOTE_LOGIN || name === YNOTE_SESS ) result.push([name, value, .note.youdao.com, /]); return result;var formattedCookies = cookies: getCookies() ;console.warn(JSON.stringify(formattedCookies, null, 2)); 控制台会输出一段格式化好的 JSON 内容。将其完整复制 在项目根目录下创建一个名为 cookies.json 的文件，并将复制的内容粘贴进去 4. 配置脚本参数 在项目根目录下，找到并编辑 config.json 文件，根据你的需求进行设置 local_dir: , ydnote_dir: , smms_secret_token: , is_relative_path: true, del_spare_file: false, del_spare_dir: false local_dir: 本地存储目录。选填，导出的笔记将存放在这里，不填则默认为当前项目文件夹。 ydnote_dir: 有道云笔记目录。选填，指定要导出的云端文件夹路径，如 根目录/子目录。不填则默认导出所有笔记。 smms_secret_token: SM.MS 图床 Token。选填，用于将笔记中的图片上传到 SM.MS 图床。不填则图片会下载到本地。 is_relative_path: 图片/附件路径。默认为 true，在 Markdown 文件中使用相对路径引用本地图片和附件。 del_spare_file: 删除多余文件。设为 true 时，脚本会删除本地存在但云端已删除的文件。 del_spare_dir: 删除多余目录。设为 true 时，脚本会删除本地存在但云端已删除的目录。 注意：del_spare_file 和 del_spare_dir 是为了同步本地与云端的状态。建议先开启 del_spare_file 自动清理，目录则根据情况手动清理 5. 执行导出与后续更新 首次运行 配置完成后，在命令行中运行脚本： # Windowspython pull_notes.py# macOS / Linuxpython3 pull_notes.py 脚本将开始拉取并转换你的笔记。如果遇到某个笔记拉取失败，可能是其格式较旧，可以尝试在有道云中新建一篇笔记，将旧内容复制过去再重新运行脚本 后续更新 再次运行相同的命令即可。脚本会根据文件的最后修改时间智能判断，只更新那些在云端被修改过或新增的笔记，不会覆盖你在本地修改过的文件 重要提示：请避免同时在有道云和本地修改同一篇笔记，这可能导致本地的修改在同步时被覆盖丢失 总结 本文介绍了两种将有道云笔记导出为 Markdown 的方法： 油猴脚本：轻量、便捷，非常适合即时导出单篇文章 Python 脚本：强大、全面，是进行批量迁移和完整备份的不二之选 根据你的具体需求，选择合适的方法，即可轻松地将你的知识库掌握在自己手中","tags":["有道云笔记","Markdown","油猴脚本","Python"],"categories":["技术教程"]},{"title":"解决 GitHub 无法访问问题","path":"/posts/46597.html","content":"本文最后更新时间：2025-10-13，部分链接可能因为未及时更新而失效，简单的介绍了几个 github 镜像地址，在某些时候无法打开 github 的特殊情况下，偶尔可以解燃煤之急，有需要的小伙伴可以添加收藏 题外话 github 又名 gayhub，是全球最大的男性交友社区平台（当然，这只是一句调侃）。 github 是一个面向开源及私有软件项目的托管平台，其日常用户主要是程序员为主，上面优秀的开源项目不计其数。虽然是一个程序员社区，不过因为上面涵盖内容非常广泛，各种实用资源也非常丰富，所以其实各行各业的小伙伴日常中或多或少都要接触到 github。 github 无法访问并不是 Github 自身网络问题，而是有一双无形的大手对 Github 域名进行了干扰（2021 年 3 月开始），模拟丢包、伪装成网站自身问题。只要将任意 IP 指向 Github 去访问，该 IP 的 443 端口就会超时 3 分钟。因为是随机针对的（伪装成网站自身网络问题），所以有时候会碰到 “短暂” 可用的 IP，这影响了我们的开发 下面介绍几个加速 GitHub 访问的方法 Watt Toolkit（原 Steam++）(推荐） Watt Toolkit 是一款集成了多种实用功能的 Windows 应用程序，主要面向游戏玩家和开发者 它提供了一键加速访问 GitHub、Huggingface 和公共 CDN 的功能，帮助用户在国内网络环境下更顺畅地访问这些平台 下载方式（推荐 Gitee 镜像） 官网直达：Watt Toolkit（点击「下载」后，选择蓝奏云网盘或者 gitee 下载） 备用通道：Gitee 镜像站，选择最靠前的正式版本 电脑是 win 系统，选择： 微软商店：搜索 “Watt Toolkit”，适合 Win11 用户（自动更新更省心） 微软商店链接：https://apps.microsoft.com/detail/9mtcfhs560ng?hl=zh-CN 安装步骤（Windows 为例） 双击安装包，选择「自定义安装」 取消勾选「开机自启」（开发者可根据需求保留） 安装完成后，桌面会生成绿色齿轮图标，右键「以管理员身份运行」（首次需权限） 使用教程 打开软件，左侧勾选「GitHub」「Huggingface」「公共 CDN」（建议全选） 点击「一键加速」，等待右下角出现「加速成功」提示（约 5 秒） 成功在国内网络下流畅打开GitHub 使用科学上网 使用一些科学上网工具如 clash 来访问 github，在 clash 里配置好相关规则即可 只有科学上网才可以完美解决 github 访问问题 例如，在克隆 GitHub 仓库时，直接在终端输入 git clone 大概率会失败 配置好 git proxy 之后，才能顺利克隆 git config --global http.proxy http://127.0.0.1:7897git config --global https.proxy http://127.0.0.1:7897 注意：上面的 7897 端口号根据你自己的代理软件端口号来设置 github 镜像网站 下面是一系列 Github 镜像网站 Githup Proxy：https://github.akams.cn/ 虾壳：https://xiake.pro/ kkgithub：https://kkgithub.com/ Githup ProxyUI：https://git.mxg.pub/ gitclone：https://gitclone.com/ github 加速下载：https://github.ur1.fun/ Github Proxy：https://ghfast.top/ 上面的地址均收集于互联网，链接可能随时失效。 具体使用方法就是找到你要访问的 github 资源页面，然后域名进行替换，其余后缀地址保持不变即可 除此之外，还可以通过修改 hosts 的方式也可以加速访问 GitHub github hosts (推荐) 按照这两个网址里的教程操作即可，有一定的技术门槛 推荐一：https://hosts.gitcdn.top/ 推荐二：https://gitlab.com/ineo6/hosts/-/raw/master/hosts 使用 DownGit 下载 GitHub 仓库文件 如果你只想下载 GitHub 上的某个文件夹或单个文件，而不想克隆整个仓库，可以使用 DownGit 工具。它可以帮助你生成一个直接下载链接，方便快捷。 访问 DownGit 网站：https://minhaskamal.github.io/DownGit/#/home 在输入框中粘贴你想下载的 GitHub 文件夹或文件的 URL 点击“Download”按钮，生成下载链接 点击生成的链接即可下载所需的文件夹或文件","tags":["GitHub","镜像","加速","hosts","Watt Toolkit"]},{"title":"为博客搭建免费图床","path":"/posts/114521.html","content":"什么叫图床 图床就是将图片上传到相关服务商或者个人服务器，通过上传文件，转换为服务器的一个网络链接地址进行远程访问 可以方便快速的将图片插入到文章中，方便后续图片二次使用、迁移、分享 常用图床的几种方式 VPS 自建：通过购买服务器搭建图床程序，比如 easyimage，lsky-pro 等。 优点：方便，快捷，空间大 缺点：速度取决于 vps 的线路，迁移服务时大量数据需要迁移。 云端 oss 储存+cdn 优点：稳定，速度快 缺点：付费（腾讯 cos/阿里 oss+cdn(cdn 需备案)）。免费的额度有限（Backblaze B2 + Cloudflare）。 Github + JsDelivr(cdn) 优点：github 绝对稳定，jsdelivr 充当 github 的 cdn 加速 缺点：虽然有加速，速度也算不上快，属中等。 本篇介绍 CLoudFlare R2+Picgo 方案 CLoudFlare R2 免费用户有 10GB/月的存储额度（30 天内每天储存峰值的平均值），对于小网站基本足够，超额的存储是$0.015/GB/月， 标准储存：日常存储容量前 10GB/月免费（30 天内每天储存峰值的平均值） Daily Class A Transactions Caps：日常 B 类事务前 100 万次免费（A 类事务包括下载、获取文件） Daily Class B Transactions Caps：日常 A 类事务前 1000 万次免费（B 类事务包括创建存储桶、列举存储桶、列举文件版本、列举 Keys） 实现目的 1.自由在 MD，网站中引用图片（picgo 上传） 2.防止恶意被刷流量（虽然 CloudFlare 只收取额外的储存费用，但被刷流量多了容易被封号） 自定义域名代替原域名（出现问题直接断开和原域名之间的跳转） 设定缓存规则（有人盗刷也是刷缓存） 防盗链（只在规定的网站使用） CloudFlare R2 注册账号 注册账号需要绑定一种支付方式（不扣费，只是用来选择支付方式），可以用信用卡，visa，paypal。 注册地址：https://dash.cloudflare.com/sign-up，验证过邮箱后即可使用。 开通 CloudFlare R2 点击右侧的 R2 对象储存。 在弹出的界面输入付款方式（银联卡，paypal 都可以） 对于个人博客来说，使用量一般超不了。 确认后就可以开通 R2 对象储存了。 创建储存桶及桶设置 自定义图床域名 进入桶设置界面 设定访问桶的域名，有两种方法，一种是有一个私有域名（需托管在 Cloudflare 上），另一个是用 R2.dev 子域名 私有域名（二选一） 继续之后，点连接域，会自动生成 dns 记录。 之后就能浏览器 https://自定义域名/文件名访问存储桶里的文件了。 PS：如果域名不托管在 CloudFlare，可以单独托管二级\\三级域名，只需要给二级域名添加一条 NS 记录指向原托管即可。 R2.dev 子域名（二选一） 点击允许访问，就可以用 https://pub-853c2f66b8ef43ae98ecd186f4be34f8.r2.dev访问桶 设定缓存规则 缓存规则一般设定两个：浏览器缓存和边缘缓存。 浏览器缓存：访问后，所需文件储存在浏览器的本地目录，在一段时间内，再次访问优先访问本地文件 边缘缓存：访问后，缓存在最近的 CDN 存一份，在一段时间内，优先访问 CDN 中的文件 进入域名页面-规则-页面规则 创建页面规则 URL 填 img.a.com/* 添加设置：缓存级别 – 缓存所有内容 添加设置：浏览器缓存 TTL – 几个小时自己选（8 小时） 添加设置：边缘缓存 TTL – 一个月（图片内容只有存在或者删除两个状态，所以越长越好） 保存。此时如果有人刷流量，理论上图片都是本地缓存或者 CDN 缓存给的，不会走到 R2 对象存储。 防盗链设置 只能通过指定的网站来访问（防君子不防小人，可以伪造 refer 信息，照样刷流量）。 但是还是有点作用，比如别人爬取文章盗用的时候，图片是无法访问的。 安全性-WAF，创建规则 设置 CORS 策略（可选） 一般不需要设置（出于安全考虑这里也不建议设置）。如果遇到 R2 作为博客图床，但是图片打不开的情况，F12 控制台发现遇到 CORS 问题，则需要配置。 官方文档：Configure CORS 进入你想设置 CORS 的存储桶的设置，拉到下面： 配置为允许特定源 比如要设置为允许两个域名： [ AllowedOrigins: [https://blog.a.com, https://blog.b.top], AllowedMethods: [GET] ] 配置为所有网站源可访问（多平台文章引用） [ AllowedOrigins: [*], AllowedMethods: [GET] ] 配置为允许所有源 如果上面配置为特定源后仍然不能修复问题，或者作为随机图片 API 的图床提供服务需要设置为所有源可访问，那么需要如下设置： [ AllowedOrigins: [*], AllowedMethods: [GET, POST, PUT, DELETE, HEAD], AllowedHeaders: [*] ] WEB API 设置 有的 api 令牌就可以用软件（PICGO）自动上传图片了。 创建令牌 需要选择内容 令牌名 权限（对象读和写） 指定储存桶 TTL 时间（永久） 记住生成的密钥，picgo 软件里面设置需要。 picgo 设置 在插件设置中，添加常用插件。 S3 插件：用来登录 S3 的图床 compress-next:用来压缩图片至 webp。 watermark：给图片打水印 autoback：用来备份图床 安装好后，里面就新增了 amazon S3 的图床设置。 这里有几项配置需要尤其注意。 应用密钥 ID，填写 R2 API 中的 Access Key ID（访问密钥 ID） 应用密钥，填写 R2 API 中的Secret Access Key（机密访问密钥） 桶名，填写 R2 中创建的 Bucket 名称，如创建 R2 的桶的名字 img 文件路径，上传到 R2 中的文件路径，这里选择使用 fileName.extName (或者fullName)来保留原文件的文件名和扩展名。 自定义节点，填写 R2 API 中的「为 S3 客户端使用管辖权地特定的终结点」，即 xxx.r2.cloudflarestorage.com格式的 S3 Endpoint 自定义域名，填写上文生成的https://xxx.r2.dev格式的域名或自定义域名，如我配置的https://img.a.com ForcePathStyle：no关闭，否则会在最终路径里面显示有桶名。 拒绝无效 TLS 证书连接 ：yes开启，如果出现证书错误可以关闭 ACL 访问控制列表：public-read Bucket 前缀：false 完成上述配置后，我们就可以在「上传区」直接拖入文件进行图片上传了，如上传后显示无误则为配置成功，生成的链接会自动在系统剪贴板中，直接在需要的地方粘贴即可。 Typora 配置 点击文件 - 偏好设置 按照官方引导配置 Picgo 图床配置 点击验证图片上传选项,提示通过，即代表配置好了，未来在文章中插入图片会自动上传到图床"},{"title":"零成本搭建个人博客","path":"/posts/114520.html","content":"本文详细介绍了如何使用 Hexo 框架搭建一个个人博客，并将其部署到 GitHub Pages 和 Cloudflare Pages 上。主要内容包括： 环境准备：安装 Node.js 和 Git 配置 Git 和 GitHub：设置 SSH 密钥，创建 GitHub 仓库 初始化 Hexo 项目：安装 Hexo，创建新博客 部署到 GitHub Pages：配置部署设置，推送静态文件 部署到 Cloudflare Pages：连接 GitHub 仓库，自动部署 基本使用方法：创建新文章，本地预览，发布更新 这个教程适合那些想要快速搭建个人博客，但又不想花费太多成本的人。 通过使用 Hexo、GitHub 和 Cloudflare 的免费服务，你可以轻松免费创建一个高效、简洁的博客网站 1.事前准备 域名（非必须，你也可以使用免费域名，或者GitHub.io或Pages.dev分配的域名也可以） GitHub（必须，你需要注册一个 GitHub 帐号） Cloudflare（非必须，你需要注册一个 Cloudflare 帐号，这样你就可以将博客部署在 CF 的 CDN 里加速，但是你也可以直接使用GitHub.io分配的域名） 2.软件支持 Node（必须） Git（必须） VSCode（非必须，但推荐，VSCode 的插件系统会让自己的编程体验更加舒适） 2.1.安装 Node 打开 Node 官网，下载和自己系统相配的 Node 的安装程序，否则会出现安装问题。下载地址：https://nodejs.org/en 下载后安装，安装的目录可以使用默认目录C:/Program Files/nodejs/ 安装完成后，检查是否安装成功。在键盘按下 win + R 键，输入 CMD，然后回车，打开 CMD 窗口，执行node -v命令，看到版本信息，则说明安装成功 node -v 修改 npm 源。npm 下载各种模块，默认是从国处服务器下载，速度较慢，建议配置成华为云镜像源。打开 CMD 窗口，运行如下命令: npm config set registry https://mirrors.huaweicloud.com/repository/npm/ 2.2.安装 Git 进入官网下载适合你当前系统的 Git：https://git-scm.com/downloads 如果是Linux 系统输入以下命令即可直接安装： sudo apt install git-all 下载后傻瓜式安装 Git 即可，安装的目录最好使用默认目录C:/Program Files/Git 点击电脑左下角开始菜单即可看见Git CMD、Git Bash、Git GUI。 Git Bash 是 linux 系统的指令风格（建议使用） Git GUI是图形化界面（个人觉得不好用） 3.配置 Git 密钥并连接至 Github 常用 Git 命令 git config -l //查看所有配置git config --system --list //查看系统配置git config --global --list //查看用户（全局）配置 3.1. 配置用户名和邮箱 git config --global user.name 你的用户名git config --global user.email 你的邮箱 通过以下命令检查是否配置成功： git config -l 3.2. 配置公钥连接 Github 执行以下命令生成 ssh 公钥，此公钥用于你的计算机连接 Github ssh-keygen -t rsa -C 你的邮箱 提示 Enter file in which to save the key 直接一路回车即可 之后打开 C 盘下用户文件夹下的.ssh 的文件夹，会看到以下文件 id_rsa私钥 id_rsa.pub公钥 如果是 Linux，用以下命令跳转： cd ~/.ssh/ 再ls一下，即可看到密钥文件位置： 用记事本打开上述图片中的公钥id_rsa.pub，复制里面的内容，然后开始在 github 中配置 ssh 密钥。 linux 系统直接 cat 一下就行： 将 SSH KEY 配置到 GitHub 进入 github，点击右上角头像 选择settings，进入设置页后选择 SSH and GPG keys，名字随便起，公钥填到Key那一栏。 测试连接，输入以下命令 ssh -T git@github.com 第一次连接会提示 Are you sure you want to continue connecting (yes/no/[fingerprint])? 输入 yes 即可 出现连接到账户的信息，说明已经大功告成，至此完成了环境准备工作。 3.3. 创建 GitHub.io 仓库 点击右上角的+按钮，选择New repository，创建一个用户名.github.io的仓库。 仓库名字的格式必须为：用户名.github.io (注意：前缀必须为用户名，此为预览博客需要，后期可修改仓库名) 可见性必须选择 Public 方便第一次部署检查问题，点击 Creat repository 进行创建即可 4.初始化 Hexo 博客 创建一个文件夹来保存博客源码（我这里选的路径为D:/Hexo-Blog），在文件夹内右键鼠标，选择Open Git Bash here 在Git BASH输入如下命令安装 Hexo npm install -g hexo-cli hexo -v 安装完后输入hexo -v验证是否安装成功 , 上面的命令中已经包含了 hexo -v 初始化 Hexo 项目安装相关依赖。 hexo init blog-democd blog-demonpm i 初始化项目后，blog-demo有如下结构： node_modules：依赖包 scaffolds：生成文章的一些模板 source：用来存放你的文章 themes：主题 .npmignore：发布时忽略的文件（可忽略） _config.landscape.yml：主题的配置文件 config.yml：博客的配置文件 package.json：项目名称、描述、版本、运行和开发等信 输入hexo cl hexo s启动项目 hexo cl hexo s 按住ctrl点击命令行里的网址 或者打开浏览器，输入地址：http://localhost:4000/ ，看到下面的效果，说明你的博客已经构建成功了。 5.将静态博客挂载到 GitHub Pages 安装 hexo-deployer-git npm install hexo-deployer-git --save 修改 _config.yml 文件 在 blog-demo 目录下的_config.yml，就是整个 Hexo 框架的配置文件了。可以在里面修改大部分的配置。详细可参考官方的配置描述。 修改最后一行的配置，将 repository 修改为你自己的 github 项目地址即可，还有分支要改为main代表主分支（注意缩进）。 deploy: type: git repository: git@github.com:cmliussss2024/cmliussss2024.github.io.git branch: main 修改好配置后，运行如下命令，将代码部署到 GitHub（Hexo 三连）。 // Git BASH终端hexo clean hexo generate hexo deploy// 或者// VSCODE终端hexo cl; hexo g; hexo d hexo clean：删除之前生成的文件，可以用hexo cl缩写。 hexo generate：生成静态文章，可以用hexo g缩写 hexo deploy：部署文章，可以用hexo d缩写 注意：deploy 时可能要你输入 username 和 password。 如果出现Deploy done，则说明部署成功了。 稍等两分钟，打开浏览器访问：https://cmliussss2024.github.io ，这时候我们就可以看到博客内容了。 6.将静态博客挂载到 Cloudflare Pages 在 Workers 和 Pages 中选择 Pages 的 连接到 Git 然后登录你 Blog 仓库对应的 GitHub 帐号 点击保存并部署后等待部署完成即可。 提示成功！您的项目已部署到以下区域：全球后，浏览器访问：https://Github用户名-github-io.pages.dev ，这时候我们就可以看到博客内容了。 这时你也就可以将你的用户名.github.io的仓库设置为Private私库了 如果你有自己的域名，你可以在这里绑定你自己的自定义域，即可 7. 如何使用? 新建一篇博文 hexo new 这是一篇新的博文 然后用文本编辑器去编辑_posts/这是一篇新的博文.md里的内容即可，注意要使用Markdown格式书写。 详细使用方法可以查阅 https://hexo.io/zh-cn/docs/writing 或者在网上搜 Markdown教程 预览 编辑完文章保存后可以使用如下命令，生成本地页面 http://localhost:4000/ ，进行预览 hexo cl hexo s 推送 确认无误后使用以下命令，将本地文章推送至 GitHub 仓库即可 hexo cl hexo g hexo d"},{"title":"提升嵌入式开发幸福感的小技巧","path":"/posts/114516.html","content":"通过优化编译流程、改进部署方式和精简开发环境，我们可以将宝贵的时间更多地投入到业务逻辑和功能创新上，而不是浪费在繁琐的重复性操作中 0. 调整 lvgl 工程，使工程能支持切换平台 在开发嵌入式 GUI 应用（如 LVGL）时，最高效的方式是实现“PC 端模拟调试，开发板端实机运行”。这需要我们将工程调整为跨平台架构，让同一套源代码无需修改，即可在 x86 和 ARM 等不同平台上编译运行 开源示例工程：本文所有配置的完整实现，可以参考此开源项目： Github:Cross-LVGL-demo Gitee:cross-LVGL-demo 核心原理 利用 CMake 构建系统的平台判断能力，结合 C 语言的预处理指令，为不同平台链接不同的底层驱动。 PC 平台：使用 SDL2 (Simple DirectMedia Layer) 库来模拟显示窗口和鼠标键盘输入。 ARM 平台：使用嵌入式 Linux 标准的 Framebuffer (缓冲区刷新显示) 和 evdev (输入) 驱动。 第一步：改造构建系统 CMake 1. 创建独立的 ARM 工具链文件 (arm.cmake) 将交叉编译配置独立出来，使主配置文件更整洁。 # 设置目标系统名称set(CMAKE_SYSTEM_NAME Linux)set(CMAKE_SYSTEM_PROCESSOR arm)# 指定交叉编译工具链的路径set(TOOLCHAIN_DIR /usr/local/arm/5.4.0/usr/)# 指定编译器set(CMAKE_C_COMPILER $TOOLCHAIN_DIR/bin/arm-linux-gcc)set(CMAKE_CXX_COMPILER $TOOLCHAIN_DIR/bin/arm-linux-g++)set(CMAKE_C_FLAGS-Wl -rpath=.)# 指定 find_library, find_path 等命令的搜索路径模式# 从不搜索宿主系统路径，只在工具链路径中找程序set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)# 只在工具链路径中找库set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)# 只在工具链路径中找头文件set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)# 只在工具链路径中找 CMake 包配置文件set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY) 2. 修改主CMakeLists.txt，增加平台判断逻辑 使用 CMake 内置变量CMAKE_CROSSCOMPILING来自动识别当前编译环境。 cmake_minimum_required(VERSION 3.12)project(main C)set(CMAKE_C_STANDARD 99)set(CMAKE_C_STANDARD_REQUIRED ON)set(CMAKE_RUNTIME_OUTPUT_DIRECTORY $PROJECT_SOURCE_DIR/bin)# --- 平台配置 ---if(CMAKE_CROSSCOMPILING) set(TARGET_ARCH arm) set(PLATFORM_LIBS pthread freetype m)else() # PC set(TARGET_ARCH pc) find_package(SDL2 REQUIRED) find_package(Threads REQUIRED) set(PLATFORM_LIBS SDL2::SDL2 Threads::Threads freetype m)endif()link_directories(libs/freetype/lib/$TARGET_ARCH)execute_process(COMMAND bash configure.sh $TARGET_ARCH WORKING_DIRECTORY $CMAKE_CURRENT_SOURCE_DIR)# --- 头文件 ---include_directories( . libs/freetype/include UI lvgl lv_drivers # lv_demos # lv_examples)# --- 源文件 ---file(GLOB_RECURSE ALL_SOURCES lvgl/src/*.c lv_drivers/*.c lvgl/demos/*.c lvgl/examples/*.c UI/*.c)# --- 构建主程序 ---add_executable($PROJECT_NAME main.c mouse_cursor_icon.c $ALL_SOURCES)# --- 链接平台库 ---target_link_libraries($PROJECT_NAME PRIVATE $PLATFORM_LIBS) 3. 添加configure.sh脚本，自动修改 LVGL 配置文件 自动化修改lv_conf.h和lv_drv_conf.h中的宏定义。 #!/bin/bash# 检查参数数量if [ $# -ne 1 ]; then echo 用法: $0 pc|arm exit 1fiTARGET_ARCH=$1LV_DRV_CONF_PATH=lv_drv_conf.hLV_CONF_PATH=lv_conf.h# 检查文件是否存在if [ ! -f $LV_DRV_CONF_PATH ]; then echo 错误：未找到 lv_drv_conf.h 文件: $LV_DRV_CONF_PATH exit 1fiif [ ! -f $LV_CONF_PATH ]; then echo 错误：未找到 lv_conf.h 文件: $LV_CONF_PATH exit 1fiecho 正在为 $TARGET_ARCH 架构配置驱动和内核...if [ $TARGET_ARCH = pc ]; then # --- 配置 lv_drv_conf.h (驱动层) --- echo 配置 lv_drv_conf.h: 启用 SDL, 禁用 Framebuffer/evdev sed -i s/^\\([[:space:]]*#\\s*define\\s*USE_SDL\\s*\\)[01]/#define USE_SDL 1/ $LV_DRV_CONF_PATH sed -i s/^\\([[:space:]]*#\\s*define\\s*USE_FBDEV\\s*\\)[01]/#define USE_FBDEV 0/ $LV_DRV_CONF_PATH sed -i s/^\\([[:space:]]*#\\s*define\\s*USE_EVDEV\\s*\\)[01]/#define USE_EVDEV 0/ $LV_DRV_CONF_PATH # --- 配置 lv_conf.h (内核层) --- echo 配置 lv_conf.h: 禁用自定义 Tick (LV_TICK_CUSTOM=0)，因为 SDL 会处理 sed -i s/^\\([[:space:]]*#\\s*define\\s*LV_TICK_CUSTOM\\s*\\)[01]/#define LV_TICK_CUSTOM 0/ $LV_CONF_PATHelif [ $TARGET_ARCH = arm ]; then # --- 配置 lv_drv_conf.h (驱动层) --- echo 配置 lv_drv_conf.h: 禁用 SDL, 启用 Framebuffer/evdev sed -i s/^\\([[:space:]]*#\\s*define\\s*USE_SDL\\s*\\)[01]/#define USE_SDL 0/ $LV_DRV_CONF_PATH sed -i s/^\\([[:space:]]*#\\s*define\\s*USE_FBDEV\\s*\\)[01]/#define USE_FBDEV 1/ $LV_DRV_CONF_PATH sed -i s/^\\([[:space:]]*#\\s*define\\s*USE_EVDEV\\s*\\)[01]/#define USE_EVDEV 1/ $LV_DRV_CONF_PATH # --- 配置 lv_conf.h (内核层) --- echo 配置 lv_conf.h: 启用自定义 Tick (LV_TICK_CUSTOM=1) 以使用 custom_tick_get() sed -i s/^\\([[:space:]]*#\\s*define\\s*LV_TICK_CUSTOM\\s*\\)[01]/#define LV_TICK_CUSTOM 1/ $LV_CONF_PATHelse echo 无效参数: $TARGET_ARCH。请使用 pc 或 arm exit 1fiecho 配置完成 第二步：改造应用代码 main.c 使用预处理指令#if USE_SDL来包裹平台相关的代码。 /** * @file main * @brief 整合了 PC 和 ARM 平台的启动代码 *//********************* * INCLUDES *********************/#define _DEFAULT_SOURCE /* needed for usleep() */#include stdlib.h#include unistd.h// 驱动配置文件#include lv_drv_conf.h// LVGL 核心库#include lvgl/lvgl.h// UI 代码头文件#include obj/head.h#include UI/ui.h// 添加对examples的引用#include lvgl/examples/lv_examples.h// 根据 lv_drv_conf.h 中的 USE_SDL 宏来包含不同的平台驱动头文件#if USE_SDL /* ========================= */ /* PC/SDL 平台头文件 */ /* ========================= */ #define SDL_MAIN_HANDLED #include SDL2/SDL.h #include lv_drivers/sdl/sdl.h#else /* ================================ */ /* ARM/Framebuffer 平台头文件 */ /* ================================ */ #include lv_drivers/display/fbdev.h #include lv_drivers/indev/evdev.h #include sys/time.h uint32_t custom_tick_get(void); // ARM 平台 tick 函数声明#endif/********************** * STATIC PROTOTYPES **********************/static void hal_init(void);/********************** * GLOBAL FUNCTIONS **********************/int main(int argc, char **argv) (void)argc; /* Unused */ (void)argv; /* Unused */ /* 初始化 LVGL */ lv_init(); /* 初始化 HAL (显示, 输入设备, tick) */ hal_init(); /* === 调用 UI 代码 === */ // obj_pos1(); ui_init(); // obj_sjpg_1(); // 用图片数组显示 // obj_sjpg_2(); // 用指定路径显示 // obj_freetype_text();// 显示文字 // lv_flex_test(); // 布局测试 /* 主循环 */ while(1) lv_timer_handler(); usleep(5 * 1000); return 0;/********************** * STATIC FUNCTIONS **********************//** * @brief 初始化硬件抽象层 (HAL) * 根据 USE_SDL 的值选择初始化 PC/SDL 平台或 ARM/Framebuffer 平台 */static void hal_init(void)#if USE_SDL /* ================================== */ /* PC/SDL 平台初始化 */ /* ================================== */ sdl_init(); /* 创建一个显示缓冲区 */ static lv_disp_draw_buf_t disp_buf1; static lv_color_t buf1_1[SDL_HOR_RES * 100]; lv_disp_draw_buf_init(disp_buf1, buf1_1, NULL, SDL_HOR_RES * 100); /* 创建一个显示驱动 */ static lv_disp_drv_t disp_drv; lv_disp_drv_init(disp_drv); disp_drv.draw_buf = disp_buf1; disp_drv.flush_cb = sdl_display_flush; disp_drv.hor_res = SDL_HOR_RES; disp_drv.ver_res = SDL_VER_RES; lv_disp_t * disp = lv_disp_drv_register(disp_drv); /* 设置默认主题 */ lv_theme_t * th = lv_theme_default_init(disp, lv_palette_main(LV_PALETTE_BLUE), lv_palette_main(LV_PALETTE_RED), LV_THEME_DEFAULT_DARK, LV_FONT_DEFAULT); lv_disp_set_theme(disp, th); lv_group_t * g = lv_group_create(); lv_group_set_default(g); /* 添加鼠标输入设备 */ static lv_indev_drv_t indev_drv_1; lv_indev_drv_init(indev_drv_1); indev_drv_1.type = LV_INDEV_TYPE_POINTER; indev_drv_1.read_cb = sdl_mouse_read; lv_indev_drv_register(indev_drv_1); /* 添加键盘输入设备 */ static lv_indev_drv_t indev_drv_2; lv_indev_drv_init(indev_drv_2); indev_drv_2.type = LV_INDEV_TYPE_KEYPAD; indev_drv_2.read_cb = sdl_keyboard_read; lv_indev_t *kb_indev = lv_indev_drv_register(indev_drv_2); lv_indev_set_group(kb_indev, g); /* 添加鼠标滚轮输入设备 */ static lv_indev_drv_t indev_drv_3; lv_indev_drv_init(indev_drv_3); indev_drv_3.type = LV_INDEV_TYPE_ENCODER; indev_drv_3.read_cb = sdl_mousewheel_read; lv_indev_t * enc_indev = lv_indev_drv_register(indev_drv_3); lv_indev_set_group(enc_indev, g);#else /* ======================================= */ /* ARM 平台初始化 */ /* ======================================= */ #define DISP_BUF_SIZE (128 * 1024) fbdev_init(); static lv_color_t buf[DISP_BUF_SIZE]; static lv_disp_draw_buf_t disp_buf; lv_disp_draw_buf_init(disp_buf, buf, NULL, DISP_BUF_SIZE); static lv_disp_drv_t disp_drv; lv_disp_drv_init(disp_drv); disp_drv.draw_buf = disp_buf; disp_drv.flush_cb = fbdev_flush; disp_drv.hor_res = 800; disp_drv.ver_res = 480; lv_disp_drv_register(disp_drv); evdev_init(); static lv_indev_drv_t indev_drv_1; lv_indev_drv_init(indev_drv_1); indev_drv_1.type = LV_INDEV_TYPE_POINTER; indev_drv_1.read_cb = evdev_read; lv_indev_t *mouse_indev = lv_indev_drv_register(indev_drv_1); LV_IMG_DECLARE(mouse_cursor_icon) lv_obj_t * cursor_obj = lv_img_create(lv_scr_act()); lv_img_set_src(cursor_obj, mouse_cursor_icon); lv_indev_set_cursor(mouse_indev, cursor_obj);#endif#if !USE_SDL/** * @brief ARM/fbdev 平台 tick 获取函数实现 */uint32_t custom_tick_get(void) static uint64_t start_ms = 0; if(start_ms == 0) struct timeval tv_start; gettimeofday(tv_start, NULL); start_ms = (tv_start.tv_sec * 1000000 + tv_start.tv_usec) / 1000; struct timeval tv_now; gettimeofday(tv_now, NULL); uint64_t now_ms; now_ms = (tv_now.tv_sec * 1000000 + tv_now.tv_usec) / 1000; uint32_t time_ms = now_ms - start_ms; return time_ms;#endif 1. 使用 telnet，避免频繁切换窗口和反复串口调试 Telnet 连接开发板分为两部分：开发板配置 和 主机配置。 注意虚拟机必须配置静态 ip，如果不知道怎么配置静态 IP，看这个文章： 配置静态 ip 的步骤 开发板配置 确保开发板与电脑在同一网段，例如 192.168.11.x 将所需软件放到合适的位置。 在 /etc/profile 文件中加入 Telnet 服务的后台启动命令，例如： if ! ps | grep -q [t]elnetd; then /IOT/telnetd fi 这样每次开机都会自动启动 Telnet 服务 主机配置 在 Ubuntu 主机上安装 Telnet 客户端： sudo apt install telnet 使用以下命令连接开发板： telnet 192.168.11.?? 连接成功后即可在电脑终端直接操作开发板 2. 使用 nfs，将 ubuntu 里的文件夹挂载到开发版 NFS（Network File System，网络文件系统）可以让开发板直接访问 Ubuntu 上的目录，省去拷贝文件的步骤。 确保开发板与电脑在同一网段，例如 192.168.11.x 注意虚拟机必须配置静态 ip，如果不知道怎么配置静态 IP，看这个文章： 配置静态 ip 的步骤 主机配置（Ubuntu） 安装 NFS 服务端： sudo apt-get install nfs-kernel-server 编辑共享目录配置文件 /etc/exports sudo vi /etc/exports 在文件末尾添加一行： /media/skyforever/Data/share 192.168.11.??(rw,sync,no_root_squash,no_subtree_check) /media/skyforever/Data/share 为需要共享的目录 192.168.11.0/24 表示允许同一网段的设备访问 no_root_squash 允许开发板上的 root 用户保留权限 重启 NFS 服务使配置生效： sudo systemctl restart nfs-kernel-server 查看 NFS 服务是否正常运行 sudo systemctl status nfs-kernel-server 开发板配置（GEC6818） GEC6818 开发板自带 NFS 客户端，无需额外安装服务。 创建挂载点： mkdir -p /mnt/nfs 在 /etc/profile 中添加挂载命令，保证开机自动挂载： if ! mount | grep -q /mnt/nfs; then mount -t nfs -o nolock,vers=3 192.168.11.??:/media/skyforever/Data/share /mnt/nfsfi 192.168.11.85 是主机的 IP 地址。 /mnt/nfs 是开发板上的挂载点。 保存并重启开发板后，就可以在 /mnt/nfs 目录下直接访问主机上的共享文件夹 3. 使用 vscode 的配置文件选项，避免调用大量插件造成卡顿 现代 IDE 功能强大，但也可能因为安装了适用于不同语言（Web、Python 等）的众多插件而变得臃肿，在进行嵌入式 C/C++开发时尤其影响性能。VSCode 的“配置文件(Profiles)”功能可以完美解决此问题。 目的：为嵌入式开发创建一个专属、轻量、无干扰的 IDE 环境。 操作步骤 创建新配置文件 点击 VSCode 左下角的 齿轮图标。 选择 配置文件 添加配置文件。 为新配置文件命名，例如“C/C++”。 在弹出的选项中，可以选择从默认配置文件复制，这样无需重新安装插件，或者用官方推荐的插件列表 定制嵌入式专属环境 切换到新创建的“C/C++”配置文件后： 打开 扩展 侧边栏 (Ctrl+Shift+X)。 将所有与 C/C++嵌入式开发无关的插件禁用。例如 Python、Jupyter、Prettier、Live Server 等。 仅保留核心插件，如： C/C++ CMake Tools 无缝切换 之后，你可以通过左下角的齿轮图标，在不同的配置文件之间快速切换。 当你需要进行嵌入式开发时，切换到“C/C++”配置文件，VSCode 会立刻关掉无关插件的负载，变得极其流畅和专注。","tags":["嵌入式","LVGL","Linux","NFS","Telnet","VSCode"],"categories":["Embedded"]},{"title":"Vim技巧整理","path":"/posts/3106.html","content":"Opening 文章转载于 GeekHour，原视频链接：Vim 进阶技巧，你知道几个？ 放在网站上方便查询 欢迎来到 GeekHour! 在程序员的世界里，编辑器之争一直是个有趣的话题。传说中程序员分三类：用 Vim 的、用 Emacs 的，还有其他。你属于哪一类呢？ 大家好，我是老萧，以后会和老杨一起为大家带来最酷的技术分享。之前在 Linux 入门教程中，我们简单介绍过 Vim 的基本使用。今天我们将深入探讨一些进阶技巧，那我们闲言少叙，开始分享。 技巧一：快速跳转 在日常编码中，我们花费大量时间在浏览和定位代码上，而不是输入新的代码。因此，掌握高效的跳转方法可以极大提升我们的工作效率。 行号跳转 gg - 跳转到文件开头 G - 跳转到文件末尾 行号G - 跳转到指定行 set relativenumber - 显示相对行号 vi +100 filename - 打开文件并跳转到第 100 行 窗口内跳转 H - 跳转到当前窗口首行 M - 跳转到窗口中间 L - 跳转到窗口底部 搜索跳转 /pattern - 向下搜索 ?pattern - 向上搜索 n / N - 重复搜索 * - 搜索光标下的单词 # - 反向搜索光标下的单词 跳转历史 :jumps - 查看跳转历史记录 Ctrl-O - 跳回上一个位置 Ctrl-I - 跳到下一个位置 :changes - 查看编辑位置历史 g; - 跳到较老的修改位置 g, - 跳到较新的修改位置 标记与跳转 ma-zA-Z - 设置标记 'mark - 跳转到标记行 技巧二：行内移动 在单行内快速移动光标是提升 Vim 使用效率的关键。 基本移动 0 - 跳到行首 $ - 跳到行尾 ^ - 跳到行内第一个非空字符 g_ - 跳到行内最后一个非空字符 精确定位 fchar - 向后查找字符并跳转 Fchar - 向前查找字符并跳转 tchar - 向后查找字符并跳到其前一个位置 Tchar - 向前查找字符并跳到其后一个位置 ; - 重复上次的字符查找 , - 反向重复上次的字符查找 单词移动 w - 移动到下一个单词开头 e - 移动到当前单词结尾 b - 移动到上一个单词开头 W/E/B - 同上，但以空格为分隔符 技巧三：高效编辑 Vim 的强大之处在于其编辑命令的组合能力。 动作命令 c - change (修改) d - delete (删除) y - yank (复制) v - visual (可视化选择) 文本对象 w - word (单词) s - sentence (句子) p - paragraph (段落) ( or ) - 圆括号内的内容 or - 花括号内的内容 [ or ] - 方括号内的内容 重复与撤销 . - 重复上次的修改 u - 撤销上次修改 Ctrl-R - 重做(撤销的反向操作) 技巧四：Buffer Windows Tab Buffer 管理 :ls - 列出所有缓冲区 :b number - 切换到指定编号的缓冲区 :bn / :bp - 切换到下一个/上一个缓冲区 :bd - 关闭当前缓冲区 Window 操作 :sp - 水平分割窗口 :vsp - 垂直分割窗口 Ctrl-w h/j/k/l - 在窗口间移动 Ctrl-w = - 使所有窗口等宽、等高 Tab 页管理 :tabnew - 创建新标签页 gt / gT - 切换到下一个/上一个标签页 :tabclose - 关闭当前标签页 技巧五：寄存器 :reg - 查看寄存器内容 ap - 粘贴 a 寄存器内容 q - 录制宏 @ - 执行宏 技巧六：Vimrc 配置 基础配置 语法高亮 显示行号 设置 Tab 缩进 配置文件编码 快捷键设置 leaderv - 快速打开配置文件 leaderq - 强制退出 leadery/p - 系统剪贴板复制/粘贴 实用替代键 Ctrl-[ - 替代 Esc 键 ZZ - 替代 :wq ZQ - 替代 :q! 技巧七：插件管理 推荐使用 vim-plug 作为插件管理器，常用插件包括： fzf：模糊查找工具 vim-easy-align：代码对齐 vim-commentary：注释插件 vim-gitgutter：显示 git diff 信息 tokyonight：配色方案 lightline：状态栏插件 vim-mucomplete：代码补全 SearchComplete：搜索补全 matchup：增强 % 跳转功能 Vim 的生态与影响力 Vim 的影响力已经渗透到各种工具中，包括 Neovim、命令行、IDE 和浏览器扩展等。 Ending Vim 就像开源世界中的一支铅笔，几乎每台类 Unix 系统都预置其中，其理念影响深远。希望大家能够通过学习，找到属于自己的高效编辑方式。 最后，让我们缅怀 Vim 之父 Bram Moolenaar，同时关注他生前致力于的乌干达儿童慈善事业。愿大家在新的一年里效率 MAX，Happy hacking！","tags":["linux"],"categories":["计算机科学与技术"]},{"title":"深澜校园网自动登陆脚本","path":"/posts/28982.html","content":"因为晚上要断电，所以写了个油猴脚本，自动登录深澜校园网 深澜校园网 - 自动登陆 原理：输入自己的账号、密码后，让浏览器填写自己设置的密码，模拟用户点击登录按钮 油猴脚本插件 - 下载地址 篡改猴 - Chrome 应用商店 篡改猴 - Microsoft Edge Addons 操作步骤 代码复制到此处， ctrl+s 保存即可，打开校园网登录地址，实现自动登录。 粘贴油猴脚本 自动登录脚本： // ==UserScript==// @name 深澜校园网-自动登陆// @namespace http://www.baidu.com/// @version 0.12// @description 仅仅提供【深澜校园网】的保存密码及自动登陆，第7行为校园网登录 IP。// @author Skyforever// @match http://218.104.96.75/*// @icon https://srun.com/favicon.ico// @icon64 https://srun.com/favicon.ico// @grant none// ==/UserScript==(function() use strict; // 用户自定义 - 输入账号密码 var usr = 这里填账号; // 账号 var pwd = 这里填密码; // 密码 // 检查账号密码是否已填写 if (usr === 这里填账号 || pwd === 这里填密码) alert(请去用户脚本管理器中，找到【深澜校园网-自动登录】脚本的代码，添加自己的账号与密码); else // 填充账号和密码 document.querySelector(#username).value = usr; document.querySelector(#password).value = pwd; // 点击登录按钮 document.querySelector(#login-account).click(); )(); 自动切换账号登录（不建议这么做，会打破付费平衡） 程序原理：在默认账号无法登录时，自动对账号+1，并重新尝试登录，如果登录成功，就把账号存在本地数据库中，方便下次登录 // ==UserScript==// @name 深澜校园网-自动登陆// @namespace http://www.baidu.com/// @version 0.22// @description 仅仅提供【深澜校园网】的保存密码及自动登陆，第7行为校园网登录 IP。// @author Skyforever// @match http://218.104.96.75/*// @icon https://srun.com/favicon.ico// @icon64 https://srun.com/favicon.ico// @grant none// ==/UserScript==(function() use strict; // 默认账号（初始账号），以及密码（密码不变） var defaultUsr = 02702127512; // 默认账号 var pwd = 123456; // 密码 // localStorage 键名 var storageKey = autoLogin_currentAccount; // 从 localStorage 获取当前账号，若没有则使用默认账号 var currentUsr = localStorage.getItem(storageKey) || defaultUsr; // 更新当前账号到 localStorage，并更新控制面板显示 function updateCurrentUsr(newUsr) localStorage.setItem(storageKey, newUsr); currentUsr = newUsr; console.log(更新当前账号为： + newUsr); updateControlPanel(); // 判断元素是否真的可见：检测 offsetWidth/offsetHeight 和 CSS 样式 function isVisible(element) if (!element) return false; var style = window.getComputedStyle(element); return style.display !== none style.visibility !== hidden element.offsetWidth 0 element.offsetHeight 0; // 登录后检测确认按钮的函数（如果检测到则执行账号自增并重新登录） function checkForConfirmButtonPostLogin() var confirmBtn = document.querySelector(.btn-confirm); if (confirmBtn isVisible(confirmBtn)) console.log(✅ 登录后检测到确认按钮，准备重新尝试登录...); // 点击确认按钮（如果需要） confirmBtn.click(); // 自增账号：转换为数字后加 1，再转回字符串 var newAccountNum = parseInt(currentUsr, 10) + 1; updateCurrentUsr(newAccountNum.toString()); // 1秒后刷新页面以重新尝试登录 setTimeout(function() location.reload(); , 1000); return true; return false; // 登录后启动定时检测确认按钮，连续检测一定时间（如 10 次，每次间隔 1 秒） function startPostLoginConfirmCheck() var attempts = 0; var maxAttempts = 10; var intervalId = setInterval(function() attempts++; if (checkForConfirmButtonPostLogin() || attempts = maxAttempts) clearInterval(intervalId); , 1000); // 自动填充账号密码并点击登录按钮 function autoLogin() var usernameField = document.querySelector(#username); var passwordField = document.querySelector(#password); var loginBtn = document.querySelector(#login-account); if (usernameField passwordField loginBtn) usernameField.value = currentUsr; passwordField.value = pwd; console.log(✅ 使用账号 + currentUsr + 已填充账号密码，尝试登录...); setTimeout(function() loginBtn.click(); // 登录后启动确认按钮检测（用于后续页面出现的确认按钮） startPostLoginConfirmCheck(); , 500); else console.log(❌ 未找到登录表单，等待加载...); setTimeout(autoLogin, 1000); // 处理初始页面上可能出现的确认按钮（登录前或中途出现的） function handleInitialConfirmButton() var confirmBtn = document.querySelector(.btn-confirm); if (confirmBtn isVisible(confirmBtn)) console.log(✅ 检测到初始确认按钮，点击确认...); confirmBtn.click(); // 检测按钮是否消失后刷新页面 var checkInterval = setInterval(function() if (!isVisible(confirmBtn)) clearInterval(checkInterval); console.log(🔄 初始确认按钮已消失，刷新页面...); setTimeout(function() location.reload(); , 1000); , 500); else console.log(❌ 初始页面未检测到确认按钮，直接尝试登录...); setTimeout(autoLogin, 1000); // 创建右上角控制面板，用于显示当前账号和重置账号按钮 function createControlPanel() var panel = document.createElement(div); panel.id = autoLoginControlPanel; panel.style.position = fixed; panel.style.top = 10px; panel.style.right = 10px; panel.style.background = rgba(0, 0, 0, 0.7); panel.style.color = #fff; panel.style.padding = 8px; panel.style.fontSize = 14px; panel.style.zIndex = 9999; panel.style.borderRadius = 4px; // 当前账号显示区域 var accountInfo = document.createElement(span); accountInfo.id = currentAccountDisplay; accountInfo.style.marginRight = 10px; panel.appendChild(accountInfo); // 重置账号按钮 var resetBtn = document.createElement(button); resetBtn.textContent = 重置账号; resetBtn.style.fontSize = 12px; resetBtn.style.cursor = pointer; resetBtn.addEventListener(click, function() updateCurrentUsr(defaultUsr); alert(账号已重置为： + defaultUsr); ); panel.appendChild(resetBtn); document.body.appendChild(panel); updateControlPanel(); // 更新控制面板中显示的当前账号 function updateControlPanel() var accountInfo = document.getElementById(currentAccountDisplay); if (accountInfo) accountInfo.textContent = 当前账号： + currentUsr; // 脚本启动入口 function init() console.log(🚀 脚本启动... 当前账号： + currentUsr); createControlPanel(); setTimeout(handleInitialConfirmButton, 2000); init();)(); 附加内容-绕过代理 将学校网关的代理设置为直连，不走代理，这样系统就可以自动弹出登录界面登录 Windows 系统设置在这个位置： Clash 设置在这个位置： 附加内容-修改浏览器标识 修改浏览器标识，可以加大概率碰到能用的账号 因为大部分用户都是用电脑登录的，而一个账号可以用于两个设备（手机和电脑）； 所以可以修改浏览器标识，让浏览器 pretend 成手机登录，这样能试到更多账号 浏览器标识修改插件 - 下载地址 User-Agent Switcher and Manager - Chrome 应用商店 User-Agent Switcher and Manage - Edge 应用商店 未应用插件的浏览器标识是，识别为电脑： 按照下面图片的步骤操作即可模拟手机标识骗过： 应用后，识别为手机：","categories":["大学生涯"]},{"title":"程序员延寿指南","path":"/posts/58559.html","content":"1. 术语 2. 目标 3. 关键结果 4. 分析 5. 行动 6. 证据 6.1. 输入 6.1.1. 固体 6.1.2. 液体 6.1.3. 气体 6.1.4. 光照 6.1.5. 药物 6.2. 输出 6.2.1. 挥拍运动 6.2.2. 剧烈运动 6.2.3. 走路 6.2.4. 刷牙 6.2.5. 泡澡 6.2.6. 做家务（老年男性） 6.2.7. 睡眠 6.2.8. 久坐 6.3. 上下文 6.3.1. 情绪 6.3.2. 贫富 6.3.3. 体重 6.3.4. 新冠 1. 术语 ACM: All-Cause Mortality / 全因死亡率 2. 目标 稳健的活得更久 花更少时间工作：见MetaGPT 3. 关键结果 降低 66.67%全因死亡率 增加~20 年预期寿命 维持多巴胺于中轴 4. 分析 主要参考：对 ACM 的学术文献相对较多，可以作为主要参考 增加寿命与 ACM 关系非线性：显然增加寿命与 ACM 关系是非线性函数，这里假设 ΔLifeSpan=(1/(1+ΔACM)-1)*10（ΔACM 为 ACM 变化值；公式欢迎优化） 变量无法简单叠加：显然各个变量之间并不符合独立同分布假设，变量之间的实际影响也并不明确 存在矛盾观点：所有的证据都有文献/研究对应，但注意到：有些文献之间有显著矛盾的观点（如对于碳水摄入比例的矛盾）；有些文献存在较大争议（如认为 22 点前睡觉会提升 43%全因死亡率） 研究仅表达相关：所有文献表明的更多是相关而非因果，在阅读时要考虑文献是否充分证明了因果 —— 如某文献表明了日均=7000 步的人有显著低的全因死亡率。但步数少的人可能包含更多长期病患，如果没有合理的排除这块数据，那此文献调查失真 5. 行动 输入 固体：吃白肉（-11%~-3% ACM）、蔬果为主（-26%~-17% ACM），多吃辣（-23% ACM），多吃坚果（-27%~-4% ACM），中量碳水、多吃植物蛋白（-10% ACM），少吃超加工食物（-62%~-18%） 液体：喝咖啡（-22%~-12% ACM），喝牛奶（-17%~-10% ACM），喝茶（-15%~-8% ACM），少喝或不喝甜味饮料（否则每天一杯+7% ACM，+多巴胺），戒酒（否则+~50% ACM，无上限） 气体：不吸烟（否则+~50% ACM，-12~-11 年寿命） 光照：晒太阳（-~40% ACM） 药物：二甲双胍（糖尿病人相比正常人可以+3 年）、复合维生素（-8%癌症风险）、亚精胺（-60%~-30% ACM）、葡萄糖胺（-39% ACM） 输出 运动：每周 3 次 45 分钟挥拍运动（-47% ACM） 日常：刷牙（-25% ACM） 睡眠：每天睡 7 小时全因死亡率最低；且 22-24 点间最好，早睡+43% ACM，晚睡+15% ACM（存在争议） 上下文 体重：减肥（-54% ACM） 6. 证据 6.1. 输入 6.1.1. 固体 白肉 JAMA 子刊：食用红肉和加工肉类会增加心脏病和死亡风险！鱼肉和家禽肉则不会 出处：Associations of Processed Meat, Unprocessed Red Meat, Poultry, or Fish Intake With Incident Cardiovascular Disease and All-Cause Mortality 增加红肉摄入与死亡风险相关。八年内平均每天增加至少半份红肉摄入（半份红肉相当于 14g 加工红肉或 40g 非加工红肉）的调查对象，在接下来八年内全因死亡风险增加 10％（HR, 1.10; 95%CI, 1.04-1.17）；每周吃两份红肉或加工肉类（但不包括家禽或鱼类）会使全因死亡风险增加 3% 红肉和白肉最大的区别是什么？为啥要这么分呢？ 蔬果 每年 54 万人死亡，竟是因为水果吃得少！？这已成十大死亡因素之一！ 出处：Estimated Global, Regional, and National Cardiovascular Disease Burdens Related to Fruit and Vegetable Consumption: An Analysis from the Global Dietary Database (FS01-01-19) 每天摄入 200 克新鲜水果可使死亡率降低 17%，糖尿病大血管并发症（如中风、缺血性心脏病等）风险降低 13%，及糖尿病小血管并发症（如糖尿病肾病、糖尿病眼病、糖尿病足病等）风险降低 28% 《自然》子刊：每天二两西兰花，健康长寿都有啦！分析近 6 万人 23 年的数据发现，吃含黄酮类食物与死亡风险降低 20%相关丨临床大发现 出处：Flavonoid intake is associated with lower mortality in the Danish Diet Cancer and Health Cohort 吃含黄酮类食物与死亡风险降低 20%相关 Bondonno 博士说道“吃不同蔬菜、水果补充，不同种类的黄酮类化合物是很重要的，这很容易通过饮食实现：一杯茶、一个苹果、一个橘子、100 克蓝莓，或 100 克西兰花，就能提供各种黄酮类化合物，并且总含量超过 500 毫克。 辣椒 辣椒成死亡克星？据调研，常吃辣患病死亡风险可降低 61% 出处 1：Chili pepper consumption and mortality in Italian adults 出处 2：The Association of Hot Red Chili Pepper Consumption and Mortality: A Large Population-Based Cohort Study 2017 年 Plos One 的另一项来自美国的研究以 16179 名，年龄在 18 岁以上的人群为对象，并对其进行了高达 19 年的随访，发现在 4946 例死亡患者中，食用辣椒的参与者的全因死亡率为 21.6％，而未食用辣椒的参与者的全因死亡率为 33.6％。相较于不吃辣或很少吃（少于每周两次）的人群，每周吃辣＞ 4 次的人群总死亡风险降低 23%，心血管死亡风险降低 34%。 鸡蛋 每天多吃半个蛋，增加 7%的全因和心血管死亡风险？ 出处：NIH-AARP 工作主页、Egg and cholesterol consumption and mortality from cardiovascular and different causes in the United States: A population-based cohort study 每天多吃半个蛋，增加 7%的全因和心血管死亡风险？在假设性替代分析中，研究者发现，用等量的蛋清/鸡蛋替代物、家禽、鱼、乳制品、坚果和豆类分别替代半只全蛋（25 克/天）可以降低 6%、8%、9%、7%、13%和 10%的全因死亡率。 *鸡蛋 坚果 哈佛 20 年研究：吃核桃的人更长寿，显著减少全因死亡，延长寿命 出处：Association of Walnut Consumption with Total and Cause-Specific Mortality and Life Expectancy in US Adults 通过分析发现，经常食用核桃可以延长寿命，降低心血管疾病死亡风险。比起不吃核桃，每周食用核桃 5 份以上（1 份 28 克）的健康预期寿命延长 1.3 岁，全因死亡风险降低 14%，心血管疾病死亡率降低 25%。 研究：每日食生坚果，死亡率降 20% 出处 1：Association of nut consumption with total and cause-specific mortality 出处 2：APG_Health--Nutrition-Research-Brochure_DEC-19-18 研究人员发现，每周吃树坚果低于 1 盎司份量的人，死亡率降低 7％。而每周吃了 1 盎司份量的人，减少 11％的死亡率；每周吃 2 份量的人，减低 13％；每周 5 至 6 份量者，减少了 15％；一周 7 份以上的人，死亡率则减少 20％。 另外两篇发表在《公共科学图书馆在线期刊》(Public Library of Science Online Journal)和《生物医学中心》(BioMed Central)上的医学预科研究论文，展示了试验开始时的横断面数据。这两项研究都评估了 7,216 名对象，以及他们食用坚果的频率和数量之间的关系。那些每周食用三份以上坚果(包括开心果)的研究对象的死亡率降低 39%。 钠（存有大量争议） Eur Heart J：钠摄入量与预期寿命、全因死亡率的关系 出处：Messerli F H, Hofstetter L, Syrogiannouli L, et al. Sodium intake, life expectancy, and all-cause mortality[J]. European heart journal, 2021, 42(21): 2103-2112. 在该分析所包含的 181 个国家中，研究人员发现钠摄入量与出生时的健康预期寿命（β=2.6 年/克每日钠摄入量，R2=0.66，P0.001）和 60 岁时的健康预期寿命（β=0.3 年/克每日钠摄入量，R2=0.60，P=0.048）之间存在正相关关系，但与非传染性疾病死亡（β=17 次事件/克每日钠摄入量，R2=0.43，P=0.100）无关。相反，全因死亡率与钠摄入量成负相关（β=−131 次事件/克每日钠摄入量，R2=0.60，P0.001）。在仅限于 46 个收入最高国家的敏感性分析中，钠摄入量与出生时的健康预期寿命呈正相关（β=3.4 年/克每日钠摄入量，R2=0.53，P0.001），而与全因死亡率（β=−168 次事件/克每日钠摄入量，R2=0.50，P0.001）呈负相关。 该（大范围）研究认为更多的钠摄入与显著更低的全因死亡率有关 针对该论文的延伸解读和讨论：A Fresh Foray in the Salt Wars: Life Expectancy Higher With Greater Sodium Intake NEJM/Lancet：不要吃太多盐，中国饮食所致心血管病和癌症死亡全球第一，吃低钠盐可降低全因死亡率 但也有多项研究认为用低钠盐可以降低一系列疾病的发生概率，对全因死亡率的减少有积极影响 碳水（存有大量争议） 低碳生酮饮食（四）碳水化合物与长期死亡率 出处：The Lancet Public Health - Dietary carbohydrate intake and mortality: a prospective cohort study and meta-analysis 碳水越低，寿命越短；碳水越高，寿命也轻微缩短；碳水 50%左右（其实按照一般的说法，这也算高碳水）是最长寿命区间 最强营养搭配！BMJ：这么吃，心血管疾病和死亡风险更低 槟榔 如何看待槟榔嚼出来的癌症？槟榔致癌风险究竟有多大？ - 丁香医生的回答 - 知乎 出处：Chewing Betel Quid and the Risk of Metabolic Disease, Cardiovascular Disease, and All-Cause Mortality: A Meta-Analysis(https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0070679) 嚼槟榔会增加 21%的全因死亡率 热量限制 怎么看待 BBC《进食、断食与长寿》？ 限制卡路里动物实验：CR（热量限制，即少吃）延迟了恒河猴的多种疾病发病和死亡率，与 CR 动物相比，正常喂养的猴子的各种疾病患病风险增加 2.9 倍，死亡风险增加 3.0 倍。 综合 最强营养搭配！BMJ：这么吃，心血管疾病和死亡风险更低 Associations of fat and carbohydrate intake with cardiovascular disease and mortality: prospective cohort study of UK Biobank participants 通过对这些参与者的数据进行分析，研究人员发现碳水化合物（糖、淀粉和纤维）和蛋白质的摄入与全因死亡率呈非线性关系，而脂肪则与全因死亡率呈线性相关。其中，较高的糖分摄入与全因死亡风险和患心血管疾病的风险较高均有关联，而较高的饱和脂肪酸摄入与全因死亡风险较高有关。 图 1：各种营养元素与全因死亡之间的关系 图 2：各种营养元素与心血管疾病之间的关系 进一步研究表明，在所有的饮食模式中，全因死亡率风险最低的饮食方式为：10-30g 高纤维、14-30%蛋白质、10-25%单不饱和脂肪酸、5%-7%多不饱和脂肪酸以及 20%-30%淀粉摄入。 最优能量来源配比：24%淀粉，15%-17%蛋白质，15%单不饱和脂肪酸，15%糖，6%饱和脂肪酸，6%多不饱和脂肪酸，30g+高纤维 BMJ | 常吃薯片汉堡巧克力等食品，平均死亡年龄仅仅为 58 岁，死亡风险剧增 Rico-Campà A, Martínez-González M A, Alvarez-Alvarez I, et al. Association between consumption of ultra-processed foods and all cause mortality: SUN prospective cohort study[J]. bmj, 2019, 365. [Srour B, Fezeu L K, Kesse-Guyot E, et al. Ultra-processed food intake and risk of cardiovascular disease: prospective cohort study NutriNet-Santé. bmj, 2019, 365.](https://www.bmj.com/content/365/bmj.l1451) Lawrence M A, Baker P I. Ultra-processed food and adverse health outcomes[J]. bmj, 2019, 365. 6.1.2. 液体 牛奶 《柳叶刀》调研 21 个国家 13 万人：每天 1 斤牛奶或酸奶，心血管死亡风险下降 23% 出处：Association of dairy intake with cardiovascular disease and mortality in 21 countries from five continents (PURE): a prospective cohort study 与不食用乳制品的人相比，每天摄入两份乳制品（一份指 244 克牛奶/酸奶，15 克奶酪或 5 克黄油）的人，全因死亡风险下降了 17%，心血管死亡风险下降 23%，中风风险下降 33% 茶 10 万中国人随访 7 年发现，每周喝三次茶与全因死亡风险降低 15%，预期寿命增加 1.26 年相关 出处：Tea consumption and the risk of atherosclerotic cardiovascular disease and all-cause mortality: The China-PAR project 中国成年人饮茶与死亡风险的前瞻性关联研究 纳入分析的 438 443 例研究对象随访 11.1 年共发生死亡 34 661 例。与从不饮茶者相比，当前非每日饮茶者和每日饮茶者全因死亡 HR 值（95%CI）依次为 0.89（0.86-0.91）和 0.92（0.88-0.95）。分性别分析显示，饮茶对全因死亡风险的保护作用主要见于男性（交互 P0.05） 无糖（甜味）饮料 「无糖饮料使死亡风险增加 26 %」，是真的吗？ 相比于软饮料摄入量＜ 1 杯/月的参与者，混合软饮料摄入 ≥1 杯/天的参与者死亡风险增加 18%，而摄入含糖软饮料或无糖软饮料会令死亡风险分别增加 11%和 27%。 Association Between Soft Drink Consumption and Mortality in 10 European Countries 有糖饮料 可乐和奶茶，增加全因死亡率高达 62%！果汁降低免疫力，影响肝代谢！含糖饮料那些事 每天 1 杯含糖饮料增加 7%全因死亡率，2 杯 21% 在 34 年的随访中，研究人员发现，相比那些一个月喝 1 杯或者更少含糖饮料的人，每天喝 2 杯的人总体死亡风险升高了 21%，心血管疾病死亡风险升高了 31%，癌症死亡风险上升了 16%。 只要每天多喝一杯含糖饮料，总体死亡风险将增加 7%，心血管疾病的风险将增加 10%，癌症相关的死亡风险将 16%。 发表在国际顶级期刊《BMJ》上的一篇论文就证明了含糖饮料会在增加患癌风险，当然这篇文章验证的不仅仅是果汁，奶茶也有份——和含糖饮料相关的总体患癌风险要高出通常值 18%，100%的鲜榨果汁也会使得整体的患癌风险上升 12%。 果汁 JAMA 子刊：100%纯果汁可能比含糖饮料更危险 每天多摄入一份 12 盎司的含糖饮料，全因死亡率风险增加 11%； 每天多摄入一份 12 盎司的果汁，全因死亡率风险增加 24%。 咖啡 重磅！多篇研究证实喝咖啡与人群全因死亡率降低直接相关 科普 | 喝咖啡又多了一个新理由：降低死亡率！ 地中海成年人咖啡消耗量及全因，心血管疾病和癌症的死亡率 在最近的荟萃分析中，该研究包括来自不同国家的 40 项研究和 3,852,651 名受试者。在这项荟萃分析显示，咖啡摄入量与各种原因的死亡率，CVD 和癌症死亡率之间存在非线性关系，每天摄入两杯咖啡的癌症死亡率最低(RR = 0.96)，CVD 最低的死亡率，每天 2.5 杯(RR= 0.83)，全天最低死亡率为每天 3.5 杯(RR= 0.85)，并且随着咖啡消费量的增加，死亡率没有进一步降低或增加 亚精胺 Science：科学背书！从精液中发现的亚精胺，竟然有着抗衰老、抗癌、保护心血管和神经、改善肥胖和 2 型糖尿病等逆天神效 饮食中亚精胺摄入量高会降低死亡率 6.1.3. 气体 吸烟 即使是低强度吸烟，也增加死亡风险！ 研究发现：在 42 416 名男性和 86 735 名女性（年龄在 35-89 岁之间，以前没有患病）中，18 985 名男性（45%）和 18 072 名女性（21%）目前吸烟，其中 33%的男性吸烟者和 39%的女性吸烟者并不每天吸烟。8866 名男性（21%）和 53 912 名女性（62%）从不吸烟。在随访期间，与从不吸烟相比，每天10 支烟或每天 ≥10 支烟的全因死亡率危险比分别为 1.17（95%置信区间 1.10-1.25）和 1.54（1.42-1.67）。无论年龄或性别，危险比相似。与每日吸烟关系最密切的疾病是呼吸道癌症、慢性阻塞性肺病和胃肠道及血管疾病。在招募时已经戒烟的人的死亡率低于现在每天吸烟者。 吸烟者平均减少寿命 11-12 年 吸烟让人过瘾是什么原理？有节制的吸烟依旧有害吗？ 6.1.4. 光照 晒太阳 [晒太阳和死亡率的关系，如何科学，安全的晒太阳？ ](https://zhuanlan.zhihu.com/p/76301306) 丹麦一项长达 26 年的研究发现，多晒太阳能显著延长寿命，即使是由于过度暴晒诱发皮肤癌的患者，平均寿命也比普通人长了 6 岁。 6.1.5. 药物 NMN 二甲双胍 “胍”吹必看 丨我就是神药——二甲双胍 二甲双胍不仅在多种肿瘤、心血管疾病及糖尿病中发挥保护作用，而且在肥胖、肝病、肾病及衰老方面也大放异彩。 二甲双胍 2020 最值得了解的“吃瓜”大新闻——护胃、健脑、抗衰、防癌还是致癌？ 二甲双胍真的那么神吗？美研究：父亲服用二甲双胍或致子女有缺陷 不良反应 作为一种使用近百年的药物，二甲双胍的不良反应已经非常明确，常见的有：维生素 B12 缺乏（7%-17.4%），胃肠道不良反应（最高 53%），疲倦（9%），头痛（6%）；严重但不常见的不良反应包括乳酸酸中毒、肝损伤；也有研究表明可能对胎儿致畸 复合维生素 服用复合维生素可降低癌症危险 8%，其他效果并不显著 葡萄糖胺 神奇！氨糖降低心血管死亡率 65%，与定期运动效果相当 美国西弗吉尼亚大学最新研究发现 氨糖（软骨素） 可以降低心血管死亡率 65%，降低总体死亡率 39%，效果与坚持定期运动相对 该研究使用 1999 年至 2010 年，16,686 名成年人的国家健康和营养检查(NHANES)数据，参与者的中位追踪时间为 107 个月，而其中有 648 位参与者定期且每服用日 500-1000 毫克的葡萄糖胺/软骨素一年以上。 亚精胺 Science：科学背书！从精液中发现的亚精胺，竟然有着抗衰老、抗癌、保护心血管和神经、改善肥胖和 2 型糖尿病等逆天神效 亚精胺是最容易从人体肠道吸收的多胺。许多的食物中都含有大量的亚精胺，例如新鲜的青椒、小麦胚芽、花椰菜、西兰花、蘑菇和各种奶酪，尤其在纳豆等大豆制品、香菇和榴莲中含量更高。在本实验中，研究人员选择了 829 位年龄在 45-84 岁之间的参与者进行了为期 20 年的随访，分析了饮食中亚精胺摄入量与人类死亡率之间的潜在关联。 研究发现，女性的亚精胺摄入量高于男性，并且摄入量都会随着年龄的增长而下降。亚精胺的主要来源是全谷物（占 13.4%）、苹果和梨（占 13.3%）、沙拉（占 9.8%）、芽菜（占 7.3%）和马铃薯（占 6.4%）。研究根据亚精胺摄入量将人群分为三组，低摄入量组（62.2 µmol / d）、中摄入量组（62.2–79.8 µmol / d）和高摄入量组（ 79.8 µmol / d）。随访期间共记录了 341 例死亡，其中血管疾病 137 例，癌症 94 例，其他原因 110 例。经计算低中高三组的粗略死亡率分别为 40.5%、23.7%和 15.1%，这些数据表明亚精胺摄入量与全因死亡率之间的负相关关系显著。随着逐步对年龄、性别和热量的比例进行调整，这种相关关系依然显著。 综合 《自然》子刊深度综述：如何开发抗衰老药 6.2. 输出 6.2.1. 挥拍运动 哪种运动性价比最高？权威医学杂志“柳叶刀”给出答案了 一周三次，每次 45-60 分钟，挥拍运动，降低~47%全因死亡率 羽毛球、乒乓球、网球等都算挥拍运动，但由于西化研究背景，可能指网球更多。这隐式的表达了全身锻炼更为重要 6.2.2. 剧烈运动 新研究：每天剧烈运动 8 分钟，可降低全因死亡和心脏病风险 每周 15-20 分钟的剧烈运动，降低 16-40%的全因死亡率，剧烈运动时间达到 50-57 分钟/周，可以进一步降低全因死亡率。这些发现表明，通过在一周的短时间内累积相对少量的剧烈运动可以降低健康风险。 6.2.3. 走路 走路降低全因死亡率超过 50%！每天走多少步最合适？《JAMA》子刊超 10 年研究告诉你答案 注 1：这项研究参与者的平均年龄为 45.2 岁 注 2：平均步数的多少与职业有关，此项研究仅表明相关性，还没有更深度的因果分析 6.2.4. 刷牙 50 万国人研究证实：不好好刷牙，致癌！血管疾病也会增多！ 经常不刷牙的人：癌症、慢性阻塞性肺病及肝硬化风险分别增加了 9%、12%和 25%，过早死亡风险增加 25%。 6.2.5. 泡澡 定期洗澡降低心血管疾病发作风险 与每周一至两次泡澡或根本不泡澡相比，每天洗热水澡可以降低 28%的心血管疾病总风险，降低 26%的中风总风险，脑出血风险下降 46%。而浴缸浴的频率与心源性猝死的风险增加无关。 6.2.6. 做家务（老年男性） Housework Reduces All-Cause and Cancer Mortality in Chinese Men 72 岁之后男性每周做重型家务可以减少 29%平均死亡率 重型家务：吸尘、擦地板、拖地、擦洗窗户、洗车、搬动家具、搬煤气罐等等。 轻型家务：掸灰尘、洗碗、手洗衣服、熨烫、晾衣服、做饭、买日用品等等。 6.2.7. 睡眠 超 30 万亚洲人数据：每天睡几个小时最有益长寿？ 在男性中，与睡眠时长为 7 小时相比：睡眠持续时间 ≥10 小时与全因死亡风险增加 34%相关； 在女性中，与睡眠持续时间 7 小时相比：睡眠持续时间 ≥10 小时与全因死亡风险增加 48%相关； 颠覆认知！加拿大研究发现：早睡比熬夜或许更伤身，几点睡才好？ 其中一个结论为，就寝时间与全因死亡率的关联性强，过早睡觉和过晚睡觉都会影响健康，但是早睡增加的全因死亡率比晚睡增加的死亡率高，早睡增加了 43%的死亡风险，而晚睡增加了 15%的死亡风险。 这项调查研究，还存在很多局限性，比如没有直接证明就寝时间与死亡的关系，仅仅说明相关性，通过参与人群自我报告统计睡眠时间，数据不够客观 6.2.8. 久坐 中国居民膳食指南科学研究报告（2021 年） 久坐和看电视时间与全因死亡、心血管疾病、癌症和 2 型糖尿病发病高风险相关，是独立风险因素。久坐时间每天每增加 1 小时，心血管疾病发生风险增加 4%，癌症增加 1%，全因死亡风险增加 3%。全因死亡和 CVD 死亡风险增加的久坐时间阈值是 6~8h/d，看电视时间阈值是 3~4h/d。 世卫组织关于身体活动和久坐行为的指南 6.3. 上下文 6.3.1. 情绪 悲观情绪与更高的全因死亡率和心血管疾病死亡率有关，但乐观情绪并不能起到保护作用 Pessimism is associated with greater all-cause and cardiovascular mortality, but optimism is not protective 在 1993-1995 年间，一项针对 50 岁以上澳大利亚人健康的双胞胎研究中包括了生活取向测试（LOT），其中包含乐观和悲观的项目。平均 20 年后，参与者与来自澳大利亚国家死亡指数的死亡信息相匹配。在 2,978 名具有很多可用分数的参与者中，有 1,068 人死亡。生存分析测试了各种乐观因素和悲观情绪分数与任何原因，癌症，心血管疾病或其他已知原因的死亡率之间的关联。年龄调整后的悲观量表上的核心与全因和心血管疾病死亡率相关（每 1 个标准差单位的危险比，95％置信区间和 p 值 1.134、1.065–1.207、8.85×10 –5 和 1.196、1.045–1.368、0.0093 ），但不会因癌症死亡。乐观得分与悲观得分之间的相关性很弱（年龄调整后的等级相关系数= − 0.176），但与总死亡率或特定原因死亡率没有显着相关性。反向因果关系（引起悲观情绪的疾病）是不可能的，因为在那种情况下，心血管疾病和癌症都会导致悲观情绪。 6.3.2. 贫富 JAMA 子刊：贫富差距真能影响寿命？这可能是真的！ 该研究使用 1994-1996 年第一次收集的数据，并通过生存模型来分析净资产和长寿之间的关联。结果显示，共收纳 5414 名参与者，平均年龄为 46.7 岁，包括 2766 名女性。较高的净资产与较低的死亡风险相关。特别是在兄弟姐妹和双胞胎中（n = 2490），在较高的净资产和较低的死亡率之间观察到类似的关联，表明拥有更多财富的兄弟姐妹或双胞胎比拥有更少财富的兄弟姐妹/双胞胎活得更久。 6.3.3. 体重 JAMA 子刊：减肥要趁早，才能有效降低死亡率风险 对体重减轻的死亡率风险评估发现，体重从肥胖减轻到超重的成年人与稳定肥胖人群相比，全因死亡率降低了 54％（危险比为 0.46），然而从成年初期的超重减轻到中年以前的正常体重的人群的死亡率风险并未降低（风险比为 1.12）。 6.3.4. 新冠 Magnitude, demographics and dynamics of the effect of the first wave of the COVID-19 pandemic on all-cause mortality in 21 industrialized countries 目前来看，新冠死亡率（美国）在 1.5%左右，人均预期寿命减少了 2 年 如何看待美国 CDC 宣称新冠死亡人数被高估？ NVSS deaths","tags":["生活"],"categories":["生活日常"]},{"title":"IOS小火箭教程","path":"/posts/58575.html","content":"[!WARNING] 不要在设置里登录账号，手机有可能会锁机！在 appstore 商店里面操作即可！ 第一步：退出自己的 appstore 账号 点开App Store-点头像-最下面点退出登录 第二步：登录最下方提供的 appstore 账号 输入下方给出的账号密码进去点登录 (显示 ID 安全验证点返回 点其他选项再点不升级) 登录教程如下图： 第三步：下载小火箭 登陆后搜索手动输入 Shadowrοckеt 找到一个白色的小火箭下载就行（有时网络不稳定，要是还显示 2.99$输入密码购买消费即可）(如果要花钱就发消息给我) 要是登录了直接搜索软件名搜索不到，在已购项目里有，还是找不到那就是没登录上，退出账号切换下网络重启手机再登录就好了。 正版小火箭图： 第四步：退出提供的账号,登录你自己的账号 下载好自己需要的软件后立刻退出共享账号！！！ 退出账号：进入App Store点头像-滑到最下面点退出登录(Sign out)，然后登录你自己的账号。 账号:alqp10thomas@hotmail.com 密码:BYG1t93gv3WDr 账号信息更新于 2025-03-01 13:05:12 这个账号可能会在 30 分钟后失效,显示密码错误就给我发消息 常见问题解决方法： 1、密码最好看好大小写复制输入或者手动输入进去登录； 2、如果提示无法登录/Can not sign in (验证失败等)，显示“好”，是连接美区商店网络不稳定，开关飞行模式、切换一下网络状态在重启手机就能登录； 3、登录好后更新不了程序 (注意是更新！)，提示app store 禁用/提示锁定/输入密码等各种问题，都要先卸载原先下载的应用在登录才可下载！ (因为你的软件程序是其他账号下载的，不能用此账号直接更新，需先卸载原先软件才能下载) 4、登录已付费 App 账号，还需要购买？是商店缓存导致的， 不用管，搜索后点击购买输入账号密码购买就好 5、登陆后商店搜不到购买的 App？ 这种是网络卡住了，没有自动切换过去，可以先在已购项目找找看；要是没有就退出账号，重启一下手机再登陆账号搜索就有了！(重启重新登录还是没有的话再发消息) 6、登录 ID 提示此 Appleid 已停用、”这个 Appleid 没有被激活、“这个人不在激活状态，解决办法：给我说账号停用了 小火箭使用教程 1、下载客户端 2、导入订阅链接 1、将下面的一长串网页链接(服务器订阅地址)复制到系统剪贴板中，以供下一步手动导入使用。 https://赔钱.com/api/v1/client/subscribe?token=d67f76adecaf76bc1befa355fbf00a99flag=meta 2、进入客户端首页，选择右上角 + 按键。 3、类型选择「Subscribe」，将第一步复制的订阅地址粘贴到URL 栏中，在下方备注区域输入分组名称(一般写服务器资源来源)，最后点击右上角完成按钮保存 4、回到客户端首页，可以看到客户端已经自动下载好所有节点及相关信息。 5、进入配置选项页，建议使用默认配置文件即可。 6、进入设置选项页，按照下图将订阅设置项的“打开时更新”和“自动后台更新”选项同时开启。 7、回到首页点击上方全局路由可以更改代理模式，其中： “配置”为配置文件代理（即按照规则自动分流） “代理”为全局代理（即所有连接均走代理） “直连”为绕过代理（即所有连接均不代理） “场景”适用于不同网络环境下自动切换代理模式 非专业用户推荐使用默认的“配置”模式进行自动分流。 点击首页右上方系统总开关即可开启代理服务 3、万一所有服务器都失效,怎么手动更新订阅。 在配置那一行右滑就会出现更新订阅的按钮，点击即可更新订阅","tags":["教程"]},{"title":"用ai批量生成课设报告","path":"/posts/114514.html","content":"1.安装 Automa 如果可以科学上网，点击下面的 chrome 浏览器插件商店一键安装 Automa - Chrome 应用商店 (google.com) 如果没有科学上网，则打开下面的插件官方 GitHub 仓库网址 AutomaApp/automa: A browser extension for automating your browser by connecting blocks (github.com) 找到下面发行版 (release)的选项,点击它 . 下载这个压缩包 . 下载好后，点击edge或者chrome浏览器的扩展按钮，点击管理扩展 . 打开开发人员模式，将下载好的压缩包直接拖入扩展管理界面 . . 如果弹出了 Automa 界面，说明安装成功 2.导入脚本到 Automa 1.点击浏览器上的 Automa 插件后，点击主面板按钮 . 2.弹出一个界面，点击导入工作流 . 3.找到脚本文件并导入： . 4.看到菜单里有此脚本说明导入成功： . 5.需要给 Automa 读取本地文件的权限 在扩展管理界面点击 Automa 下面的详细信息按钮 . 勾选允许访问文件 URL： . 3.编写自己的提示词 打开QA.xlsx这个表格 . 可以看到里面有很多提示词 . 怎么批量修改表格里的内容？ 例如，你要修改你的名字，先按CTRL+F,唤出查找和替换页面 . 写出类似于这样的修改 . 点击一键替换即可 你需要批量替换表格里的以下内容（将非通用内容改为自己的）： XX 管理系统 你的姓名 系统概述：XX 管理系统旨在提供一个高效的在线平台，用于图书的展示、销售与管理。该系统面向普通用户和管理员，覆盖了从图书浏览、订单管理到后台数据分析等功能，满足了用户方便购书和管理员高效管理的需求。 修改好了上面的内容后，保存一下表格 4.提前登陆 kimiai 点击下面的网址，在里面进行登陆 Kimi.ai - 帮你看更大的世界 (moonshot.cn) 5.启动脚本 点击启动按钮 . 将这个路径改为自己表格所在路径： . 点击 run 启动 然后就可以看到 ai 在自动写报告的文字内容 . 写完后会生成一个表格文件 . 用 excel 打开这个文件，就可以看到 ai 生成的结果 . 生成报告的图片内容 1.系统结构图 ai 提示词如下 我想画一个“XX系统”的系统结构图，但是我是一个大学生小白，不懂这一部分具体的内容改怎么画。我希望你作为一个经验丰富的架构师。请帮我梳理一下这个系统的系统架构，并使用mermaid图来表示。 将生成的代码复制到支持 markdown（mermaid）的文本编辑器里就可以看到图片 下面是一个在线的 mermaid 编辑器 Online FlowChart Diagrams Editor - Mermaid Live Editor 2.er 图 【VS Code】Windows10 下 VS Code 配置 Graphviz 和 DOT 语言环境_怎么给 codeblocks 配置 graphviz-CSDN 博客 AI 提示词如下： 按照下面第二段的规则，用 dot 语法给第一段的 sql 代码画一个图要求：每个实体，属性，关系都用中文表示，让实体及其属性尽量的靠在一起，实体的属性环绕在实体旁边，属性连接各个实体：---## 这里放你数据库的 sql 定义!​ 1.1 长方形：表示实体。​ 实体是客观存在的事物。​ 例如用户、商品、订单、供应商等。说直白了，就是数据库的表名就可以做一个实体对象。一个系统是由很多个实体对象构成的，然后它们之间存在一定的关系和属性。​ 1.2 椭圆形：表示属性。​ 属性分为唯一属性（ unique attribute）和非唯一属性，唯一属性指的是唯一可用来标识该实体实例或者成员的属性，用下划线表示，一般来讲实体都至少有一个唯一属性。​ 举个栗子：用户实体拥有属性【id（唯一属性）、姓名、年龄、电话、身份证号（唯一属性）】、商品实体拥有属性【id、商品名称、商品类型、商品价格、商品图片、商品描述、供应商名称】、订单实体拥有属性【id、订单编号、用户名称、商品名称、下单日期】、供应商实体拥有属性【id、名称、地址、联系电话】。​ 1.3 菱形：表示关系。## ​ 例如用户和商品应该购买关系（一个用户购买多件商品）、订单与商品应该是包含关系（一个订单中包含多件商品）。"},{"title":"校园网多设备共享","path":"/posts/114515.html","content":"无需硬件！手把手教你在 VMware 上安装软路由，实现校园网多设备共享上网！ 写这一篇文章是为了防止学校的校园网以后使用别的防检测手段，到时怕忘了如何编译 OpenWrt ‍ 本文绝大部分参考以下两位 up 主的视频，在这里万分感谢！！！ 【正片】面对校园网的多设备检测，「我」的解决方案是—— 校园网防检测！软路由固件编译教程 1.搭建本地编译环境 1.1 下载 Ubuntu 镜像，推荐 Ubuntu20.04.05 LTSx64 https://cn.ubuntu.com/download/desktop 1.2 安装 ubuntu 虚拟机 以 VMware Workstation 16 Pro 16.2.4 版本为例，新建虚拟机，选择自定义选项 PS：如果你要安装很多插件建议最低保持 100G 添加 Ubuntu 系统镜像 安装完成之后，打开软件与更新，将下载自（位于中国的服务器）修改为阿里云的地址，下载快点，也可以不修改。 安装完测试一下宿主机能不能和 ubuntu 虚拟机进行直通，后面会需要复制粘贴命令行到终端，如果能复制粘贴命令行到 ubuntu 虚拟机中，则跳过安装 vmware tools（以下三行） sudo apt upgradesudo apt install open-vm-tools-desktop -ysudo reboot 1.3 配置编译环境 按 Ctrl+Alt+T 快捷键在终端输入以下命令 sudo apt updatesudo apt upgrade -y 执行完毕输入 sudo apt-get -y install build-essential asciidoc binutils bzip2 gawk gettext git libncurses5-dev patch python3 python2.7 unzip zlib1g-dev lib32gcc-s1 libc6-dev-i386 subversion flex uglifyjs gcc-multilib p7zip p7zip-full msmtp libssl-dev texinfo libglib2.0-dev xmlto qemu-utils upx-ucl libelf-dev autoconf automake libtool autopoint device-tree-compiler g++-multilib antlr3 gperf wget curl swig rsync 从这一步开始开启网络代理，否则有的文件无法下载 下载 lede 大佬的源码，注意下载路径不能有中文 git clone https://github.com/coolsnowwolf/lede 无法下载的话设置一下 git 代理 git config --global --unset http.proxygit config --global --unset https.proxy 进入 lede 目录 cd lede 拉取校园网防检测所需要的模块 git clone https://github.com/EOYOHOO/UA2Fgit clone https://github.com/EOYOHOO/rkp-ipid.git package/rkp-ipid 然后进入 lede 源码的根目录中添加下面代码到 feeds.conf.default 文件 src-git kenzo https://github.com/kenzok8/openwrt-packagessrc-git small https://github.com/kenzok8/small 更新 feed 模块，终端输入 ./scripts/feeds update -a./scripts/feeds install -a 2. 本地编译.config 打开编译菜单，在终端输入 make menuconfig 前三项选择以下选项(VMware 是 x86 架构，所以咱们选 x86 的) ‍ 以下为校园网防检测必选 # 勾选上 ipid# kernel-modules-Other modules-kmod-rkp-ipid# 选上模块# kernel modules-Netfilter Extensions-kmod-ipt-ipopt# kernel modules-Netfilter Extensions-kmod-ipt-u32# 勾选上 ua2f# network-Routing and Redirection-ua2f# 选上模块# network-firewall-iptables-mod-conntrack-extra# network-firewall-iptables-mod-filter# network-firewall-iptables-mod-ipopt# network-firewall-iptables-mod-u32 Copy 根据自己喜好选择插件，然后保存退出 插件参考链接：Applications 添加插件应用说明-L 大 ‍ 3. 本地编译 openwrt 固件 下载 dl 库，在终端输入 make download -j8 Copy 开始编译固件，在终端输入 （-j 后面是线程数，第一次编译推荐用单线程） make V=s -j1 Copy 编译完成后镜像包输出路径：lede/bin/targets 然后这里会有两个镜像文件分别是：openwrt-x86-64-generic-squashfs-rootfs.img.gz 和 openwrt-x86-64-generic-squashfs-combined.img.gz， 选择导出：openwrt-x86-64-generic-squashfs-combined.img.gz 如果第一次编译失败，进入虚拟机进行二次编译 cd lederm -rf ./tmp rm -rf .configgit pull./scripts/feeds update -a ./scripts/feeds install -amake menuconfig Copy 4. 在线编译 openwrt 固件 使用 github Actions 功能编译固件 此方法需要有 github 账号，将 P3TERX 项目拉到自己账号仓库 参考视频：校园网防检测！软路由固件编译教程——利用 github 编译 openwrt 固件 PS：GitHub Actions 是有限制的，安装很多插件可能会导致编译失败，不过安装文章里的插件是可以编译成功的，详情请看：GitHub Actions 官方文档-使用限制、计费和管理 然后编辑拉取到自己仓库下 diy2 脚本，添加 ua2f 和 rkp-ipid 模块 git clone https://github.com/EOYOHOO/UA2F.git package/UA2Fgit clone https://github.com/EOYOHOO/rkp-ipid.git package/rkp-ipid 在虚拟机进入 lede 目录，将 feeds.conf.default 文件和 .config 文件导出虚拟机 以记事本打开.config 文件按 Ctrl+F 查找 Netfilter Extensions 关键词，在 Netfilter Extensions 下第二行后添加代码，保存 CONFIG_NETFILTER_NETLINK_GLUE_CT=y 上传 feeds.conf.default 文件和 .config 文件 查看一下是否上传完毕 开始编译 当出现这个界面时，Actions 已经开始编译，编译时间 4-6 小时（插件越多编译时间越长） 报错的话，到 Ubuntu 虚拟机上重新编译一次 ‍ 5. 刷入 openwrt 系统 5.1 镜像转换 将编译好的固件包导出来，使用 StarWind V2V Converter 将 img 镜像文件转换为 vmdk 格式 StarWind V2V Converter 下载地址：https://www.starwindsoftware.com/tmplink/starwindconverter.exe 5.2 创建虚拟机并导入固件 以 VMware Workstation 16 Pro 16.2.4 版本为例，新建虚拟机，选择自定义选项 此时先不要开机，在创建好的虚拟机点击编辑虚拟机设置，添加另一个网络适配器 网络适配器 NAT 做 lan(第一个不用改，Openwrt 默认将第一个网口设置为 lan 口)，网络适配器 2 桥接模式(自动)做 wan 口 5.3 虚拟机网卡配置 点击虚拟网络编辑器，将桥接模式的网卡修改为计算机的物理网卡（当作 openwrt 的 wan 口）然后将 NAT 模式的 nat 地址这里划分为 192.168.20.0 5.4 配置上网环境 宿主机通过虚拟机中的 Openwrt 上网 该方案原理是 OpenWrt 作为主路由，VMware 的虚拟机和宿主机的数据流量都是要通过 OpenWrt，取消宿主机物理网卡的 ipv4 和 ipv6，使 OpenWrt 虚拟机的 WAN 口桥接到了物理网卡上，接管了 IP 层的工作，此时，宿主机通过 NAT 模式虚拟网卡连接到 OpenWrt 虚拟机 LAN 口通过 OpenWrt 上网 wan 口（就是你要桥接的物理网卡） lan 口（配置 VMware Network Adapter VMnet8） 6. 配置 OpenWrt 6.1 防检测配置 开机进入 OpenWrt 系统设置, 勾选启用 NTP 客户端和作为 NTP 服务器提供服务 在候选 NTP 服务器四个输入框分别填写：ntp1.aliyun.com、time1.cloud.tencent.com、stdtime.gov.hk 、pool.ntp.org 然后保存并应用 6.2 防火墙添加一下自定义规则 点击网络–防火墙–自定义规则，添加以下规则 iptables -t nat -A PREROUTING -p udp --dport 53 -j REDIRECT --to-ports 53iptables -t nat -A PREROUTING -p tcp --dport 53 -j REDIRECT --to-ports 53#通过rkp-ipid设置IPID#若没有加入rkp-ipid模块，此部分不需要加入iptables -t mangle -N IPID_MODiptables -t mangle -A FORWARD -j IPID_MODiptables -t mangle -A OUTPUT -j IPID_MODiptables -t mangle -A IPID_MOD -d 0.0.0.0/8 -j RETURNiptables -t mangle -A IPID_MOD -d 127.0.0.0/8 -j RETURN#由于本校局域网是A类网，所以我将这条注释掉了，具体要不要注释结合你所在的校园网iptables -t mangle -A IPID_MOD -d 10.0.0.0/8 -j RETURNiptables -t mangle -A IPID_MOD -d 172.16.0.0/12 -j RETURNiptables -t mangle -A IPID_MOD -d 192.168.0.0/16 -j RETURNiptables -t mangle -A IPID_MOD -d 255.0.0.0/8 -j RETURNiptables -t mangle -A IPID_MOD -j MARK --set-xmark 0x10/0x10# 防时钟偏移检测iptables -t nat -N ntp_force_localiptables -t nat -I PREROUTING -p udp --dport 123 -j ntp_force_localiptables -t nat -A ntp_force_local -d 0.0.0.0/8 -j RETURNiptables -t nat -A ntp_force_local -d 127.0.0.0/8 -j RETURNiptables -t nat -A ntp_force_local -d 192.168.0.0/16 -j RETURNiptables -t nat -A ntp_force_local -s 192.168.0.0/16 -j DNAT --to-destinatio# 通过 iptables 修改 TTL 值 数字为需要的修改的 ttl 值iptables -t mangle -A POSTROUTING -j TTL --ttl-set 64#iptables 拒绝 AC 进行 Flash 检测iptables -I FORWARD -p tcp --sport 80 --tcp-flags ACK ACK -m string --algo bm --string src=\\http://1.1.1. -j DROP 6.3 UA2F 配置 # 开机自启uci set ua2f.enabled.enabled=1# 自动配置防火墙(默认开启) (建议开启)uci set ua2f.firewall.handle_fw=1uci set ua2f.firewall.handle_tls=1uci set ua2f.firewall.handle_mmtls=1uci set ua2f.firewall.handle_intranet=1# 保存配置uci commit ua2f# 开机自启service ua2f enable# 启动 ua2fservice ua2f start# 重启一下设备reboot ‍‍ 然后这里有两个骚操作可以为其他设备提供网络： 方法一：电脑上下载360 免费 WIFI，开启 WIFI，这里有几率无法创建无线网络，可以以校园网模式运行，（注意使用此方法开热点，网速就看你学校网络质量了，我这边白天用好到爆，晚上的时候卡成狗，玩游戏都玩不了） 方法二：将电脑的网络桥接给路由器（此步骤要有一个路由器和网线）打开网络控制面板—网络和 Internet—网络和共享中心—更改适配器设置—然后按住 Ctrl 键选择 VMware Network Adapter VMnet8 和电脑的有线物理网卡(如图)，选择桥接连接。然后进入路由器改为桥接模式，然后可以多设备上网了！！！ ua 检测网站（有可能显示不正确，但能使用） UserAgent 查看/UA 检测 - 在线工具 注： 如果你手上有 X86 硬路由或者可以刷机的路由器 (如：红米 AC2100)，可以在(2.本地编译.config)打开编译菜单时将前三项修改成你的路由器相关信息，在编译完成 openwrt 固件后导出虚拟机，通过 U 盘将镜像上传到你的设备 参考资料 【正片】面对校园网的多设备检测，「我」的解决方案是—— 校园网防检测！软路由固件编译教程 VMware 安装 OpenWrt 虚拟机让宿主机上网 VMware 安装 OpenWrt 让宿主机上网旁路由（两种方案）"},{"title":"Linux命令速查手册","path":"/posts/15440.html","content":"按Ctrl + F搜索 shell 的作业控制 命令 作用 jobs 列出作业 在后台运行作业 Ctrl+Z 挂起当前（前台）作业 suspend 挂起 shell 的执行 fg [%jobnumber] 撤销作业的挂起操作，让它在前台运行 bg [%jobnumber] 让挂起的作业在后台运行 文件基本操作 命令 作用 ls 列出目录中的文件 cp 复制文件 mv 重命名（“移动”）文件 rm 删除（“移除”）文件 ln 创建文件链接（替代名称） ls 格式：ls [option] [files] 作用：列出文件和目录的属性 常用选项： -a 列出所有的文件，包括文件名以句点开头的文件 -l 长列表，包括文件属性。添加-h 选项后，输出文件大小时，将以千字节、兆字节和千兆字节为单位，而不是以字节为单位 -G 在长列表中，不输出文件的组所有权 -F 用意义明确的符号修饰文件名称，从而指示文件的类型。通常，文件名后面附加“/”表示“可执行文件”，附加“@”表示符号链接，附加“|”表示命名管道，附加“=”表示套接字。这些只是对人类有提示作用的视觉标识，而不是文件名的一部分。 -S 按大小对文件排序 -t 按照最近修改时间对文件进行排序 -r 反序 -R 显示目录时，递归显示其内容 -d 显示目录时，不显示其内容，仅显示目录本身的信息 cp 格式：cp [options] files (file | directory) 作用：复制文件 常用选项： -p 不仅复制文件内容，同时复制文件权限、时间戳，同时如果你具有足够的权限的话，还可以复制其属主和用户组（通常，这些副本将归你所有，以当下时间作为时间戳，相应的权限则是通过将 umask 应用于原始权限来设置的） -a 递归复制目录的层次结构，保留所有的文件属性和链接 -r 递归复制目录的层次结构。该选项不保留文件的属性，如权限和时间戳，但是会保留符号链接 -i 交互模式。在覆盖目标文件之前会进行询问 -f 强制复制。如果目标文件存在的话，则无条件覆盖 mv 格式：mv [options] source target 作用：对文件进行重命名，或将文件或目录移动到目标目录中 常用选项： -i 交互模式。在覆盖目标文件之前进行询问 -f 强制移动。如果目标文件存在的话，则无条件覆盖 rm 格式：rm [options] files | directories 作用：删除文件或递归删除目录 常用选项： -i 交互模式。在删除每个文件之前都会进行询问 -f 强制删除，忽略任何错误或警告 -r 递归删除目录及其内容。该选项请谨慎使用，特别是与-f 选项结合使用时尤其如此，因为这会删除所有的文件 ln 格式：ln [options] source target 作用：创建链接 常用选项： -s 创建一个符号链接而非硬链接 -i 交互模式。在覆盖目标文件之前进行询问 -f 强制链接。如果目标文件存在的话，则无条件覆盖 -d 创建指向目录的硬链接（仅限于超级用户） 注：readlink linkname命令用于查找符号链接指向的位置，而当符号链接指向其他符号链接时，要想找出整个链接最终指向的位置，请使用readlink -f命令 目录操作 命令 作用 cd 更改当前目录 pwd 打印当前目录的名称 basename 打印文件路径的最后部分 dirname 打印文件路径，其中不包括最后部分 mkdir 创建目录 rmdir 删除空目录 rm -r 删除非空目录及其内容 cd 格式：cd [directory] 作用：设置当前的工作目录 注：如果不提供具体目录的话，默认切换到主目录 pwd 格式：pwd 作用：输出当前工作目录的绝对路径 basename 格式：basename path [extension] 作用：输出文件路径中的最后面部分 注：如果提供了可选的扩展名，那么结果中的扩展名也同时删除 dirname 格式：dirname path 作用：输出文件路径（同时删除其最后面的部分） 注：dirname 命令不会改变当前的工作目录。它只是处理并输出一个字符串，与 basename 类似 mkdir 格式：mkdir [options] directories 作用：创建一个或多个目录 常用选项： -p 给定目录路径（而非简单的目录名），自动创建必需的父目录 -m 创建具有给定权限的目录，如：mkdir -m 0755 publicdir，默认情况下，赋予的权限是由 shell 的 umask 来控制的 rmdir 格式：rmdir [options] directories 作用：删除一个或多个空目录 常用选项： -p 如果提供了目录路径（而非简单的目录名称），那么不但可以自动删除指定的目录，还可以自动删除指定的父目录 注：要删除非空目录及其内容，请谨慎使用 rm -r 目录。如果使用 rm -ri 命令的话，可以进行交互式删除，如果使用 rm -rf 命令的话，则会直接删除而不提供任何错误信息，同时也不要求进行确认 查看文件 命令 作用 cat 查看完整的文件 less 逐页查看文本文件 nl 利用行编号查看文本文件 head 查看文本文件的第一行 tail 查看文本文件的最后一行 strings 显示嵌入二进制文件的文本 od 以八进制（或其他格式）格式查看数据 cat 格式：cat [options] [files] 作用：将文件输出至标准输出，或将一组文件发送到 shell 管道 常用选项： -T 将制表符输出为 I -E 将换行符输出为$ -v 以人类可读的格式打印其他非打印字符 -n 为每行添加行号 -b 为非空白行添加行号 -s 将连续的空白压缩为一个空白行 less 格式：less [options] [files] 作用：以每次一页的方式查看文本 常用选项： -c 在显示下一页之前清除屏幕。这样可以避免滚屏，并且看起来更加舒适 -m 输出更详细的提示，并给出显示进度 -N 显示行号 -r 按照字面形式显示控制字符；通常 less 会将控制字符转换为人类可读的格式 -s 将多个相邻的空白行压缩成单个空白行 -S 当某行内容很长时，截短为与屏幕等宽 nl 格式：nl [options] [files] 作用：将文件复制到标准输出，并添加行号 常用选项： -b [a|t|n|p R] 在所有行（a）、非空白行（t）或包含正则表达式 R 的行前面添加行号。而 n 表示不给任何一行编号（默认值=a） -v N 从整数 N 开始编号（默认值=1） -i N 每一行递增 N，例如，你可以仅使用奇数（-i 2）或偶数（-v 2 -i 2）（默认值=1） -n [ln|rn|rz] 将编号格式化为左对齐（ln）、右对齐（rn）或带前导零（rz）的右对齐（默认值=ln） -w N 将数字的宽度强制为 N 列（缺省值=6） -s S 在行号和文本之间插入字符串 S（默认值=Tab） head 格式：head [options] [files] 作用：输出文件前 10 行，或预览命令管道输出的前几行内容 常用选项： -n N 打印前 N 行，而不是前 10 行 -N 作用与-n N 相同 -c N 输出文件的前 N 个字节 -q 安静模式，当处理一个以上的文件时，不在每一个文件之上打印一个横幅。通常，head 命令会输出包含文件名的横幅 tail 格式：tail [options] [files] 作用：输出文件的最后 10 行，并执行其他操作 常用选项： -n N 输出最后 N 行，而不是最后 10 行 -N 作用与-n N 相同 -n +N 输出除了第 N 行之外的所有行 -c N 输出文件的最后 N 个字节 -f 打开文件，每当文件附加新的行时，输出它们。这个功能是非常有用的。如果文件不存在，但你想等到它出现的话，可以添加–retry 选项 -q 安静模式，当处理的文件多于一个的时候，不给每个文件都输出一个横幅。通常情况下，tail 都会输出一个包含文件名的横幅 strings 格式：strings [options] [files] 作用：提取二进制文件中的可读文本，并将其显示在标准输出中 常用选项： -n length 仅显示长度大于 length（默认值为 4）的字符串 od 格式：od [options] [files] 作用：查看二进制文件 常用选项： -N B 仅显示每个文件的前 B 字节，可以用十进制、十六进制（通过前缀 0x 或 0X）、512 字节块（通过附加 b）、千字节（通过附加 k）或兆字节（通过附加 m）来指定（默认情况下会显示整个文件） -j B 从每个文件的第 B+1 字节处开始输出，可接受的格式与-N 选项相同（缺省值=0） -w [B] 每行显示 B 字节，可接受的格式与-N 选项相同。如果只是使用-w 本身的话，就等同于-w 32（默认值=16） -s [B] 将每行字节分为 B 字节为单位的序列，由空格分隔；可接受的格式与-N 选项相同。如果只是使用-s 本身的话，就等同于-s 3（默认值=2） -A(d|o|x|n) 显示最左列，可以以十进制（d）、八进制（o）、十六进制（x）或全部（n）为单位（默认值=o） -ta|c 以字符格式显示输出，非字母数字字符输出为转义序列（c）或名称（a） -td|o|u|x 以整数格式显示输出，可以使用八进制（o）、有符号十进制（d）、无符号十进制（u）、十六进制（x） 注：将 z 附加到-t 选项的话，会在输出的右侧输出一个新列，用来显示每行中的可打印字符 文件属性 命令 说明 stat 显示文件和目录的属性 wc 统计字节数、字数和行数 du 显示文件和目录的磁盘使用情况 file 识别（猜测）文件的类型 touch 更改文件和目录的时间戳 chown 更改文件和目录的属主 chgrp 更改文件和目录所属的用户组 chmod 更改文件和目录的保护模式 umask 为新的文件和目录设置默认模式 chattr 更改文件和目录的扩展属性 lsattr 列出文件或目录的扩展属性 stat 格式：stat [options] files 作用：显示文件（默认情况下）或文件系统（-f 选项）的重要属性 常用选项： -L 跟踪符号链接，并报告它们指向的文件 -f 显示文件所在文件系统的信息，而不是文件本身的信息 -t 简洁模式，单行输出所有信息 wc 格式：wc [options] [files] 作用：输出文本文件中的字节数、字数和行数 常用选项： -l 仅输出行数 -w 仅输出字数 -c 仅输出字节数 -L 找出每个文件中最长的行，并以字节为单位输出该行的长度 du 格式：du [options] [files | directories] 作用：输出文件或目录所占用的磁盘空间（以块为单位） 常用选项： -b 输出以字节为单位的大小 -k 输出以千字节为单位的大小 -m 输出以兆字节为单位的大小 -B N 根据所定义块为单位来显示大小，其中 1 个块=N 字节（默认值=1024） -h -H 以人类可读的单位进行输出。-h 选项使用 1024 的幂，而-H 则使用 1000 的幂 -c 在最后一行输出总数。这是输出目录大小时的默认设置，但是用于特定文件的时候，如果需要统计总大小的话，请使用-c 选项 -L 跟踪符号链接并显示它指向的文件的大小 -s 仅输出总大小 -a 递归显示 file 格式：file [options] files 作用：输出文件的类型 常用选项： -b 输出时忽略左边部分的文件名 -i 输出文件的 MIME 类型，而不是常规的文件信息 -f name_file 从给定的 name_file 文件中读取文件名，逐行读取，每行一个文件名，并报告其类型。之后，以常规命令行的方式处理文件名 -L 跟踪符号链接，然后报告目标文件的类型，而不是显示链接的类型 -z 如果文件被压缩，则检查未压缩的内容以确定文件类型，而非显示“压缩数据” touch 格式：touch [options] files 作用：修改文件的两个时间戳（修改时间、访问时间）；创建空文件 常用选项： -a 仅修改访问时间 -m 仅更改修改时间 -c 如果文件不存在，不要创建它 -d timestamp 设置文件的时间戳 -t timestamp 一种设置时间戳的高级方式，格式为[[CC]YY] MMDDhhmm [.ss] chown 格式：chown [options] user_spec files 作用：设置文件和目录的所有权 user_spec参数可以是： 现有用户名（或任何数字形式的用户 ID），以便设置属主 现有用户名（或任何数字形式的用户 ID），作为可选项可以跟冒号和现有用户组名（或任何数字形式的用户组 ID），以便设置属主和用户组 现有的用户名（或任何数字形式的用户 ID）后面跟冒号，来设置属主，并将用户组设置为调用用户的登录组 位于冒号之后的现有用户组名（或任何数字形式的组 ID），仅设置用户组 –reference=file，将属主和用户组设置为给定的另一个文件的属主和用户组 常用选项： –dereference 跟踪符号链接并对其指向的文件进行操作 -R 递归更改目录层次结构中的相应权限 chgrp 格式：chgrp [options] group_spec files 作用：设置文件和目录的属组 group_spec参数可以是以下任何一种： 用户组名或数字形式的用户组 ID –reference=file，将属组设置为另一给定文件的属组 常用选项： –dereference 跟踪符号链接，并对其指向的文件进行操作 -R 递归更改目录层次结构中的所有权 chmod 格式：chmod [options] permissions files 作用：设置文件和目录的访问权限 permissions参数可以采用三种不同的形式： –reference=file，设置与其他给定文件相同的权限 最多四位数字的八进制数，用于指定文件的绝对权限 一个或多个字符串，指定绝对权限或相对权限（即相对于该文件的现有权限） 常用选项： -R 递归更改目录层次结构中的所有权 umask 格式：umask [options] [mask] 作用：设置或显示创建文件和目录时的默认模式，赋予自己、用户组和所有人相应的读、写和/或执行权限 常用选项： -S 以更直观的形式显示默认模式 chattr 格式：chattr [options] [+ - =] attributes [files] 作用：设置或更改扩展属性（仅限 ext 文件系统） 属性 含义 a 只能进行追加：只能向文件中添加数据，而不能编辑数据，只有 root 才能设定这个属性 A 不访问时间戳：对这个文件进行访问时不会更新其访问时间戳（atime） c 压缩：数据在写入时自动压缩，在读取时自动解压缩 d 不转储：在进行备份时，告诉转储程序忽略此项 i 不可变：不允许对该文件进行更改或删除（仅限 root 使用该属性） j 文件在写入时会先被记录在 journal 中（仅限 ext3 系统） s 安全删除：删除时，用零覆盖文件中的所有数据 S 同步更新：更改将立即写入磁盘 u 不可删除：该文件不允许执行删除操作 常用选项： -R 递归处理目录 lsattr 格式：lsattr [options] files 作用：显示扩展属性 注：如果没有指定文件的话，lsattr 会输出当前目录中所有文件的属性 常用选项： -R 递归处理目录 -a 列出所有的文件，包括以点号开头的文件 -d 如果显示目录的话，不显示其内容，仅显示目录本身 文件的定位 命令 作用 find 在目录层次结构中查找文件 xargs 处理找到的文件列表（以及其他功能） locate 创建一个文件索引，然后通过索引搜索字符串 which 在搜索路径中查找可执行文件（命令） type 查找搜索路径中的可执行文件（bash 内置命令） whereis 查找可执行文件、文档和源文件 find 格式：find [directories] [expression] 作用：在一个或多个目录（及其递归子目录）中搜索符合特定条件的文件 常用选项： -name|-path|-lname pattern 查找对象的文件名称（-name）、路径名（-path）或符号链接目标文件（-lname）必须匹配这里给出的 shell 模式，其中可以含有 shell 通配符*，?和[]（必须对通配符进行转义处理，以便让 shell 忽略这些通配符本身，而按照通配符所指代的内容进行查找）。注意，这里的路径是相对于正在搜索的目录树的相对路径 -iname|-ipath|-ilname pattern 分别对应于前面三个，不区分大小写 -regex regexp 路径（相对于正在搜索的目录树）必须与给定的正则表达式相匹配 -type t 仅查找类型为 t 的文件。这些类型包括普通文件（f）、目录（d）、符号链接（l）、块设备（b）、字符设备（c）、命名管道（p）和套接字（s） -atime|-ctime|-mtime N 以 N*24 小时为参考，最后一次访问（-atime）、最后一次修改（-mtime）或发生状态变化（-ctime）的文件。此外，+N 表示“大于 N”，而-N 表示“小于 N” -amin|-cmin|-mmin N 以 N 分钟为参考，最后一次访问（-amin）、最后一次修改（-mmin）或发生状态变化（-cmin）的文件。此外，+N 表示“大于 N”，而-N 表示“小于 N” -anewer|-cnewer|-newer other_file 访问时间（-anewer）、修改时间（-newer）或者状态变化时间（-cnewer）晚于 other_file 的相应时间的那些文件 -maxdepth|-mindepth N 在正在搜索的目录树中查找文件时，最少（-mindepth）或最多（-maxdepth）搜索 N 层 -follow 如果遇到符号链接，就跟踪链接所指的文件 -depth 继续使用深度优先搜索：在对目录本身进行操作之前，首先通过递归方式彻底搜索目录中的内容 -xdev 将搜索范围限制为单个文件系统（即不允许跨越设备边界） -size N[bckw] 查找大小为 N 的文件，其单位可以是块（b），单字节字符（c），千字节（k）或双字节的字（w）。+N 表示“大于 N”，-N 表示“小于 N” -empty 查找大小为零的普通文件或目录 -user name 查找属主为给定用户的文件 -group name 查找属组为给定用户组的文件 -perm mode 查找权限与给定模式相同的文件。可以使用-mode 来检查所有给定的位是否被设置，或者使用+mode 来检查给定的位是否被设置 此外，可以使用运算符对表达式的组成部分进行分组和求反： expression1 -a expression2：与运算，该选项为默认值 expression1 -o expression2：或运算 ! expression 或-not expression：对表达式的值进行求反 (expression)：优先级标记 expression1,expression2：计算两个表达式的值，然后返回第二个表达式的值 指定搜索条件后，就可以让 find 命令在符合条件的文件上执行以下操作。 常用选项： -print 只需输出相对于搜索目录的相对路径 -printf string 输出给定的字符串，可以用 C 库函数 printf()的方式对其进行替换 -printO 类似于-print，区别在于不是使用换行符分隔每行输出，而使用 null（ASCII 0）字符。通常在将搜索结果以管道方式传递给另一个程序，并且文件名列表可能含有空格时使用。当然，这要求接收程序必须能够读取并解析这些以 null 字符分隔的行 -exec cmd; 调用给定的 shell 命令 cmd。需要注意的是，一定要对 shell 元字符转义处理，包括最后面的分号，因此它们不会在命令行中立即进行计算。此外，符号“{}”（务必加上引号或进行转义处理）代表所找的文件的路径，如：find . -exec ls '' \\; -ok cmd 与-exec 选项的作用类似，区别是将在调用每个命令之前提示用户 -ls 对文件执行 ls -dils 命令 xargs 格式：xargs [options] [command] 作用：从标准输出读取文本行，将其转换为命令，并执行 常用选项： -n K 对于每个命令来说，只使用输入中的 K 行内容。而-n 1 的作用是确保每个命令只处理一行输入。否则，xargs 可以将多行输入传递给单个命令 -O 将输入的行尾字符设置为 ASCII 的零字符，而非空格符，并且按照字面含义来处理所有字符。当输入来自 find -printO 时，可以使用该选项 locate 格式：locate [options] 作用：在一个不太发生变化的目录层次结构中搜索文件 注：将 locate 命令与 updatedb 命令搭配使用的话，可以创建一个搜索速度极快的文件位置的索引（数据库） updatedb 命令的索引选项： -u 从根目录向下创建索引 -U directory 从 directory 向下创建索引 -l(0|1) 安全功能开关，0 表示关闭，1 表示打开。默认值为 1 -e directories 从索引中排除一个或多个目录，这里使用的路径分隔符为逗号 -o outfile 将索引写入 outfile 文件中 locate 命令的搜索选项： -d index 指出要使用的索引 -i 搜索时不区分大小写 -r regexp 搜索与给定正则表达式匹配的文件 which 格式：which file 作用：在 shell 的搜索路径中查找可执行文件 注：如果搜索路径中有重名的程序，只会显示首先找到的那个程序 type 格式：type [options] commands 作用：在 shell 的搜索路径中查找可执行文件 注：type 是内置在 bash shell 中的，而 which 则是位于硬盘上的外部程序。作为一个内置的 shell 命令，在速度方面 type 要比 which 更快一些，但它的不足之处在于只能在某些 shell（如 bash）中使用 whereis 格式：whereis [options] files 作用：通过搜索硬编码的目录列表来查找给定的文件，可以查找可执行文件、文档和源代码 常用选项： -b|-m|-s 仅列出可执行文件（-b）、联机帮助页（-m）或源代码文件（-s） -B|-M|-S dirs… -f 仅在给定的目录中搜索可执行文件（-B）、联机帮助页（-M）或源代码文件（-S）。在列出所查找的文件之前，你必须使用-f 选项来跟踪目录列表 文件的正文处理 命令 作用 grep 在文件中查找与正则表达式匹配的行 cut 从文件中提取列 paste 附加列 tr 将字符转换为其他字符 expand/unexpand 在制表符和空格符之间进行转换 sort 按各种标准对文本行进行排序 uniq 在文件中查找相同的行 tee 复制文件，同时将其输出到标准输出上 grep 格式：grep [options] pattern [files] 作用：给定一个或多个文件，输出其中与特定正则表达式模式匹配的所有行 注：grep 命令可以使用两种不同类型的正则表达式，它们分别称之为基本类型和扩展类型 常用选项： -v 只输出与正则表达式不匹配的行 -l 仅输出包含匹配行的文件的名称，而不是输出匹配的行 -L 仅输出不包含匹配行的文件的名称 -c 仅输出匹配的行数 -n 在输出匹配结果的时候，每行的前面给出其原始行号 -b 在输出匹配结果的时候，每行的前面给出其在文件中的偏移字节 -i 匹配时不区分大小写 -w 只匹配完整的单词（即匹配整个正则表达式的单词） -x 仅匹配完整的行（即与整个正则表达式匹配的行），优先级高于-w 选项 -A N 输出匹配行，以及位于匹配行之后的 N 行 -B N 输出匹配行，以及位于匹配行之前的 N 行 -C N 输出匹配行，以及原文件中位于匹配行前后的 N 行内容 –color=always 突出显示匹配文本的颜色，以提高可读性 -r 递归搜索目录及其子目录中的所有文件 -E 使用扩展正则表达式。见 egrep 命令 -F 使用固定的字符串列表，而不是正则表达式。见 fgrep 命令 egrep 格式：egrep [options] pattern [files] 作用：类似与 grep，只不过在正则表达式方面，它使用了一种不同的（“扩展性”）语言。它等价于 grep -E 基本类型 扩展类型 含义 . 任何单个字符 […] 匹配该列表中的任何单个字符 [^…] 匹配不属于该列表的任何单个字符 (…) 分组 | | 或操作符 ^ 行首 $ 行尾 \\ 词首 \\ 结束一个字 [: alnum: ] 任何字母数字字符 [: alpha: ] 任何字母字符 [: cntrl: ] 任何控制字符 [: digit: ] 任意数字 [: graph: ] 任何图形字符 [: lower: ] 任何小写字母 [: print: ] 任何可打印字符 [: punct: ] 任何标点符号 [: space: ] 任何空格字符 [: upper: ] 任何大写字母 [: xdigit: ] 任何十六进制数字 * 正则表达式出现零次或多次 \\ + + 正则表达式出现一次或多次 \\ ? ? 正则表达式出现零次或一次 \\ {n} 正则表达式恰好出现 n 次 ,\\ {n,} 正则表达式恰好出现 n 次或 n 次以上 ,m\\ {n,m} 正则表达式出现次数介于 n 和 m（含 m）之间，nm \\c 取文字 c 的字面意义，即使 c 是一个特殊的正则表达式字符 fgrep 格式：fgrep [options] [fixed_strings] [files] 作用：类似于 grep，但是它无法接收正则表达式，只能支持用换行符分隔的固定字符串的列表。该命令等价于 grep -F。通常，可以使用小写形式的-f 选项让 fgrep 命令从一个文件中读取固定的字符串。此外，还可以使用引号从命令行中读取固定的字符串。搜索非数字字符如*和{时，fgrep 命令用起来会非常方便，因为它们是按照字母的字面意义来对待的，而不是作为正则表达式字符来对待 cut 格式：cut -(b|c|f)range [options] [files] 作用：从文件中提取文本列，这里的“列”是由字符偏移（c）或字节偏移（b）或分隔字段（f）来定义的 常用选项： -d C 使用字符 C 作为-f 选项的字段之间的输入分隔符。默认使用制表符 –output-delimiter=C 使用字符 C 作为-f 选项的字段之间的输出分隔符。默认使用制表符 -s 排除（不输出）不包含分隔符的行 paste 格式：paste [options] [files] 作用：将多个文件视为垂直列，并将它们合并到标准输出上 常用选项： -d delimiters 使用给定分隔符来分隔各列；默认使用制表符。可以提供一个单个字符（如-d:）并自始至终使用该字符，或提供一个字符列表(如-dxyz)将其依次用于各行 -s 将输出的行和列进行转置 tr 格式：tr [options] charset1 [charset2] 作用：将一组字符转换为另一组字符 字符集 charset 可以采用以下格式： 格式 含义 ABDG 由字符 A、B、D、G 组成的序列 A-Z 从 A-Z 之间的字符 [x*y] 字符 x 重复 y 次 [ :class: ] 见 grep 命令支持的字符类 常用选项： -d 从输入中删除包含在 charset1 中的字符 -s 从输入中删除（位于 charset1 中的）那些连续重复字符 -c 只对 charset1 之外的字符进行操作 -t 如果 charset1 长于 charset2，则通过截断 charset1 使其长度相同。如果没有提供-t 的话，则不断复制 charset2 的最后一个字符，直到 charset2 与 charset1 的长度相同为止 expand / unexpand 格式：expand [options] [files]，unexpand [options] [files] 作用：expand 命令用来将制表符转换为特定数量的空白字符，使其看起来长度不变，而 unexpand 命令的作用则刚好相反。默认情况下，每八个空格“兑换”一个制表符。 常用选项： -t N 规定用 N 个空格替换一个制表符 sort 格式：sort [options] [files] 作用：以字母顺序输出文本行，或按照你指定的其他规则来进行排序。该命令首先会将提供的所有文件连接起来，然后对结果排序输出 常用选项： -f 排序时区分大小写 -n 按照字母顺序进行排序，而不是按照字母顺序 -g 另一种具有不同算法的数字排序方法，该算法能够识别不同的计数法 -u 排序时忽略重复行（当通过-c 检查排序文件的时候，如果任意的连续两行相同的话，则返回失败） -c 不进行排序，只检查输入是否已经过排序处理。如果是的话，不输出任何内容；否则，输出错误信息 -b 忽略各行的前导空格 -r 对输出进行反转：按照从最大到最小的顺序来排序 -t X 使用 X 作为-k 选项的字段分隔符 -k key 选择用于排序的键（组合-t 选项后，可以指定各个键之间的分隔符） uniq 格式：uniq [options] [files] 作用：处理文本中连续的重复行 常用选项： -c 计算相邻的重复行的数量 -i 操作时不区分大小写 -u 仅输出唯一的行 -d 仅输出重复行 -s N 检测重复行时，忽略每行中前面 N 个字符 -f N 当检测重复行时，忽略每行中前面 N 个由空白符分隔的第一个字段 -w N 当检测重复行时，仅考察每行的前 N 个字符。当与-s 或-f 选项结合使用的时候，sort 将忽略每行前面指定数量的字符或字段，然后考察接下来的 N 个字符 tee 格式：tee [options] files 作用：将标准输入原封不动地复制到标准输出，同时将相同的标准输入复制到一个或多个文件中 注：tee 命令最常用于命名管道中，它不仅可以把中间数据写入文件，同时还将其传递给管道中的下一个命令 常用选项： -a 附加至文件末尾，而非覆盖文件 -i 忽略中断信号 文件的压缩与打包 命令 作用 tar 将多个文件打包成单个文件 gzip 使用 GNU Zip 压缩文件 gunzip 使用 GNU Zip 解压缩 bzip2 以 BZIP 格式压缩文件 bunzip2 解压 BZip 文件 bzcat 通过标准输入/输出压缩/解压 BZip 文件 compress 使用 UNIX 传统的压缩命令来压缩文件 uncompress 使用 UNIX 传统的解压命令来解压文件 zcat 通过标准输入/输出来压缩/解压缩文件（gzip 或 compress） zip 用 Windows Zip 格式压缩文件 unzip 解压 Windows Zip 文件 munpack 将 MIME 数据提取到文件中 mpack 将一个文件转换成 MIME 格式 tar 格式：tar [options] [files] 作用：将多个文件和目录打包为单个文件，以便于传输，同时还可以进行压缩处理，该压缩功能是可选的 常用选项： -c 创建归档。必须在命令行中列出输入文件和目录 -r 将文件附加到现有归档 -u 将新建的/修改的文件附加至现有归档 -A 将一个归档附加到另一个归档，该选项不适用于压缩归档 -t 列出（测试）归档 -x 从归档中提取文件 -f file 从给定的文件中读取归档，或将归档写入给定的文件中。该选项通常用于磁盘上的 tar 文件，但也可以用于磁带驱动器 -d 对归档与文件系统进行比较 -z 使用 gzip 压缩 -j 使用 bzip2 压缩 -Z 使用 UNIX 压缩 -v 冗长模式：输出详细信息 -h 跟踪符号链接，而不仅仅是复制它们 -p 提取文件时，恢复原来的权限和所有权 gzip 格式：gzip|gunzip|zcat [options] [files] 作用：gzip 命令和 gunzip 命令可利用 GNU Zip 格式来压缩和解压文件。在某些情况下，原始文件可能会被删除。使用这些命令的时候，压缩文件的扩展名为.gz 示例命令： gzip file 压缩文件，生成 file.gz。同时，原始文件会被删除 gzip -c file 生成压缩数据，并输出至标准输出 cat file | gzip 从命令管道生成压缩数据 gunzip file.gz 解压 file.gz，并创建 file 文件。原始文件 file.gz 将被删除 gunzip -c file.gz 将数据解压至标准输出 cat file.gz | gunzip 解压来自命令管道的数据 zcat file.gz 解压数据，并输出至标准输出 tar -czf tarfile dir 通过 gzip 将目录 dir 打包成 tar 文件。使用-cvzf 选项时，会在处理它们时输出其文件名 bzip2 格式：bzip2|bunzip2|bzcat [options] [files] 作用：bzip2 命令和 bunzip2 命令可利用 Burrows-Wheeler 格式压缩和解压文件。在某些情况下，原始文件可能会被删除。使用这些命令的时候，压缩文件的扩展名为.bz2 示例命令： bzip2 file 压缩 file，从而生成 file.bz2。原始文件会被删除 bzip2 -c file 压缩数据，并将结果写至标准输出 cat file | bzip2 压缩数据，并将结果写至标准输出 bunzip2 file.bz2 解压 file.bz2，从而生成 file。原始文件 file.bz2 将被删除 bunzip2 -c file.bz2 解压缩数据，并将结果写至标准输出 cat file.bz2 | bunzip2 解压缩数据，并将结果写至标准输出 bzcat file.bz2 解压缩数据，并将结果写至标准输出 tar -cjf tarfile dir 将目录 dir 打包成 bzip 压缩格式的 tar 文件。使用-cvjf 可以在处理过程中显示相应的文件名 compress 格式：compress|uncompress|zcat [options] [files] 作用：compress 命令和 uncompress 命令可利用标准的 UNIX 压缩格式（Lempel Ziv）来压缩和解压文件。在某些情况下，原始文件可能会被删除。使用这些命令的时候，生成的压缩文件的扩展名为.Z 示例命令： compress file 压缩 file，从而生成 file.Z 文件。原始文件会被删除 compress -c file 压缩数据，并将结果写至标准输出 cat file | compress 压缩来自命令管道的数据 uncompress file.Z 解压 file.Z，从而生成 file。原始文件 file.Z 将被删除 uncompress -c file.Z 解压缩数据，并将结果写至标准输出 cat file.Z | uncompress 解压来自命令管道中的数据 zcat file.Z 解压缩数据，并将结果写至标准输出 tar -cZf tarfile dir 将目录 dir 打包成 compress 命令格式的 tar 文件。使用-cvZf 选项时，可以在处理过程中显示相应的文件名 zip 格式：zip|unzip [options] [files] 作用：命令 zip 和 unzip 能够以 Windows Zip 格式来压缩和解压文件。它们生成的压缩文件的扩展名为.zip。与大多数其他 Linux 压缩命令不同，zip 不会删除原始文件 示例命令： zip myfile.zip file1 file2 file3 … 文件打包 zip -r myfile.zip dirname 递归打包 unzip -l myfile.zip 列出内容 unzip myzip 解包 munpack 格式：munpack [options] mail_file，mpack [options] files 作用：munpack 可以将邮件的附件解压为文件，mpack 则是将一个或多个文件作为附件插入到 MIME 格式的文件中 文件的比较 命令 作用 diff 对两个文件或目录逐行比较 comm 对两个排序后的文件逐行比较 cmp 对两个文件逐字节比较 md5sum 计算给定文件的校验和（MD5） diff 格式：diff [options] file1 file2 作用：diff 命令可用来对两个文件（或两个目录）进行逐行比较。在比较文本文件时，diff 可以提供详细的差异报告。对于二进制文件，diff 仅能指出是否存在差异。对于所有文件来说，如果没有差异的话，diff 都不会生成任何输出 常用选项： -n 使用 rcsdiff 命令的 RCS 版本控制格式 -c 使用上下文输出格式，供 patch 命令使用 -D macro C 预处理器格式，即#ifdef macro … #else … #endif 格式 -u 一体化输出格式，它会对文件进行合并处理，其中“-”表示删除，“+”表示添加 -y 并排格式；使用-W 来调整输出的宽度 -e 创建一个 ed 脚本，如果运行该脚本的话，将会把 fileA 变为 fileB -q 不报告发生的哪些变化，仅指出是否存在差异 -b 不考虑空格 -B 不考虑空白行 -i 忽略大小写 -r 当比较目录时，递归考察子目录 comm 格式：comm [options] file1 file2 作用：比较两个已排序的文件，并生成由三列组成的输出，各列之间以制表符分隔 第 1 列：所有出现在 file1 中但不在 file2 中的行 第 2 列：所有出现在 file2 中但不在 file1 中的行 第 3 列：所有同时出现在两个文件中的行 常用选项： -1 不显示第 1 列 -2 不显示第 2 列 -3 不显示第 3 列 -23 显示仅在第一个文件中出现的行 -13 显示仅在第二个文件中出现的行 -12 显示同时出现在第一个和第二个文件中的行 cmp 格式：cmp [options] file1 file2 [offset1 [offset2]] 作用：比较两个文件，如果它们的内容是一样的，则不会输出任何内容；否则给出第一处差异所在的位置。通常情况下，cmp 命令都是从每个文件的开头处开始比较，但如果提供了偏移量的话，则将从指定的地方开始比较 常用选项： -l 长输出：逐字节输出所有差异 -s 静默输出：不打印任何东西，只在退出程序时返回相应的状态码；如果文件匹配，返回 0，如果不匹配返回 1（如果比较失败的话，则返回其他代码） md5sum 格式：md5sum files | --check file 作用：md5sum 命令与校验和一起使用的时候，可以用来验证文件是否未经改动。该命令的第一种使用方式是通过 MD5 算法为指定文件生成 32 字节校验和；第二种使用方式则是测试校验和是否与相应的文件相匹配，这时需要使用–check 选项 注：shasum 是一个更为强大程序，但是（到目前为止）还不太流行，它可以使用不同的算法来生成更长的哈希值。因此，它要比 md5sum 更加可靠一些 处理 PDF 文件和 PostScript 文件 命令 作用 pdftotext 从 PDF 文件中提取文本 ps2ascii 从 PostScript 或 PDF 文件中提取文本 pdfseparate 从 PDF 中提取单页 pdftk 通过拆分、连接、旋转或以其他方式来操作 PDF 文件 pdf2ps，ps2pdf 实现 PDF 和 PostScript 之间的格式转换 pdftotext 格式：pdftotext [options] [file.pdf [outfile.txt]] 作用：从 PDF 文件中提取文本数据，并将其写入指定的文件中。只有当 PDF 包含实际文本，而非文本的图像时，该命令才能生效 常用选项： -f N 从 PDF 的第 N 页开始。注意，必须在选项和数字之间留出空格 -l N 在 PDF 文件的第 N 页结束。同样，必须在选项和数字之间留出空格 -htmlmeta 生成 HTML，而非纯文本 -eol(dos|mac|unix) 在文本中使用给定操作系统的行尾字符 ps2ascii 格式：ps2ascii [file.(ps|pdf)] [outfile.txt] 作用：从 PostScript 或 PDF 文件中提取文本 pdfseparate 格式：pdfseparate [options] [file.pdf] [pattern.txt] 作用：将一个 PDF 文件分割成多个独立的 PDF 文件，每页对应一个文件。最后一个参数是单页文件名称的组成方式，其中的%d 表示提取的页码 常用选项： -f N 从 PDF 的第 N 页开始。必须在选项和数字之间留出空格 -l N 至 PDF 文件的第 N 页结束。必须在选项和数字之间留出空格 pdftk 格式：pdftk [arguments] 作用：从 PDF 文件中提取页面，或将多个 PDF 文件合并成一个、旋转页面、添加水印、加密和解密等 pdf2ps 格式：pdf2ps [options] file.pdf [file.ps]，ps2pdf [options] file.ps [file.pdf] 作用：pdf2ps 命令可以将 Adobe PDF 文件转换为 PostScript 文件（如果不提供输出文件名，则默认使用输入文件名，只是将.pdf 替换为.ps 而已，其他部分不变）；相反，ps2pdf 命令则可以将 PostScript 文件转换为 PDF 格式 打印 命令 作用 lpr 打印文件 lpq 查看打印队列 lprm 从队列中删除打印作业 lpr 格式：lpr [options] [files] 作用：向打印机发送文件 常用选项： -P printername 将文件发送给之前设置的打印机 printername - #N 打印 N 份副本 -J name 设置封面打印作业 name（如果系统已经设置为打印封面的话） lpq 格式：lpq [options] 作用：显示处于等待状态的所有打印任务 常用选项： -P printername 显示打印机 printername 的队列 -a 显示所有打印机的队列 -l 冗长模式：使用长格式显示信息 lprm 格式：lprm [options] [job_IDs] 作用：取消一个或多个打印作业。如果不提供任何作业 ID 的话，当前的打印作业将被取消（注意，只有超级用户才能够取消其他用户的作业）。-P 选项用来指出作业所在的打印队列 拼写检查 命令 作用 look 快速检查单词的拼写是否出错 aspell 交互式的拼写检查程序 spell 批处理式的拼写检查程序 look 格式：look [options] prefix [dictionary_file] 作用：打印以给定字符串 prefix 开头的单词，这些单词通常位于一个字典文件中（默认为/usr/share/dict/words）。当你提供自己的字典文件（可以是任何文本文件，只要各行按字母顺序排序即可）时，look 命令将打印以给定字符串 prefix 开头的所有行 常用选项： -f 忽略大小写 -t X 设置终止字符 X，即将该字符之前（包括该字符）的内容作为匹配字 aspell 格式：aspell [options] file | command 作用：找出无法识别的单词，并给出相应的替代词 常用命令： aspell -c file 通过交互方式对文件中的所有单词的拼写进行检查和纠正 aspell dump master 在标准输出上显示 aspell 的主字典 aspell help 打印一个简明的帮助信息 spell 格式：spell [files] 作用：输出给定文件中与其字典相比存在拼写错误的所有单词 磁盘和文件系统 命令 作用 df 显示已挂载文件系统上的可用空间 mount 使磁盘分区可以访问 umount 卸载磁盘分区（使其无法访问） fsck 检查磁盘分区是否出错 eject 弹出 CD、DVD 或其他可移动磁盘 df 格式：df [options] [disk devices | files | directories] 作用：显示给定磁盘分区的大小，以及其中已用空间和可用空间的大小。如果指定了文件或目录的话，df 将提供该文件或目录所在的磁盘设备的相关数据。如果不提供参数的话，df 将会显示已挂载的所有文件系统的使用情况 常用选项： -k 以千字节为单位显示大小（默认值） -m 以兆字节为单位显示大小 -B N 显示区块数目，并将区块大小指定为 N 个字节（默认值=1024） -h|-H 为了以可读性较高的方式来显示信息，为每个空间大小选择最合适的单位。使用-h 选项时，1K=1000；使用-H 选项时，1K=1024 -l 仅显示本地文件系统，而不显示网络文件系统 -T 在输出中提供文件系统类型 -t type 仅显示给定类型的文件系统 -x type 不显示给定类型的文件系统 -i Inode 模式。显示每个文件系统的 inode 总量以及已经使用和空闲的 inode 数量，而不是磁盘块的相应数量 mount 格式：mount [options] device | directory 作用：挂载分区，使其处于可用状态 常用选项： -t type 指定文件系统的类型 -l 显示所有已挂载的文件系统，也可以与-t 组合使用 -a 挂载/etc/fstab 中列出的所有文件系统。忽略包含 noauto 选项的条目，也可以与-t 组合使用 -r 挂载只读文件系统 umount 格式：umount [options] [device | directory] 作用：卸载磁盘分区，使其无法通过文件系统访问 注：sudo umount -a 可卸载所有已挂载设备，但请不要这么操作 fsck 格式：fsck [options] [devices] 作用：验证 Linux 磁盘分区并按需修复发现的错误 注：一般来说，在检查设备之前需要先将其卸载，以便保证没有其他程序同时对其进行操作。fsck 命令实际上是位于/sbin 目录中的一组文件系统检查程序的前端程序，这些程序的名称都是以“fsck”开头。该命令只支持某些类型的文件系统，可以使用以下命令将其列出：ls /sbin/fsck.* | cut -d. -f2 常用选项： -A 按顺序检查/etc/fstab 中列出的所有磁盘 -N 输出检测报告，但是不进行修复 -r 通过交互方式修复错误，执行每项修复任务之前都会进行提示 -a 自动修复错误（只有当你真正了解所执行的这些任务时，才可以使用这个选项；否则，将会带来严重的后果） eject 格式：eject [options] [device_name] 作用：弹出可移动设备 注：使用该命令时，其中的可移动介质必须处于可以弹出的状态 常用选项： -h 显示帮助信息 -n 显示选定的设备，但是不执行任何动作。可以结合-v 显示选定设备的详细描述 -v 产生详细输出 -d 显示要弹出的默认设备的名称，然后退出 -c N 从光驱柜中选择光驱 N 命令 作用 rsync 即使在跨网络环境下，也可以高效地复制一个文件集合 dd 完成数据的低级复制 growisofs 刻录 DVD 或蓝光光盘 rsync 格式：rsync [options] source destination 作用：复制一组文件，既可以进行精确复制，包括文件权限和其他属性（这种方式称为镜像），也可以只复制数据。此外，它不仅可以通过网络运行，也可以在单机上运行 常用选项： -o 复制文件的所有权（可能需要远程主机的超级用户权限） -g 复制文件属组信息（可能需要远程主机的超级用户权限） -p 复制文件权限 -t 复制时间戳 -r 递归复制目录（即包括其内容） -l 允许复制符号链接（而不是指向它们的文件） -D 允许复制设备（仅限超级用户） -a 镜像：复制原始文件的所有属性。这意味着使用选项-ogptrlD -x 当复制文件树时，在当前的文件系统中进行，不要涉及已挂载的其他文件系统 -n Dry 运行模式：实际上不进行任何复制，只是显示哪些文件将被传输 -v 详细模式：输出复制期间发生的情况的详细信息。添加–progress 后，在复制文件时会以数字方式显示进度 dd 格式：dd [options] 作用：完成二进制位和字节低层操作的复制，它可以将数据从一个文件复制到另一个文件，也可以在复制时进行数据转换，设置可以通过设备复制的方式来克隆磁盘（警告：该操作会彻底摧毁目标设备上的所有数据） 常用选项： if=file 指定输入文件或设备 of=file 指定输出文件或设备 bs=N 一次复制 N 个字节，称为“块大小”（要设置输入和输出的块大小，请分别使用 ibs 和 obs） skip=N 在开始复制之前跳过 N 个输入块 seek=N 在开始复制之前丢弃 N 个输出块 conv=spec 对复制的数据进行转换。spec 可以是 ucase（转换为大写字母）、lcase（转换为小写）、ascii（从 EBCDIC 转换为 ASCII） growisofs 格式：growisofs [options] tracks 作用：刻录可写的 CD、DVD 或 Blu-ray 光盘 步骤： 通过以下命令找到光盘刻录机设备：more /proc/sys/dev/cdrom/info 将要刻录的文件放到相应的目录中，比如 dir。根据需要，进行相应的组织安排。需要注意的是，目录 dir 本身不会被复制到光盘，仅复制其内容 使用 mkisofs 命令创建 ISO（光盘）映像文件，并使用 growisofs 将其刻录到光盘上，假设你的设备是/dev/sr1，具体命令如下所示： # mkisofs -R -l -o $HOME/mydisk.iso dir# growisofs -dvd-compat -Z /dev/sr1=$HOME/mydisk.iso# rm $HOME/mydisk.iso 注：如果要刻录音频 CD，请使用更加友好的图形工具，例如 k3b 查看进程 命令 作用 ps 显示进程 uptime 查看系统负载 w 列出所有用户的活动进程 top 以交互方式查看资源密集型进程 free 显示可用内存 ps 格式：ps [options] 作用：显示用户正在运行的进程的相关信息，也可以显示其他用户的进程信息，为可选项 示例命令： 查看自己当前运行的进程：ps -ux 查看用户 wayne 的所有进程：ps -U wayne 一个程序的所有进程：ps -C program_name 在终端 N 上的各个进程：ps -tN 显示特定的进程，比如进程 1、2 和 3505：ps -p1,2,3505 输出所有进程的信息，但是输出信息的宽度会根据屏幕宽度截取：ps -ef 输出所有进程的完整信息，避免详细参数被截断：ps -efww 输出所有进程的信息，并根据线程的角度，对隶属于同一个父进程之下的子进程进行缩进处理：ps -efH 注：可以借助 grep 和其他过滤程序，以更精细的方式从 ps 的输出中提取信息 uptime 格式：uptime 作用：指出从上次启动以来系统已经运行了多长时间 w 格式：w [username] 作用：显示所有登录用户在每个 shell 中运行的当前进程，如果提供了用户名的话，就只输出该用户的有关信息 常用选项： -h 不显示标题行 -f 不显示 FROM 列 -s 不显示 JCPU 和 PCPU 列 top 格式：top [options] 作用：监视最活跃的进程，并能够定期更新信息。它是一个基于屏幕的程序，以交互方式更新显示内容。top 运行过程中，可以通过按键来改变其行为，例如设置更新速度（s）、隐藏空闲进程（i）或杀死进程（k）。输入 h 则可以查看完整的列表，输入 q 退出。此外，还有一些类似的程序可以用来监控系统的 I/O 和网络带宽，如 iotop 和 iftop 常用选项： -nN 执行 N 次更新，然后退出 -dN 每 N 秒更新一次显示内容 -pN-pM… 仅显示 PID 为 N，M，…的进程的信息，最多显示 20 个进程的信息 -c 显示进程的命令行参数 -b 将信息以非交互式显示到标准输出，所以无需使用与屏幕显示方面的交互技巧。top -b -n1 outfile将快照保存到文件中 free 格式：free [options] 作用：显示内存的使用情况（以千字节为单位） 常用选项： -s N 连续运行，每 N 秒更新一次显示内容 -b 显示字节数 -m 显示数量（兆字节） -t 在底部添加总行数 -o 不显示“buffers/cache”行 控制进程 命令 作用 kill 终止进程（或向其发送信号） timeout 终止运行时间太长的命令 nice 调用特定优先级的程序 renice 在运行时更改进程的优先级 flock 确保同一时刻只有一个进程副本在运行，这要用到锁 kill 格式：kill [options] [process_ids] 作用：向进程发送信号，从而达到终止进程（默认动作）、中断进程、挂起进程、使其崩溃等目的，但是前提条件是，你必须是这个进程的属主，或者是超级用户，这样才有权限执行这些操作 操作示例： 例如，要终止进程 13243，可以运行如下所示的命令： kill 13243 如果该命令没有作用的话（一些程序会捕获该信号，但是并不终止运行），可以添加-KILL 或-9 选项，这两个选项是等价的： kill -9 13243 这样一来，就肯定能终止进程了。但是，这样无法让程序“干净利索”地退出，从而导致进程死亡后，无法全部释放所占用的资源（或导致其他的问题） 如果你不知道进程的 PID，可以运行 ps，然后从输出结果中找到（以 emacs 为例）： ps -aux | grep emacs 当然，最好还是使用 pidof 命令，利用它可以通过进程名称来查找进程，并输出其 PID： pidof emacs 现在，可以通过使用 shell 的反引号来执行 pidof，终止已知其程序名称的进程了： kill `pidof emacs` 或者使用 killall 命令终止给定程序的所有进程： killall emacs 除了位于文件系统中的 kill 程序（通常位于/bin/kill）之外，大多数 shell 都提供了内置的 kill 命令，不过两者在语法和行为方面有所差异。但是，它们都支持以下用法： kill -N PIDkill -NAME PID 其中 N 是信号编号，NAME 是信号字符串“SIG”开头的信号名称（例如，使用-HUP 发送 SIGHUP 信号）。使用kill -l命令查看 kill 传输的所有信号 timeout 格式：timeout [options] seconds command... 作用：限制另一个程序的运行时间（以秒为单位），如果程序运行时间超过规定的范围，timeout 将会终止其运行 常用选项： -s signal 发送默认值（TERM）之外的信号 -k seconds 如果程序在第一个信号之后没有终止，那么在等待规定的秒数之后，发送致命的 KILL 信号 nice 格式：nice [-n level] command_line 作用：在调用占用大量系统资源的程序时，可以通过降低其优先级，从而让它谦让一下其他进程（和用户）。它为一个进程设置了一个优先级数值（一个谦让度值），从而降低 Linux 进程调度程序对它的关注程度，即调整进程的优先级 操作示例： 将一个大型任务的优先级数值设置为 7： nice -n 7 sort hugefile outfile 在运行 nice 的时候，如果不指定优先级的话，则使用 10。正常进程（运行时没有指定优先级）运行在零级，为了查看进程的优先级，可以直接运行 nice，不要加任何参数，具体如下所示： $ nice 超级用户也可以降低进程的优先程度，为此，只需指定更大的优先级数值即可： sudo nice -n -10 myprogram 为了了解自己的任务的优先级数值，可以借助 ps 于命令，只要看看该命令输出中的“NI列就知道了： ps -o pid,user,args,nice renice 格式：renice [-n N] [options] PID 作用：修改已运行的进程的优先级级别 注：普通用户可以增加自己进程的优先级数值，而超级用户还可以降低该数值（提高优先程度），并且可以对任何进程进行该操作。优先级的取值范围为-20~+20，但是，我们要尽量避免使用绝对值较大的负数，否则可能会干扰重要的系统进程 常用选项： -p pid 影响给定的进程 ID。这里可以省略-p，直接提供 PID -u username 影响给定用户拥有的所有进程 flock 格式：flock [options] lockfile command... 作用：通过为多个命令指定同一个锁定文件，起到防止备份脚本之类的命令同时运行多个副本的作用 常用选项： -n 如果另一个命令已经运行，则立即失败 -w N 如果另一个命令已经在运行，则等待 N 秒后失败 -s 使用共享锁而不是排他锁。你可以使用该选项同时运行多个命令，但如果省略该选项，则 flock 将失败。这个选项对于允许有限数量的命令同时运行是非常有用的 作业调度 命令 作用 sleep 暂停指定的秒数，除了等待什么也不做 watch 以指定的时间间隔重复运行程序 at 在将来某个时间执行一次任务 crontab 为将来某些时间点安排任务 sleep 格式：sleep time_specification 作用：等待一定的时间。在指定时间的时候，可以使用一个整数（单位是秒），或一个整数，后跟字母 s（也就是秒），m（分钟），h（小时）或 d（天） watch 格式：watch [options] command 作用：定期重复执行指定的命令；默认的时间间隔是两秒。该命令将被传递给 shell（所以一定要对特殊字符使用引号或进行转义处理）执行，并且运行结果将以全屏模式显示，以便于观察输出结果，看看发生了什么变化。退出时，按 Ctrl+C 常用选项： -n seconds 设置两次执行之间的时间间隔（以秒为单位） -d 高亮显示输出，强调两次执行之间发生的变化 -g 当命令的运行结果与上一次的不同时，退出 at 格式：at [options] time_specification 作用：在规定的时间运行一次 shell 命令 注：可以通过/usr/share/doc/at/time-spec 了解其详细语法 常用选项： -f filename 从给定文件读取命令，而不是标准输入 -c job_number 将作业命令显示到标准输出 crontab 格式：crontab [options] [file] 作用：在特定的时间调度作业，适用于重复性的工作。为了使此类工作顺利进行，可以编辑并保存一个名为 crontab 的文件，通常该文件自动安装在系统目录（/var/spool/cron）中的。每过一分钟，一个名为 cron 的 Linux 进程就会被唤醒，并检查你的 crontab 文件，执行所有到期的作业 常用命令： crontab -e 使用默认编辑器（$VISUAL）编辑 crontab 文件 crontab -l 在标准输出上显示 crontab 文件 crontab -r 删除 crontab 文件 crontab myfile 将文件 myfile 安装为 crontab 文件 注：超级用户可以添加选项-u username，来处理其他用户的 crontab 文件 登录、注销与关机 shutdown 格式：shutdown [options] time [message] 作用：停止或重新启动 Linux 系统。只有超级用户才有权运行该命令 注：对于 time 参数，可以用加号后跟分钟数表示的相对时间，或用小时和分钟表示的绝对时间，或用 now 这个词表示立即。如果不使用选项的话，shutdown 会让系统进入单用户模式，这是一个特殊的维护模式，只允许一个人（从系统控制台）登录系统，同时，所有非必需的服务都将被关闭。要想退出单用户模式，可以再次执行 shutdown 命令来停止或重新启动系统，或输入 Ctrl+D 以使系统进入正常的多用户模式 常用选项： -r 重启系统 -h 关闭系统 -k 模拟关机，并非真的关机，只是向所有用户发送警告消息，就像系统正在关闭一样 -c 取消已经在执行的 shutdown 指令（省略 time 参数） -f 重新启动时，跳过 fsck 程序所执行的常规系统检查 -F 在重新启动时，进行常规的系统检查 systemctl 格式：systemctl [options] command [arguments] 作用及说明：在一些 Linux 发行版中，shutdown 命令实际上是 systemctl 命令的一个符号链接；而 systemctl 则是一个用于启动和停止各种服务的多用途命令。实际上，systemctl 只是名为 systemd 的服务管理器的一部分 常用命令： sudo systemctl poweroff 关闭系统 sudo systemctl reboot 重启系统 sudo systemctl suspend 挂起系统 用户及环境变量 命令 作用 logname 显示登录名 whoami 显示当前的有效用户名 id 显示用户的用户 ID 和组 ID who 显示目前登录系统的用户，给出详细信息 users 显示目前登录系统的用户，给出简要信息 finger 显示用户的相关信息 last 显示用户最近登录时间 printenv 显示环境变量的值 logname 格式：logname 作用：显示用户的登录名 注：如果在你的系统上无法使用此命令，请尝试echo $LOGNAME whoami 格式：whoami 作用：显示当前有效的用户名称。如果你用过 sudo 命令的话，该名称可能与（logname 命令输出的）登录名不同 id 格式：id [options] [username] 作用：显示用户 ID、用户组 ID 及其关联的用户名称和组名称 常用选项： -u 显示有效用户 ID 并退出 -g 显示有效组 ID 并退出 -G 显示用户所属的所有其他组的 ID -n 显示（用户和用户组的）名称，而不是数字 ID。必须与-u、-g 或-G 选项组合使用 -r 显示登录 ID 而不是有效 ID，必须与-u、-g 或-G 选项组合使用 who 格式：who [options] [filename] 作用：列出所有登录用户，每行一个用户 shell 注：通常，who 将从/var/run/utmp 文件获取相应的数据，filename 参数可以用于指定不同的数据文件，例如用/var/log/wtmp 记录过去的登录情况，或用/var/log/btmp 记录失败的登录 常用选项： -H 将第一行作为标题显示 –lookup 对于远程登录的用户，显示原始主机名 -u 在用户的终端上显示其空闲时间 -T 指出每个用户的终端是否可写。加号表示“是”，减号表示“否”，问号表示“未知” -m 仅显示当前用户的信息（即与当前终端相关联的用户） -q 仅显示用户名和用户数，该命令与 users 命令非常类似，只是增加了一个用户数 users 格式：users [filename] 作用：显示已经登陆的用户的快速列表（如果用户正在运行多个 shell，则会在表中出现多次） 注：像 who 命令一样，默认情况下 users 命令将读取/var/log/utmp 文件，但是也可以通过设置让它从另一个文件读取相关信息 finger 格式：finger [options] [user[@host]] 作用：显示已经登录的用户的简要或详细信息 注：参数 user 可以是本地用户名或远程用户，该参数的具体形式为 user@host。当然，远程主机只有做了相应配置时才会响应该 finger 命令的请求 常用选项： -l 显示详细信息 -s 显示简要信息 -p 不显示 Project 和 Plan 部分，这两部分通常分别从用户的~/.project 和~/.plan 文件中读取 last 格式：last [options] [users] [ttys] 作用：显示历史登录信息，按时间逆序排列；可以提供用户名或 tty 名称来限定输出的内容 常用选项： -N 仅显示最近期的 N 行输出，其中 N 为正整数 -i 显示 IP 地址而不是主机名 -R 不显示主机名 -x 显示系统关闭和系统运行级别的变化情况（例如，从单用户模式到多用户模式） -f filename 从/var/run/wtmp 之外的其他文件中读取数据 printenv 格式：printenv [environment_variables] 作用：输出 shell 所知的所有环境变量及其值，或只显示指定的变量 用户帐户管理 命令 作用 useradd 创建一个帐户 userdel 删除一个帐户 usermod 修改帐户 passwd 修改密码 chfn 修改用户的个人信息 chsh 修改用户的 shell useradd 格式：useradd [options] username 作用：超级用户可以通过此命令来创建用户帐户 注：由于该命令的默认选项不是非常有用（运行 useradd -D 可以查看默认选项），因此，请确保提供所需的全部选项 常用选项： -d dir 将用户的主目录设置为 dir -s shell 将用户的登录 shell 设置为 shell -u uid 将用户的 ID 设置为 uid。除非你自己十分有把握，否则请忽略该选项并接受默认值 -c string 设置用户的 comment 字段（历史上称为 GECOS 字段）。通常情况下，该字段被设为用户的全名，但实际上可以是任何字符串。chfn 命令还可以用来设置该信息 -g group 将用户的初始（默认）组设置为 group，它可以是数字形式的组 ID 或组名称，但是，这些组必须是已经存在的 -G group1,group2,… 让用户加入现有的其他组，即 group1，group2 等 -m 将系统基干目录/etc/skel 中的所有文件复制到新创建的主目录中。基干目录通常用来存放初始化文件的最小（基干）版本，如~/.bash_profile，以供新用户使用。如果你希望从不同的目录复制这些文件，请添加-k 选项（-k dirname） userdel 格式：userdel [-r] username 作用：删除现有帐户 注：除非提供-r 选项，否则它不会删除用户主目录中的文件。删除用户之前，请务必仔细斟酌；如无必要，请首先考虑停用帐户（使用 usermod -L）。在删除帐户之前，请确保已备份该用户的所有文件，因为有时候你可能会需要用到它们 usermod 格式：usermod [options] username 作用：以各种方式修改给定用户的帐户 常用选项： -d dir 将用户的主目录改为 dir -l username 将用户的登录名改为 username。在修改登录名之前，请三思而后行，一定要避免系统上还有某些内容依赖于原始名称的情况的发生。同时，一般不要更改系统帐户（root，daemon 等），除非你真的清楚自己在做什么！ -s shell 将用户的登录 shell 改为 shell -g group 将用户的初始（默认）组改为 group，它可以是数字形式的组 ID 或组名称，但是这些组必须是已经存在的 -G group1,group2,… 修改用户所属的附加群组，即 group1，group2 等现有的组。如果用户在此之前已经加入其他组，但是这里没有给出这些组的话，则用户将退出这些组 -L 禁用（锁定）帐户，以使用户无法登录 -U 在执行锁定（-L）操作后，为帐户解锁 passwd 格式：passwd [options] [username] 作用：更改登录密码，或以超级用户身份来修改其他用户密码 chfn 格式：chfn [options] [username] 作用：更新系统维护的个人信息：真实姓名、家庭电话、办公室电话和办公室位置。如果调用该命令的时候没有指定用户名的话，chfn 命令就是针对你的帐户；如果（以 root 身份）调用该命令时提供了用户名，那么它就会更新该用户的相关信息。如果不提供任何选项的话，chfn 将提示你输入所需的信息 常用选项： -f name 将全名改为 name -h phone 将家庭电话号码改为 phone -p phone 将办公室电话号码改为 phone -o office 将办公室地址改为 office chsh 格式：chsh [options] [username] 作用：设置登录 shell 程序。如果调用时没有指定用户名的话，chsh 默认会修改用户自己的登录 shell；如果（以 root 身份）调用该命令时指定了用户名的话，它会修改指定用户的登录 shell。如果没有给出任何选项的话，chsh 将提示你输入所需信息。当然，新的 shell 必须是存在于文件/etc/shells 中的 常用选项： -s shell 指定新的 shell -l 列出所有可用的 shell 用户组的管理 命令 作用 groups 显示用户所在组 groupadd 创建用户组 groupdel 删除用户组 groupmod 修改用户组 groups 格式：groups [usernames] 作用：显示你所属的或其他用户所属的 LInux 组 groupadd 格式：groupadd [options] group 作用：创建组。在大多数情况下，应该使用-f 选项来防止创建重名的组 常用选项： -g gid 自己指定数字组 ID，而不是让 groupadd 选择一个 -f 如果指定的组已经存在，给出提示并退出 groupdel 格式：groupdel group 作用：删除现有的组 注：在进行该项操作之前，最好找出所有组 ID 被设置为给定组的文件，以便稍后处理 sudo find / -group group -print 因为 groupdel 不会改变文件所属的组。它只是从系统中删除相应的组的名称。如果你显示这些文件的话，你会看到数字组 ID，而不是组名 groupmod 格式：groupmod [options] group 作用：修改给定组，改变其名称或组 ID 注：groupmod 命令不影响属于该组的任何文件：它只是修改系统记录中的 ID 或名称。但是，更改 ID 时要小心，否则会导致这些文件归属于不存在的组 常用选项： -n name 将组的名称更改为 name（安全） -g gid 将组 ID 更改为 gid（危险） 主机信息 命令 作用 uname 显示系统基本信息 hostname 显示系统的主机名 domainname 相当于 hostname -y ip 设置和显示网络接口信息 ifconfig 设置和显示网络接口信息 uname 格式：uname [options] 作用：显示计算机的基本信息 常用选项： -a 所有信息 -s 只显示内核名称（默认） -n 只显示主机名，与 hostname 命令一样 -r 只显示内核发行版 -v 只显示内核版本 -m 只显示硬件名称 -p 只显示处理器类型 -i 只显示硬件平台 -o 只显示操作系统名称 hostname 格式：hostname [options] [name] 作用：显示计算机的名称。根据你的设置情况，该命令可能会显示完整或简略的主机名；也可以以 root 身份设置你的主机名 常用选项： -i 显示主机的 IP 地址 -a 显示主机的别名 -s 显示短主机名称 -f 显示你的主机的全域名 -d 显示主机的 DNS 域名 -y 显示主机的 NIS 或 YP 域名 -F hostfile 设置你的主机名，并且该名称是从 hostfile 文件中读取的 ip 格式：ip [options] object command ... 作用：显示和设置计算机网络接口的相关参数 常用命令： 获取默认网络接口（通常称为 eth0）的有关信息： ip addr show eth0 查看所有已经加载的网络接口： ip addr show 查看帮助信息： ip help 显示网络设备的 IP 地址： ip addr 显示网络设备的组播地址： ip maddr 显示网络设备的属性： ip link 显示路由表： ip route 开始监控网络设备，输入 Ctrl+C 停止监控： ip monitor 注：这些命令都有多个选项，在相应的命令后面添加 help，可以查看相应的用法。此外，ip 可以在超级用户权限下面修改网络：配置网络设备、管理路由表和规则、创建隧道等。实际上，它是名为 iproute2 的工具集的一部分 ifconfig 格式：ifconfig [options] interface 作用：设置和显示网络接口的信息 常用命令： ifconfig eth0 显示默认网络接口（通常为 eth0）的信息 ifconfig -a 查看所有已经加载的网络接口 主机位置 命令 作用 host 查找主机名、IP 地址和 DNS 信息 whois 查找互联网域名注册者 ping 检查远程主机是否可达 traceroute 查看到远程主机的网络路径 host 格式：host [options] name [server] 作用：通过查询 DNS 来查找远程机器的主机名或 IP 地址 常用选项： -a 显示所有可用信息 -t 选择名称服务器查询的类型：A、AXFR、CNAME、HINFO、KEY、MX、NS、PTR、SIG、SOA 等 whois 格式：whois [options] domain_name 作用：查找 Internet 域名的注册信息 常用选项： -h registrar 在给定的注册商服务器上进行查找 -p port 查询给定的 TCP 端口而非默认端口 43（whois 服务） ping 格式：ping [options] host 作用：确认远程主机是否处于可访问状态。它会向远程主机发送一些小数据包（即 ICMP 数据包），并等待响应 常用选项： -c N 最多 ping N 次 -i N 每隔 N 秒 ping 一次（默认为 1） -n 在输出中显示 IP 地址，而非主机名 traceroute 格式：traceroute [options] host [packet_length] 作用：输出从本地主机到远程主机的网络路径，以及数据包通过该路径所需的时间 注：该命令会向路径中的每个主机发送三个探测数据包，并报告返回时间。如果五秒内没有收到对方的响应，traceroute 会显示一个星号。此外，traceroute 可能被防火墙阻止或由于其他原因而无法进行，在这种情况下，它会显示相应的符号： 符号 含义 !F 需要分片 !H 主机不可达 !N 网络不可达 !P 协议不可达 !S 源路由失败 !X 通信出于管理的需要而被禁止 !N ICMP 不可达代码 N 默认数据包大小为 40 字节，但你可以通过可选参数 packet_length 来进行修改 常用选项： -n 数字模式：显示 IP 地址而不是主机名 -w N 将超时从 5 秒改为 N 秒 网络连接 命令 作用 ssh 安全地登录到远程主机，或在其上运行命令 scp 安全地将文件复制到远程主机中（批处理方式） sftp 安全地将文件复制到远程主机，或者从远程主机安全地复制文件到本地主机（交互方式） ftp 将文件复制到远程主机，或者从远程主机安全地复制文件到本地主机（交互式，不安全） netcat 创建任意网络连接 ssh 格式：ssh [options] host [command] 作用：如果你在某远程机器上面拥有相应的帐户的话，可以通过 ssh 程序来进行安全的远程登录，或是调用远程机器上的程序而无需登录。ssh 会加密通过其连接进行传输的所有数据，包括你的用户名和密码（这是你需要访问远程计算机所需的）。SSH 协议还支持其他方式进行身份验证，例如公钥和主机 ID 常用选项： -l user 指定你的远程用户名，否则，ssh 将默认使用你的本地用户名。你还可以使用 username@host 语法：ssh wayne@server.example.com -p port 使用非默认端口号（默认端口号为 22） -t 在远程系统上分配 tty，这在尝试使用交互式用户界面（如文本编辑器）运行远程命令时很有用 -v 产生详细的输出，这就调试很有用 scp 格式：scp local_spec remote_spec 作用：将文件和目录从一台计算机批量复制到另一台计算机，它会对两台机器之间的所有通信进行加密处理 命令示例： 将本地文件复制到远程机器： scp myfile remote.example.com:newfile 将目录复制到远程机器： scp -r mydir remote.example.com: 将远程文件复制到本地计算机： scp remote.example.com:myfile . 将远程目录复制到本地计算机： scp -r remote.example.com:mydir . 要指定远程系统上的用户名，请使用 username@host 语法： scp myfile wayne@remote.example.com: 常用选项： -p 复制所有的文件属性（权限、时间戳） -r 递归复制目录及其内容 -v 产生详细的输出，该选项对调试非常有用 sftp 格式：sftp (host username@host) 作用：在两台计算机之间以交互方式安全地通过批量方式复制文件 注：如果你在远程系统上的用户名与本地用户名不同的话，则需要使用 username@host 参数 命令 含义 help 查看可用的命令 ls 列出当前远程目录中的文件 lls 列出当前本地目录中的文件 pwd 显示远程工作目录 lpwd 显示本地工作目录 cd dir 将远程目录更改为 dir lcd dir 将本地目录更改为 dir get file1 [file2] 将远程 file1 复制到本地机器，并将重新命名为 file2（可选） put file1 [file2] 将本地 file1 复制到远程机器，并将重新命名为 file2（可选） mget file * 使用通配符*和?将多个远程文件复制到本地计算机 mput file * 使用通配符*和?将多个本地文件复制到远程计算机 quit 退出 sftp ftp 格式：ftp [options] host 作用：在计算机之间复制文件，无法以安全的方式复制文件，用户名和密码是以纯文本形式在网络中传播的 netcat 格式：netcat [options] [destination] [port]，nc [options] [destination] [port] 作用：netcat 或 nc 都是用于进行网络连接的通用工具，该工具不仅可以用来调试、了解网络，同时还有许多其他用途 常用选项： -u 建立 UDP 连接而不是 TCP 连接 -l 侦听给定端口上的连接 -p N 使用端口 N 作为源端口 -w N N 秒后超时 -h 获取帮助信息 Email 命令 作用 mutt 基于文本的邮件客户端 mail 基于文本的迷你邮件客户端 mailq 查看系统上的外发邮件队列 mutt 格式：mutt [options] 作用：mutt 是一个基于文本的邮件程序，能够在普通终端（或终端窗口）中运行，因此可以在本地（例如，X 终端窗口）中使用或通过 SSH 连接远程使用 mail 格式：mail [options] recipient 作用：mail 程序是一个快速、简单的电子邮件客户端，利用命令行或脚本来快速处理邮件 常用选项： -s subject 设置邮件的主题行 -v 冗长模式，显示邮件传递的相关信息 -c address 指定邮件副本的收信人地址（以逗号分隔的列表） -b address 指定密件副本的收信人地址（以逗号分隔的列表） mailq 格式：mailq 作用：列出所有等待发送的外发电子邮件，发送的邮件将记录在日志文件中 网页浏览 命令 作用 lynx 纯文本的网页浏览器 wget 下载网页和文件 lynx 格式：lynx [options] [URL] 作用：lynx 是一个精简的纯文本网页浏览器，由于太过精简，因此无法显示图片、播放音频或视频，甚至无法响应鼠标。但是，当你只需要快速浏览页面，或网络速度慢或下载网站的 HTML 时，这种精简特性却是非常有用的。此外，它特别适合检测可疑网址，因为 lynx 不运行 JavaScript，甚至在未经允许的情况下都不会接受 cookie。所有浏览活动都是通过键盘完成的。有时候，浏览的效果不太完美，特别是浏览大量使用表格或框架的页面的时候，不过，浏览网站的概貌还是没问题的 常用选项： -dump 将渲染的页面打印到标准输出并退出（类似于-source 选项） -source 将 HTML 源代码打印到标准输出并退出（类似于 wget 命令） -emacskeys 让 lynx 使用 emacs 编辑器的按键指令 -vikeys 让 lynx 使用 vim（或 vi）编辑器的按键指令 -homepage=URL 将你的主页网址设置为 URL -color 打开彩色文字模式 -nocolor 关闭彩色文字模式 wget 格式：wget [options] URL 作用：打开 URL 并将数据下载到文件或标准输出 注：与之类似的一个命令是 curl，它默认情况下会将相应内容写入标准输出，这与 wget 不同，wget 默认情况下会复制原始页面和文件名 常用选项： -i filename 从指定的文件读取 URL 并依次检索它们 -O filename 将所有捕捉到的 HTML 写入给定的文件夹，逐页追加 -c 续传模式：如果之前的下载被中断，只剩下部分内容，那么 wget 将从上次中断的地方开始下载。也就是说，如果内容 150K，上次已经下载了 100K，那么使用-c 选项后，就只下载剩下的 50K，然后把它添加到已经下载的内容后面即可。不过，有时候 wget 可能会“被耍”，例如从上次进行了（部分）下载之后，文件已经发生变化，所以，只有确保远程文件没有发生变化时，才能使用这个选项 -t N 尝试 N 次，然后放弃。N=0 表示不停尝试下去 –progress=dot 通过点号来显示下载进度 –progress=bar 通过条型来显示下载进度 –spider 不下载，只是检查远程页面是否存在 -nd 将所有的文件下载到当前目录中，即使它们原先位于一个非常复杂的目录树中（默认情况下，wget 会按照原样来复制远程目录的层次结构） -r 递归下载页面层次结构，包括子目录 -l N 在最多下载 N 层内的文件（默认为 5） -k 内部检索的文件，修改 URL，以便可以在网络浏览器中查看文件 -p 下载完整显示页面所需的所有文件，如样式表和图像文件等 -L 下载（页面内的）相对链接，但不下载绝对链接 -A pattern 接受模式：仅下载名称与给定模式匹配的文件。模式可以使用 shell 通配符 -R pattern 拒绝模式：仅下载名称与给定模式不匹配的文件 -I pattern 目录包含：仅从匹配给定模式的目录中下载文件 -X pattern 目录排除：仅从不符合给定模式的目录中下载文件 即时通信 命令 作用 write 向终端发送消息 mesg 设置当前终端的写权限，即是否让其他用户向本终端发消息 tty 显示终端设备名称 sendxmpp 通过 XMPP（Jabber）发送即时消息 profanity 基于文本的 XMPP 客户端 irssi 基于文本的 IRC 客户端 write 格式：write user [tty] 作用：向同一台机器上的其他用户发送多行文本，Ctrl+D 组合键用于结束连接。也可以在管道中发送一次性消息 注：与 write 命令功能比较接近的一个命令是 wall，它能同时向所有登录用户发送消息： wall The system will reboot in 1 hour mesg 格式：mesg [y|n] 作用：决定是否可以向终端写入内容。mesg y 表示允许写入，mesg n 表示拒绝写入，而 mesg 则会显示当前状态（y 或 n），其中 y 是默认值。mesg 对现代即时通信程序无效 tty 格式：tty 作用：显示与当前 shell 相关联的终端设备名称（如果收件人多次登录，write 命令可能需要这些信息） sendxmpp 格式：sendxmpp [options] recipients 作用：通过 XMPP 协议（Jabber）发送即时消息的快速方式。当你只想发送单个消息或文本文件的内容，而无需接收消息的时候，这个程序是非常方便的 常用选项： -t 使用 TLS 来保护连接 -e 使用 SSL 来保护连接 -s text 随消息一起发送主题行 -v 冗长模式：显示调试信息。如果当连接失败的时候，该选项将非常有用 profanity 格式：profanity [options] 作用：用于 XMPP 协议（Jabber）的一款全功能即时通信客户端。与图形客户端不同，profanity 是在 shell 窗口中运行的，因此你可以通过 SSH 来使用该客户端 irssi 格式：irssi [options] 作用：功能齐全的基于文本的 IRC 客户端 屏幕输出 命令 作用 echo 在标准输出上显示简单文本 printf 在标准输出上显示格式化文本 yes 在标准输出上显示重复文字 seq 在标准输出上显示一个数字序列 clear 清除屏幕或窗口 echo 格式：echo [options] strings 作用：显示其参数 常用选项： -n 不要打印最后面的换行符 -e 识别并解释转义字符 -E 不解释转义字符：与-e 选项的作用相反 可用的转义字符包括： \\a 警报（发出哔声） \\b 退格 \\c 不打印最后面的换行符（与-n 选项的作用相同） \\f 换页 换行 \\r 回车 \\t 水平制表符 \\v 垂直制表符 \\\\ 反斜杠 \\' 单引号 \\ 双引号 nn 插入 nnn（八进制）所代表的 ASCII 字符 printf 格式：printf format_string [arguments] 作用：增强版的 echo 命令，能够在标准输出上显示格式化的字符串，类似于 C 语言的 printf()函数，将一个格式字符串应用于参数序列以创建指定的输出 yes 格式：yes [string] 作用：重复打印指定的字符串（或默认为“y”），并且每个字符串占一行 seq 格式：seq [options] specification 作用：输出一系列整数或实数，适用于其他程序的管道。它有三种规格参数：一个数字：上限，两个数字：下限和上限，三个数字：下限，增量和上限 常用选项： -w 根据需要打印前导零，以使所有行的宽度相同 -f format 使用类似 printf 的格式字符串来格式化输出行，该字符串必须包含%g（默认值）、%e 或%f -s string 使用给定的字符串作为数字之间的分隔符。在默认情况下，会打印换行符（即每行一个数字） clear 格式：clear 作用：清除显示器或 shell 窗口中的内容 复制和粘贴 命令 作用 xclip 在 shell 和剪切板之间进行复制并粘贴操作 xsel 通过 shell 来操作剪切板 xclip 格式：xclip [options] 作用：可以对三个 Linux 选择（剪切板）命令进行读取和写入操作，从而实现在 shell 和图形应用程序之间复制和粘贴文本 常用选项： -selection name 通过名称，从 primary、secondary 或 clipboard 中指定一个选择命令。默认情况下，将会选取 primary 命令 -i 从标准输入中读取选择命令中的内容，该选项可省略 -o 将选择命令中的内容写入标准输出 xsel 格式：xsel [options] 作用：xsel 是 xclip 的增强版本，它除了能够读写三个选择（剪切板）命令中的内容之外，还支持附加、交换和清除操作 常用选项： -p 使用 primary 命令（默认） -s 使用 secondary 命令 -b 使用 clipboard 命令 -i 选择命令从标准输入读取相应的内容，这是默认的行为 -a 附加到选择命令中 -o 将选择命令的内容写入标准输出 -c 清除选择命令中的内容 -x 交换 primary 和 secondary 命令中的内容 数学和计算 命令 作用 expr 在命令行进行简单的数学运算 bc 基于文本的计算器 dc 基于文本的 RPN 计算器 expr 格式：expr expression 作用：在命令行中执行简单的数学（和其他表达式求值）运算 bc 格式：bc [options] [files] 作用：读取算术表达式，每行一个，并显示结果 dc 格式：dc [options] [files] 作用：从标准输入读取表达式，并将结果写入标准输出，它是一个使用逆波兰表示法（RPN）、基于堆栈的计算器 日期和时间 命令 作用 cal 显示当前日历 date 显示或设置日期和时间 ntpdate 使用远程时间服务器设置系统时间 cal 格式：cal [options][month [year]] 作用：显示日历。默认情况下，它会显示当前月份的日历；要想显示当前月份之外的日历的话，请提供相应的月份和年份（用四位数字表示）。如果省略具体的月份，那么该命令就会显示整年的日历 常用选项： -y 显示当前年份的日历 -3 显示三个月的日历：包括前一个月和下一个月的日历 -j 显示某一日位于当年中的第几天 date 格式：date [options] [format] 作用：显示日期和时间，该命令的输出结果将取决于系统的区域设置，在默认情况下，date 将显示本地时区的系统日期和时间。可以通过提供以加号开头的格式字符串来格式化输出内容 常用选项： -d string 显示给定的日期或时间 string，并按照你的要求进行格式化 -r filename 显示给定图像的最后修改时间戳，并按照你的要求进行格式化 -s string 将系统日期和/或时间设置为 string，只有超级用户才能执行该操作 ntpdate 格式：ntpdate timeserver 作用：通过访问网络上的时间服务器来设置当前系统时间，需要 root 权限 图像 命令 作用 display 显示图像文件 convert 将文件从一种图形格式转换为另一种格式 mogrify 修改图形文件 montage 将多个图形文件组合成一个文件 display 格式：display [options] files 作用：显示多种格式的图像文件 常用选项： -resize size 调整图像的大小。size 的设置方式非常灵活，包括设置宽度（800），高度（x600），高度乘以宽度（800x600），缩放百分比（50%），像素面积（480000@）等 -flip 垂直反转图像 -flop 水平反转图像 -rotate N 将图像旋转 N 度 -backdrop 在纯色背景（该颜色将铺满图像之外的整个屏幕）下显示图像 -fill 设置-backdrop 选项使用的纯色 -delay N 显示图像 N 秒，然后退出。如果列出多幅图像的话，以幻灯片形式播放，延迟时间为 N 秒 -identify 将图像的格式、大小和其他统计信息打印到标准输出 convert 格式：convert [input_options] infile [output_options] outfile 作用：复制图像，同时将其转换为不同的图形格式。同时，可以对图像的副本进行修改 注：该命令的选项与 display 命令大部分保持一致 mogrify 格式：mogrify [options] file 作用：像 convert 命令那样对图像进行转换，不过该命令的转换操作是直接针对原图像文件，而不是通过副本来完成的（所以 convert 是一个更加安全的命令）。该命令能支持 convert 命令的大部分选项 montage 格式：montage infiles [options] outfile 作用：将一组输入文件组合到单个图像文件中，该命令在图像的显示方式方面具有非常强大的控制能力 常用选项： -geometry widthxheight[±]x[±]y 设置图像的高度宽度和偏移（x，y） -frame N 在每个图像周围绘制宽度为 N 个像素的框 -label string 使用字符串来标注各个图像，其中可以包括以百分号开头的特殊转义字符：%f 表示原始文件名，%h 和%w 表示高度和宽度，%m 表示文件格式等 音频和视频 命令 作用 cdparanoia 将 CD 音轨转换（也就是”提取“）成 WAV 文件 lame 将 WAV 文件转换为 MP3 文件 id3info 查看 MP3 文件中的 ID3 标签 id3tag 编辑 MP3 文件中的 ID3 标签 ogginfo 查看 OGG 的信息 metaflac 查看和编辑 FLAC 文件的信息 sox 在各种音频流格式之间进行转换 mplayer 播放视频或音频 cdparanoia 格式：cdparanoia [options] span [outfile] 作用：从 CD 读取（提取）音频数据，并将其存储到 WAV 文件（或其他格式） 常见用法： cdparanoia N 将 N 音轨转换为一个文件 cdparanoia -B 将 CD 上的所有音轨都转换为单独的文件 cdparanoia -B 2-4 将 2、3 和 4 音轨转换为单独的文件 cdparanoia 2-4 将 2、3 和 4 音轨转换为单个文件 注：如果访问驱动器遇到困难，可以尝试运行cdparanoia -Qvs命令来查找相关线索 lame 格式：lame [options] file.wav 作用：将 WAV 音频文件转换为 MP3 文件 id3info 格式：id3info [options] [files] 作用：显示 MP3 音频文件的相关信息，前提是文件中含有 ID3 标签 id3tag 格式：id3tag [options] files 作用：添加或修改 MP3 文件中的 ID3 标签 常用选项： -A name 设置艺术家的名字 -a title 设置专辑标题 -s title 设置歌曲标题 -y year 设置年份 -t number 设置音轨数 -g number 设置流派码 ogginfo 格式：ogginfo [options] [files] 作用：显示 OGG Vorbis 音频文件的各种信息，添加-h 选项可以获取更详细的用法说明信息 metaflac 格式：metaflac [options] [files] 作用：显示或更改 FLAC 音频文件的信息 常用选项： –show-tag name 显示给定标签的值 –remove-tag name 从 FLAC 文件中删除所有给定的标签 sox 格式：sox [options] infile outfile 作用：音频文件格式转换 常用选项： -S 显示进度表，适用于长时间的格式转换情形 –no-clobber 如果输出的文件已经存在，则不覆盖原来的文件 -t type 指定输入的类型，如果 sox 无法识别的话 mplayer 格式：mplayer [options] video_files ... 作用：播放视频或音频文件 原作者：Wayne.Chen 整理于 2018 年 11 月 8 日下午","tags":["linux"],"categories":["计算机科学与技术"]},{"title":"首页","path":"/wiki/LVGL-CarDashboard/index.html","content":"LVGL 跨平台汽车仪表盘 这是一个基于 LVGL v8 图形库构建的、高仿真度的车载仪表盘项目。其核心设计理念是 “一次编码，到处运行” ，代码无需修改即可在 PC (Windows/Linux) 上进行快速开发与仿真，也能无缝交叉编译到嵌入式 ARM Linux 平台上高效运行。 得益于一个智能化的 CMake 构建系统和预置的依赖库，本项目实现了真正的 “开箱即用” ，极大地简化了开发和部署流程。 核心亮点 真正的跨平台: 一套代码，原生支持 Windows, Linux PC (SDL2) 和 嵌入式 ARM (Framebuffer)。 零配置构建: CMake 脚本会自动检测平台并修改 LVGL 配置，无需手动开关宏。 依赖自包含: 静态链接 freetype 等库，部署到开发板时只需单个可执行文件，无外部 .so 依赖。 实时交互控制: 无需重新编译，即可通过控制台指令实时改变车速、转速、灯光等状态，极大提升调试效率。 想了解更多细节？请查看 功能特性详解。 🚀 快速上手 1. 环境准备 通用: Git, CMake (3.5+), C/C++ 编译器。 PC (Linux): 安装 SDL2 开发库 sudo apt-get install libsdl2-dev。 PC (Windows): 无需额外安装，项目已内置 SDL2 库。 嵌入式 ARM: 准备好你的交叉编译工具链。 2. 克隆与构建 首先，克隆仓库（如果项目使用了 git submodules，请确保它们已被拉取）： git clone https://github.com/zhangwei43721/LVGL-CarDashboard.gitcd LVGL-CarDashboard 方式一：在 PC 上编译和运行 # 配置项目cmake -S . -B build# 编译cmake --build build -j12# 运行./bin/main 方式二：交叉编译并在 ARM 开发板上运行 # 确保你的工具链文件 (例如 arm.cmake) 已正确配置# 使用工具链文件进行配置cmake -S . -B build_arm -DCMAKE_TOOLCHAIN_FILE=arm.cmake# 编译cmake --build build_arm -j12 3. 部署到开发板 得益于静态链接，部署过程非常简单： 传输可执行文件: 将 bin/main 这一个文件传输到开发板的任意位置 赋予权限并运行:chmod +x ./main./main 🎮 控制台指令 程序运行时，在终端输入以下命令并回车即可控制仪表盘： 开关类: 左转, 右转, 双闪, 远光, 近光, 安全带 数值设置: 速度 0-220 转速 0-8000 水温 0-150 油量 0-100 胎压 位置 数值 (位置: 左前, 右前, 左后, 右后) ❔ 常见问题 (FAQ) Q: PC 运行后没有出现窗口？ A: 请确保您已按要求安装了 libsdl2-dev (Linux) 或项目 libs 目录完整 (Windows)。 Q: 在开发板上运行提示 libfreetype.so: cannot open file？ A: 这是旧版本部署方式的问题。在新版构建系统中，freetype 库是静态链接的，您无需也禁止拷贝任何 .so 文件。请只部署 main 可执行文件。 Q: 为什么项目克隆后编译失败，提示找不到 lvgl.h? A: 很可能是你忘记了初始化 git 子模块。请运行 git submodule update --init --recursive 来下载 lvgl 和 lv_drivers。 Q: 交叉编译失败？ A: 请仔细检查你的工具链 CMake 文件，确保其中的编译器路径 (arm-linux-gcc 等) 是正确的。"},{"title":"功能特性","path":"/wiki/LVGL-CarDashboard/features.html","content":"技术架构特性 1. 真正的一体化跨平台 项目采用 CMake 和 C 预处理器宏实现了一套代码在不同平台的原生编译 PC 平台 (Windows/Linux): 使用 SDL2 作为后端，进行高效的图形渲染和输入处理，非常适合快速开发和 UI 调试 嵌入式 ARM 平台: 直接使用 Linux Framebuffer (/dev/fb0) 进行渲染，并通过 evdev 读取输入事件，性能高、资源占用少 2. 零配置智能构建系统 CMakeLists.txt 是项目的自动化核心在配置阶段 (cmake ..)，它会自动执行以下任务： 平台检测: 自动识别目标是 PC 还是 ARM 交叉编译 依赖管理: 为不同平台选择链接正确的库（系统库或项目内置库） LVGL 配置自动化: 动态修改 lv_conf.h 和 lv_drv_conf.h，根据平台自动启用/禁用 USE_SDL, USE_FBDEV 等宏，开发者完全无需手动干预 3. 依赖自包含与静态链接 为了实现“开箱即用”和简化部署，项目在 libs/ 目录中预置了关键依赖的预编译版本，并尽可能采用静态链接 Windows: 内置 SDL2 静态库 嵌入式 ARM: 内置并静态链接 freetype 库 最终效果: 交叉编译后，只需部署单个可执行文件到目标板，极大降低了部署复杂度和运行时风险 仪表盘功能特性 1. 高仿真度动态仪表 平滑指针动画: 所有仪表盘指针（速度、转速、水温、油量）的转动都带有 ease-in-out 动画效果，视觉体验流畅自然 数据驱动更新: UI 严格遵循“数据模型驱动”的设计模式，所有显示都源自一个全局的 VehicleState 结构体，逻辑清晰 2. 全面的指示与报警系统 常规指示灯: 包含左/右转向灯、双闪、远光灯、近光灯、安全带未系提醒、ECO 驾驶模式等 动态报警系统: 高温报警: 水温超过阈值时，红色水温图标会自动显示 低油量报警: 油量低于阈值时，加油机图标会自动点亮 胎压异常报警: 实时监测四轮胎压，当压力超出正常范围时，对应数值会变为红色以警示 3. 沉浸式交互体验 开机自检: 程序启动后的前 2 秒，所有指示灯会自动点亮，模拟真实车辆的启动自检过程 实时控制台: 这是项目的一大亮点开发者可以在程序运行时，通过标准输入流（终端）直接发送指令来模拟各种工况，实时查看仪表盘的响应，无需断点或重新编译即可完成大部分逻辑调试"},{"title":"(obj/) 代码解析","path":"/wiki/LVGL-CarDashboard/usage-obj.html","content":"obj/ 目录是车载仪表盘的“大脑”，它负责处理所有非 UI 的业务逻辑。这部分代码采用了 “数据模型驱动 UI” 的设计思想，将车辆的实时状态（数据模型）与界面的视觉表现完全分离，实现了高度的解耦和可维护性。 其核心职责可以分为两大部分： 输入与状态更新 callback.c：接收外部指令（如控制台输入），并更新内部的车辆状态数据模型。 状态渲染 control.c：根据数据模型的当前值，周期性地更新 UI 界面，包括指针、数字、报警灯等。 文件功能详解 head.h (公共接口与数据模型) 这个头文件是 obj 模块的“公共 API”，它定义了整个模块的数据核心和对外暴露的接口。 VehicleState 结构体: 这是项目中最核心的数据结构，定义了车辆的所有状态，如速度、转速、水温、油量、胎压和里程等。它是整个仪表盘状态的唯一真实来源 (Single Source of Truth)。 g_vehicle_state 全局变量: VehicleState 结构体的一个全局实例，在 control.c 中定义，并在 head.h 中通过 extern 声明，使其可以在整个项目中被访问。 常量定义: 定义了各种报警阈值，如水温报警 (WATER_TEMP_WARN)、低油量 (FUEL_LOW) 等，方便集中管理和调整。 函数原型: 声明了需要被 main.c 调用的主要函数，如 handle_console_input(), update_ui_from_state(), 以及各种初始化函数。 control.c (状态-UI 渲染器) 该文件负责将 g_vehicle_state 结构体中的数据“渲染”到 UI 界面上，是连接数据和视觉的桥梁。 update_ui_from_state(lv_timer_t* timer): 这是渲染循环的核心。这个函数使用lvgl 官方建议使用的 lv_timer 的回调函数，由 main.c 周期性调用来实现类似多线程的效果。 将以下函数注册到一个定时器中，每隔 50 毫秒执行一次，确保 UI 界面与仪表盘结构体保持同步 它调用的函数如下： 1. 更新指针: 调用 update_all_pointers_from_state()。此函数内部使用 map_value_to_angle() 将速度、转速等物理值映射为指针的旋转角度，然后通过 animate_img_angle_to() 平滑地将指针以动画形式转到目标角度。 2. 更新胎压: 调用 update_tire_pressure_display()，更新四个轮胎的压力读数。如果压力异常，它还会将对应标签的颜色变为红色。 3. 更新里程: 调用 update_mileage_labels()，根据当前车速和定时器周期计算并累加行驶里程。 4. 更新报警: 调用 check_and_update_warnings()，检查水温、油量等是否达到报警阈值，并相应地显示或隐藏报警图标。 callback.c (输入处理与事件回调) 该文件负责处理所有的外部输入和异步事件，并根据这些输入来修改 g_vehicle_state 结构体。 控制台输入处理: handle_console_input(): 使用非阻塞的 select() 系统调用来检查标准输入流。这使得程序可以在不暂停 UI 渲染主循环的情况下，实时接收用户在终端的输入。 process_command(): 这是指令解析的核心。它使用 sscanf 解析用户输入的字符串，支持两种命令： 开关类命令 (如 左转, 远光): 直接切换对应状态。 设值类命令 (如 速度 120, 胎压 左前 240): 调用 parse_and_set_state_value() 将字符串数值转换为整数，并更新 g_vehicle_state 中对应的字段。 指示灯控制: 提供了多种控制灯光的方法，如通过 LV_STATE_CHECKED (远光灯、安全带)、LV_OBJ_FLAG_HIDDEN (水温报警) 或直接修改透明度 (转向灯闪烁)。 转向灯的闪烁效果是通过 lv_timer 实现的。control_manual_flashing() 函数负责创建和删除这个定时器，从而启动或停止闪烁。 初始化与自检: init_all_lights_test(): 实现开机自检功能，在启动时点亮所有指示灯 2 秒，然后通过一个一次性的 lv_timer 自动熄灭。 init_time_display(): 创建一个每秒触发的定时器，用于更新屏幕上的时间显示。 核心数据流 本项目的逻辑遵循一个清晰的单向数据流，极大地简化了状态管理： 输入 (Input): 用户在控制台输入指令，例如 速度 80。 处理 (Process): handle_console_input() 捕获输入，process_command() 解析指令。 更新模型 (Update Model): process_command() 修改全局数据模型 g_vehicle_state.speed 的值为 80。 渲染 (Render): LVGL 的主循环定时器触发 update_ui_from_state()。 同步 UI (Sync UI): update_ui_from_state() 函数读取到 g_vehicle_state.speed 的新值 80，计算出对应的指针角度，并调用 LVGL 的动画函数，使速度指针平滑地指向 80km/h 的位置。 这个流程确保了 UI 的任何变化都源于 g_vehicle_state 的变化，代码逻辑清晰，易于调试和扩展"},{"title":"主程序入口 (main.c) 解析","path":"/wiki/LVGL-CarDashboard/usage-main.html","content":"main.c 文件是整个项目的Orchestrator (编排器) 和 Bootstrap Loader (引导加载程序)。它负责在程序启动时进行所有必要的初始化，然后进入一个无限循环来驱动整个应用程序的运行。 其最核心的设计是利用 C 语言的预处理器 (Preprocessor)，特别是 #if USE_SDL ... #else ... #endif 这样的条件编译 (Conditional Compilation) 块，来实现平台代码的抽象。这意味着同一份 main.c 源代码，无需任何修改，就可以被编译成面向完全不同硬件平台的两个版本：一个用于 PC/SDL 仿真，另一个用于嵌入式 ARM/Framebuffer 运行。 关键点: USE_SDL 这个宏的值并不是由开发者手动修改的。它是由 CMakeLists.txt 在执行 cmake 配置阶段时，根据目标平台自动写入到 lv_drv_conf.h 文件中的，实现了完全的自动化。 核心职责 平台硬件抽象层 (HAL) 初始化: 根据编译目标，选择性地初始化显示驱动（SDL 或 Framebuffer）和输入驱动（SDL Mouse/Keyboard 或 evdev）。 LVGL 核心库初始化: 调用 lv_init() 启动 LVGL 引擎。 应用程序初始化: 创建 UI (ui_init())，并启动业务逻辑相关的模块，如开机自检、时间显示、UI 状态更新定时器等。 主事件循环: 运行一个 while(1) 循环，在其中周期性地调用 LVGL 的任务处理器，并处理来自控制台的输入。 代码执行流程详解 Includes 阶段: 代码首先根据 lv_drv_conf.h 中 USE_SDL 宏的值，决定包含哪一套头文件。 如果 USE_SDL 为 1，则包含 sdl.h。 如果 USE_SDL 为 0，则包含 fbdev.h 和 evdev.h，并声明 custom_tick_get() 函数。 main() 函数入口: lv_init(): 初始化 LVGL 的所有内部机制。 hal_init(): 这是平台抽象的核心所在。这个函数内部包含了完整的条件编译块，用于执行与平台相关的硬件初始化（详见下文）。 ui_init(): 调用 UI 模块的入口函数，创建所有屏幕和控件。 业务逻辑启动: init_all_lights_test(): 启动开机自检，短暂点亮所有指示灯。 init_time_display(): 创建一个定时器，用于更新时间显示。 init_roller_event_handler(): 为驾驶模式选择器绑定事件。 lv_timer_create(update_ui_from_state, 100, NULL): 创建数据驱动 UI 的核心定时器。它会每隔 100 毫秒调用一次 obj/ 目录中的 update_ui_from_state 函数，将车辆状态数据渲染到 UI 上。 主循环 while(1): handle_console_input(): 调用 obj/ 模块的函数，非阻塞地检查并处理来自用户终端的命令。 lv_timer_handler(): 这是 LVGL 的“心跳”。它负责处理所有任务，包括重绘屏幕、执行动画、调用定时器回调等。该函数会返回下一次需要被调用之前可以休眠的毫秒数。 usleep(time_to_wait_ms * 1000): 根据 lv_timer_handler() 的返回值进行智能休眠。这极大地降低了 CPU 占用率，避免了空转，对于 PC 和嵌入式设备都至关重要。 hal_init() 函数：平台抽象的核心 这个静态函数是实现跨平台的关键。它内部完全根据 USE_SDL 宏分成了两个独立的世界。 功能 PC / SDL 平台 (#if USE_SDL) 嵌入式 ARM 平台 (#else) 显示初始化 调用 sdl_init() 调用 fbdev_init() 显示缓冲区 创建一个较小的缓冲区 (SDL_HOR_RES * 100) 创建两个全尺寸的缓冲区 (800*480) 以支持双缓冲 显示刷新回调 注册 sdl_display_flush 函数 注册 fbdev_flush 函数，将像素数据写入 /dev/fb0 输入设备 调用 evdev_init() 指针设备 注册 sdl_mouse_read 作为鼠标输入 注册 evdev_read 作为触摸屏或鼠标输入 其他输入 额外注册了键盘 (sdl_keyboard_read) 和鼠标滚轮 (sdl_mousewheel_read) 通常只有一个 evdev 设备 custom_tick_get() 函数：嵌入式平台的“时钟” PC / SDL 平台 嵌入式 ARM 平台 Tick 来源 SDL 库内部提供了 SDL_GetTicks()，它会自动为 LVGL 提供时间流逝信息。 Linux Framebuffer 本身不提供 Tick 功能。 实现方式 无需额外代码。 当 CMakeLists.txt 检测到交叉编译时，它会自动在 lv_conf.h 中启用 #define LV_TICK_CUSTOM 1。这会告诉 LVGL 去调用一个名为 custom_tick_get() 的函数来获取时间。main.c 中的这个函数使用 gettimeofday() 系统调用来计算从程序启动开始经过的毫秒数，从而为 LVGL 提供了必需的“时钟”。 通过这种精巧的设计，main.c 成功地将平台相关的底层代码与平台无关的上层应用代码（UI 和业务逻辑）清晰地分离开来，是整个项目可移植性的基石。"},{"title":"构建系统 (CMake) 解析","path":"/wiki/LVGL-CarDashboard/usage-cmake.html","content":"本项目的构建系统 CMakeLists.txt 是实现跨平台编译和“一键构建”的核心。它不仅能根据目标平台（Linux PC, Windows, 嵌入式 ARM）链接不同的库，更精妙的是，它能在编译前自动修改 LVGL 的配置文件，使开发者无需手动在 lv_conf.h 和 lv_drv_conf.h 中切换宏定义。 核心设计思想 平台自动化检测: 通过 CMake 内置变量（如 CMAKE_CROSSCOMPILING, WIN32）自动识别当前是为哪个平台进行编译。 依赖隔离与预置: 对于 Windows 和 嵌入式 ARM 平台，项目在 libs/ 目录下预置了编译好的静态库 (.a)，实现了“开箱即用”，用户无需在系统上安装 SDL2 或 Freetype。 对于 Linux PC 平台，则采用标准的 find_package 方式，使用系统中已安装的开发库，符合 Linux 的开发习惯。 配置自动化修改: 这是本构建系统最高级的特性。它通过读取、正则替换、重写 lv_conf.h 和 lv_drv_conf.h 文件，自动启用或禁用 SDL, Framebuffer, evdev 等驱动，彻底免去了手动配置的麻烦。 脚本逐段详解 1. 项目基本设置 cmake_minimum_required(VERSION 3.5)project(main C)if(WIN32) # ... 路径检查 ...endif()set(CMAKE_C_STANDARD 99)set(CMAKE_C_STANDARD_REQUIRED ON)set(CMAKE_RUNTIME_OUTPUT_DIRECTORY $PROJECT_SOURCE_DIR/bin) project(main C): 定义项目名称为 main，语言为 C。 if(WIN32): 一个非常贴心的检查。由于 Windows 平台对非 ASCII 字符路径的支持不佳，这里会检测项目路径是否包含中文等字符，并在发现时报错，避免后续难以排查的编译问题。 CMAKE_RUNTIME_OUTPUT_DIRECTORY: 指定生成的可执行文件（如 main.exe 或 main）统一存放在项目根目录下的 bin/ 文件夹中，保持根目录整洁。 2. 核心：平台检测与依赖配置 这是实现跨平台链接的关键部分。脚本定义了一个变量 PLATFORM_LIBS，并根据检测到的平台向其填充不同的库。 # --- 平台检测与配置 ---set(TARGET_PLATFORM unknown)if(CMAKE_CROSSCOMPILING) # ... ARM 配置 ...elseif(WIN32) # ... Windows 配置 ...elseif(UNIX AND NOT APPLE) # ... Linux PC 配置 ...endif() 嵌入式 ARM (if(CMAKE_CROSSCOMPILING)): 触发条件: 当你在 cmake 命令中使用了 -DCMAKE_TOOLCHAIN_FILE 参数指定交叉编译工具链时，CMAKE_CROSSCOMPILING 变量会自动变为 TRUE。 库配置: 它通过 add_library(freetype_local STATIC IMPORTED) 创建了一个名为 freetype_local 的“导入目标”，并将其指向 libs/freetype/lib/arm/libfreetype.a 这个预编译好的静态库。最终将 pthread, freetype_local 和 m (数学库) 添加到 PLATFORM_LIBS 中。 Windows (elseif(WIN32)): 触发条件: 在 Windows 系统上编译时自动满足。 库配置: 直接指定 libs/ 目录下预置的 SDL2 和 Freetype 静态库 (.a) 的完整路径，并包含了编译 Windows GUI 程序所需的一系列系统库（如 gdi32, winmm 等）。 Linux PC (elseif(UNIX AND NOT APPLE)): 触发条件: 在 Linux 系统上进行本地编译时满足。 库配置: 使用 find_package() 在系统中查找 SDL2, Threads (线程库) 和 Freetype。这要求用户的系统上必须通过包管理器（如 sudo apt-get install libsdl2-dev libfreetype-dev）预先安装好这些开发库。 目标平台 检测方式 库来源 PLATFORM_LIBS 内容 嵌入式 ARM CMAKE_CROSSCOMPILING 为 TRUE 项目内置的静态库 pthread, freetype_local, m Windows WIN32 为 TRUE 项目内置的静态库 libSDL2.a, libfreetype.a, 系统库… Linux PC UNIX AND NOT APPLE 系统安装的开发库 SDL2::SDL2, Threads::Threads, … 3. 自动化核心：动态修改 LVGL 配置文件 这是整个构建脚本最智能的部分。它解决了为不同平台维护不同配置文件的痛点。 # --- 动态修改配置文件 ---file(READ $LV_DRV_CONF_PATH LV_DRV_CONF_CONTENT)# ...string(REGEX REPLACE (#define[ \\t]+USE_SDL[ \\t]+) \\\\11 LV_DRV_CONF_CONTENT $LV_DRV_CONF_CONTENT)# ...file(WRITE $LV_DRV_CONF_PATH $LV_DRV_CONF_CONTENT) 工作流程: file(READ ...): 将 lv_drv_conf.h 和 lv_conf.h 的全部内容读入 CMake 的字符串变量中。 if(TARGET_PLATFORM ...): 根据上一步检测到的平台，进入不同的逻辑分支。 string(REGEX REPLACE ...): 使用正则表达式查找特定的宏定义行，例如 #define USE_SDL 0 或 #define USE_SDL 1。 (#define[ \\t]+USE_SDL[ \\t]+): 这是一个捕获组，匹配宏定义的前半部分。 [01]: 匹配当前的设置值，无论是 0 还是 1。 \\\\11: 这是替换内容。\\\\1 是对第一个捕获组的回引（即 #define USE_SDL ），后面的 1 是新的值。这样就能精确地将宏的值修改为 1，同时保持原有的格式不变。 file(WRITE ...): 将修改后的字符串内容写回到原始文件中。 效果: 当你为 PC 编译时，脚本会自动将 USE_SDL 改为 1，USE_FBDEV 改为 0；而当你交叉编译时，则会自动将 USE_SDL 改为 0，USE_FBDEV 改为 1。整个过程在 cmake 配置阶段完成，对开发者完全透明。 4. 源码聚合与编译 include_directories(...)file(GLOB_RECURSE ALL_SOURCES lvgl/src/*.c ...) include_directories: 将所有需要的头文件路径（如 . 根目录, UI/, lvgl/）添加到编译器的搜索路径中。 file(GLOB_RECURSE ALL_SOURCES ...): 递归地查找所有指定的 .c 源文件，并将它们的路径列表存入 ALL_SOURCES 变量中。这避免了手动逐一列出所有源文件的繁琐工作。 5. 生成最终可执行文件 add_executable($PROJECT_NAME main.c ... $ALL_SOURCES)target_link_libraries($PROJECT_NAME PRIVATE $PLATFORM_LIBS) add_executable: 创建最终的可执行文件目标（名为 main），并将入口文件 main.c 以及 ALL_SOURCES 变量中收集的所有源文件都加入编译。 target_link_libraries: 这是最后一步，将可执行文件与之前根据平台配置好的 PLATFORM_LIBS 变量中的所有库进行链接，生成最终可运行的程序。 通过这些步骤，使这份 CMake 脚本实现了一个高度自动化、可移植且对用户友好的构建环境"},{"title":"(UI/) 代码解析","path":"/wiki/LVGL-CarDashboard/usage-ui.html","content":"UI/ 目录包含了所有与用户界面相关的代码和资源。这部分代码使用 LVGL 的可视化设计工具 SquareLine Studio 自动生成，开发者主要负责调用和与业务逻辑进行交互。 目录结构详解 UI/├── CMakeLists.txt # 编译脚本，将所有UI源文件打包├── components/ # 存放自定义的复合组件├── fonts/ # 字体文件 (C 数组格式)├── images/ # 图片文件 (C 数组格式)├── screens/ # 存放各个屏幕的 UI 定义代码├── ui.c / ui.h # UI 的主入口，负责创建和初始化所有界面└── ui_events.c / .h # UI 事件的回调函数（本项目中较少使用） screens/: 每个 .c 文件定义了一个完整的屏幕界面。例如 ui_Screen1.c 负责创建仪表盘的主界面，包括背景、指针、标签等所有静态元素。 components/: 用于存放可复用的 UI 组件，例如一个自定义的警告图标和文本组合。这有助于保持代码的整洁和可维护性。 fonts/ 和 images/: 这两个目录存放的是项目所需的静态资源。LVGL 会将字体文件 (.ttf) 和图片文件 (.png) 转换为 C 语言的数组格式（.c 文件）。这样做的好处是，资源文件会直接被编译进最终的可执行文件中，无需在运行时从文件系统加载，极大地提高了嵌入式设备的运行效率和部署便利性。 ui.c 和 ui.h: 这是整个 UI 模块的“门面”。ui.h 对外暴露了 ui_init() 函数和各个 UI 控件的句柄（例如 ui_Image_SpeedoMeter）。ui.c 中的 ui_init() 函数则会调用 screens/ 目录下的函数来完成所有界面的初始化。 UI/CMakeLists.txt: 这个文件负责将 UI/ 目录下的所有 .c 文件收集起来，并编译成一个静态库或对象文件集合，供根目录的 CMakeLists.txt 链接。 工作流程 在 main.c 中，首先调用 ui_init(ui) 来创建和初始化所有 UI 元素。 在 obj/control.c 中，通过 extern 关键字引用 ui.h 中声明的 UI 控件句柄。 当需要更新界面时（例如更新速度值），control.c 会直接调用 LVGL 的 API 函数来操作这些句柄，例如 lv_bar_set_value(ui_BarSpeed, new_speed)。"},{"title":"代码架构与实现详解","path":"/wiki/LVGL-CarDashboard/usage.html","content":"本项目遵循 “UI-逻辑-平台” 分离的设计原则，实现了高度的模块化和可移植性 主要包含以下几个部分： UI/: 负责所有界面的显示和资源管理，由 LVGL 的界面设计工具 SquareLine Studio 生成 obj/: 负责实现项目的核心业务逻辑，例如处理控制台指令、管理仪表盘数据状态等 main.c: 作为程序的入口和粘合剂，负责初始化硬件平台、LVGL 库以及连接 UI 和业务逻辑 CMakeLists.txt: 负责整个项目的构建和编译，通过强大的跨平台能力支持 PC 和 ARM 嵌入式平台 通过模块化设计，使代码“干湿分离”，你可以用 SquareLine Studio 随意覆盖 UI 代码，而不影响obj里的逻辑代码的运行，以实现功能的快速迭代 下面将对每个部分进行详细说明，点击链接查看具体解析： 构建系统 (CMake) 解析 了解项目是如何通过 CMake 实现跨平台编译的 主程序入口 (main.c) 解析 了解程序如何启动、初始化平台驱动和 LVGL 核心 UI 代码 (UI/) 解析 深入了解 LVGL UI 文件的结构和作用 核心逻辑代码 (obj/) 解析 理解仪表盘数据处理和控制指令的实现"},{"title":"蓝桥杯嵌入式笔记","path":"/data/ES/蓝桥杯嵌入式笔记.html","content":"嵌入式蓝桥杯笔记 一，新建项目 打开 STM32CubeMX，点击 help，Updater Settings，设置配置文件夹路径，将官方的配置放进去 点击 Start My project from MCU-ACCESS TO MCU SELECTOR，开始新建工程 选择芯片，我自己用的是 STM32G431CBT6，比赛用的是 STM32G431RBT6 进入芯片配置界面，依次设置： RCC-High Speed Clock (HSE)-Crystal Ceramic Resonator(外部晶振) SYS-Debug-Serial Wire（串行输出） 更改下图中的值，其中系统频率为 80 MHz (80,000,000 Hz，一秒钟振动八千万次) 二、点亮 LED 1. 项目结构说明 为了方便开发和管理代码，我们创建了以下三个自定义文件： headfile.h：公共头文件，集中包含常用库头文件。 fun.c / fun.h：封装控制 LED 的功能函数。 main.c：主函数中调用功能函数。 2. 公共头文件（headfile.h） #ifndef _headfile_h#define _headfile_h#include stm32g4xx.h#include stdio.h#include string.h#include stdint.h#include main.h#include gpio.h#include fun.h#endif 该文件在主函数中被引用，避免多处修改，提高可维护性 3. LED 控制函数 fun.h #ifndef _fun_h#define _fun_hvoid led_show(uint8_t led, uint8_t mode);#endif fun.c #include headfile.hvoid led_show(uint8_t led, uint8_t mode) // 使能锁存器 HAL_GPIO_WritePin(GPIOD, GPIO_PIN_2, GPIO_PIN_SET); // 控制 LED if (mode) HAL_GPIO_WritePin(GPIOC, GPIO_PIN_8 (led - 1), GPIO_PIN_RESET);// 点亮 else HAL_GPIO_WritePin(GPIOC, GPIO_PIN_8 (led - 1), GPIO_PIN_SET);// 熄灭 // 关闭锁存器 HAL_GPIO_WritePin(GPIOD, GPIO_PIN_2, GPIO_PIN_RESET); 说明： 通过 GPIO_PIN_8 (led - 1) 实现控制多个 LED（如 LED1~LED8），可以在对应代码位置按下 f12 查看原有定义。 mode 为 1 点亮，0 熄灭。 使用锁存器的使能引脚 PD2 控制 LED 状态稳定写入。 4. 主函数调用（main.c） /* Includes ------------------------------------------------------------------*/#include main.h#include gpio.h/* USER CODE BEGIN Includes */#include headfile.h/* USER CODE END Includes */ 在 while 循环中调用点灯函数，例如点亮 LED1、LED4、LED8： while (1) led_show(1, 1); led_show(4, 1); led_show(8, 1); 注意：自定义代码需写在 /* USER CODE BEGIN */ 与 /* USER CODE END */ 区域之间，避免被 STM32CubeMX 自动生成代码覆盖。 三，按键 根据上面的文档对按键的定义，需要配置上拉输入（默认未按下按键是高电平（电平被上拉）） 多选，对应位置全部改成上拉： 正常生成后，gpio.c 里就会有相关引脚定义 fun.c 要加的代码： unit8_t B1_state;unit8_t B1_last_state;void key_scan() B1_state=HAL_GPIO_ReadPin(GPIOB,GPIO_Pin_0); if(B1_state==0B1_last_state==1)//按键B1按下 led_show(1,1); B1_last_state=B1_state; fun.h 也要修改： #ifndef _fun_h##define _fun_h#include stm32g4xx.hvoid led_show(unit8_t led,unit8_t mode);void key_scan(void);#endif main.c 里调用按键扫描函数 /* USER CODE BEGIN WHILE */while (1)key_scan(); /* USER CODE END WHILE */ B1 按键按下，第一个 LED 点亮 代码下载之后，按键还没按下，此时 b1 读取高电平，if 不满足，然后把这个高电平赋值给 b1-last-state，一直这样循环，直到我们按下按键，这个时候 b1 等于 0，就点亮了。 边沿检测：就是按下并且松开 led 才亮，如果不松开就不亮；只检测下降沿 修改 fun.c 里的按键扫描方法，以支持四个按键： uint8_t led_flag;uint8_t B1_state,B1_last_state=1,B2_state,B2_last_state=1,B3_state,B3_last_state=1,B4_state,B4_last_state=1;void key_scan() B1_state=HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_0); B2_state=HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_1); B3_state=HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_2); B4_state=HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0); if(B1_state==0B1_last_state==1) led_flag ^=1; if(B2_state==0B2_last_state==1) led_flag ^=1; if(B3_state==0B3_last_state==1) led_flag ^=1; if(B4_state==0B4_last_state==1) led_flag ^=1; B1_last_state=B1_state,B2_last_state=B2_state,B3_last_state=B3_state,B4_last_state=B4_state; led_show(1,led_flag); 长按和短按区分 这里涉及到了定时器相关功能，可以先看下面这个视频先理解定时器的工作原理： 【STM32】第 16 集 动画告诉你, STM32 的定时器到底怎么回事 在这个程序中，使用了定时器 TIM3 来判断按键的按下时间，从而区分短按和长按。关键参数如下： 参数 值 含义 PSC（预分频器） 8000-1 分频后得到 10kHz 时钟（0.1ms 一次） ARR（自动重装载值） 65535 最大计数值（约 6.5 秒） CNT（当前计数值） 0~65535 按键按下持续时间（单位 0.1ms） 所以设置判断 CNT = 10000 就是 1 秒，用来区分长短按。 随便选一个基本定时器，选内部时钟，PSC=8000-1,ARR 默认最大值即可 在正常判断逻辑的基础上，再增加判断条件： unit8_t B1_state,B1_last_state=1;//初始化，避免只进入短按，无法进入长按void key_scan() B1_state=HAL_GPIO_ReadPin(GPIOB,GPIO_Pin_0); if(B1_state==0B1_last_state==1)//按键B1按下 TIM3-CNT=0;//计数器清零 else if(B1_state==0B1_last_state==0)//按键B1一直按下 if（TIM3-CNT=10000)//按键b1长按，计数器数了一万次，约等于现实的1ms count++; else if(B1_state==1B1_last_state==0)//按键B1松开 if（TIM3-CNT10000)//按键b1短按 count+=2; //中间再写四个if写成其他按键的判断逻辑 B1_last_state=B1_state; 主函数加上定时器使能，while 循环前的内容如下： /* Initialize all configured peripherals */MX_GPIO_Init();/* USER CODE BEGIN 2 */LCD_Init(); // 初始化 LCDLCD_Clear(Black); // LCD 清屏为黑色背景LCD_SetBackcolor(Black); // 设置文字背景为黑色LCD_SetTextColor(White); // 设置文字颜色为白色HAL_TIM_Base_Start(htim3); //启动化计数器/* USER CODE END 2 *//* Infinite loop *//* USER CODE BEGIN WHILE */while (1) 四，LCD 首先 headfile.h 里要引用 lcd.h 其次，做初始化准备（初始化方法通过查询官方 led 函数定义得） 主函数 while 循环前的内容如下： /* Initialize all configured peripherals */MX_GPIO_Init();/* USER CODE BEGIN 2 */LCD_Init(); // 初始化 LCD（建议加在gpio初始化的前面）LCD_Clear(Black); // LCD 清屏为黑色背景LCD_SetBackcolor(Black); // 设置文字背景为黑色LCD_SetTextColor(White); // 设置文字颜色为白色/* USER CODE END 2 *//* Infinite loop *//* USER CODE BEGIN WHILE */while (1) 此时编译下载。 LED 灯全亮, 因为 led 和 lcd 共用 io 口，全亮是正常的 fun.h 中声明 LCD 的显示函数： #ifndef _fun_h##define _fun_h#include stm32g4xx.hvoid led_show(unit8_t led,unit8_t mode);void key_scan(void);void lcd_show(void);#endif fun.h 中实现 lcd_show 函数 char text[20];//一行只能显示20个字符void lcd_shoW() sprinf(text, text );//拷贝后面的一串字符到前面字符串里 LCD_DiaplayStringLine(Line0,(unit8_t *)text);//在第一行显示这个字符串 为什么要对字符串进行强制类型转换？因为这个函数要输入的参数是 u8 的，u8是无符号数据，char 有符号 将显示函数放在主函数循环里 /* USER CODE BEGIN WHILE */while (1) key_scan(); lcd_show(); /* USER CODE END WHILE */ 可以看到，屏幕上显示了 text 字符 按键+LCD 利用按键。 B1 按下 Count 加加。 B2 按下 Count 减减 屏幕显示。第零行 Test。第三行显示 count。 下面是修改好了的 fun.c 代码： #include headfile.hint count=0;//新加一个数据用于计数void led_show(unit8_t led,unit8_t mode) HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_SET); if(mode) HAL_GPIO_WritePin(GPIOC,GPIO_PIN_8(led-1),GPIO_PIN_RESSET); else HAL_GPIO_WritePin(GPIOC,GPIO_PIN_8(led-1),GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_RESET);unit8_t B1_state;unit8_t B1_last_state;unit8_t B2_state;unit8_t B2_last_state;unit8_t B3_state;unit8_t B3_last_state;unit8_t B4_state;unit8_t B4_last_state;void key_scan() B1_state=HAL_GPIO_ReadPin(GPIOB,GPIO_Pin_0); B2_state=HAL_GPIO_ReadPin(GPIOB,GPIO_Pin_1); B3_state=HAL_GPIO_ReadPin(GPIOB,GPIO_Pin_2); B4_state=HAL_GPIO_ReadPin(GPIOA,GPIO_Pin_0); if(B1_state==0B1_last_state==1)//按键B1按下 count++;//计数++ if(B2_state==0B2_last_state==1)//按键B2按下 count--;//计数-- if(B3_state==0B3_last_state==1)//按键B3按下 led_show(2,1); if(B4_state==0B4_last_state==1)//按键B4按下 led_show(2,0); B1_last_state=B1_state; B2_last_state=B2_state; B3_last_state=B3_state; B4_last_state=B4_state;char text[20];//一行只能显示20个字符void lcd_shoW() sprinf(text, text ); LCD_DiaplayStringLine(Line0,(unit8_t *)text); sprinf(text, count：%d ，count); LCD_DiaplayStringLine(Line3,(unit8_t *)text); LCD 高亮显示 在原有基础上加一个标志位，记录那一行用了高亮 LED 和 LCD 引脚冲突问题 在 LCD 设置前。将引脚配置成低电平 每一次在主函数循环之前锁住 led 灯相关的寄存器： /* USER CODE BEGIN SysInit */LCD_Init();LCD_Clear(Black);LCD_SetBackColor(Black);LCD_SetTextColor(White); /* USER CODE END SysInit */ /* Initialize all configured peripherals */ MX_GPIO_Init(); /* USER CODE BEGIN 2 */HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_RESET);//关掉相关寄存器 /* USER CODE END 2 */ /* Infinite loop */ /* USER CODE BEGIN WHILE */ while (1) 或者写下面这个版本，遍历所有灯状态： uint8_t led_state[8]=0;void led(uint8_t led, uint8_t mode) led_state[led] = mode; for (uint8_t i = 0; i 8; i++) HAL_GPIO_WritePin(GPIOD, GPIO_PIN_2, GPIO_PIN_SET); if (led_state[i]) HAL_GPIO_WritePin(GPIOC, GPIO_PIN_8 i, GPIO_PIN_RESET); else HAL_GPIO_WritePin(GPIOC, GPIO_PIN_8 i, GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOD, GPIO_PIN_2, GPIO_PIN_RESET); 五，定时器中断实现 LED 闪烁 原理解释： PSC = 7999: 预分频值为 7999。 ARR = 9999: 自动重载值为 9999。 计算定时器计数时钟频率: Counter Clock = 80,000,000 Hz / (7999 + 1) = 80,000,000 Hz / 8000 = 10,000 Hz (即 10 kHz) 计算定时器更新事件频率: Update Frequency = Counter Clock / (ARR + 1) = 10,000 Hz / (9999 + 1) = 10,000 Hz / 10000 = 1 Hz 计算定时器更新事件周期: Period = 1 / Update Frequency = 1 / 1 Hz = 1 second 目的/原因: 这个配置是为了让定时器每隔 1 秒钟产生一次更新事件（例如触发一次中断）。 首先通过较大的 PSC (7999) 将 80 MHz 的高速时钟乘以 8000，分频到一个较低、好计算的频率 (10 kHz)， 然后通过 ARR (9999) 设置计数器从 0 数到 9999（总共 10000 个计数周期），刚好是 10000 次 10000 Hz = 1 秒。 在这个程序中，使用了定时器 TIM2 来判断按键的按下时间，从而区分短按和长按。关键参数如下： 参数 值 含义 PSC（预分频器） 8000-1 分频后得到 10kHz 时钟（0.1ms 一次） ARR（自动重装载值） 10000-1 最大计数值（约 1 秒） 所以设置判断 ARR = 10000-1 就是 1 秒，用来每隔一秒自动调用中断回调函数。 随便选一个基本定时器，选内部时钟，PSC=8000-1,ARR 设置为 10000-1 即可 使中断使能 找到中断函数 在 headfile 里加入 tim.h 在 fun.c 里，实现回调函数，每隔一秒钟 count++ void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) if(htim-Instance==TIM2) count++; 在主函数进行计时器初始化 /* Initialize all configured peripherals */ MX_GPIO_Init(); MX_TIM4_Init(); MX_TIM2_Init(); /* USER CODE BEGIN 2 */HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_RESET);HAL_TIM_Base_Start_IT(htim2);//触发中断 /* USER CODE END 2 */ /* Infinite loop */ /* USER CODE BEGIN WHILE */ while (1) lcdshow(); key_scan(); /* USER CODE END WHILE */ 中断函数不建议执行耗时间的调用 例如这个 led_show 函数,若将相关逻辑放在中断函数中 会全部闪亮，出现和之前一样的状态 因为控制 led 相关寄存器的代码写在循环里的，如果在还没有锁 led 寄存器的时候进入中断函数，就会出现 LED 和 LCD 引脚冲突问题 六，PWM psc=800-1, arr=100-1, ccr=50 PSC = 799: 预分频值为 799。 ARR = 99: 自动重载值为 99。 CCR = 50: 捕获/比较寄存器值为 50。 计算定时器计数时钟频率: Counter Clock = 80,000,000 Hz / (799 + 1) = 80,000,000 Hz / 800 = 100,000 Hz (即 100 kHz) 计算 PWM 频率: PWM 频率由 ARR 决定。 PWM Frequency = Counter Clock / (ARR + 1) = 100,000 Hz / (99 + 1) = 100,000 Hz / 100 = 1,000 Hz (即 1 kHz) 计算 PWM 占空比 (Duty Cycle): 占空比由 CCR 和 ARR 决定 (假设为 PWM 模式 1 或 2，向上计数)。 Duty Cycle = CCR / (ARR + 1) = 50 / (99 + 1) = 50 / 100 = 0.5 = 50% 目的/原因: 这个配置是为了生成一个频率为 1 kHz，占空比为 50% 的 PWM 波。 PSC (799) 将 80 MHz 分频到 100 kHz。ARR (99) 设定了 PWM 的周期长度为 100 个计数时钟周期 (100 / 100,000 Hz = 0.001 秒，即 1 kHz)。 CCR (50) 设定了在一个 PWM 周期内，输出高电平（或低电平，取决于 PWM 模式）的持续时间为 50 个计数时钟周期，占总周期 100 的一半，因此是 50% 的占空比 先按之前的操作建立一个空工程 选择 PA1 引脚，设置定时器 TIM2CH2（确保其他东西没有选这个定时器） 这里设置 PSC=800-1；ARR=100-1； 在主函数 while 循环附近，加上代码： /* USER CODE BEGIN 2 */HAL_TIM_PWM_Start(htim2,TIM_CHANNEL_2);//启动PWM输出TIM2-CCR2=50;//高电平计数50 /* USER CODE END 2 */ 编译运行，测 PA1，可以看到输出了 1000HZ 的方波 原理：比正常定时器多了个 CCR（compare，比较）字段，用于控制高电平占整个周期的频率 . 七，输入捕获测量 PWM 频率 PSC = 79: 预分频值为 79。 计算定时器计数时钟频率: Counter Clock = 80,000,000 Hz / (79 + 1) = 80,000,000 Hz / 80 = 1,000,000 Hz (即 1 MHz) 定时器计数周期: Counter Period = 1 / Counter Clock = 1 / 1,000,000 Hz = 1 microsecond (µs) 理解捕获: 输入捕获模式下，当指定的输入引脚检测到信号边沿（上升沿或下降沿）时，定时器当前的计数值 (CNT) 会被锁存到捕获/比较寄存器 (CCR) 中。 频率测量原理: 通过捕获两次连续相同边沿之间的时间，可以计算输入信号的周期，进而得到频率。 假设两次捕获的值分别为 CCR1 和 CCR2。 两次捕获之间的计数值差 Delta_Counts = CCR2 - CCR1 (需要考虑计数器溢出)。 输入信号的周期 T_input = Delta_Counts * Counter Period = Delta_Counts * 1 µs。 输入信号的频率 f_input = 1 / T_input = 1 / (Delta_Counts * 1 µs) = 1,000,000 / Delta_Counts Hz。 代码中计算频率的公式: 频率 = 80000000 / (80 * 两次捕获之间的计数值差) 这里的 80000000 是系统时钟。 这里的 80 是 PSC + 1。 公式为 f_input = 80,000,000 / (80 * Delta_Counts) f_input = (80,000,000 / 80) / Delta_Counts f_input = 1,000,000 / Delta_Counts Hz。 此公式等价于用 1 MHz 的计数器时钟频率除以捕获到的计数值差来计算输入信号的频率。 目的/原因: 这个配置将定时器的计数频率设置为 1 MHz，意味着每次计数代表 1 微秒。这提供了一个较高的时间分辨率，适合测量上面配置的微秒级别的脉冲宽度或较高频率的信号。选择 PSC=79 是为了从 80 MHz 得到一个整数且方便计算的 1 MHz 计数频率。 用 PA7 引脚测量输出频率 这里的 tim17_Ch1 激活选择输入捕获 PSC 设置为 80-1 . 启用中断 . 留下显示函数，用于验证是否获取频率成功 . 在主函数 while 循环附近，加上代码： /* USER CODE BEGIN 2 */HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_RESET);HAL_TIM_PWM_Start(htim2,TIM_CHANNEL_2);TIM2-CCR2=50;HAL_TIM_IC_Start_IT(htim17,TIM_CHANNEL_1);//输入捕获中断启动 /* USER CODE END 2 */ 加入输入中断的回调函数 按 CTRL+F 在 hal 库代码头文件里寻找 capture . 在 fun.c 中实现回调函数： char text[20];void lcdshow() sprintf(text, text ); LCD_DisplayStringLine(Line0,(uint8_t *)text); sprintf(text, fre:%d ,fre); LCD_DisplayStringLine(Line3,(uint8_t *)text);uint32_t fre,capture_value;//中断频率和捕获值void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) if(htim-Instance==TIM17) capture_value=HAL_TIM_ReadCapturedValue(htim,TIM_CHANNEL_1);//捕获值 TIM17-CNT=0; fre=8000 0000/(80*capture_value); 在主函数调用，并初始化 LCD /* USER CODE BEGIN 2 */ HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_RESET);// HAL_TIM_Base_Start_IT(htim2); HAL_TIM_PWM_Start(htim2,TIM_CHANNEL_2); TIM2-CCR2=50; HAL_TIM_IC_Start_IT(htim17,TIM_CHANNEL_1); /* USER CODE END 2 */ /* Infinite loop */ /* USER CODE BEGIN WHILE */ while (1) lcdshow(); . fre 是 0 的看看是不是中断使能那个函数用错了，要带 IT (中断）的才行 频率显示 0 的检查一下有没有加使能函数 是零看看初始化函数位置放对没，放在 tim2 和 tim17 初始化之后 没成果的可以重新检查一下代码和配置（比如端口的模式）有没有对 这里的 led 怎么全亮了？ PD2 的引脚没初始化 PD2 没有初始化，默认高电平，初始化后才能写低电平 八，输入捕获两个 555 定时器输出的频率 PA15 引脚选择 TIM2_CH1 . PB4 引脚选择 TIM16_CH1 . TIM2 选输入捕获直接模式,PSC 设置 80-1，开启中断 . TIM16_CH1 选择 Activate，选择输入捕获直接模式，PSC=80-1 . fun.c 代码： char text[20];uint32_t fre1,capture_value1,fre2,capture_value2;void lcdshow() sprintf(text, text ); LCD_DisplayStringLine(Line0,(uint8_t *)text); sprintf(text, count:%d ,count); LCD_DisplayStringLine(Line2,(uint8_t *)text); sprintf(text, R39fre:%d ,fre1); LCD_DisplayStringLine(Line3,(uint8_t *)text); sprintf(text, R40fre:%d ,fre2); LCD_DisplayStringLine(Line4,(uint8_t *)text);void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) if(htim-Instance==TIM16)//频率输出1 R39 capture_value1=HAL_TIM_ReadCapturedValue(htim,TIM_CHANNEL_1); TIM16-CNT=0; fre1=8000 0000/(80*capture_value1); if(htim-Instance==TIM2)//频率输出2 R40 capture_value2=HAL_TIM_ReadCapturedValue(htim,TIM_CHANNEL_1); TIM2-CNT=0; fre2=8000 0000/(80*capture_value2); 主函数代码： /* USER CODE BEGIN 2 */LCD_Init();LCD_Clear(Black);LCD_SetBackColor(Black);LCD_SetTextColor(White);HAL_TIM_PWM_Start_IT(htim2,TIM_CHANNEL_1);HAL_TIM_PWM_Start_IT(htim16,TIM_CHANNEL_1); /* USER CODE END 2 */ /* Infinite loop */ /* USER CODE BEGIN WHILE */ while (1) lcdshow(); 调整旋钮，可以看到值在变化： 。 九，ADC 测量 PB15 选 adc2in15 pb12 选 ADC1in11 都选 single-ended headfile.h 引入 adc.h fun.c： void lcdshow() sprintf(text, text ); LCD_DisplayStringLine(Line0,(uint8_t *)text); HAL_ADC_Start(hadc1); uint32_t adc_value = HAL_ADC_GetValue(hadc1);//R30 sprintf(text, value:%d ,adc_value); LCD_DisplayStringLine(Line2,(uint8_t *)text); 主函数代码： /* USER CODE BEGIN SysInit */ LCD_Init(); LCD_Clear(Black); LCD_SetBackColor(Black); LCD_SetTextColor(White); /* USER CODE END SysInit */while (1) lcdshow(); 可以看到屏幕上的值在 0-4096 之间变化 . 添加电压转换函数 adc 值 = 3.3 * adc 捕获值 / 4096 原理： 3.3: 代表 ADC 的参考电压 Vref+ 是 3.3 V。这是 ADC 能够测量的最大电压（或电压范围的上限）。 adc 捕获值: 这是 ADC 完成一次转换后读取到的原始数字值。 4096: 代表 ADC 的分辨率级别数。STM32 上常见的 ADC 是 12 位的，其输出范围是 0 到 2^12 - 1，即 0 到 4095。因此总共有 4096 个级别。 公式解释: 这个公式是将 ADC 读到的数字值（0-4096 范围）线性地映射到实际的模拟电压值（0-3.3V 范围）。 (adc捕获值 / 4096)表示当前读数占 ADC 满量程的比例。 将这个比例乘以参考电压 (3.3V)，就得到了对应的模拟输入电压值。 fun.c： void lcdshow() sprintf(text, text ); LCD_DisplayStringLine(Line0,(uint8_t *)text); sprintf(text, R37_VOL:%d ,get_vol(hadc2)); LCD_DisplayStringLine(Line2,(uint8_t *)text); sprintf(text, R38_VOL:%d ,get_vol(hadc1)); LCD_DisplayStringLine(Line3,(uint8_t *)text);double get_vol(ADC_HandleTypeDef *hadc) HAL_ADC_Start(hadc1); uint32_t adc_value = HAL_ADC_GetValue(hadc1);//R30 return 3.3*adc_value/4096; 在 headfile.h 里声明函数 double get_vol(ADC_HandleTypeDef *hadc); 主函数代码： /* USER CODE BEGIN SysInit */ LCD_Init(); LCD_Clear(Black); LCD_SetBackColor(Black); LCD_SetTextColor(White); /* USER CODE END SysInit */while (1) lcdshow(); 九，串口通信 串口发送数据 设置为异步通信 PC4,PC5 改为 PA9,PA10 中断使能作用 后面用于接收的 主函数循环附近的代码如下： /* USER CODE BEGIN WHILE */while (1)char text1[20];sprintf(text1,hahahaha\\r );HAL_UART_Transmit(huart1,(uint8_t *)text1,sizeof(text1),50);HAL_Delay(1000); /* USER CODE END WHILE */ 串口调试 查找电脑端口，此电脑，管理查找 波特率和之前保持一致，115200 比赛中一般为 9600/115200 . 串口中断接收配置 在 fun.c 里实现串口中断回调函数（可用 ctrl+f 在 uart.h 里找） uint8_t rec_data;void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) if(huart-Instance == USART1) HAL_UART_Transmit(huart,rec_data,1,50); HAL_UART_Receive_IT(huart,rec_data,1); 注意，在 fun.h 里，声明接收数据变量为全局变量： #ifndef __fun_H__#define __fun_H__#include headfile.h#include stm32g4xx.h // Device headervoid led_show(uint8_t led,uint8_t mode);void key_scan(void);void lcdshow(void);extern uint8_t rec_data;//声明为全局变量#endif 在主函数，要启用对应的串口中断 /* USER CODE BEGIN 2 */HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_RESET);HAL_UART_Receive_IT(huart1,rec_data,1); /* USER CODE END 2 */ 利用定时器进行串口非定长数据接收，并处理数据 串口接收: 每次进入中断只能接收一个字节的数据 考虑错误情况： 每次接收一个字节就要判断该字节是否符合要求 接收完所有字符，判断字符串是否符合要求 解决方法: 利用定时器，处理串口接收 串口波特率=9600 bit/s 就是 1s 可以传输 9600bit 串口传输一次数据包含起始位，数据位，结束位，一共 10bit 10 *1/9600 = 0.00104s =1.04ms 头文件与变量定义 #include headfile.hchar send_buff[20]; // 发送缓冲区uint8_t rec_data; // 接收单字节数据uint8_t count; // 接收数据计数uint8_t rec_flag; // 接收标志位uint8_t rec_buff[20]; // 接收缓冲区 串口接收中断回调函数 void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) if(huart-Instance == USART1) TIM4-CNT = 0; // 清零定时器计数 rec_flag = 1; // 设置接收标志 rec_buff[count++] = rec_data; // 存入接收数据 HAL_UART_Receive_IT(huart, rec_data, 1); // 继续接收下一个字节 串口数据处理函数 void uart_data_rec() if(rec_flag TIM4-CNT 15) // 若接收到数据并且超时判断通过，超时判断比1.04多0.5毫秒左右 if(rec_buff[0]==l rec_buff[1]==a rec_buff[2]==n) sprintf(send_buff, lan\\r ); else if(rec_buff[0]==q rec_buff[1]==i rec_buff[2]==a rec_buff[3]==o) sprintf(send_buff, qiao\\r ); else if(rec_buff[0]==b rec_buff[1]==e rec_buff[2]==i) sprintf(send_buff, bei\\r ); else sprintf(send_buff, error!\\r ); HAL_UART_Transmit(huart1, (uint8_t *)send_buff, sizeof(send_buff), 50); rec_flag = 0; // 重置接收标志 memset(rec_buff, 0, count); // 清空接收缓存 count = 0; // 计数归零 整体来看，这段代码实现了 USART1 串口数据的中断接收、基于定时器的接收完成判断以及按规则对接收数据的处理与回复功能。 可以在 if 最后加上 rec_buff[最后一位 + 1]==0，避免输入 lanqiao 也会返回 lan 可以在 if 最后加上 rec_buff[最后一位 + 1]==0，避免输入 lanqiao 也会返回 lan 。 会只输出 lan 因为对后面的数据不再进行判断 十，用 I2C 协议对 eeprom 读写 这段 C 语言代码，用于向 EEPROM 写入数据，函数借助 I2C 通信协议来实现操作 下面加的两个函数需要在对应头文件里声明 void eeprom_write(uint8_t addr, uint8_t dat)//参数列表为要写入数据的rom地址和要写入地址的数据 I2CStart();//准备发送 I2CSendByte(0xa0);//找rom设备，地址是a0 I2CWaitAck();//等待设备发送确认信号 I2CSendByte(addr);//要向rom设备地址为addr的位置写数据 I2CWaitAck();//等待设备发送确认信号 I2CSendByte(dat);//向该地址写入数据 I2CWaitAck();//等待设备发送确认信号 I2CStop();//结束本次通信 HAL_Delay(20);//写入数据需要时间 在 eeprom 设备手册里，可以了解到： 0xa0 为写的操作 0xa1 为读的操作 eeprom_read 函数： uint8_t eeprom_read(uint8_t addr)//参数为要读取数据的ROM地址 //设置读取地址阶段 I2CStart(); //开始通信，准备发送写地址 I2CSendByte(0xa0); //发送EEPROM写地址 I2CWaitAck(); //等待确认 I2CSendByte(addr); //发送要读取数据的地址 I2CWaitAck(); //等待确认 I2CStop(); //结束写地址设置 //数据读取阶段 I2CStart(); //重新开始通信，准备读取数据 I2CSendByte(0xa1); //发送EEPROM读地址 I2CWaitAck(); //等待确认 uint8_t dat = I2CReceiveByte(); //接收数据 I2CSendNotAck(); //发送非应答，表示读取结束 I2CStop(); //结束通信 return dat; //返回读取的数据 主函数代码 /* USER CODE BEGIN 2 */ LCD_Init(); // 初始化LCD LCD_SetTextColor(White); // 设置字体为白色 LCD_SetBackColor(Black); // 设置背景为黑色 LCD_Clear(Black); // 黑色清屏 I2CInit(); // 初始化I2C总线 eeprom_write(0,10);//向第零个地址写入数据10 uint8_t dat = eeprom_read(0); // 读取地址0的数据 char text[20]; // 显示用字符串缓冲区 /* USER CODE END 2 */while (1) sprintf(text, %d, dat); // 数据转为字符串 LCD_DisplayStringLine(Line0, (uint8_t *)text); // 显示在LCD第0行 总结：初始化外设 → 从 EEPROM 读取数据 → 将数据循环显示在 LCD 屏幕上 未存储时，显示默认值 255 . 存储后，显示存储的内容 . 十一，rtc 实时时钟 主要功能实现： 1.设置时间和日期 2.读取时间和日期 3.设置一个闹钟 fun.c 代码 char text[20];RTC_TimeTypeDef sTime = 0;//时间信息RTC_DateTypeDef sDate = 0;//日期信息(不需要也要调用，不然时间不动)void lcd_show() HAL_RTC_GetTime(hrtc, sTime, RTC_FORMAT_BIN); HAL_RTC_GetDate(hrtc, sDate, RTC_FORMAT_BIN); sprintf(text, test); LCD_DisplayStringLine(Line0, (uint8_t *)text); sprintf(text, %2d:%2d:%2d, sTime.Hours, sTime.Minutes, sTime.Seconds); LCD_DisplayStringLine(Line1, (uint8_t *)text); sprintf(text, %d-%d-%d-%d, sDate.Year, sDate.Month, sDate.Date, sDate.WeekDay); LCD_DisplayStringLine(Line2, (uint8_t *)text); led_show(1, led_mode);void HAL_RTC_AlarmAEventCallback(RTC_HandleTypeDef *hrtc)//这是一个 RTC 闹钟事件的回调函数 led_mode=1;//控制灯的翻转 灯点不亮的看看主函数 rtc 有没有使能 完结撒花！！！！！ 📘 单独补充：STM32 定时器知识要点 一、用到的定时器分类 定时器类型 特点 用途举例 基本定时器（TIM6/TIM7） 无输入输出通道，只能内部计数 延时、中断、DAC 触发 通用定时器（TIM2~TIM5） 有多个通道，可用于 PWM、输入捕获、编码器等 PWM 控制、电机驱动等 二、核心参数公式 1. PWM 频率 fPWM=ftimer_clk(PSC+1)×(ARR+1)f_{\\text{PWM}} = \\frac{f_{\\text{timer\\_clk}}}{(PSC + 1) \\times (ARR + 1)} fPWM​=(PSC+1)×(ARR+1)ftimer_clk​​ 中文释义： PWM频率=定时器时钟频率(预分频器+1)×(自动重装值+1)\\text{PWM频率} = \\frac{\\text{定时器时钟频率}}{(\\text{预分频器}+1) \\times (\\text{自动重装值}+1)} PWM频率=(预分频器+1)×(自动重装值+1)定时器时钟频率​ 2. PWM 占空比 Duty Cycle=CCRARR+1×100%\\text{Duty Cycle} = \\frac{CCR}{ARR + 1} \\times 100\\% Duty Cycle=ARR+1CCR​×100% 中文释义： 占空比=比较寄存器值（CCR）自动重装值（ARR）+1×100%\\text{占空比} = \\frac{\\text{比较寄存器值（CCR）}}{\\text{自动重装值（ARR）}+1} \\times 100\\% 占空比=自动重装值（ARR）+1比较寄存器值（CCR）​×100% 3. 基本定时器中断周期 T=(PSC+1)×(ARR+1)ftimer_clkT = \\frac{(PSC + 1) \\times (ARR + 1)}{f_{\\text{timer\\_clk}}} T=ftimer_clk​(PSC+1)×(ARR+1)​ 中文释义： 定时周期（秒）=(预分频器+1)×(自动重装值+1)定时器时钟频率\\text{定时周期（秒）} = \\frac{(\\text{预分频器}+1) \\times (\\text{自动重装值}+1)}{\\text{定时器时钟频率}} 定时周期（秒）=定时器时钟频率(预分频器+1)×(自动重装值+1)​ 三、常用寄存器 寄存器详细说明 寄存器 说明 详细解释 PSC 预分频器（Prescaler） 定时器的预分频器，决定定时器计数的频率。通过将系统时钟（timer_clk）除以 PSC + 1，可以降低定时器的计数频率。PSC 设置的数值越大，定时器计数速度越慢。 ARR 自动重装寄存器（Auto-Reload Register） 自动重装寄存器，决定定时器计数的周期。定时器从 0 数到 ARR 的值后会自动重置为 0，重新开始计数，形成一个周期。这个周期通常决定 PWM 输出的频率（PWM频率 = 1 / 周期）。 CNT 当前计数值（Counter） 当前计数器的值，表示定时器已经计数的时间。CNT 是一个递增的计数器，从 0 开始，直到它达到 ARR 的值。当计数值达到 ARR 时，定时器会溢出并重新从 0 开始。 CCRx 比较寄存器（Capture/Compare Register） 用于输出比较的寄存器。它的值控制了定时器的输出事件，比如 PWM 的高电平持续时间。当定时器的计数值（CNT）等于 CCRx 的值时，定时器会触发一个事件（如输出高电平或低电平）。在 PWM 模式下，CCRx 决定了高电平的持续时间。 CR1 控制寄存器（Control Register 1） 控制定时器的基本功能，如定时器启停、计数方向等。它用于配置定时器的工作模式，比如选择向上计数或向下计数，是否启用定时器等。常用的配置位有：CEN（计数器使能），DIR（计数方向），UDIS（更新使能）等。 寄存器之间的关系： PSC 和 ARR 配合使用，控制了定时器的计数频率和周期。PSC 控制定时器的频率，ARR 控制计数器的周期。 CNT 是定时器的实际计数值，随着时钟和设置的 PSC、ARR 进行增减，当 CNT 达到 ARR 时，定时器溢出并触发相应事件。 CCRx 用于控制 PWM 输出时的占空比或定时器的输出比较。当计数器 CNT 与 CCRx 相等时，定时器会触发输出事件（比如切换引脚的电平）。 CR1 用于开启定时器以及选择定时器的工作模式。 四、基础功能总结 项目 基本定时器 通用定时器 输出 PWM ❌ 不支持 ✅ 支持 中断功能 ✅ 支持 ✅ 支持 复用引脚输出 ❌ 无 ✅ 可映射到 IO 口输出 常见用途 延时、中断 PWM、捕获、测频","tags":[null],"categories":[null]},{"title":"C++复习","path":"/data/notebooks/C++复习.html","content":"C++ 复习 1.C++和 C 语言 C++是在 C 语言基础上改进发展而来的，是 C 语言的一个超集 C++和 C 语言在除了面向对象的设计思想以外有什么不一样？ 1. 头文件 C 语言用例如 stdio.h的头文件 C++ 用的 iostream 意为输入输出流，用于实现更高层次的输入输出操作 2. 输入输出流 标准输入输出是利用iostream库中的 cin(input) 和 cout(output) 这两个流对象 输入输出流可理解为河流，放入一艘船，捞出一艘船 C 语言使用 printf 和 scanf 进行输入输出操作 而 C++ 则引入了流操作符 cin 和 cout，更加直观： cin x;cout x endl;//endline,结束行之意 3. 变量类型 C++ 增加了 bool 类型和 string 类型，扩展了变量的表示形式： bool 类型: 变量的值为布尔判断结果，即 true（真）或 false（假） 其底层实质为整数：true 表示为 1，false 表示为 0 string 类型: string 是 C++ 提供的字符串类，包含许多便捷的工具成员（例如字符串拼接、查找等） 在 C 语言中，字符串只能存储在 char 类型的变量或 char 类型数组中 而 C++ 提供了更高层次的封装，可以直接使用 string 来处理字符串 C++ 在 C 语言的基础上还新增了 引用类型 和 类类型。 引用是已存在变量的别名，定义格式为：类型标识符 引用名 = 目标变量名; 例如：int x = 200; int y = x; // y 是 x 的引用 注意: 引用必须初始化 声明引用时必须同时初始化，未初始化是错误的：int y; // 错误，未初始化 引用类型必须一致 引用的类型需与目标变量一致：float y = x; // 错误，类型不一致 引用常量或表达式需加 const 常量或表达式作为引用必须需加 const，且引用值不可更改： const int y = 200; // 合法int y = 200; // 错误，缺少 const 4. 标准库文件和命名空间 C++ 引入命名空间的概念,命名空间用于解决全局变量或函数命名冲突的问题，提供更好的代码组织能力 为什么程序开头需要写 using namespace std;？ ​ 在 C++ 中，命名空间用于避免不同库中函数或对象命名冲突的问题，就像使用工具箱一样 ​ 假设我们有两套工具箱：一个是水工工具箱，另一个是电工工具箱 ​ 它们可能都有一些同名的工具（例如“手套”），但用途和构造完全不同 ​ 为了避免混淆，我们需要明确指定使用哪个工具箱中的工具 ​ 在 C++ 中，std (standard) 是标准工具箱的名称，包含了标准库中的函数和对象（如 cin 和 cout） ​ 使用命名空间有两种方式： 在程序开头定义命名空间： using namespace std; 这就相当于声明整个程序默认使用标准工具箱中的工具 每次使用时加上命名空间前缀： std::cin x;std::cout x std::endl; 这样显式地指定工具来自于标准工具箱 std ​ 如果没有正确指定命名空间，程序可能会出错 ​ 例如电工手套需要绝缘透气，而水工手套需要完全防水，混用会导致问题 ​ 同样，程序无法识别函数或对象的来源时也会产生错误 自增和自减运算符 自增（++）和自减（--）运算符用于对变量进行快速的加 1 或减 1 操作 前置形式（++x 或 --x）：变量先增减，再参与表达式运算 后置形式（x++ 或 x--）：变量先参与表达式运算，再增减 int x = 5, y = ++x, z = x--; // y = 6, z = 6, x = 5 逻辑运算符 逻辑运算符用于对布尔值进行逻辑运算，按优先级从高到低排列： 非（!）：最高优先级，用于取反操作 与（）：中间优先级，两个条件都为真时结果为真 或（||）：最低优先级，至少一个条件为真时结果为真 bool a = true, b = false, c = !a || b a;// c = false (先算 !a, 再算 b a, 最后 ||) 常变量 常变量（const）是值不可更改的变量，在程序中提供只读特性，常用于保护数据不被意外修改。 定义时初始化：常变量必须在声明时赋值。 作用：提高代码的安全性和可读性。 const int maxValue = 100; // 定义常变量// maxValue = 200; // 错误：常变量的值不能修改 引用类型!!! 在 C中，引用类型是一个变量的别名，通过它可以直接访问另一个变量。引用提供了对变量的一种间接访问方式，同时也保证了引用始终指向同一个变量（不可更改绑定对象）。以下是对 C中引用类型的详细介绍： 1. 定义和语法 引用通过在变量名前加上 来声明： type reference_name = variable_name; type：引用的目标变量的类型。 ：表示这是一个引用类型。 reference_name：引用的名字。 variable_name：被引用的目标变量。 2. 特性 引用必须在定义时初始化： int a = 10;int ref = a; // 正确int ref2; // 错误，引用必须初始化 引用不可重新绑定： 一旦引用初始化为某个变量，它就不能再引用其他变量。 int a = 10, b = 20;int ref = a;ref = b; // 赋值给引用，修改的是 a 的值，而不是重新绑定 refcout a; // 输出 20 引用本身没有独立存储： 引用只是原变量的别名，不占用额外的内存空间。 3. 引用的用途 （1）用作函数参数 引用常用于函数参数传递，以避免拷贝大对象，并允许函数修改实参。 void increment(int x) x++;int main() int a = 5; increment(a); cout a; // 输出 6 return 0; 传递引用避免了值传递的开销。 引用传递允许函数直接修改调用者的变量。 （2）用作函数返回值 引用可以作为函数返回值，允许函数返回调用者可以操作的变量。 int findMax(int a, int b) return (a b) ? a : b;int main() int x = 10, y = 20; findMax(x, y) = 100; // 修改返回的引用值 cout x y; // 输出 10 100 return 0; 返回引用时，确保被引用的变量在函数返回后仍然有效。 （3）在范围 for 循环中 引用可以用于遍历容器时避免拷贝，提高效率。 #include iostream#include vectorusing namespace std;int main() vectorint vec = 1, 2, 3, 4; for (int x : vec) x *= 2; // 通过引用直接修改元素 for (const int x : vec) cout x ; // 输出 2 4 6 8 return 0; （4）常量引用 常量引用（const 引用）用于防止修改被引用的变量，通常用于函数参数传递。 void print(const int x) // x = 10; // 错误，const 引用不可修改 cout x endl;int main() int a = 5; print(a); // 输出 5 return 0; 常量引用的特点： 可绑定到临时对象（右值）。 保护目标变量不被修改。 4. 引用与指针的对比 特性 引用 指针 初始化 必须在定义时初始化。 可以定义后初始化（赋值）。 绑定 一旦绑定，无法更改引用的目标。 可以指向不同的对象。 语法简洁性 使用简单，与普通变量操作类似。 需要显式使用 * 和 进行解引用或取地址。 空值支持 引用必须绑定到合法的对象。 指针可以为空（指向 nullptr）。 存储 不占用额外内存，是目标变量的别名。 占用独立内存空间，用来存储目标变量的地址。 右值绑定 常量引用支持绑定到右值。 需要特殊指针类型（如 const int*）绑定右值。 5. 示例：引用的综合应用 以下示例展示了引用在参数传递、返回值、const 修饰等场景的使用： #include iostreamusing namespace std;void modify(int x) x *= 2; // 修改引用的变量const int getValue() static int val = 42; return val; // 返回 const 引用int main() int a = 10; modify(a); // 通过引用传递 cout After modify: a endl; // 输出 20 const int ref = getValue(); cout Value: ref endl; // 输出 42 return 0; 输出： After modify: 20Value: 42 总结 引用的本质是变量的别名，提供对变量的一种间接访问方式。 必须初始化，且绑定后不能更改引用的目标。 应用场景广泛，如函数参数、函数返回值、const 引用保护数据。 与指针相比，引用语法更简洁，但灵活性略低。 2.数组、指针、引用和函数的使用 1 回顾函数概念 函数是执行特定任务的一段代码，通过调用它可以实现代码复用 伪代码示例： // 函数定义int 加法(int a, int b) return 参数1 + 参数2// 函数调用int a = 加法(3, 5) // 结果 = 8 2 默认参数 默认参数允许在函数定义时为某些参数提供默认值，调用时可选择性地忽略这些参数 int add(int a, int b = 5) return a + b; // b 默认值为 5int result = add(3); // result = 8int result = add(3,4); // result = 7 注意:除函数形参外，其他引用定义时必须赋初始值 3 引用传参 引用传参（）让函数直接操作原变量，而不是其副本，提高效率并支持修改实参值： void increment(int x) x++; int a = 5;increment(a); // a = 6 如果不用引用传参，可以通过返回修改后的值，并将结果重新赋值给变量来间接实现效果： int increment(int x) return x + 1; int a = 5;a = increment(a); // a = 6 虽然这种方法也能改变原变量的值，但每次调用函数都需要显式赋值，代码冗长且容易出错。 而引用传参不仅简洁，还能直接操作变量，避免不必要的复制和赋值操作 4 函数重载 函数重载和 Java 一样,允许在同一作用域内定义多个同名函数 但参数列表(参数数量或类型)必须不同 int multiply(int a, int b) return a * b; //原函数double multiply(double a, double b) return a * b; //传入参数不同double multiply(int a, int b) return a * b; //这是错的，要改的是参数列表int result = multiply(2, 3); // result = 6double result2 = multiply(2.5,2.0); // result2 = 5.0 5 内联函数 内联函数通过在调用处直接插入函数代码，减少函数调用开销，但只适用于小型函数 inline int square(int x) return x * x; int result = square(4); // result = 16 3.抽象与封装 1 面向对象思想 面向对象思想是一种以对象为中心的编程方式，强调抽象、封装、继承和多态四大特性 抽象：从现实世界中提取关键属性和行为，忽略细节 封装：隐藏对象内部实现细节，仅暴露必要接口 继承：通过复用已有类的特性实现代码复用和扩展 多态：允许对象表现出多种形态，提高程序灵活性 2 类和 UML 图 类是对现实中对象的抽象，UML 图是用于表示类的结构和关系的工具 一个类的 UML 图通常包含以下部分： 类名 属性（成员变量） 方法（成员函数） 示例 UML 图： +---------------+| Car | // 类名+---------------+| - color | // 属性（私有）| - speed |+---------------+| + start() | // 方法（公有）| + stop() |+---------------+ 3 类和对象实现 1. 定义和作用 公有（public）：所有类和对象都能访问 私有（private）：只能被类的内部访问 保护（protected）：仅类内部及其子类可访问 2. 类定义和实例化 class Car public: string color; void start() cout 启动车 endl; ;Car myCar; // 实例化对象myCar.color = red; // 访问成员变量myCar.start(); // 调用成员函数 3. 构造/析构函数 都和类名字一样,一个是用于初始化,一个用于清内存资源. 构造函数：在对象创建时自动调用，用于初始化对象 析构函数：在对象销毁时自动调用，用于释放资源 #include iostreamusing namespace std;class Person public: string *name; // 动态分配的内存 int age; // 构造函数,函数名和类名一样 Person(string n, int a) name = new string(n); // 动态分配内存 age = a; cout 构造函数调用，分配资源 endl; // 析构函数,在类名基础上加了~标记 ~Person() delete name; // 释放动态分配的内存 cout 析构函数调用，释放资源 endl; void display() cout *name , age endl; ;int main() Person p(Alice, 25); // 实例化对象,调用构造函数分内存 p.display(); // 输出：Alice, 25 return 0; // 在程序结束时调用析构函数 4 封装与读写接口 封装通过隐藏实现细节提高安全性，提供接口供外部访问或修改对象状态 读接口：提供只读访问成员变量的方法 写接口：提供修改成员变量的方法 class Car private: int speed;public: int getSpeed() return speed; // 读接口 void setSpeed(int s) speed = s; // 写接口;Car myCar;myCar.setSpeed(80); // 写接口cout myCar.getSpeed(); // 读接口 5. 类模板 类模板是一种通用设计方式，用于根据不同的数据类型创建类，避免为每种类型重复编写代码。它通过模板参数实现灵活性，在实例化时根据传入的类型生成具体的类 模板声明：使用 templateclass T 定义模版 实例化：通过 T 指定具体类型，如 Compareint 优点：减少代码重复，适配多种数据类型 #include iostreamusing namespace std;// 定义模板template typename T//也可以写成class T,原因后面讲了class Compare public: Compare(T a, T b) : x(a), y(b) // T是个占位符,代替了原本的参数类型的表示 T max() return (x y) ? x : y; // T是个占位符,代替了原本的函数返回的参数类型表示private: T x, y; // 模板类型的成员变量;int main() // 比较两个整数 Compareint cmp1(3, 7);//调用类的时候,在尖括号里传入参数 cout cmp1.max() 是两个整数中较大的值 endl; // 比较两个字符 Comparechar cmp2(a, g); cout cmp2.max() 是两个字符中较大的字符 endl; // 比较两个浮点数 Comparefloat cmp3(1.0f, 3.0f); cout cmp3.max() 是两个浮点数中较大的值 endl; return 0; class 和 typename的区别 虽然在模板参数中 class 和 typename 是等价的，但在其他场景中，两者有细微的区别： typename 在嵌套依赖类型中的用途： 在使用模板时，可能会遇到嵌套依赖的情况，这时必须使用 typename 来指示一个依赖类型是一个“类型”，否则编译器可能会报错： template typename Tclass Example typename T::NestedType value; // 必须使用 typename; 如果改为 class，编译器会报错，因为 class 不能用于明确说明嵌套依赖类型。 class 的语义歧义： 在模板参数中，class 不一定表示它是一个“类”，它可以是任何类型（包括基本类型如 int 和 double）。 typename 则更直观地表示“类型”。 typename 更符合现代风格： 随着 C++ 标准的演进（尤其是 C++11 和之后的标准），typename 在语义上更准确，现代代码更倾向于使用 typename。 为什么会有两种关键字？ 历史原因： 在 C++ 最初的设计中，class 已经是一个关键词，并用于定义模板参数。后来为了更清晰地表示“类型”，在 C++98 标准中引入了 typename。 向后兼容性： C++ 没有移除 class 用法，是为了兼容老代码。任何支持 C++98 或更高版本的编译器都会支持两者。 4. 数据共享和保护 4.1 静态成员变量 静态成员变量属于类本身，而非类的具体对象，所有对象共享该变量 只初始化一次，在整个程序运行期间都存在 class Counter public: static int count; // 静态成员变量声明 Counter() count++; ;int Counter::count = 0; // 静态成员变量初始化Counter c1, c2; // c1 和 c2 共享 count变量，最终 count = 2 4.2 静态成员函数 静态成员函数只能访问静态成员变量或其他静态成员函数 主要是为了引出本类中的静态成员变量 不需要依赖具体对象，通过类直接调用 class Counter public: static int count; static void showCount() cout count endl; ; // 在main函数中可以直接通过类名访问静态成员变量 Counter::count = 10; Counter::showCount(); // 输出：10 // 也可以通过实例化对象访问静态成员变量（不推荐，但合法）\t//这看起来像是访问对象的成员，但实际上还是修改类的静态成员，所有对象都会受到影响 Counter obj; obj.count = 20; obj.showCount(); // 输出：20 4.3 友元函数 可以理解为在类外面定义的属于类中的函数方法 友元函数通过关键字 friend 声明，可以访问类的私有和保护成员 友元不是类成员，但拥有类的访问权限 class Box private: int width;public: Box(int w) : width(w) friend void showWidth(Box b); // 友元函数声明;void showWidth(Box b) cout b.width endl; // 定义Box b(5);showWidth(b); // 输出：5 4.4 友元类 友元类通过 friend class 声明，允许另一个类访问当前类的私有和保护成员 class Box private: int width; friend class Display; // 友元类声明public: Box(int w) : width(w) ;class Display public: void show(Box b) cout b.width endl; ;Box b(7);Display d;d.show(b); // 输出：7 5. 继承与多态 1. 继承的概念 继承是面向对象编程的核心特性之一，允许子类从父类继承属性和行为，从而实现代码复用 父类（基类）：提供通用属性和行为 子类（派生类）：继承父类并扩展或重写其功能 2. 派生与继承 派生类定义：通过 : 指定继承的父类 访问控制： 根据访问权限总结出不同的访问类型，如下所示： 访问 public protected private 同一个类 yes yes yes 派生类 yes yes no 外部的类 yes no no 一个派生类继承了所有的基类方法，但下列情况除外： 基类的构造函数、析构函数和拷贝构造函数。 基类的重载运算符。 基类的友元函数。 继承类型 当一个类派生自基类，该基类可以被继承为 public、protected 或 private 几种类型。 继承类型是通过上面讲解的访问修饰符 access-specifier 来指定的。 几乎不使用 protected 或 private 继承，通常使用 public 继承 当使用不同类型的继承时，遵循以下几个规则： 公有继承（public）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。 保护继承（protected）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。 私有继承（private）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。 class Base public: int x;protected: int y;private: int z;;class Derived : public Base // 公有继承public: void display() cout x endl; // 只能访问 x 和 y; 3. 多态 多态是面向对象编程的核心特性之一，它允许同一个接口在不同情况下表现出不同的行为，分为静态多态和动态多态 1.静态多态 静态多态在编译时决定具体的函数调用，通常通过函数重载或运算符重载实现 函数重载(在 2.4 部分有说): 在同一作用域内定义多个同名函数,但参数列表(参数数量或类型)必须不同 class Calculator public: int add(int a, int b) return a + b; double add(double a, double b) return a + b; ;Calculator calc;cout calc.add(2, 3) endl; // 输出：5cout calc.add(2.5, 3.5) endl; // 输出：6.0 运算符重载 是静态多态的一种形式，允许重新定义运算符的行为，使其适用于自定义类 class Complex public: int real, imag; Complex(int r, int i) : real(r), imag(i) Complex operator+(const Complex c) //和函数重载方式一样,只是在运算符左边加上了operator标识 return Complex(real + c.real, imag + c.imag); ;Complex c1(2, 3), c2(4, 5), c3 = c1 + c2;cout c3.real + c3.imag i endl; // 输出：6 + 8i 2.动态多态 动态多态在运行时决定具体的函数调用，通常通过虚函数实现。这种机制依赖于动态绑定（运行时绑定） 虚函数 比正常函数后面加了个virtual表示虚拟,是实现动态多态的关键 允许在基类中定义通用接口，并在派生类中重写具体实现 class Base public: virtual void show() cout 基类 endl; //虚函数;class Derived : public Base public: void show() override cout 衍生类 endl; ;Base *obj = new Derived();obj-show(); // 输出：衍生类 纯虚函数与抽象类 纯虚函数就是没有具体实现的虚函数，用于强制派生类提供自己的实现。 在函数声明后加 = 0 即为纯虚函数 包含纯虚函数的类称为抽象类，无法直接实例化,它用于作为基类提供统一的接口 class Shape //抽象类,类似于java的接口类public: virtual void draw() = 0; // 纯虚函数,没有函数定义; class Circle : public Shape public: void draw() override cout 画个圆 endl; ;Shape *shape = new Rectangle();shape-draw(); // 输出：画个圆 意义：抽象类定义了规范或协议，使派生类必须实现具体的行为，从而保证代码的一致性和灵活性","tags":[null],"categories":[null]},{"title":"Java复习","path":"/data/notebooks/Java复习.html","content":"Java 复习总结 2.1.3 java 标识符 规则： 标识符只能由数字、字母（包括中文）、下划线_、美元符号$组成，不能含有其它符号。 标识符不能以数字开头 关键字不能做标识符。 例如：public class static void 这些都是关键字，关键字不能做标识符的。 标识符严格区分大小写。大写 A 和小写 a 不一样。 规标识符理论上是没有长度限制的。 2.1.5 Java 中的常量 在 Java 中，final修饰的实例变量一般和 static 联合使用，称为常量。 例如： public static final double PI = 3.1415926; 在 C 语言中，我们可以使用#define 预处理指令来定义常量。 #define PI 3.14159 2.2.3 变量的类型转换 1 小容量可以直接赋值给大容量，称为自动类型转换。 容量从小到大的排序为： byte short(char) int long float double， 其中 short 和 char 都占用两个字节，但是 char 可以表示更大的正整数； 2 大容量不能直接赋值给小容量，需要使用强制类型转换符进行强转。 大容量转换成小容量，要想编译通过，必须加强制类型转换符，进行强制类型转换。 底层是怎么进行强制类型转换的呢？long类型100L：00000000 00000000 00000000 00000000 00000000 00000000 00000000 01100100以上的long类型100L强转为int类型，会自动将“前面”的4个字节砍掉：00000000 00000000 00000000 01100100 需要注意的是：加强制类型转换符之后，虽然编译可以通过，但是运行的时候可能会损失精度。 2.4.3 switch 语句 在 c 语言中，switch 里只能判断字符和整型数，Java 可以额外判断字符串 2.5.5 跳转语句（break、continue） break 用于跳出本循环语句，执行循环后面的代码 continue 用于跳出本次循环，执行下一次循环 2.6 方法 2.6.2 方法的重载 什么时候代码会发生方法重载？ 在同一个类当中，方法名相同，参数列表不同 参数列表不同具体指：参数的个数不同，参数的类型不同，参数的顺序不同 只要同时满足以上条件，那么我们可以认定方法和方法之间发生了重载机制。 2.7 数组 相关实验： 猜数字游戏 案例 2-7 抽取幸运观众 关于 C 与 Java 的不同（总结） 1. 无符号数据类型 Java: Java 没有无符号的byte、short、int和long数据类型，这一点与 C 语言有很大的不同。因此，在 Java 中声明unsigned int m是错误的。 unsigned int m = 10;// Java 不支持无符号整型，这是错误的： C: C 语言支持无符号数据类型。 unsigned int m = 10;// C 支持无符号整型 2. 数组声明 Java: 与 C 语言不同，Java 不允许在声明数组时在方括号内指定数组的大小。例如，int a[12];在 Java 中是非法的。 int[] a;// Java 中不能在声明数组时指定大小a = new int[12]; // 正确的方式 C: C 语言允许在声明数组时在方括号内指定数组的大小。 int a[12];// C 中可以在声明数组时指定大小 3. 数组大小 Java: 与 C 语言不同，Java 允许使用int型变量来指定数组的大小。例如： int size = 10;double[] number = new double[size]; C: C 语言也允许使用int型变量来指定数组的大小，但必须在数组声明之前赋值。 int size = 10;double number[size]; // C99 及以上版本支持变长数组（VLA），在标准C中不支持 4. 不规则二维数组 Java: 与 C 语言不同，Java 允许二维数组的列数可不相同，即 Java 支持不规则的二维数组。 int[][] irregularArray = new int[3][];//这里没有定义列，这在Java中可行irregularArray[0] = new int[2];irregularArray[1] = new int[3];irregularArray[2] = new int[4]; C: C 语言的二维数组要求所有行的列数相同，不支持不规则的二维数组。 int regularArray[3][4]; // C 中的二维数组要求所有行的列数相同 这些示例展示了 Java 和 C 语言在无符号数据类型、数组声明和使用方面的主要区别。 面向对象 3.1 面向对象的思想 面向对象编程（OOP）包括三大特征： 1. 封装 解释: 封装是将对象的状态（属性）和行为（方法）结合在一起，并隐藏对象的内部实现细节，只暴露必要的接口。这种特性提高了代码的可维护性和安全性。 示例: public class Person private String name; // 私有属性，外部不可直接访问 public String getName() // 公有方法，用于访问私有属性 return name; public void setName(String name) // 公有方法，用于修改私有属性 this.name = name; 2. 继承 解释: 继承是创建新类时可以基于已有类的定义，继承其属性和方法，从而实现代码重用和扩展。子类可以增加新的属性和方法，也可以重写父类的方法。 示例: public class Animal public void eat() System.out.println(This animal eats food.); public class Dog extends Animal public void bark() System.out.println(The dog barks.); 3. 多态 解释: 多态是指同一接口可以有不同的实现方式。多态分为编译时多态（方法重载）和运行时多态（方法重写）。多态使得程序在处理不同对象时具有灵活性。 示例: public class Animal public void sound() System.out.println(动物发出叫声.); public class Dog extends Animal @Override public void sound() System.out.println(狗吠); public class Cat extends Animal @Override public void sound() System.out.println(猫“喵”); public class Main public static void main(String[] args) Animal myDog = new Dog(); Animal myCat = new Cat(); myDog.sound(); // 输出：狗吠 myCat.sound(); // 输出：猫“喵” 3.2.4 访问控制 Java 提供的四种访问控制权限如下： 访问控制修饰符 本类 同包 不同包子类 任意位置 public（公共） 可以 可以 可以 可以 protected（受保护） 可以 可以 可以 不行 default（默认） 可以 可以 不行 不行 private（私有的） 可以 不行 不行 不行 范围从大到小排序：public protected default private 3.3 封装性 封装的代码实现两步 第一步：属性私有化 第二步：为每个属性提供两个方法：set 方法和 get 方法 外部程序只能通过 set 方法修改属性值，只能通过 get 方法读取属性值。 可以在 set 方法中设立检查机制来保证数据的安全性。 重要说明 set 方法和 get 方法都是实例方法，不能带static。 不带static的方法称为实例方法，调用实例方法必须先创建对象（使用new关键字）。 3.4 构造方法 什么是构造方法，有什么用？ 构造方法是一个比较特殊的方法，用于完成对象的创建以及实例变量的初始化。换句话说，构造方法是用来创建对象并且同时给对象的属性赋值。 当一个类没有提供任何构造方法时，系统会默认提供一个无参数的构造方法，这个方法不会显示出来，但他存在。 构造方法的调用 使用**new**运算符来调用构造方法。 注意： 构造方法名和类名必须一致。 构造方法不能（也不需要）指定返回值类型，只能返回 0（return 0）作为函数结束标志； 构造方法的重载 和普通方法一样，方法输入参数不同即可 3.5 this关键字 3.5.1. 什么是this关键字？ this是一个引用，指向当前对象。 在类的方法和构造方法中，this指向调用该方法的对象。 3.5.2. this关键字的用途 用于区分实例变量和局部变量 当实例变量和局部变量同名时，使用this来区分它们。 public class Person private String name; public void setName(String name) this.name = name; // this.name指的是实例变量，name指的是参数 用于调用类的其他构造方法 在一个构造方法中调用另一个构造方法，可以避免重复代码。 调用时必须是方法中的第一句。 public class Person private String name; private int age; public Person() this(Unknown, 0); // 调用另一个构造方法，且在方法的第一句 public Person(String name, int age) this.name = name; this.age = age; 返回当前对象 方法可以通过返回this来实现方法链。 public class Person private String name; public Person setName(String name) this.name = name; return this; // 返回当前对象 public void printName() System.out.println(this.name); // 使用方法Person person = new Person();person.setName(John).printName(); 3.5.3 注意事项 this不能在静态方法中使用，因为静态方法属于类，不属于对象。 this只能在实例方法和构造方法中使用。 4.1 类的继承 4.1.1 什么是继承？ 继承是一种面向对象编程的特性，允许子类继承父类的属性和方法。 继承使得代码可以重用，子类可以扩展和修改父类的行为。 继承的限制 Java 只支持单继承，即一个类只能继承一个直接父类。 但是，一个类可以实现多个接口，这被称为多实现。 继承的优点 提高代码的复用性，可维护性。 提供了多态的实现基础。 继承的语法： 使用extends关键字来实现继承。 public class ParentClass // 父类的属性和方法public class ChildClass extends ParentClass // 子类的属性和方法 继承的特点 子类拥有父类的属性和方法 子类可以直接使用父类的属性和方法。 public class Animal public void eat() System.out.println(This animal eats food.); public class Dog extends Animal public void bark() System.out.println(The dog barks.); public class Main public static void main(String[] args) Dog dog = new Dog(); dog.eat(); // 调用父类的方法 dog.bark(); // 调用子类的方法 4.1.2 方法重写（Override） 子类可以重写父类的方法，以提供特定的实现。重写的方法必须具有相同的方法签名（方法名、参数列表和返回类型）。 使用@Override注解来标识重写的方法。 public class Animal public void makeSound() System.out.println(Some generic animal sound.); public class Dog extends Animal @Override public void makeSound() System.out.println(The dog barks.); 4.1.3 使用super关键字 super关键字用于访问父类的属性和方法，特别是在子类重写了父类的方法时。 super也可以用来调用父类的构造方法。 public class Animal public void makeSound() System.out.println(一些动物在叫。); public class Dog extends Animal @Override public void makeSound() super.makeSound(); // 调用父类的方法 System.out.println(狗在叫。); public class Main public static void main(String[] args) Dog dog = new Dog(); dog.makeSound(); super和this的区别 特点 super this 指向什么 指向父类的成员或构造方法 指向当前对象的成员或构造方法，没有就找父类 使用范围 在子类中使用 在类的任何地方使用 调用构造 调用父类的构造方法，必须放在子类构造方法首行 调用本类的构造方法，必须放在构造方法首行 总结：super主要用于访问父类的成员和调用父类的构造方法，而this用于访问当前对象的成员和调用自身的构造方法。 4.2 final 关键字 类用 final 关键字修饰后，该类不可被继承(不能有子类) 4.3 抽象类和接口 注意事项 抽象类和接口都是用于实现类的多态性，提供了规范和约束。 抽象类适用于具有共同特征的类之间的继承关系，而接口适用于不同类之间的共性行为和规范定义。 在 Java 中，抽象类和接口都是用来实现抽象化的工具，但它们有不同的用途和特点。 下面通过一个例子来展示它们的区别。 抽象类 抽象类可以包含抽象方法（没有方法体的方法）和具体方法（有方法体的方法）。抽象类不能被实例化，只能被继承。 abstract class Animal public abstract void makeSound();// 抽象方法 public void sleep() // 具体方法 System.out.println(动物在睡觉); class Dog extends Animal // 继承并实现实现抽象方法 public void makeSound() System.out.println(Woof); 接口 接口只能包含抽象方法~~（Java 8 及以后的版本中可以包含默认方法和静态方法）~~。接口中的方法默认是 public 和 abstract，可以被多个类实现。 interface Animal void makeSound();//不用再写abstractclass Dog implements Animal// 实现接口中的方法 public void makeSound() System.out.println(汪); 区别总结 抽象类可以有构造方法、成员变量和具体方法，而接口不能有实例变量~~（Java 8 及以后可以有静态变量）~~。 一个类只能继承一个抽象类，但可以实现多个接口。 抽象类适用于共享代码的情况，而接口适用于定义一组方法，让不同类实现。 案例 4-5 图形的面积与周长计算程序 4.4 多态 什么是多态： 多态指的是同一个方法在不同对象上具有不同的表现形式，可以实现不同对象的同名方法的多种不同行为。 例如子类重载或重写父类的方法 向上转型和向下转型的概念： 向上转型（upcasting）：子类对象可以自动转换为父类类型。 示例：Animal a = new Cat(); 向下转型（downcasting）：父类对象需要强制转换为子类类型。 示例：Cat c = (Cat)a;，需要添加强制类型转换符。 向下转型容易出现ClassCastException（类型转换异常）。 如何避免这个风险？ 可以使用instanceof运算符，在程序运行阶段动态判断某个引用指向的对象是否为某一种类型。 示例： Animal a = new Cat();if (a instanceof Cat) Cat c = (Cat) a; // 调用 Cat 类的特有方法 4.7 异常 4.7.1 什么是异常 异常是指程序在运行过程中遇到的不正常情况，可能导致程序无法继续执行的问题。 Java 中的异常是以对象的形式存在的，它们都是 Throwable 类或其子类的实例。 4.7.2 try…catch 和 finally try…catch 块：用于捕获可能引发异常的代码块，捕获到异常后进行相应的处理。 try // 可能引发异常的代码 catch (ExceptionType1 e1) // 处理异常类型1的代码 catch (ExceptionType2 e2) // 处理异常类型2的代码 finally // 无论是否发生异常，都会执行的代码块 finally 块：用于在不管是否发生异常的情况下都执行的代码块，通常用于释放资源等操作。 4.7.3 throws 关键字 throws关键字用于在方法声明中标识该方法可能会抛出的异常，表示该方法不处理异常，而是将异常抛给调用者处理。 public void doSomething() throws SomeException // 可能抛出 SomeException 的代码 Java API 5.1 字符串类 字符串类在 Java 中非常重要，用于表示和操作字符串数据。常用的字符串类是String类，它提供了丰富的方法用于字符串的操作，例如拼接、截取、替换等。 String str = Hello, World!;System.out.println(str.length()); // 输出：13System.out.println(str.substring(7)); // 输出：World!System.out.println(str.replace(Hello, Hi)); // 输出：Hi, World! 案例 5-3 模拟用户注册 5.3 Math 和 Random 类 Math 类 Math类包含了各种数学运算的静态方法，例如取整、取绝对值、计算平方根、求最大最小值等。 int num1 = 10;int num2 = -5;System.out.println(Math.abs(num2)); // 输出：5System.out.println(Math.max(num1, num2)); // 输出：10System.out.println(Math.sqrt(num1)); // 输出：3.1622776601683795 Random 类 Random类用于生成随机数，可以生成不同范围的整数或浮点数随机数。 Random random = new Random();int randomInt = random.nextInt(100); // 生成0到99之间的随机整数double randomDouble = random.nextDouble(); // 生成0.0到1.0之间的随机浮点数System.out.println(randomInt);System.out.println(randomDouble); 5.4 日期和时间类 日期和时间类用于表示和操作日期、时间和时间戳。Java 中常用的日期和时间类有Date类、Calendar类和SimpleDateFormat类。 Date date = new Date(); // 创建当前日期时间对象System.out.println(date);Calendar calendar = Calendar.getInstance(); // 获取当前日期时间的 Calendar 对象int year = calendar.get(Calendar.YEAR);int month = calendar.get(Calendar.MONTH) + 1; // 注意月份从0开始计算，所以要加1int day = calendar.get(Calendar.DAY_OF_MONTH);System.out.println(year + - + month + - + day);SimpleDateFormat sdf = new SimpleDateFormat(yyyy-MM-dd HH:mm:ss); // 定义日期时间格式化对象String formattedDate = sdf.format(date); // 格式化日期时间对象System.out.println(formattedDate); 集合 6.1 集合简述 Java 集合框架提供了一组用于存储和操作数据的类和接口。集合可以动态地存储、检索和操作对象。集合框架主要包含以下接口：List、Set、Queue和Map，每个接口有不同的实现类。 6.3 List 集合 List接口表示一个有序的集合，允许存储重复的元素。常用的List实现类有ArrayList、LinkedList和Vector。 6.3.2 ArrayList 集合 ArrayList是List接口的实现类，使用动态数组来存储元素。它提供了快速的随机访问时间，但在插入和删除元素时性能较低。 ArrayListString arrayList = new ArrayList();arrayList.add(Apple);arrayList.add(Banana);arrayList.add(Cherry);System.out.println(arrayList); // 输出：[Apple, Banana, Cherry]arrayList.remove(Banana);System.out.println(arrayList); // 输出：[Apple, Cherry]String fruit = arrayList.get(1);System.out.println(fruit); // 输出：Cherry 6.3.4 Iterator 接口 Iterator接口用于遍历集合中的元素。它提供了hasNext()、next()和remove()方法。 ListString list = new ArrayList();list.add(狗);list.add(猫);list.add(兔);IteratorString iterator = list.iterator();while (iterator.hasNext()) String animal = iterator.next(); System.out.println(animal); if (猫.equals(animal)) iterator.remove(); // 从集合中删除当前元素 System.out.println(list); // 输出：[狗, 兔] 6.4 Set 接口 Set接口表示一个不包含重复元素的集合。常用的Set实现类有HashSet、LinkedHashSet和TreeSet。 SetString set = new HashSet();set.add(1);set.add(2);set.add(3);set.add(2); // 重复元素不会被添加System.out.println(set); // 输出：[1, 2, 3]for (String number : set) System.out.println(number); Java 集合框架提供了丰富的数据结构和操作方法，使得数据的存储和处理变得更加灵活和高效。 I/O 流式传输 7.2 字节流 字节流是以字节为单位进行数据读写的流，常用于处理二进制数据或者文本文件。Java 中的字节流主要包括 InputStream 和 OutputStream 两个抽象类，以及它们的具体实现类如 FileInputStream、FileOutputStream 等。 字节流的使用示例 import java.io.*;public class ByteStreamExample public static void main(String[] args) String data = Hello, 牢大!; // 写入数据到文件（输出流） try (FileOutputStream fos = new FileOutputStream(example.txt)) fos.write(data.getBytes()); System.out.println(输出流输出内容到文件里); catch (IOException e) e.printStackTrace(); // 从文件读取数据（输入流） try (FileInputStream fis = new FileInputStream(example.txt)) int byteData; System.out.print(从文件输入到程序的内容是: ); while ((byteData = fis.read()) != -1) System.out.print((char) byteData); catch (IOException e) e.printStackTrace(); 7.3 字符流 字符流是以字符为单位进行数据读写的流，常用于处理文本文件。Java 中的字符流主要包括 Reader 和 Writer 两个抽象类，以及它们的具体实现类如 FileReader、FileWriter 等。 字符流的使用示例 import java.io.*;public class CharStreamExample public static void main(String[] args) String data = Hello, 坤坤!; // 写入数据到文件（输出流） try (FileWriter fw = new FileWriter(example.txt)) fw.write(data); System.out.println(输出流输出内容到文件里); catch (IOException e) e.printStackTrace(); // 从文件读取数据（输入流） try (FileReader fr = new FileReader(example.txt)) int charData; System.out.print(从文件输入到程序的内容是: ); while ((charData = fr.read()) != -1) System.out.print((char) charData); catch (IOException e) e.printStackTrace(); 字节流适用于处理二进制数据或者文本文件，而字符流适用于处理文本文件，可以更方便地处理字符编码和字符集。 多线程 8.2 线程的创建 在 Java 中，线程的创建有两种方式：继承 Thread 类和实现 Runnable 接口。 8.2.1 继承 Thread 类 继承 Thread 类是创建线程的一种方式，需要重写 Thread 类的 run()方法来定义线程的执行逻辑。 示例 class MyThread1 extends Thread private int breakfast = 10; private String name; public MyThread1(String name) this.name = name; public void run() for (int i = 0; i 500; i++) if (this.breakfast 0) System.out.println(this.name + 卖早餐---- + (this.breakfast--)); public static void main(String[] args) MyThread1 mt1 = new MyThread1(一号窗口); MyThread1 mt2 = new MyThread1(二号窗口); MyThread1 mt3 = new MyThread1(三号窗口); mt1.start(); mt2.start(); mt3.start(); 8.2.2 实现 Runnable 接口创建多线程 另一种创建线程的方式是实现 Runnable 接口，然后将实现了 Runnable 接口的类传递给 Thread 类的构造方法。 示例 class MyThread2 implements Runnable private int breakfast = 10; private String name; public void run() for (int i = 0; i 500; i++) if (this.breakfast 0) System.out.println(Thread.currentThread().getName() + 卖早餐---- + (this.breakfast--)); public static void main(String[] args) // 设计三个线程 MyThread2 mt = new MyThread2(); Thread t1 = new Thread(mt, 一号窗口); Thread t2 = new Thread(mt, 二号窗口); Thread t3 = new Thread(mt, 三号窗口); t1.start(); t2.start(); t3.start(); 通过实现 Runnable 接口，可以更灵活地管理线程的生命周期和资源，并且可以避免 Java 单继承的限制。在实际开发中，通常推荐使用实现 Runnable 接口的方式来创建多线程，因为它更符合面向对象的设计原则。 继承 Thread 类 | Runnable 接口 两者实现多线程的区别 第一个继承 Thread 类来实现多线程，其实是相当于拿出三件事即三个卖早餐 10 份的任务分别分给三个窗口，他们各做各的事各卖各的早餐各完成各的任务，因为 MyThread 继承 Thread 类，所以在 newMyThread 的时候在创建三个对象的同时创建了三个线程； 而实现 Runnable， 相当于是拿出一个卖早餐 10 份的任务给三个人去共同完成，newMyThread 相当于创建一个任务，然后实例化三个 Thread，创建三个线程即安排三个窗口去执行。 **一个类只能继承一个父类，存在局限；一个类可以实现多个接口。**在实现 Runnable 接口的时候调用 Thread 的 Thread(Runnable run)或者 Thread(Runnablerun,String name)构造方法创建进程时，使用同一个 Runnable 实例，建立的多线程的实例变量也是共享的；但是通过继承 Thread 类是不能用一个实例建立多个线程，故而实现 Runnable 接口适合于资源共享；当然，继承 Thread 类也能够共享变量，能共享 Thread 类的 static 变量； 其实，抽象来说，这并不是 Thread 类和 Runnable 接口的区别了，这可以看做是接口和继承的问题。我们弄懂了接口和继承，就不难理解 Thread 和 Runnable。 在刚接触的时候可能会有些迷糊这二者的区别于联系，但是实践和总结过后我们会发现这是两个完全不同的实现多线程，一个是多个线程分别完成自己的任务，一个是多个线程共同完成一个任务。其实，在实现一个任务用多个线程来做也可以用继承 Thread 类来实现，只是比较麻烦，一般我们用实现 Runnable 接口来实现。 连接数据库 10.3 实现 JDBC 程序 import java.sql.*;public class JDBCTutorial public static void main(String[] args) // Step 1: 导入JDBC相关的包 // Step 2: 加载数据库驱动 try Class.forName(com.mysql.cj.jdbc.Driver);//6.0.2版本之前的数据库需要删除“.cj”字样 catch (ClassNotFoundException e) System.err.println(驱动加载失败!); e.printStackTrace(); return; // Step 3: 建立数据库连接 Connection connection = null; try String url = jdbc:mysql://localhost:3306/mydatabase; String user = username; String password = password; connection = DriverManager.getConnection(url, user, password); catch (SQLException e) System.err.println(连接数据库失败!); e.printStackTrace(); return; // Step 4: 创建Statement对象 Statement statement = null; try statement = connection.createStatement(); catch (SQLException e) System.err.println(创建statement对象失败!); e.printStackTrace(); try if (connection != null) connection.close(); catch (SQLException ex) ex.printStackTrace(); return; // Step 5: 执行SQL语句 String sqlQuery = SELECT * FROM users; ResultSet resultSet = null; try resultSet = statement.executeQuery(sqlQuery); catch (SQLException e) System.err.println(数据请求失败!); e.printStackTrace(); try if (statement != null) statement.close(); if (connection != null) connection.close(); catch (SQLException ex) ex.printStackTrace(); return; // Step 6: 处理查询结果 try while (resultSet.next()) String username = resultSet.getString(username); int age = resultSet.getInt(age); System.out.println(Username: + username + , Age: + age); catch (SQLException e) System.err.println(数据处理失败!); e.printStackTrace(); finally // Step 7: 关闭资源 try if (resultSet != null) resultSet.close(); if (statement != null) statement.close(); if (connection != null) connection.close(); catch (SQLException e) System.err.println(关闭资源失败!); e.printStackTrace();","tags":[null],"categories":[null]},{"title":"操作系统入门","path":"/data/notebooks/操作系统入门.html","content":"操作系统 1.1_1 操作系统的概念、功能和目标 作为用户和计算机硬件之间的接口 提供的功能 命令接口（联机命令接口|脱机命令接口） 程序接口 GUI（图形用户界面 win|ios|andrio） 目标 方便用户使用 1.1_2 操作系统的特征 并发|并行 并发：多个事件交替发生（宏观同时发生、微观交替进行） 并行：多个事件同时发生 共享 两种资源共享方式: 互斥共享方式：一个时间段内只允许一个进程访问该资源 同时共享方式：允许一个时间段内由多个进程“同时”对它们进行访问 虚拟 概念：把一个物理上的实体变为若干个逻辑上的对应物 空分复用计数 时分复用计数 异步 概念：在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停的，以不可预知的速度向前推进。只有系统拥有并发性，才有可能导致异步性。 1.1_3 操作系统的发展与分类 OS 的发展与分类 手工操作阶段 纸带机（用户独占全机、人机速度矛盾） 批处理阶段——dan’dao 单道批处理系统（外围机——磁带） 多道批处理系统（操作系统开始出现） 分时操作系统 轮流处理作业 不能处理紧急任务 实时操作系统 优先处理紧急任务 硬实时系统：必须在严格的时间内完成处理 软实时系统：可以偶尔犯错 网络操作系统 分布式操作系统 个人计算机操作系统 1.1_4 操作系统的运行机制与体系结构 OS 的运行机制和体系结构 运行机制： 两种指令 特权指令 非特权指令 两种处理器状态 核心态（root） 用户态 两种程序 内核程序(运行在核心态 ) 应用程序 操作系统内核 时钟管理（实现计时功能） 中断处理 原语（程序运行具有原子性，不可中断） 对系统资源进行管理的功能 进程管理 存储器管理 设备管理 操作系统的体系结构 大内核（将操作系统的主要功能模块都作为系统内核，运行在核心态） 微内核（只把最基本的功能保留在内核） 1.1_5 中断和异常 中断机制的诞生 操作系统介入，开展管理工作 “用户态—核心态”是通过中断实现的。并且中断是唯一途径 中断的概念和作用 中断的分类 内中断（异常） 陷阱（trap） 故障（fault） 中止（abort） 外中断 （CPU 外部） 外中断的处理过程 1.1_6 系统调用 概念：应用程序通过系统调用请求操作系统的服务。保证系统的稳定性和安全性。 系统调用和库函数的区别： 系统调用是操作系统向上层提供的接口 有的库函数是对系统调用的进一步封装 当今编写的应用程序大多是通过高级语言提供的库函数间接地进行系统调用 2.1_1 进程的定义、组成、组织方式、特征 定义：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。（就是一个指令序列） 组成：PCB（进程存在唯一的标志），程序段，数据段 组织方式：链接方式，指针指向不同的队列；索引方式，索引表 特征：动态性、并发性、独立性、异步性、结构性 2.1_2 进程的状态与转换 状态： 运行状态：占有 CPU，并在 CPU 上运行，单核只能一个进程（双核两个）（CPU√，其它资源 √） 就绪状态：已经具备运行条件，但是没有空闲的 CPU，暂时不能运行（CPUX，其它资源 √） 阻塞状态：等在某个事件的发生，暂时不能运行（CPUX，其它资源 X） 创建状态：创建 PCB，程序段，数据段 终止状态：回收内存，程序段，数据段，撤销 PCB 进程状态间的转换： stateDiagram-v2 state 创建态 { [*] --> 就绪态 } 就绪态 --> 运行态 运行态 --> 就绪态 运行态 --> 中止态: 数组越界 运行态 --> 阻塞态: 主动 阻塞态 --> 就绪态: 被动 2.1_3 进程控制 基本概念： 什么是进程控制？ 答：实现各种进程状态转换。 如何实现进程控制？ 答：用“原语”实现。 原语做的事情： 1、更新 PCD 中的信息 2、将 PCD 插入合适的队列 3、分配/回收资源 进程控制相关的原语： 1、进程的创建： 创建原语：申请空白 PCB、为新进程分配所需资源、初始化 PCB、将 PCB 插入就绪队列 引起进程创建的事件：用户登录、作业调度、提供服务、应用请求 2、进程的终止： 撤销原语 引起进程中止的事件：正常结束、异常结束、外界干预 3、进程的阻塞： 阻塞原语：运行态-阻塞态 引起进程阻塞的事件：需要等待系统分配某种资源、需要等待相互合作的其他进程完成工作 4、进程的唤醒： 唤醒原语：阻塞态-就绪态 引起进程唤醒的事件：等待的事件发生 5、进程的切换 切换原语 引起进程切换的事件：当前进程事件片到、有更高优先级的进程到达、当前进程主动阻塞、当前进程终止 2.1_4 进程通信 1、共享存储 （分配共享空间，且互斥（P、V 操作） 基于数据结构的共享：固定分配（低级） 基于存储区的共享：划分存储区（高级） 2、消息传递 消息：消息头、消息体 直接通信方式（直接挂载消息） 间接通信方式（间接利用信箱发送消息） 3、管道通信（pipe） 只能半双工通信 互斥（没写满，不能读，反之同理） 2.1_5 线程概念和多线程模型 什么是线程，为什么要引入线程？ 答：线程是一个基本的 CPU 执行单元，也是程序执行流的最小单位，进一步提高了系统的并发度 引入线程机制后，有什么变化？ 资源分配、调度：进程是资源分配的基本单位，线程是调度的基本单位 并发性：各线程间也能并发，提升了并发度 系统开销：可以只在进程中切换，减小了 CPU 切换环境的系统开销 1、线程有哪些重要的属性 线程是处理机调度的基本单位 多 CPU 计算机中，各个线程可占用不同的 CPU 每个线程都有一个线程 ID、线程控制块（TCB） 线程也有就绪、阻塞、运行三种基本状态 线程几乎不拥有系统资源 同一进程的不同线程间共享进程的资源 由于共享内存地址空间，统一进程中的线程间通信甚至无需系统干预 同一进程中的线程切换，不会引起进程切换 不同进程中的线程切换，会引起进程切换 切换同进程内的线程，系统开销很小 切换进程，系统开销较大 2、线程的实现方式 用户级线程（ULT）： 由应用管理，从用户的视角看能看到的线程 内核级线程（KLT）： 由操作系统管理，从操作系统内核视角看能看到的线程 n 个 ULT 可以映射到 m 个 KLT 上（n=m） 内核级线程才是处理机分配的单位 3、多线程模型 多对一模型 n 个 ULT 映射到 1 个 KLT 优点：开销小，效率高 缺点：容易阻塞，并发度不高 一对一模型 n 个 ULT 映射到 n 个 KLT 优点：并发能力很强 缺点：占用成本高，开销大 多对多模型 n 个 ULT 映射到 m 个 KLT 上（n=m） 中和以上两种优缺点 2.2_1 处理机调度的概念、层次 基本概念 通常进程数量大于处理机数量，所以要按照一定的算法选择一个进程，并将处理机分配给它运行，以实现进程的并发执行 三个层次 高级调度（作业调度） 辅助外存与内存之间的调度，作业调入时会建立相应的 PCB，作业调出时才撤销 PCB，调入可由操作系统决定，调出由作业运行结束才调出 中级调度（内存调度） 将暂时不用的进程放到外存（PCB 不外放），提高内存利用率和系统吞吐量，进程状态为挂起状态，形成挂起队列 低级调度（进程调度） 最基本，用算法为进程分配处理机资源，几十 ms 一次 三层调度的联系、对比 进程的“挂起态” 七状态模型 stateDiagram-v2 [*] --> 创建态 创建态 --> 就绪态 就绪态 --> 运行态 运行态 --> 就绪态 运行态 --> 阻塞态: 等待事件 运行态 --> 中止态: 正常结束/异常 阻塞态 --> 就绪态: 事件发生 创建态 --> 中止态: 创建失败 创建态 --> 就绪态: 创建成功 运行态 --> 挂起态: 主动挂起 挂起态 --> 运行态: 恢复运行 挂起态 --> 阻塞挂起态: 等待事件 阻塞态 --> 阻塞挂起态: 主动挂起 阻塞挂起态 --> 挂起态: 事件发生 挂起态 --> 就绪态: 恢复就绪 五状态模型前面学了，挂起分为就绪挂起、阻塞挂起 2.2_2 进程调度的时机、切换与过程调度方式 1、时机 什么时候需要进程调度？ 主动放弃（进程正常终止、运行过程中发生异常而终止、进程主动请求阻塞） 被动放弃（分给进程的时间片用完、有更紧急的事需要处理、有更高优先级的进程进入就绪队列） 什么时候不能进行进程调度？ 在处理中断的过程中 在操作系统内核程序临界区中 临界资源：一个时段段内各进程互斥地访问临界资源 临界区：访问临界资源的那段代码 内核程序临界区会访问就绪队列，导致其上锁 在原子操作过程中（原语） 2、切换与过程 “狭义的调度”与“进程切换”的区别 狭义：选择一个进程 广义：狭义+进程切换 进程切换的过程需要做什么？ 对原来运行进程各种数据的保存 对新的进程各种数据的恢复 3、方式 非剥夺调度方式（非抢占式） 只允许进程主动放弃处理机 剥夺调度方式（抢占式） 进程被动放弃，可以优先处理紧急任务，适合分时操作系统、实时操作系统 2.2_3 调度算法的评价指标 1、CPU 利用率 ​ CPU 利用率=CPU 忙碌的时间/总时间 2、系统吞吐量 ​ =总共完成了多少道作业/总共画了多少时间 3、周转时间 周转时间（提交作业到完成作业花费的时间）、平均周转时间（各作业周转时间之和/作业数） 带权周转时间（作业周转时间/作业实际运行的时间）、平均带权周转时间（各作业带权周转时间/作业数） 4、等待时间 进程或作业等待处理机状态时间的和 进程：等待被服务的时间之和 作业：建立后的等待时间+作业在外存后备队列中等待的时间 5、响应时间 从用户提交请求到首次产生响应所用的时间 2.2_4 FCFS、SJF、HRRN 调度算法 1、先来先服务（FCFS） 先到达先进行服务 作业-后备队列；进程-就绪队列 非抢占式 公平、算法简单 对长作业有利、对短作业不利、不会饥饿 2、短作业优先（SJF，shortest job first） 最短（服务时间最短）的作业优先得到服务，时间相同，先到达的先被服务 非抢占式（SJF）：选最短需要时间的作业先进入运行态 抢占式（SRTN）：有新作业进入就绪队列或有作业完成了，考察队列中的最小需要时间的作业 在所有进程都几乎同时到达时，采用 SJP 调度算法的平均等待时间、平均周转时间最少 若无红色前提，抢占式的短作业/进程的平均时间最少 优点：“最短的”平均等待时间，平均周转时间 缺点：对短作业有利，对长作业不利，可能产生饥饿现象 3、高响应比优先（HRRN） 要综合考虑作业/进程的等待时间和要求服务的时间 在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务 响应比=（等待时间+要求服务时间）/要求服务时间 非抢占式 进程主动放弃 CPU 时，需要该算法选取就绪队列的作业 不会饥饿 2.2_5 时间片轮转、优先级调度、多级反馈队列（适合交互式系统） 1、时间片轮转算法（RR） 算法思想：公平轮流地位各个进程服务，让每个进程在一定时间间隔内都可以得到响应 算法规则：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如 100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列对位重新排队。 只能用于进程调度 抢占式 优点：响应块，适用于分时操作系统 缺点：由于高频率的进程切换，因此有一定的开销；不区分任务的紧急程度 不会饥饿 2、优先级调度算法 算法思想：根据任务的紧急程度来决定处理顺序 算法规则：每个进程/作业有各自的优先级，调度时选择优先级最高的作业/进程 适用：作业/进程/IO 抢占式/不可抢占均有 静态优先级：不变 动态优先级：可以变 通常：系统进程优先级高于用户进程，前台进程优先级高于后台进程，操作系统更偏好 I/O 进程 可以从追求公平、提升资源利用率等角度考虑改变优先级 可能会饥饿 3、多级反馈队列调度算法 算法思想：对其它算法调度的这种权衡 算法实现：设置多级就绪队列，各级队列优先级从高到低，时间片从小到大。新进程到达时先进入第一级队列，按照 FCFS 原则排队等待被分配时间片。若用完时间片进程还未结束，则进程进入下一级队列对位。如果此时已经在最下级的队列，则重新放回最下级队列末尾。啊只有第 K 级队头的进程为空时，才会为 K+1 级对头的进程分配时间片，被抢占处理机的进程重新放回原队列队尾。 优点：对各个进程相对公平（FCFS 的优点），每个新到达的进程都可以很快就得到响应（RR 的优点）；短进程只用较少的时间就可以完成（SPF 的优点）；不必实现估计进程的运行时间（避免用户作假）；可灵活地调整对各类进程的偏好程度，比如 CPU 密集型进程、IO 密集型进程 默认抢占式 会饥饿 2.3_1 进程同步、进程互斥 1、进程同步 ​ 指为了完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调他们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。 2、进程互斥 ​ 把一个时间段内只允许一个进程使用的资源称为临界资源。 ​ 对临界资源的互斥访问，可以在逻辑上分为四个部分： do entry section; //进入区 对访问的资源检查或进行上锁 critical section; //临界区(段) 访问临界资源的那部分代码 exit section; //退出区 负责解锁 remainder section; //剩余区 其它处理 while(true) 1、空闲让进。 空的可以直接进去 2、忙则等待。 繁忙不能进去 3、有限等待。 不能让进程等待无限长时间 4、让权等待。 不能进去，不要堵着 2.3_2 进程互斥的软件实现方法 1、单标志法 两个进程在访问完临界区后会把使用临界区的权限教给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予 int turn =0;//p0进程while(turn!=0);critical section;turn = 1;remainder section;//p1进程while(turn!=1);critical section;turn = 0;remainder section; 可以实现互斥 存在的问题：p1 要访问的话，必须 p0 先访问，违背：空闲让进原则 2、双标志先检查 算法思想:设置一个 bool 数组 flag[]来标记自己是否想要进入临界区的意愿 bool flag[2]=false,false;//p1进程while(flag[1]);flag[0]=true;critical section;flag[0]=false;remainder section;//p2进程while(flag[0]);flag[0]=true;critical section;flag[1]=false;remainder section; 主要问题：由于进程是并发进行的，可能会违背忙则等待的原则 3、双标志后检查 算法思想:设置一个 bool 数组 flag[]来标记自己是否想要进入临界区的意愿,不过是先上锁后检查 bool flag[2]=false,false;//p1进程flag[0]=true;while(flag[1]);critical section;flag[0]=false;remainder section;//p2进程flag[0]=true;while(flag[0]);critical section;flag[1]=false;remainder section; 主要问题：由于进程是并发进行的，可能会两个同时上锁，都进不去，违反空闲让进和有限等待原则 会饥饿 4、Peterson 算法 主动让对方先使用处理器 bool flag[2]=false,false;int turn=0;//p1进程flag[0]=true;turn=1;while(flag[1]turn==1);critical section;flag[0]=false;remainder section;//p2进程flag[1]=true;turn=0;while(flag[0]turn==0);critical section;flag[1]=false;remainder section; 遵循空闲让进、忙则等待、有限等待三个原则 但是未遵循让权等待的原则 2.3_3 进程互斥的硬件实现方法 1、中断屏蔽方法 关中断（不允许进程中断） 临界区 开中断 优点：简单、高效 缺点：不适用于多处理机，可能有两个进程会同时访问临界资源 只适用 OS 内核进程 2、TestAndSet（TSL 指令） TSL 是用硬件实现的，上锁、检查一气呵成 不满足让权等待，会盲等 C 语言描述逻辑： //true表示已经上锁bool TestAndSet(bool *lock) bool old; old=*lock; *lock=true; return old; //以下是使用TSL指令实现互斥的算法逻辑while(TestAndSet (lock));//上锁并检查临界区代码段lock=false; //解锁 3、Swap 指令 别称：Exchange 指令、XCHG 指令 Swap 指令是用硬件实现的 //true表示已经上锁void Swap(bool *a,bool *b) bool temp; temp=*a; *a=*b; *b=temp; //以下是使用Swap指令实现互斥的算法逻辑bool old=true;while(old=true) Swap(lock,old);临界区代码段lock=false; //解锁//剩余代码段 简单 适用多处理机 不能让权等待 2.3_4 信号量机制 信号量： 信号量是一种变量，表示系统中某种资源的数量 一对原语：wait（S）原语和 signal（S）原语，分别简称 P（S）、V（S） 1、整形信号量 用一个整数表示系统资源的变量，用来表示系统中某种资源的数量 int S=1;void wait(int S) //wait原语，相当于：进入区 while(S=0); //如果资源数不够，就意志循环等待 S=S-1; //如果资源数够，则占用一个资源 void signal(int S)//signal原语，相当于“退出区” S=S+1; //使用完资源后，在退出区释放资源 可能会出现盲等 2、记录型信号量 记录型数据结构表示的信号量 //记录型信号量的定义typedef struct int value; struct process *L; semaphore;//某进程需要使用资源时，通过wait原语申请void wait (semaphore S) S.value--; if(S.value0) block (S.L);//将该进程加入到消息队列中 //进程使用完资源后，通过signal原语释放void signal (semaphore S) S.value++; if(S.valie=0) wakeup(S.L); 除非特别说明，否则默认 S 为记录型信号量 2.3_5 用信号量机制实现进程互斥、同步、前驱关系 1、实现进程互斥 设置互斥信号量 mutex，初值为 1 对不同的临界资源需要设置不同的互斥信号量 PV 必须成对出现 2、实现进程同步 保证一前一后的操作顺序 设置同步信号量 S，初始为 0 在“前操作”之后执行 V（S） 在“后操作”之后执行（V） 3、实现进程的前驱关系 要为每一对前驱关系各设置一个同步变量 在“前操作”之后对相应的同步变量执行 V 操作 在“后操作”之前对相应的同步变量执行 P 操作 2.3_6 生产者-消费者问题 （好像逻辑很幼稚 只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待 只有缓冲区不空时，消费者才能从中取出产品，否则必须等待 缓冲区是临界资源，各个进程互斥访问 实现互斥的 P 操作要放在实现同步的 P 操作之后，不然会发生死锁 V 操作不会导致进程发生阻塞的状态，所以可以交换 使用操作不要放在临界区，不然并发度会降低 2.3_7 多生产者-多消费者模型 在生产-消费者问题中，如果缓冲区大小为 1，那么有可能不需要设置互斥信号量就可以实现互斥访问缓冲区 分析同步问题是，应该从“事件”的角度来考虑 2.3_8 吸烟者问题 解决“可以让生产多个产品的单生产者”问题提供一个思路； 若一个生产者要生产多种产品（或者说会引发多种前驱事件），那么各个 V 操作应该放在各自对应的“事件”发生之后的位置 2.3_9 读者-写者问题 1、允许多个读者同时对文件执行读操作 2、只允许一个写者往文件中写信息 3、任一写者在完成写操作之前不允许其他读者或写者工作 4、写者执行写操作前，应让已有的读者和写者全部退出 semaphore rw=1;//用于实现对文件的互斥访问。表示当前是否有进程在访问共享文件int count=0;//记录当前有几个读进程在访问文件semaphore mutex=1;//用于保证对count变量的互斥访问semaphore w=1; //用于实现“写优先”writer() while(1) P（w）; P(rw); //写之前“加锁” 写文件。。。 V（rw);//写之后“解锁” V(w); ​reader() while(1) P(w); P(mutex); //各读进程互斥访问count if(count==0) P(rw); //第一个读进程的读进程数+1 count++; //访问文件的读进程数+1 V(mutex); V(w); 读文件... P(mutex); //各读进程互斥访问count count--; //访问文件的读进程数-1 if(count==0) V(rw); //最后一个读进程负责“解锁” V(mutex); 2.3_10 哲学家进餐问题 五个人，必须拿左右的筷子才能吃饭 避免死锁发生 解决方案： 1、可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐，这样可以保证至少有一个哲学家是可以拿到左右两只筷子的。 2、要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一只后再等待另一只的情况。 3、仅当一个哲学家左右两只筷子都可用时才允许他抓起筷子。 semaphore chopstick[5]=1,1,1,1,1;semaphore mutex = 1; //互斥地取筷子Pi() //i号哲学家的进程 while(1) P(mutex); p(chopstick[i]); //拿右 p(chopstick[(i+1)%5]);//拿左 V(mutex); 吃饭... V(chopstick[i]); V(chopstick[(i+1)%5]); 思考... 2.3_11 管程 1、为什么要引入管程 PV 操作容易出错、困难 2、管程的定义和基本特征 定义： 局部于管程的共享数据结构说明 对该数据结构进程操作的一组过程 对局部于管程的共享数据设置初始值的语句 管程有一个名字 基本特征： 局部于管程数据结构只能被局部于管程的过程所访问 一个进程只有通过调用管程内的过程才能进入管程访问共享数据 每次仅允许一个进程在管程内执行某个内部过程 心得：相当于 C++的类，管程是数据放在 private 中，函数放在 public 中 拓展 1：用管程解决生产者消费者问题 monitor producerconsumer condition full,empty; int count = 0; void insert(Item item) if(count == N) wait(full); count++; insert_item (item); if(count == 1) signal(empty); Item remove() if(count == 0) wait(empty); count--; if(count == N-1) signal(full); return remove_item(); end monitor;​//使用producer() while(1) item = 生产一个产品; producerconsumer.insert(item); ​consumer() while(1) item = producerconsumer.remove(); 消费产品 item; 拓展 2：Java 中类似于管程的机制 java 中用 synchronized 来描述一个函数,这个函数同一时间只能被一个线程调用 2.4_1 死锁的概念 1、什么是死锁 各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。 2、进程死锁、饥饿、死循环的区别 死锁： 定义：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。 区别：至少两个或两个的进程同时发生死锁 饥饿： 定义：由于长期得不到想要的资源，某进程无法向前推进的现象。 区别：可能只有一个进程发生饥饿 死循环： 定义：某进程执行过程中一直跳不出某个循环的现象。 区别：死循环是程序员的问题 3、死锁产生的必要条件 互斥条件：多个进程争夺资源发生死锁 不剥夺条件：进程获得的资源不能由其它进程强行抢夺 请求和保持条件：某个进程有了资源，还在请求资源 循环等待条件：存在资源的循环等待链 4、什么时候会发生死锁 对系统资源的竞争 进程推进顺序非法 信号量的使用不当也会造成死锁 5、死锁的处理策略 预防死锁 避免死锁 死锁的检测和解除 2.4_2 死锁的处理策略——预防死锁 1、不允许死锁发生 静态策略：预防死锁 破坏互斥条件（有些不能破坏） 把互斥的资源改造为共享资源 破坏不剥夺条件（复杂，造成之前工作失效，降低系统开销，会全部放弃、导致饥饿） 方案 1：当请求得不到满足的时候，立即释放手里的资源 方案 2：由系统介入，强行帮助剥夺 破坏请求和保持条件（资源利用率极低，可能会导致某些进程饥饿） 采用静态分配方法，一次性全部申请，如果申请不到，不要允许 破坏循环等待条件（不方便增加新的设备，实际使用与递增顺序不一致，会导致资源的浪费，必须按规定次序申请资源） 顺序资源分配法：对资源编号，进程按编号递增顺序请求资源 动态检测：避免死锁 2、允许死锁发生 死锁的检测和解除 2.4_3 死锁的处理策略——避免死锁 动态检测：避免死锁 什么是安全序列 进行后面的某些情况，不会使系统发生死锁 什么是系统的不安全状态，与死锁有何联系 如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就可能发生死锁（处于不安全状态未必就是发生了死锁，但发生死锁时一定时在不安全状态） 如何避免系统进入不安全状态——银行家算法 初始分配完成后，优先全部分配给最少的，并且拿回资源 ​ 步骤： ​ 1、检查此次申请是否超过了之前声明的最大需求数 ​ 2、检查此时系统剩余的可用资源是否还能满足这次请求 ​ 3、试探着分配，更改各数据结构 ​ 4、用安全性算法检查此次所分配是否会导致系统进入不安全状态 2.4_4 死锁的处理策略——检测和解除 死锁的检测 ​ 1、用某种数据结构来保存资源的请求和分配信息 ​ 2、提供一种算法，利用上述信息来检测系统是否已进入死锁状态 死锁的解除 ​ 1、资源剥夺法：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。 ​ 2、撤销进程法：强制撤销部分，甚至全部死锁进程，并剥夺这些进程的资源。 ​ 3、进程回退法：让一个或多个死锁进程回退到足以避免死锁的地步。 3.1_1 内存的基础知识 1、什么是内存 ​ 存储单元：每个地址对应一个存储单元 ​ 内存地址： 2、进程运行的基本原理 指令的工作原理： 逻辑地址 vs 物理地址：逻辑地址就是相对地址 从写程序到程序运行：编辑-编译-链接-装入 三种链接方式：静态链接（在程序运行前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件）、装入时动态链接（将各目标模块装入内存时，边装入边链接的链接方式）、运行时动态链接（在程序执行中需要该模块时，才对它进行链接，其优点时便于修改和更新。） 三种装入方式：绝对装入（在编译的时候就知道程序放在内存的哪个位置）、静态重定位（装入时将逻辑地址转表为物理地址）、动态重定位（把地址转化推迟到程序真正要执行时才进行） 3.1_2 内存管理的概念 1、内存空间的分配与回收 2、内存空间的扩充 ​ 内存的虚拟性 3、地址转换 ​ 逻辑地址和物理地址转换 4、存储保护 设置上下限寄存器 采用重定位寄存器（基址寄存器）和界地址寄存器（限长寄存器） 3.1_3 覆盖与交换 对内存空间的扩充 覆盖技术：将程序分为多个段，内存分为”固定区“和”覆盖区“，需要常驻的放在”固定区“，调入后就不再调出，不常用的段放在”覆盖区“，需要用到时调入内存，用不到时掉出内存 交换技术：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（PCB 会常驻内存，不会被患处） 虚拟存储技术： 3.1_4 连续分配管理方式 连续分配方式 单一连续分配：内存被分配为系统区和用户区，系统区在低地址，用户区是一个用户独享 固定分区分配：将用户区分割为若干固定分区给各道程序，分割策略有分区大小相等和分区大小不相等，可以建议一个分区说明表来管理各个分区 动态分区分配：可变分区分配，不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。 内部碎片：分配给某进程的内存区域中，如果有些部分没有用上 外部碎片：是指内存中的某些空闲分区由于太小而难以利用（如果有外部碎片，可以采用紧凑技术） 3.1_5 动态分区分配算法 1、首次适应算法（First Fit) ​ 算法思想：每次从低地址开始查找，找到第一个能满足大小的空闲分区 2、最佳适应算法(Best Fit) ​ 算法思想：为了保证“大进程”到来时能有连续的大片区域，可以尽可能留下大片的空闲区，优先使用更小的空闲区。 ​ 空闲分区按容量递增次序链接，分配内存时顺序查找空闲分区链 ​ 缺点：会留下小碎片 3、最坏适应算法(Worst Fit) ​ 算法思想：和最佳适应算法相反，按容量递减次序排列，每次尽可能用大的分区 4、领近适应算法(Next Fit) ​ 算法思想：每次从上次查找结束的位置开始检索 ​ 缺点：大空间容易被用完 3.1_6 基本分页存储管理的基本概念 允许一个进程分散地装入道许多不相邻的位置 连续分配：为用户进程分配连续的内存空间 非连续分配：为用户进程分配分散的内存空间 将内存分为大小相等的小分区“页框”，将用户的进程空间也分为大小相等的一个个区域，以页框的基本单位分配给每个进程片 分页管理：物理地址=页面的其实位置+偏移量 计算机中用 2 的整数倍表示页面的大小 页表：存放页号和块号的对应关系 3.1_7 基本地址变换机构 页表寄存器（PTR），存放页表在内存中的起始地址 F 和页表长度 M，进程未执行时，页表的起始地址和页表的长度放在进程控制块（PCB）中，当进程被调度时，操作系统内核会把它们放在页表寄存器中。 3.1_8 具有快表的地址变换机构 1、局部性原理 时间局部性：访问某个变量后，在不久的将来还会被访问 空间局部性：程序访问了某个存储单元，不久之后，其附近的存储单元也很有可能被访问 2、什么是快表（TLB） 快表：又称联想寄存器（TLB），是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。 与此对应，内存中的页表常称为慢表。 3、引入快表后，地址的变换过程 3.1_9 两级页表 1、单级页表存在什么问题？如何解决？ 所有页表项必须连续存放，页表过大时需要很大的连续空间 在一段时间内并非所有页面都用得到，因此没必要让整个页表常驻内存 2、两级页表的原理、逻辑地址结构 将长长的页表再分页 逻辑地址结构：（一级页号、二级页号、页内偏移量） 页目录表、外层页表、顶级页表 3、如何实现地址变换？ 按照地址结构将逻辑地址拆分成三部分 从 PCB 中读出页目录表始址，根据一级页号查页目录表，找到下一级页表在内存中的存放位置 根据二级页号查表，找到最终想访问的内存块号 结合页内偏移量得到物理地址 4、两级页表问题需要注意的几个细节 多级页表中，各级页表的大小不能超过一个页面。若两级页表不够，可以分更多级 多级页表的访问次数（假设没有快表结构）——N 级页表访问一个逻辑地址需要 N+1 次访存 3.1_10 基本分段存储管理方式 1、什么是分段？ 进程的地址空间：按照程序自身的逻辑关系划分为若干个段，每段有段名，每段从 0 开始编址 段号的位数决定了每个进程最多可以分几个段 段内地址位数决定了每个段的最大长度是多少 2、什么是段表 段表：段映射表 每个程序被分段后，用段表记录该程序在内存中存放的位置 段表：段号 段长 基址 3、如何实现地址变换 4、分段、分页管理的对比 页：信息的物理单位，实现离散分配，提高内存利用率，地址是一维的，访存两次 段：信息的逻辑单位，对系统可见，地址是二维的，访存 3 次 分段比分页更容易实现信息的共享和保护（不能被修改的代码称为纯代码和可重入代码，不属于临界资源） 3.1_11 段页式的管理方式 1、分页、分段管理方式最大的优缺点 分页：利用率高，碎片少，不方便进行信息共享和保护 分段：方便信息共享和保护，如果段长大，容易产生外部碎片 2、分段+分页的结合——段页式管理方式 先分段再分页 段号+页号+页内偏移量 地址结构是二维的 3、段表、页表 4、如何实现地址变换 3.2_1 虚拟内存的基本概念 1、传统存储管理方式的特征、缺点 之前讲的 一次性：作业必须全部装入内存后才能开始运行，并发性下降 驻留性：一旦作业被装入内存，就会一直驻留在内存 2、局部性原理 时间局部性 空间局部性 高速缓存技术 3、虚拟内存的定义和特征 虚拟内存最大容量是计算机地址结构确定的 虚拟内存的实际容量=min(内存和外存容量之和，CPU 寻址范围) eg：某计算机地址结构为 32 位，按字节编址，内存大小为 512MB，外存大小为 2DB. 则虚拟内存的最大容量为 2^32B=4GB 虚拟内存的实际容量=min(2^32B,512MB+2GB)=2GB+512MB 多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调用内存 对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入换出 虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量 4、如何实现虚拟内存技术 ​ 在程序执行过程中，当所访问的信息不再内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。 ​ 若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。 3.2_2 请求分页管理方式 1、页表机制 请求分页存储的页表： 内存块号 状态位 访问字段 修改位 外存地址 2、缺页中断机构 内中断，可被修复 3、地址变换机构 3.2_3 页面置换算法 1、最佳置换算法（OPT） 每次选择淘汰的页面是以后永不使用或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。 实际上不知道后面的序列 2、先进先出置换算法（FIFO） 每次选择淘汰的页面是最早进入内存的页面 Belady 异常，当分配的内存块增大时，缺页次数反而增加 3、最近最久未使用置换算法（LRU） 每次淘汰最近最久未使用的页面 4、时钟置换算法（最近未用算法，CLOCK） 简单的：最多经历两轮扫描，初始为 1，扫一下为 0，再扫一下被踢 5、改进型的时钟置换算法 优先淘汰没有被修改过的，因为没有修改过的不用进行 IO 操作 00-01（改）-00-01 3.2_4 页面分配策略 1、驻留集 ​ 指请求分页存储管理中给进程分配的物理块的集合 2、页面分配、置换策略 固定分配局部替换：驻留集大小不可改变 可变分配全局替换：可以将操作系统保留的空闲物理块分配给缺页进程 可变分配局部替换：只能选进程自己的物理块置换 3、调入页面的时机 预调页策略：一次调用若干个相邻页面，运行前调入 请求调页策略：运行时缺页再调入 4、从何处调页 对换区：快，采用连续分配方式 文件区：慢，采用离散分配方式 5、抖动（颠簸）现象 刚刚换出的又要换入，刚刚换入的又要换出，物理块不够 6、工作集 指在某段时间间隔里，进程实际访问页面的集合 4.1_1 初识文件管理 提供的功能： 处理机管理 存储器管理 文件管理 设备管理 目标：安全高效 4.1_2 文件的逻辑结构 1、无结构文件 文件由一系列二进制文件流组成 2、有结构文件（记录式文件） 顺序文件：文件中的记录一个接一个顺序排列，定长或变长，可以顺序存储或者链式存储 按照是否与关键字顺序有关，可以分为串结构和顺序结构 链式：无法随机存取 顺序存储： 可变长：无法随机存取 定长：可以随机存取，采用串结构，无法快速找到关键字；采用顺序结构，可以快速查找关键字 索引文件：索引表本身是定长的顺序文件 索引顺序文件：多级索引表嵌套查找 4.1_3 文件目录 1、文件控制块（FCB） ​ 搜索、创建文件、删除文件、显示目录、修改目录 2、目录结构 单级目录结构 两级目录结构 ​ 主文件目录（MFD）+用户文件目录（UFD） 多级目录结构（树形目录结构） 当代操作系统采用方法、不便于文件共享 无环图目录结构 可以共享 3、索引节点（对文件控制块） ​ 压缩文件名和信息 4.1_4 文件的物理结构（文件分配方式） 1、对非空闲磁盘块的管理 连续分配：连续分配方式要求每个文件在磁盘上占有一组连续的块，对文件的拓展不方便，有很多磁盘碎片 链接分配 隐式分配：采用链接分配方式的文件，只支持顺序访问，不支持随机访问，方便拓展 显示分配：文件分配表显式记录下一块物理块的位置，方便拓展，支持随机访问，文件表会占内存空间 索引分配 索引分配允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表记录了文件的各个逻辑块对应的物理块 支持随机访问 链接方案 多层索引 混合索引 4.1_5 文件存储空间管理 1、存储空间的划分与初始化 文件卷（逻辑卷）的概念 目录区与文件区 2、几种管理方法 空闲表法：首位置+长度，回收时注意修改 空闲链表法（空闲盘块链、空闲盘区链） 位示图法 成组链接法：文件卷的目录区中专门用一个磁盘块作为超级块，当系统启动时需要将超级内存块读入内存。并且保证内存与外存中的超级块数据一致。 4.1_6 文件的基本操作 创建文件（create） 1、在外存中找到文件所需的空间 2、创建该文件对应的目录项 删除文件(delete) 1、找到文件名对应的目录项 2、回收文件占用的磁盘块 3、删除文件对应的目录项 读文件(read) 写文件(write) 打开文件(open) 1、找到文件名对应的目录项 2、将目录项复制到内存中的“打开文件”中 关闭文件(close) 4.1_7 文件共享 1、基于索引结点的共享方式（硬链接） ​ 直接指向文件的索引节点 2、基于符号链的共享方式（软链接） ​ 相当于 win 的快捷方式 4.1_8 文件保护 1、口令保护 2、加密保护 ​ 保密性强，不需要在系统中存储“密码” ​ 编码/译码，需要花费一定时间 3、访问控制 ​ 在每个文件的 FCB 中增加一个访问控制表（ACL），该表记录了各个用户可以对该文件执行哪些操作 4.1_9 文件系统的层次结构 用户/应用接口 用户接口 文件目录系统 存取控制模块 逻辑文件系统与文件信息缓冲区 物理文件系统 辅助分配模块 设备管理模块 ​ 设备 4.2_1 磁盘的结构 磁盘、磁道、扇区的概念 如何在磁盘中读写数据 盘面柱面的概念 磁盘的物理地址 磁盘的分类 4.2_2 磁盘调度算法 1、一次磁盘读/写操作需要的时间 寻找时间 Ts=s+m*n 延迟时间 Tr=1/(2r) 传输时间 Tt=b/(rN) 2、磁盘调度算法 先来先服务（FCFS） 最短寻找时间优先（SSTF） 优先处理最近的磁道，可能会产生饥饿现象 扫描算法（SCAN） 只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动 LOOK，如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向 循环扫描算法（C-SCAN） 返回时直接快速移动至起始端而不处理任何请求 C-LOOK，如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向 4.2_3 减小磁盘延迟时间的方法 1、寻找时间（寻道时间）：启动磁臂、移动磁头所花的时间 2、延迟时间：将目标扇区转到磁头下面所化的时间 磁头读取一块内容后，需要一小段的时间处理 采用交替编号策略 柱面号在盘面号之前，可以减少磁头移动消耗的时间 错位命名 3、传输时间：读/写 数据花费的时间 4.2_4 磁盘的管理 1、磁盘初始化 ​ 低级格式化/物理分区 2、引导块 ​ ROM 不可修改，ROM 中只存放很小的“自举装入程序” 3、坏块的管理 ​ 在 FAT 表上标明（坏块对操作系统不透明） 5.1_1 I-O 设备的概念和分类 1、什么是 I-O 设备 ​ 输入/输出 2、按使用特性分类 人机交互的外部设备 存储设备 网络通信设备 3、按传输速率分类 ​ 低速、中速、高速设备 4、按信息交换的单位分类 ​ 块设备、字符设备 5.1_2 I-O 控制器 机械部件：鼠标等 电子部件 功能： 1、接受和识别 CPU 发出的命令 控制寄存器 2、向 CPU 报告设备的状态 状态寄存器 3、数据交换 数据寄存器 4、地址识别 内存映射 IO 寄存器独立编制 5.1_3 I-O 控制方式 1、程序直接控制方式 轮询：完成一次读/写操作的流程 CPU 干预频繁 每次读写一个字 实现简单 会使 CPU 忙等 2、中断驱动方式 让 cpu 发出 io 指令后做其它的事情 大量中断会使 cpu 效率低 每次读写一个字 cpu 和 io 可并行工作 3、DMA 方式：直接存储器存取 数据单位：连续的多个块 直接从设备到内存 减少了 cpu 干预 DR：数据寄存器 MAR：内存地址寄存器 DC：剩余读写字节数 CR：命令/状态寄存器 4、通道控制方式 弱鸡版 cpu 通道程序：任务清单 cpu 发送命令给通道，然后让通道处理 IO 操作就行了 处理完了，向 cpu 发送中断信号 5.1_4 I-O 软件层次结构 1、用户层软件 ​ 实现与用户交互的接口，向上提供方便易用的库函数 2、设备独立性软件（设备无关性软件） 向上层提供统一的调用接口（read/write） 设备的保护 差错处理 设备的分配与回收 数据缓冲区管理 建立逻辑设备名到物理设备名的映射关系 根据设备类型选择调用相应的驱动程序 3、设备驱动程序（比如打印机驱动） ​ 设置设备寄存器、检查设备状态 4、中断处理程序 ​ 进行中断处理 5、硬件 ​ 执行 IO 操作，有机械部件、电子部件组成 5.1_5 I-O 核心子系统 1、用户层软件 ​ 假脱机系统 2、设备独立性软件（设备无关性软件） ​ IO 调度、设备保护、设备分配与回收、缓冲区管理 3、设备驱动程序（比如打印机驱动） 4、中断处理程序 5、硬件 5.1_6 假脱机技术 1、什么是脱机技术，脱机技术可以解决什么问题 脱离主机的控制进行输入/输出控制 SPPOLing 系统：必须要有多道程序并发进行 2、假脱机技术的实现原理 输入井和输出井 输入进程和输出进程 输入缓冲区和输出缓冲区 3、共享打印机的原理分析 5.1_7 设备的分配与回收 1、设备分配时应考虑的因素 设备的固有属性：独占设备、共享设备、虚拟设备 设备分配算法： 设备分配中的安全：为进程分配一个设备后就将进程阻塞，本次 IO 完成后才将进程唤醒 2、静态分配与动态分配 静态分配：进程运行前为其分配全部所需资源、运行结束后归还资源 动态分配：运行中动态分配 3、设备分配管理中的数据结构 树 系统设备表 SDT，表目：（设备类型、设备标识符、DCT、驱动程序入口） 设备控制表 DCT（设备类型、设备标识符、设备状态、指向控制器表的指针、重复执行次数或事件、设备队列的队首指针） 控制器控制表 COCT（控制器标识符、控制器状态、指向通道表的指针设备队列的队首指针、控制器队列的队尾指针） 通道控制表 CHCT（通道标识符、通道状态、与通道连接的控制器表首址、通道队列的队首指针、通道队列的队尾指针） 4、设备分配的步骤 ​ 根据进程请求的物理设备名——设备控制表——控制器控制表——通道 5、设备分配步骤的改进方法 ​ 建立逻辑设备名和设备的映射 5.1_8 缓冲区管理 1、什么时缓冲区？有什么作用？ 缓冲区是一个存储区域 缓和 CPU 与 IO 设备之间速度不匹配的矛盾 减少对 CPU 的中断频率 解决数据粒度不匹配的问题 提高 CPU 与 IO 设备之间的并行性 2、单缓冲 在内存中分配一块缓冲区 处理一块时间=max（C,T)+M 3、双缓冲 在内存中分配两块缓冲区 max(T,C+M) 4、循环缓冲 5、缓冲池 ​ 由系统中共用的缓冲区组成。这些缓冲区可以分为：空缓冲队列、装满输入数据的缓冲队列、装满输出数据的缓冲队列","tags":[null],"categories":[null]},{"title":"数据库复习","path":"/data/notebooks/数据库复习.html","content":"数据库标红内容摘录 简述数据库的三级模式结构（主要背模式的概念） 对用户而言，外模式、模式和内模式分别对应一般用户模式、概念模式和物理模式，它们分别反映了看待数据库的三个角度。 模式也称为概念模式，是数据库中全体数据的逻辑结构和特征的描述，处于三级模式结构的中间层，不涉及数据的物理存储细节和硬件环境，与具体的应用程序、所使用的应用开发工具及高级程序设计语言无关。一个数据库只有一个模式。 （就是描述外模式和内模式的映射关系的部分，如你定义一张存了学生选课的信息表） 外模式又称为子模式或用户模式，是三级模式结构的最外层，是与某一应用有关的数据的逻辑结构，即用户视图。外模式一般是模式的子集，一个数据库可以有多个外模式。 （就是数据库用户（包括应用程序员和最终用户）最终可以看到的内容，如你给老师和学生分别定义了他们能看选课表的哪些内容） 内模式又称存储模式或物理模式，是三级模式结构中的最内层，也是靠近物理存储的一层，即与实际存储数据方式有关的一层。它是对数据库存储结构的描述，是数据在数据库内部的表示方式。一个数据库只有一个内模式。 （数据在数据库上存储的内容，是数据在数据库内部的表示方式，如你定义学生选课信息表的数据按照学生 id 的 B+树索引存储）（例如，记录的存储方式是顺序存储、按照 B 树结构存储还是按 hash 方法存储；索引按照什么方式组织；数据是否压缩存储，是否加密；数据的存储记录结构有何规定）。 三个世界指什么？它们之间有什么联系？ 三个世界是指现实世界、信息世界和计算机世界。 现实世界，即客观存在的世界。其中存在着各种事物及它们之间的联系，每个事物都有自己的特征或性质。 信息世界是现实世界在人们头脑中的反映，经过人脑的分析、归纳和抽象，形成信息，人们把这些信息进行记录、整理、归类和格式化后，就构成了信息世界。 计算机世界是信息世界中信息的数据化，就是将信息用字符和数值等数据表示，便于存储在计算机中并由计算机进行识别和处理。 对上面废话的总结：现实世界的客观事物 → 信息世界（大脑）的抽象实体属性 → 机器世界的数据记录 举例说明什么是实体完整性和参照完整性 实体完整性是指主码的值不能为空或部分为空。 例如，教材中表 1-3 的课程关系中的主码“课程号”（cno）可以唯一标识一门课程实体。如果主码中的值为空或部分为空，即主属性为空，则不符合关系键的定义条件，不能唯一标识元组及与其相对应的实体。例如，课程关系中的主码“课程号”不能为空，授课关系中的主码“教师号+课程号”不能部分为空，即“教师号”和“课程号”两个字段的取值都不能为空。 （文档里的原话，看不懂思密达~）参照完整性是指如果关系 R2 的外码 X 与关系 R1 的主码相符，则 X 的每个值或者等于 R1 中主码的某一个值或者取空值。 解释这句话： 关系 R1：这是一个具有主码（Primary Key）的关系（表）（主表）。主码（主键）是关系中唯一标识每一行的属性或属性组合。例如，学生表中的学号可以作为主码。 关系 R2：这是另一个关系（表），其中包含一个外码（Foreign Key）（从表）。外码（外键）是关系中的一个属性，它与其他关系的主码相关联。例如，选修课表中的课程编号可以作为外码，与学生表中的学号关联。 如果关系 R2 的外码 X 与关系 R1 的主码相符，意味着 X 的每个值都必须满足以下条件： 要么等于 R1 中某一行的主码值。 要么为空值（即没有对应的主码值）。 用人话解释上面的内容：如果在学生表和选修课之间用学号建立关联，学生表是主表，选修课是从表，那么，在向选修课表（从表）中输入一条新记录时，系统要检查新记录的学号是否在学生表（主表）中已存在，如果存在，则允许执行输入操作，否则拒绝输入，这就是参照完整性。 简述相关子查询的过程 相关子查询的执行顺序是： 首先，选取父查询表中的第一行记录，子查询利用此行中相关的属性值在子查询设计的基本表中进行查询，然后，父查询根据子查询返回的结果判断父查询表中的此行是否满足查询条件。如果满足条件，则把该行放入父查询的查询结果集合中。重复执行这一过程，直到处理完父查询表中的每一行数据。（这句废话太长，直接看下面的例子理解） 举个例子， 假设我们有一个名为 employees 的表，其中包含员工的信息（例如员工 ID、姓名、薪水等）。我们想要找出薪水高于所有员工平均薪水的员工。以下是查询语句： SELECT employee_id, first_name, last_name, salary#FROM employeesWHERE salary (SELECT AVG(salary) FROM employees);#左边是主查询，右边是子查询，语句从左到右依次执行，将主查询的内容一行一行比对 这将返回薪水高于平均薪水的员工列表。 视图的作用 提升数据操作的便捷性、提升数据的逻辑独立性、提升数据的安全性、数据集成。 以下是将图片中的内容直接转换为 Markdown 格式的中文版本，保留了原文的数学符号和格式： 函数依赖 是关系模式中属性之间的一种逻辑依赖关系 设有关系模式 ( R(U) )，( U ) 是属性全集，( X ) 和 ( Y ) 是 ( U ) 的子集，如果 ( X \\rightarrow Y )，并且对于 ( X ) 的任何一个真子集 ( X’ )，都有 ( X’ ot\\rightarrow Y )，则称 ( Y ) 对 ( X ) 完全函数依赖（Full-Functional-Dependency），记作： [ X \\xrightarrow{f} Y ] 如果存在 ( X ) 的某一个真子集 ( X’ )，有 ( X’ \\rightarrow Y )，则称 ( Y ) 对 ( X ) 部分函数依赖（Partial-Functional-Dependency），记作： [ X \\xrightarrow{p} Y ] 设有关系模式 ( R(U) )，( U ) 是属性全集，( X, Y, Z ) 是 ( U ) 的子集，若 ( X \\rightarrow Y )，但是 ( Y ot\\rightarrow X )，而且 ( Y \\rightarrow Z )（( Y \\in X, Z \\in Y )），则称 ( Z ) 对 ( X ) 传递函数依赖（Transitive-Functional-Dependency），记作： [ X \\xrightarrow{t} Z ] 试述 E-R 图转换成关系模型的转换规则 答：E-R 图向关系模型的转换一般应遵循如下原则： （1）实体的转换。一个实体型转换为一个关系模式。实体的属性就是关系的属性，实体的码就是关系的码。 （2）联系的转换。一个联系转化为一个关系模式，与该联系相连的各实体的码以及联系的属性转化为关系的属性，该关系的码则有几种情况： 若联系为 1:1，则每个实体的码均是该关系的候选码。 若联系为 1:n，则关系的码为 n 端实体的码。 若联系为 m:n，则关系的码为诸实体码的组合。 ​ 三个或三个以上实体间的多元联系、同一实体集内的自反联系的转换规则与二元联系相同。 （3）具有相同码的关系模式可合并。 下面为了方便理解，举一些例子： 一、首先了解 E-R 图中常用图形及代表的意思 ​ 1.1 长方形：表示实体。 ​ 实体是客观存在的事物。 ​ 例如用户、商品、订单、供应商等。说直白了，就是数据库的表名就可以做一个实体对象。一个系统是由很多个实体对象构成的，然后它们之间存在一定的关系和属性。 ​ 1.2 椭圆形：表示属性。 ​ 属性分为唯一属性（ unique attribute）和非唯一属性，唯一属性指的是唯一可用来标识该实体实例或者成员的属性，用下划线表示，一般来讲实体都至少有一个唯一属性。 ​ 举个栗子：用户实体拥有属性【id（唯一属性）、姓名、年龄、电话、身份证号（唯一属性）】、商品实体拥有属性【id、商品名称、商品类型、商品价格、商品图片、商品描述、供应商名称】、订单实体拥有属性【id、订单编号、用户名称、商品名称、下单日期】、供应商实体拥有属性【id、名称、地址、联系电话】。 ​ 1.3 菱形：表示关系。 ​ 例如用户和商品应该购买关系（一个用户购买多件商品）、订单与商品应该是包含关系（一个订单中包含多件商品）。 二、ER 图中关联关系有三种 ​ **一对一（1:1） ：**1 对 1 关系是指对于实体集 A 与实体集 B，A 中的每一个实体至多与 B 中一个实体有关系；反之，在实体集 B 中的每个实体至多与实体集 A 中一个实体有关系。 ​ 例如：一个用户只能拥有一张身份证，而一张身份证只属于一个用户。所以这就是一对一的关系。 ​ **一对多（1:n） ：**1 对多关系是指实体集 A 与实体集 B 中至少有 n(n0)个实体有关系；并且实体集 B 中每一个实体至多与实体集 A 中一个实体有关系。 ​ 例如：一对多和多对一是一样的。一个用户拥有多张银行卡，但是一张银行卡只属于一个用户。所以这就是一对多的关系。反过来说法就是多对一。 ​ **多对多（m:n） ：**多对多关系是指实体集 A 中的每一个实体与实体集 B 中至少有 m(m0)个实体有关系，并且实体集 B 中的每一个实体与实体集 A 中的至少 n（n0）个实体有关系。 ​ 例如：用户与商品的关系，一个用户可拥有多件商品。同样一件商品可被多个用户所拥有。所以这就是多对多的关系。 实体的转换 每个实体型转换为一个关系模式。例如，我们有一个学生实体（Student）和一个课程实体（Course）。 转换后的关系模式： 学生(学号, 姓名, 年龄) 课程(课程号, 课程名称, 学分) 具有相同码的关系模式可合并 如果两个关系模式具有相同的码，它们可以合并。例如，一个人有基本信息和联系信息，且码都是身份证号。 转换后的关系模式可以合并为一个： 人(身份证号, 姓名, 年龄, 邮箱, 电话) 简述数据库设计的基本步骤。 主要步骤：① 需求分析 ② 概念模型设计 ③ 逻辑模型设计 ④ 物理模型设计 ⑤ 数据库的实施 ⑥ 数据库的维护 游标 是一种能够从包括多条数据记录的结果集中进行逐条访问这些记录的机制。 可以将游标看作一种特殊的指针，它与某个查询结果集相关联，可以指向结果集的任意位置，可以将数据放在数组、应用程序中或其他的地方，允许数据库用户对指定位置的数据进行处理。 触发器（TRIGGER） 是在满足一定条件下自动触发执行的数据库对象，如向表中插入记录、更新记录或者删除记录时被系统自动地触发并执行的特殊类型的存储过程。触发器的作用是可以对表执行复杂的完整性约束。","tags":[null],"categories":[null]},{"title":"计算机二级C语言复习","path":"/data/notebooks/计算机二级C语言复习.html","content":"第一章 C 语言基本知识 C 程序 源程序文件后缀为 .c 编译后生成目标文件，后缀为 .obj 连接库函数后生成可执行文件，后缀为 .exe 三种基本结构：顺序结构、选择结构、循环结构 main 函数 C 程序的入口，有且仅有一个 示例：int main() return 0; 数据的存储形式 数据以二进制形式存储，1 Byte = 8 bit 进制转换： 二进制、八进制、十六进制转十进制使用乘法 十进制转其他进制使用除法 数据地址即数据的存放位置 注释 格式：/* 注释内容 */，不可嵌套 书写格式 每条语句后加分号 ; 示例：x = 1; y = 2; 标识符 命名规则：由字母、数字、下划线组成，首字符必须为字母或下划线，区分大小写 三类： 关键字，例如 int 预定义标识符，例如 define 用户自定义标识符 常量与变量 常量：值不可变 整型：5 实型：3.14 字符：'a' 字符串：abc 符号常量：#define PI 3.14 变量：值可变，C 语言无字符串变量，字符串使用字符数组存储 整型数据 表示形式： 十进制：10 八进制：012 十六进制：0xA 注意：整形数据没有二进制形式！ 类型： int (4 字节) short（2 字节） long (8 字节) unsigned(4 字节) 实型数据 表示形式： 小数形式：3.14 指数形式：1.23e-4 类型： float (4 字节) double 算术运算 运算符：+, -, *, /, % 示例：5 / 2 = 2（整型运算舍去小数部分） 强制类型转换 格式：(类型)表达式 示例：(float)5 / 2 = 2.5 赋值 运算符：= 复合赋值：+= 等价于 n = n + 100 自加自减运算 运算符：++, -- 示例： j = i++ 表示 j = i; i = i + 1 j = ++i 表示 i = i + 1; j = i 逗号运算 优先级最低 示例：a = 1, b = 2 第二章 顺序结构 运算符、表达式与语句 表达式：a + b 语句：a = b + 1; 运算符优先级 从高到低：初等运算 单目运算 算术运算 关系运算 逻辑运算 赋值运算 逗号运算 printf 函数 格式：printf(%d, 123) 格式说明 格式符 完整名称 数据类型 %d integer 整型 %f float 单精度浮点型 %lf long float 双精度浮点型 %c character 字符 %s string 字符串 scanf 函数 输入项需加取地址符 ，分隔符可以是空格、制表符或回车 示例：scanf(%d, x) 交换变量 示例：t = x;x = y;y = t; 第三章 选择结构 关系运算 非 0 表示真，0 表示假 运算符：、=、== 等 逻辑运算 运算符：（与）、||（或）、!（非） 短路求值示例：a++ || b++（若 a 非 0，则 b++ 不执行） if 语句 嵌套时，else 与最近的 if 匹配 示例：if (x 0) y = 1;else y = 0; 条件运算 格式：x 0 ? 1 : 0 switch 语句 switch 表达式不可为实型，case 后不可接变量 示例：switch (x) case 1: break; 第四章 循环结构 三种循环 while (x 5) do while (x 5); for (i = 0; i 5; i++) break 与 continue break：终止整个循环 continue：结束当前轮次，继续下一次循环 循环嵌套 示例：for (i = 0; i 2; i++) for (j = 0; j 3; j++) 第五章 字符型数据与位运算 字符常量 格式：'a' ASCII 码：'0' = 48, 'A' = 65, 'a' = 97 转义字符 示例：' ' 表示换行，'\\101' 表示 'A'，后面的数字表示 ASCII 码的偏移量，是 8 进制码 字符与整型转换 示例：'A' + 32 = 'a' 位运算符 ~（取反）、（左移）、（右移）、（与）、^（异或）、|（或） 示例：1 ^ 1 = 0 putchar 与 getchar putchar()：输出字符 getchar()：输入字符 示例：putchar('A');, x = getchar(); 第六章 函数 函数定义 格式：int func(int x) return x; 空函数定义：void func(); 库函数 示例：#include stdio.h 函数返回值 示例：return 0; 函数声明 示例：int func(int); 参数传递 传值：func(x)，形参不影响实参 传址：func(x) 递归调用 示例：int factorial(int n) //阶乘 if (n = 1) return 1; return n * factorial(n - 1); 第七章 指针 🔹 指针常见用法 声明 函数 () [] 数组 * 指针 int 类型 语义 int a - - - int a 变量 a，整型 (int type) int a[3] - a[] - int a[] 数组 a，元素=int 变量 int *p - - *p int *p 指针 p，指向 int 变量 int *p[3] - p[] *p[] int *p[] 数组 p，元素=指向 int 变量的指针 int (*p)[3] - (*p)[] (*p) int (*p)[] 指针 p，指向数组 []，元素=int 变量 int **p - - a=*p *(a) int *(*p) 指针 p → 指针 a → int int z(int) z() - - int z() 函数 z，形参=int 变量，返回=int int (*p)(int) (*p)() - (*p) int (*p)() 指针 p，指向函数 (形参=int, 返回=int) 第八章 数组 数组定义 格式：int a[5]; 数组初始化 示例：int a[] = 1, 2; 二维数组 左边是行数，右边是列数（行内个数） 示例：int a[2][3] = 1, 2, 3, 4, 5, 6; 数组名 表示数组首地址，不可被赋值 第九章 字符串 字符串常量 格式：ABC，末尾自动加 '\\0' 字符数组 示例：char str[6] = Hello; 输入输出 示例：gets(str);, puts(str); 字符串函数 函数名 完整名称 功能 strcpy() string copy 复制字符串 strlen() string length 计算字符串长度 strcat() string cat 连接字符串 strcmp() string compare 比较字符串 注意： strlen() 返回值是 int 类型，表示字符串的长度，即字符串中字符的个数，遇到’\\0’之后就不再数了，即不包括 '\\0'。 strcmp() 返回值是 int 类型，表示两个字符串的比较结果，返回值小于 0 表示第一个字符串小于第二个字符串，返回值大于 0 表示第一个字符串大于第二个字符串，返回值等于 0 表示两个字符串相等。 第十章 结构体与共用体 结构体 结构体是一种自定义数据类型，用于组合多个不同类型的成员，每个成员占用独立内存，总大小为成员大小之和（可能因内存对齐增加）。 定义格式：struct stu char name[10]; // 字符数组，10 字节 int age; // 整数，4 字节; 使用时需定义变量，如 struct stu s; 或通过 typedef 简化类型名。 成员引用 访问结构体成员的三种方式： 变量直接访问：s.name（点运算符，访问结构体变量的成员） 指针访问：p-age（箭头运算符，访问指针指向的成员） 间接访问：(*p).age（解引用后用点运算符） 示例：struct stu s = Alice, 20;struct stu *p = s;printf(%s, %d , s.name, p-age); // 输出: Alice, 20 共用体 共用体也是一种自定义类型，所有成员共享同一块内存，大小为最大成员的大小（可能因内存对齐调整）。一次只能存储一个成员的值，新赋值会覆盖旧值。 定义格式：union data int i; // 4 字节 float f; // 4 字节; 示例：union data d;d.i = 65; // 存整数printf(%d , d.i); // 输出: 65d.f = 3.14; // 存浮点数，覆盖 iprintf(%f , d.f); // 输出: 3.14 用途：节省内存或实现类型灵活性，如表示单一值的多种形式。 第十一章 文件 文件指针 文件指针是一个指向 FILE 类型的指针，用于操作文件。FILE 是 C 标准库中定义的一个结构体，包含了文件操作所需的信息（如文件位置、状态等）。 定义格式：FILE *fp; fp 是一个指针变量，必须在使用前初始化，通常通过 fopen 函数赋值。 示例： FILE *fp; // 定义文件指针 注意：文件指针在使用后需要通过 fclose 关闭，以释放资源。 打开文件 文件的打开形式如下：FILE *fp; fp = fopen(c:\\\\lab.c, rb); fopen 函数用于打开文件，返回一个文件指针。 参数说明： 第一个参数是文件名（包含路径），如 c:\\\\lab.c 表示 Windows 系统下的路径，使用双反斜杠是因为反斜杠 \\ 在字符串中需转义。 第二个参数是文件打开模式，常见模式包括： r：只读模式，文件必须存在。 w：只写模式，若文件不存在则创建，若存在则清空。 a：追加模式，写入数据追加到文件末尾。 rb：以只读二进制模式打开文件。 wb：以只写二进制模式打开文件。 ab：以追加二进制模式打开文件。 rb 表示以只读二进制模式打开文件，这种模式适用于读取非文本文件（如图片或可执行文件），不会对数据进行任何转换。 示例： FILE *fp;fp = fopen(c:\\\\lab.c, rb); // 打开文件if (fp == NULL) printf(文件打开失败 ); // 检查是否打开成功 注意：打开文件时应检查 fopen 返回值是否为 NULL，以判断文件是否成功打开。 文件函数 C 语言提供了多种文件操作函数，分别用于字符、字符串和二进制数据的读写。 字符操作函数： fgetc(fp)：从文件中读取一个字符，返回值为 int 类型（若到文件末尾返回 EOF）。 示例： int ch = fgetc(fp); // 读取一个字符if (ch != EOF) putchar(ch); // 输出读取的字符 fputc(ch, fp)：将一个字符写入文件。 示例：fputc(A, fp); // 写入字符 A 字符串操作函数： fgets(str, n, fp)：从文件中读取一行或最多 n-1 个字符到字符串 str 中，自动在末尾添加 \\0。 示例：char str[100];fgets(str, 100, fp); // 读取一行printf(%s, str); fputs(abc, fp)：将字符串写入文件，不自动添加换行符。 示例：fputs(abc, fp); // 写入字符串 abc 格式化输入输出函数： fscanf(fp, %d, x)：从文件中按格式读取数据。 示例：int x;fscanf(fp, %d, x); // 读取一个整数 fprintf(fp, %d, x)：按格式将数据写入文件。 示例：int x = 123;fprintf(fp, %d, x); // 写入整数 123 二进制操作函数： fread(buf, size, count, fp)：从文件中读取 count 个大小为 size 的数据块到缓冲区 buf。 示例：int data[5];fread(data, sizeof(int), 5, fp); // 读取 5 个整数 fwrite(buf, size, count, fp)：将缓冲区 buf 中的 count 个大小为 size 的数据块写入文件。 示例：int data[5] = 1, 2, 3, 4, 5;fwrite(data, sizeof(int), 5, fp); // 写入 5 个整数 文件位置控制函数： fseek(fp, offset, origin)：移动文件指针。 参数： offset：偏移量（字节数） origin：起始位置（SEEK_SET 文件开头，SEEK_CUR 当前位置，SEEK_END 文件末尾） 示例：fseek(fp, 0, SEEK_SET); // 移动到文件开头 ftell(fp)：返回文件指针当前所在位置（相对于文件开头的字节数）。 示例：long pos = ftell(fp); // 获取当前位置 rewind(fp)：将文件指针移到文件开头。 示例：rewind(fp); // 回到文件开头 文件结束判断： feof(fp)：判断是否到达文件末尾，返回非 0 表示文件结束。 示例：while (!feof(fp)) ch = fgetc(fp); // 循环读取字符 关闭文件： fclose(fp)：关闭文件，释放资源。 示例：fclose(fp); // 关闭文件 注意：文件操作函数分为文本文件和二进制文件适用的类型，使用时需根据文件模式选择合适的函数。 第十二章 深入讨论 编译预处理 凡以#开头的这一行，都是编译预处理命令行，编译预处理不加分号，不占运行时间。 宏替换仅是简单的文本替换，如#define f(x) (x)*(x)和#define f(x) x*x 替换 f(2+2)时就有区别，前者展开为(2+2)*(2+2)，后者为 2+2*2+2。 如果源文件 f2.c 中有#includef1.c可以理解为：把源文件 f1.c 原样包含到 f2.c 中，使 f1.c 和 f2.c 融合到一起成为一个 C 程序编译。 所以一个 C 程序必有主函数，但一个 C 源文件未必有主函数。 标识符作用域 局部变量：在函数内或复合语句内定义的变量，作用域为定义它的函数内。 局部变量有三种类型： 自动 auto：自动变量随着函数的使用与否创建消失。 寄存器 register：寄存器变量分配在 cpu 中，没有内存地址。 静态 static：静态变量占用固定存储单元，在程序执行过程不释放，直到程序运行结束。 全局变量：在函数外定义的变量，作用域从定义它的位置到整个源文件结束为止，生存期为整个程序运行期间。 全局变量都是静态变量。 动态存储分配 malloc(size)：创建连续 size 个字节存储区，返回值类型为 void *型。malloc 函数常用于动态创建链表结点，如 int *p; p=(int *)malloc(sizeof(int));。 calloc（n,size）：创建 n 个同一类型的存储空间，可以理解为 n 个 malloc。 free(p)：释放动态分配的存储单元。","tags":[null],"categories":[null]},{"title":"计算机二级公共基础知识点考点整理","path":"/data/notebooks/计算机二级公共基础知识点考点整理.html","content":"以下内容在 c 语言中占了 40 分，所以考 c 语言二级必看，如果是考 wps 二级之类的话就不用看 这个资料分为了两部分： 计算题部分穿插在 c 语言选择题中 30 分 记忆题部分只占了 10 分，所以几乎不用看记忆部分 一 、计算题部分讲解 1.进制转换 十进制数转换为二进制 方法：将十进制数除以 2，取余数，倒序排列。 2.原码反码补码偏移码的计算 原始规则 正数：原码=反码=补码 负数的反码：符号位为 1，原码数值位取反 负数的补码：反码+1 偏移码=补码符号位取反 选择题中的绕口令 反码的反码 = 原码 补码的补码＝原码 补码之和 = 和的补码 引入补码之后，带符号数的加减运算都可以用加法实现 整数在计算机中的存储和运算，通常采用补码 3.线性结构的判断 线性表特点：表中的每一个数据元素： 除了第一个外，有且只有一个前件， 除了最后一个外，有且只有一个后件。 简单说，就是用一条线能吧所有元素串在一起 例题： 设元素集合为 D={1, 2, 3, 4, 5, 6}，B=(D,R)为线性结构所对应的 R 是 A.R={(6,1),(5,6),(1,3),(2,4),(3,2)} B.R={(4,5),(6,1),(5,6),(1,3),(2,4),(3,2)} C.R={(6,1),(5,6),(1,3),(2,4),(3,2)} D.R={(6,1),(5,6),(2,3),(2,4),(3,2)} 此题选 A，A 选项 5-6-1-3-2-4 能连成一根线，首尾不连接 4.栈和队列元素的增删计算 栈的特点 栈顶/栈底 先进后出、后进先出（迟到早退） 具有记忆功能 子程序调用 函数调用 递归调用 队列 队头/队尾 先进先出、后进后出 队列的应用 操作系统中的工作调度， 若工作的优先权相同，则采用先到先操作的原则。 5.栈中元素个数的计算 需要分栈的升降序 当初始状态 top 值小于 1 栈底序号为 1，序号越往上走越大 当初始状态 top 值大于存储空间最大序号 n 栈底序号 n 为最大序号，序号越往上走越小 栈底的最小值会超出栈的范围（0 或者 n+1),这个栈底位置不存数据！只存栈的状态） 6.循环队列元素个数的计算 Rear 指向队列最后一个元素的位置 Front 指向队列第一个元素的位置 指针情形 指针情形 队列中元素个数 Rear=front 0 或容量为满 Rearfront Rear-front Rearfront Rear-front+总容量 顺序查找 长度为 n 的线性表，找到某个特定元素，最坏需要比较 n 次，最坏需要比较 n-1 次 长度为 n 的线性表，找到最大（最小）值，最坏需要比较 n 次最坏需要比较 n-1 次 7.树中元素个数的计算 树的特点 父节点 在树结构中，每一个结点只有一个前件，称为父结点。 根节点 没有前件的结点只有一个，称为树的根结点，简称树的根。 子节点 每一个结点可以有多个后件，称为该结点的子结点。 叶子节点 没有后件的结点称为叶子结点。 节点的度 一个结点所拥有的后件的个数称为该结点的度。 树的度 所有结点中最大子节点个数称为树的度。 树的深度 树的最大层次称为树的深度。 树的节点个数计算 父节点树相加 度数与对应的节点数乘积之和 +1 例题 度为 3 的一棵树共有 30 个结点，其中度为 3、1 的结点个数分别为 3、4，则该树中的叶子结点数为（ ）。 A. 14 B. 15 C. 16 D. 不可能有这样的树 对应解法 根据树的基本性质： 树的叶子结点数（LLL）可以通过如下公式计算： L=N−∑(度数×该度数的结点数)L = N - \\sum (\\text{度数} \\times \\text{该度数的结点数}) L=N−∑(度数×该度数的结点数) 其中， N=30N = 30N=30（总节点数） 度为 3 的结点数为 3，则它们贡献的子节点数为 3×3=93 \\times 3 = 93×3=9 度为 1 的结点数为 4，则它们贡献的子节点数为 4×1=44 \\times 1 = 44×1=4 假设度为 2 的结点数为 xxx，则它们贡献的子节点数为 2x2x2x 根据上面给的计算方法： 30−1=9+4+2x+L30 - 1 = 9 + 4 + 2x + L 30−1=9+4+2x+L 29=13+2x+L29 = 13 + 2x + L 29=13+2x+L L=16−2xL = 16 - 2x L=16−2x 由于树的度数最高为 3，度为 2 的结点数量 xxx 可能为 0（即所有非叶子节点度为 3 或 1），因此： L=16−2×0=16L = 16 - 2 \\times 0 = 16 L=16−2×0=16 所以，正确答案是： C. 16 8.二叉树的计算 基本性质 性质 1 ：在二叉树的第 kkk 层上，最多有 2(k−1) (k≥1)2^{(k-1)} \\ (k \\geq 1)2(k−1) (k≥1) 个结点。 性质 2 ：深度为 mmm 的二叉树最多有 2m−12^m - 12m−1 个结点。 性质 3 ：在任意一棵二叉树中，度数为 0 的结点（即叶子结点）总比度为 2 的结点多一个。 性质 4 ：具有 nnn 个结点的二叉树，其深度至少为 ⌊log⁡2n⌋+1\\lfloor \\log_2 n \\rfloor + 1⌊log2​n⌋+1，其中 ⌊log⁡2n⌋\\lfloor \\log_2 n \\rfloor⌊log2​n⌋ 表示取 log⁡2n\\log_2 nlog2​n 的整数部分。 特殊二叉树 满二叉树：每一层上的所有结点都有两个子结点。 完全二叉树： 除了最后一层，每一层都达到最大节点数，最后一层只缺少右侧节点。 完全二叉树总结点个数，是奇数，度为 1 的结点个数为 0 个；是偶数，度为 1 的结点个数为 1 个。 二叉树遍历结构 A 下面有两个子节点，左到右为 B-C 按照三种不同的排序排出来为（根在哪里就是什么序）： 前序 中序 后序 根-左-右 左-根-右 左-右-根 ABC BAC BCA 9.扇入数，扇出数，宽度 扇入数：指一个节点的输入边的数量，即有多少个其他节点指入该节点，注意是只看本节点的入数。 扇出数：指一个节点的输出边的数量，即该节点往下指出多少个其他节点，注意是只看本节点的出数。 结构图宽度：指的是宽度最大一层的宽度 10.传统集合运算 计算机二级考这部分的选择题，一般可以根据图的特点判断，下面后面括号里的就是特点 并（Union） 将两个集合中的所有元素合并成一个新集合，并去除重复元素（特点是行数增加） 交（Intersection） 返回同时属于两个集合的共同元素，即两个集合的交集（特点是行数减少）。 差（Difference） 返回属于第一个集合但不属于第二个集合的元素，即集合的差集。 下面的情况考的不多 笛卡儿积：两个集合的笛卡儿积是指将每个元素与另一个集合的每个元素两两组合，形成所有可能的有序对（特点是行数和列数都增加）。 商运算：两个集合做除法（特点是行数和列数都减少）。 11.数据库关系运算 除开上面的运算，还有下面的这几种运算 基本关系运算 选择：从关系中筛选满足特定条件的元组（行），一般用σ表示。 投影：从关系中选择特定的属性（列），一般用π表示。 连接运算 自然连接：基于同名属性匹配并合并两个关系的数据。 等值连接：通过相等条件进行连接。 一般情况下，商运算得到的结果**一定和除数完全相关** 12.三大范式 直接看本网站数据库复习的部分 二、记忆题部分速记 01 计算机系统概述 概述 计算机产生与发展 冯诺依曼 存储程序控制 二进制 计算机五大组成部分 运算器 控制器 存储器 输入设备 输出设备 计算机硬件发展阶段 电子管 晶体管 小规模集成电路 大规模、超大规模集成电路 计算机系统 硬件系统 主机 CPU（中央处理器） 由运算器和控制器构成 性能指标：字长和主频 内存（主存储器） ROM 断电后数据不会消失 信息由生产厂家先写入 RAM 断电后数据会消失 SRAM：静态随机存储器 DRAM：动态随机存储器 外设 外存储器 输入设备 输出设备 软件系统 系统软件 操作系统 语言处理系统 数据库系统 应用软件 文字处理软件 图像处理软件 辅助设计软件 Internet 工具软件 02 存储器考点 存储器 ★ 寄存器 分布在 CPU 内部的高速存储器 保存正在执行的指令，保存中间数据、操作数 CPU 不经过总线能直接访问的是寄存器 ★CACHE 高速缓冲存储器 解决 CPU 和内存速度不匹配 内存储器 ROM 和 RAM 外存储器 硬盘 光盘 U 盘 读取速度排序 寄存器 缓存 内存 外存 程序局限性 时间局部性 如果一个存储项被访问，则该项在近期可能很快被再次访问 空间局部性 如果一个存储项被访问，则该项及其邻近的项也可能很快被访问 03 机器指令 机器指令 定义 计算机可直接识别和执行的命令 组成 操作码：执行什么操作 操作数：操作的对象（数据或者地址） 操作数地址 有效地址（真实地址） 形式地址（需按寻址方式转换成有效地址） ★ 寻址方式 目标：确定本条指令的数据地址与下一条将要执行的指令地址 指令寻址 顺序寻址 跳跃寻址 ★ 数据寻址 立即寻址：地址码直接给出操作数 直接寻址：地址码给出的是操作数的地址 间接寻址：地址码部分给出的是操作数的地址 隐含寻址：操作数的地址隐含在固定的地址或寄存器中 指令系统 计算机的所有指令的集合称指令系统 不同的计算机指令系统各有不同（指令条数、操作码、地址码） 指令周期 计算机完成一条指令所花费的时间 04 总线 总线 作用 CPU 可以通过总线访问计算机内存和各种输入输出设备 ★ 易考：CPU 不经过总线能直接访问的是寄存器 分类 片内总线 CPU 芯片内部连接各元件的总线 ★ 系统总线 地址总线（单向） 地址总线的位数决定 CPU 直接寻址的内存范围 数据总线（双向） 控制总线（双向） 通信总线 串行数据总线 并行数据总线 性能指标 总线宽度（数据总线根数） 总线带宽（数据传输率） 时钟同步/异步 同步总线：通过使用统一的时钟信号来协调设备间的数据传输 异步总线：不依赖统一的时钟信号进行数据传输 05 操作系统 操作系统主要特征 共享性 异步性 虚拟性 并发性 分类 多道程序处理操作系统：分时操作系统、网络操作系统、嵌入式操作系统 分时操作系统 允许多个联机用户同时使用一个计算机系统 采用时间片轮转技术，使用户的相应速度较快 实时操作系统 工业控制系统、过程控制系统 快速响应 分布式操作系统 由多个微型计算机或计算机网络组成 可协同完成同一任务 主要功能 进程管理 进程：程序在内存中运行的基本单位 进程管理的任务： 进程的创建 进程的终止 进程的调度 进程的同步和通信 进程控制块（PCB）：存储进程控制信息 进程的状态： 就绪：等待 CPU 分配 运行：正在执行 阻塞：等待某些事件完成 存储管理 地址重定位方式 静态重定位 动态重定位 存储管理技术 连续分区存储管理 固定分区存储管理 可变分区存储管理 分页存储管理 分段存储管理 段页式存储管理 虚拟存储器 通过存储管理提高 CPU 的效率 采用请求分页、请求分段方式进行存储 文件管理 负责存取和管理文件系统 组织文件的存储结构 设备管理 I/O 控制：操作系统用于管理输入输出设备的技术 方式 程序查询：CPU 查询设备状态 中断驱动：CPU 执行其他任务，设备准备好时发出中断 DMA（直接存储访问）：数据由 I/O 设备直接存取内存 通道方式：独立的处理单元管理 I/O 操作 06 I/O 控制方式 概述 I/O 控制方式是计算机系统中用于管理和控制输入输出操作的一组技术。 方式 程序查询 程序主动查询 I/O 设备是否准备好 程序中断 当出现异常或特殊情况时，CPU 停止当前程序的运行，转而执行对这些情况进行处理的程序（中断服务处理程序） DMA（直接内存存取） I/O 设备不经过 CPU 的情况下直接与内存交换数据 通道方式 通过独立的通道处理器来控制 I/O 操作，使得 CPU 可以更高效地处理其他任务 增加计算机系统的并行程度 07 算法 定义 算法是解决问题的方法和步骤。 程序可以作为算法的一种描述方法，但算法 ≠ 程序。 四个特点 确定性：每条指令有明确含义 可行性：在经过有限次运算后得到结果 有穷性：有穷时间内可以执行完 补充：算法是有穷的，程序可以是无穷的 输入输出： 0 个或多个输入 1 个或多个输出 算法的控制结构 顺序结构 选择结构（分支结构） 循环结构（重复） 衡量算法的优劣标准 时间复杂度：需要运算的次数（工作量） 空间复杂度： 程序代码所占空间 输入数据所占空间 程序运行所需的额外空间 补充： 原地工作：执行算法时不需要额外辅助空间 额外辅助空间固定，不随输入数据规模增长 注：时间复杂度与空间复杂度没有直接关系 08 数据结构 逻辑结构 定义 数据元素在逻辑上的前后件关系。 数据的逻辑结构与所使用的计算机无关。 分类 线性结构 特点：数据元素之间存在一对一的线性关系 实例：数组、线性表、栈、队列 非线性结构 特点：数据元素之间存在一对多或多对多的关系 实例：树、二叉树、图 存储结构 定义 数据元素在计算机上的存储关系。 算法的执行效率与数据的存储结构有关。 分类 顺序存储 存储方式：将数据元素按照顺序依次存放在连续的存储区域中 特点：逻辑上相邻的元素在物理存储位置上也相邻 链式存储 存储方式：通过指针来链接各个数据元素的存储方式 特点：逻辑上相邻的元素在物理存储位置上不一定相邻 优点：插入、删除元素效率更高 实例：链表 关系 线性表可以采用顺序存储，也可以采用链式存储 非线性表可以采用顺序存储，也可以采用链式存储 数据结构的表达 数据元素的集合：d 数据的前后件关系：r 示例： 数据集合 D = {1,2,3,4} 前后件关系 R = {(1,2), (2,3), (3,4)} 09 栈与队列 栈 栈：只允许在一端（栈顶）插入或删除的线性表。 结构 栈顶/栈底 特点：先进后出，后进先出 应用 子程序调用 具有记忆功能 函数调用 递归调用 存储方式 顺序存储 链式存储 栈中元素个数（计算题） TOP 小于等于 0 TOP 大于最大容量值 队列 队列：只允许在一端进行插入，在另一端删除的线性表。 结构 在队尾添加记录 在队头删除记录 特点：先进先出，后进后出 循环队列元素个数（计算题） rear = front → 0 或 满 rear front → rear - front rear front → rear - front + 总容量 队列的应用 操作系统中的工作调度 若工作的优先权相同，则采用先到先得的原则。 10 查找与排序技术 查找技术 顺序查找 适用于长度为 n 的线性表，查找特定元素。 最坏情况：需要查找 n 次。 平均比较次数： (n+1)/2 次。 可用于查找最大（最小）值，最坏情况需要比较 n-1 次。 二分法查找（对分查找） 只适用于顺序存储的有序表。 最坏情况：查找特定元素时需要 log₂(n) 次比较。 排序技术 交换类排序 冒泡排序 快速排序（适用于顺序存储的线性表） 插入类排序 简单插入排序 希尔排序（每次数据元素的移动可以消除多个逆序） 选择类排序 简单选择排序 堆排序（时间复杂度最小） 重点-排序方法及时间复杂度 类别 排序方法 时间复杂度 交换类 冒泡排序 N(N-1)/2 快速排序 N(N-1)/2 插入类 简单插入排序 N(N-1)/2 希尔排序 O(n^1.5) 选择类 简单选择排序 N(N-1)/2 堆排序 O(nlog₂n)（最小） 11 软件工程基础 软件的组成 软件是包括程序、数据及相关文档的完整集合。 功能分类 系统软件 操作系统 数据库管理系统 编译程序 汇编程序 应用软件 支撑软件 软件工程 源于软件危机 软件危机可归结为成本、质量、生产率等问题。 三要素 方法 工具 过程 软件生命周期 软件定义阶段 问题定义 可行性研究 需求分析 软件开发阶段 概要（总体）设计 详细设计 软件实现 软件测试 软件运行维护阶段 软件生命周期中花费最多的阶段是软件运行维护阶段。 12 需求分析（做什么） 主要任务 确定软件系统的功能（做什么） 2 种方法 结构化分析方法 面向对象的分析方法 4 个步骤 需求获取 需求分析 需求分析的最终结果 软件设计和交付的依据 编写软件需求规格说明书 需求评审 4 种工具 数据字典 DD 数据字典的作用是对数据流图中出现的被命名的图形元素的确切解释。 数据字典是结构化分析方法的核心。 作用：支持软件系统功能建模。 数据流图 DFD 梳理或存贮：数据处理 箭头：数据流 双线：表示数据存储，又称为文件。 矩形：源、池 判定树 判定表 13 软件设计（怎么做） 总体设计（概要设计） 主要任务：确定软件系统的整体结构、模块划分、接口和数据流等 模块的两个定性指标 耦合性：不同模块之间相互链接的紧密程度 内聚性：单个模块内部各元素间彼此结合的紧密程度 目标：高内聚、低耦合 系统总体结构图 风入数、风出数、宽度、深度 示例图 总体设计完成后，需要编写概要设计文档 详细设计 主要任务：确定每个模块的算法和使用的数据结构，并用特定表达工具表示细节 程序流程图 图形工具 N-S（方盒图） PAD（问题分析图） HIPO（层次图 + 输入/处理/输出图） 表格工具 判定表 语言工具 PDL（伪码） 14 软件测试（找错误） 软件测试的目的 发现错误 测试方法 按是否被运行 静态测试（不运行） 动态测试（运行） 是否考虑软件内部逻辑结构 白盒测试 逻辑覆盖测试 基本路径测试 等价类别划分 黑盒测试 边界值分析法 错误推测法 软件测试的四个步骤 单元测试 依据：编码和详细设计说明书 测试内容：模块的接口、局部数据结构和出错处理能力 集成测试 系统测试 确认测试 测试用例 测试数据 预期结果 测试环境 操作步骤 其他测试原则 软件测试严格执行测试计划，排除测试的随意性 软件调试的目的是改正软件错误 15 数据库系统 基本术语 数据库系统（DBS） 包括数据库（DB）和数据库管理系统（DBMS） DBMS 是 DBS 的核心 数据管理三大发展阶段 人工管理阶段 文件系统阶段 数据库系统阶段 数据库系统特点 集成性高 高共享低冗余 数据独立性高 数据的统一管理与控制 数据库语言 数据定义语言 对概念模式内容进行说明 数据操纵语言 负责数据的增删改查等操作 数据控制语言 支持安全性定义和检查 数据库系统三级模式 内模式（物理模式） 反映物理存储形式，只有一个 外模式（用户模式） 反映用户的需求，可有多个 概念模式（逻辑模式） 反映全局逻辑要求，只有一个 三级模式的作用 物理独立性 逻辑独立性 保持数据库的独立性 16 数据库与数据模型 关系型数据库 记录（元组）：二维表中的每一行信息 字段（属性）：二维表中的每一列信息 关系（二维表）：一张二维表就是一个关系 约束 候选码：能唯一标识一行记录的字段（例如学号字段） 主码：从多个候选码中选出一个，以它作为唯一关键字 外码（外部关键字）：如果表 A 的某字段是表 B 的主码，则 A 这个字段就是外码 全码：极个别情况下，表的所有字段组合成主码 数据模型 基本概念 实体：实体是具有特定属性的对象或事物 属性：事物的特征 联系：事物之间的关系 一对一 一对多 多对多 三大要素 数据结构 数据操作 数据约束 参照完整性 实体完整性 自定义完整性（相当于设置数据库约束规则） 面向宏观世界和用户 数据模型分类 概念数据模型 ER 模型 矩形：实体 椭圆：属性 菱形：联系 逻辑数据模型 按照数据之间的联系方式划分 层次模型 网状模型 关系模型 物理数据模型 面向计算机物理存储 数据库设计 四个阶段 需求分析阶段 - 形成软件需求说明书 概念设计阶段 - ER 模型 逻辑设计阶段 - ER 模型 → 关系模型 物理设计阶段 规范化 第一范式（1NF）：关系中的每个属性都不可分 第二范式（2NF）：在 1NF 的基础上，消除非主属性对主码的部分依赖 第三范式（3NF）：在 2NF 的基础上，消除非主属性对主码的传递依赖","tags":[null],"categories":[null]},{"title":"源码目录结构详解","path":"/wiki/Smart_Home_System/code-structure.html","content":"项目的核心C源码全部位于 obj/ 目录下，其内部结构清晰，遵循模块化的设计原则。 obj/├── AI # AI 聊天功能模块 (基于OpenAI API)│ ├── examples│ ├── include│ ├── markdown│ └── src├── data # 数据持久化模块│ ├── state_store.c│ └── state_store.h├── hardware # 硬件抽象层│ └── hardware.c├── http # HTTP客户端实现│ ├── weather.c│ └── weather.h├── Include # 所有模块的公共头文件│ ├── config.h│ ├── Hardware.h│ └── ... (其他 .h 文件)├── JoyPixels emojis # Emoji图片资源 (C数组格式)│ └── bolt.c ...├── MQTT # MQTT通信模块│ ├── MQTT.c│ └── MQTT_File.c└── screen # 所有LVGL屏幕/界面源码 ├── screen_ac.c └── ... (其他页面 .c 文件) 目录说明 AI/: 实现了与大语言模型（如OpenAI兼容接口）的交互逻辑，将 OpenAI C 项目魔改，使用内核链表管理会话数据，实现多次对话的功能，内核链表使用方法。 data/: 负责将设备的关键状态（灯光、安防等）保存到本地文件系统，详见 数据持久化模块 hardware/: 封装了对 /dev/Led, /dev/beep 等底层硬件设备文件的 ioctl 操作，详见 硬件控制与外设驱动 http/: 手动实现的HTTP客户端，用于调用天气等第三方API，详见 第三方API集成 Include/: 头文件中心。存放了所有模块对外暴露的函数声明（API）和数据结构。其他模块包含这些头文件来使用其功能。config.h 也在此处，用于配置密钥和服务器地址。 JoyPixels emojis/: 将PNG格式的Emoji图标转换为了LVGL可以直接使用的C数组 (lv_img_dsc_t)，避免了在运行时从文件系统读取图片的开销。 具体方法可以查看：LVGL图像与字体使用笔记 MQTT/: 负责与MQTT Broker的全部通信，包括一个用于文件传输的扩展实现 (MQTT_File.c)，详见 MQTT 通信协议与实现 screen/: UI层。每个 .c 文件对应一个独立的屏幕或复杂的UI组件（如主页、灯光控制页），负责该页面的所有LVGL对象创建、布局和事件绑定"},{"title":"CMake 构建系统详解","path":"/wiki/Smart_Home_System/build-system.html","content":"本项目的构建由根目录下的 CMakeLists.txt 文件驱动，其核心设计思想是自动化平台检测与配置动态修改，以实现一套代码在 Linux PC、ARM 嵌入式 Linux 和 Windows 平台之间的无缝切换。 核心功能 1. 自动化平台检测与库链接 CMake脚本首先会检测当前的编译环境，并根据平台链接不同的依赖库： ARM 交叉编译 (arm): 通过 -DCMAKE_TOOLCHAIN_FILE 触发 CMAKE_CROSSCOMPILING 变量。 链接本地静态库：它会链接 libs/ 目录下为 ARM 预编译好的静态库 (.a 文件)，包括 libfreetype.a, libpng16.a, libcrypto.a, libssl.a, libmosquitto.a, libcurl.a。 这种方式避免了在交叉编译环境中配置复杂的依赖库。 Linux PC (pc): 使用系统库：通过 find_package, pkg_check_modules 等命令，查找并链接系统上已经安装好的动态库。 依赖项包括：SDL2, Threads, Freetype, PNG, ZLIB, OpenSSL, CURL, mosquitto, libcjson。 Windows (win): 同样链接 libs/ 目录下的 SDL2 和 Freetype 库。 链接一系列 Windows 系统特有的库，如 gdi32, winmm 等。 2. 动态修改LVGL配置文件 这是本构建系统的一大亮点。为了避免开发者手动修改 lv_conf.h 和 lv_drv_conf.h 来适配不同平台，CMake脚本会在编译前自动完成这个过程： 读取配置文件: 使用 file(READ) 将两个 .h 文件的内容读入变量。 正则替换: 当目标平台是 pc 或 win 时，脚本会自动启用 USE_SDL 并禁用 USE_FBDEV / USE_EVDEV。同时禁用 LV_TICK_CUSTOM，因为心跳由SDL提供。 当目标平台是 arm 时，则会自动禁用 USE_SDL 并启用 USE_FBDEV / USE_EVDEV，以适配嵌入式Linux的帧缓冲设备。同时启用 LV_TICK_CUSTOM 以使用自定义的心跳函数。 写回配置文件: 使用 file(WRITE) 将修改后的内容写回原文件。 这个自动化流程极大地简化了跨平台开发的配置工作。 3. 源文件管理 全局搜索: 使用 file(GLOB_RECURSE) 递归地将 lvgl, lv_drivers, obj, libs/cJSON 目录下的所有 .c 文件加入编译列表。 智能过滤: 通过 list(FILTER ... EXCLUDE REGEX) 命令，排除了文件名中包含连字符 - 的C文件，因为这可能导致C语言宏定义或符号名语法错误。 同时，也排除了 obj/AI/examples/ 目录下的示例代码，使其不参与主程序编译。 4. 输出配置 所有编译生成的可执行文件（名为 main）会被统一放置在项目根目录下的 bin/ 文件夹中，保持了目录结构的整洁。"},{"title":"第三方API集成","path":"/wiki/Smart_Home_System/api-integration.html","content":"为了丰富智能家居的功能，本项目集成了第三方网络API，例如用于获取实时天气信息。相关实现代码位于 obj/http/weather.c 使用到的知识点为Linux网络编程里的使用 UDP做DNS解析 和 使用CJSON解析字符串 这个部分的HTTP客户端是从零开始、基于底层 Socket API手写的，而没有依赖 libcurl 等高层HTTP库，使用的是心知天气的API 天气api数据获取流程 sh_weather_fetch_now 函数完整地展示了一个手动构造并执行HTTP GET请求的流程： DNS解析: 使用 gethostbyname() 函数将API的域名 (如 api.seniverse.com) 解析成IP地址。这是建立TCP连接的第一步 建立TCP连接: 使用 socket() 创建套接字，然后 connect() 到服务器的IP地址和HTTP标准端口（80） 手动拼接HTTP报文: 根据心知天气API官方定义，我们使用 snprintf() 手动拼接出符合HTTP/1.1规范的GET请求报文，包括请求行、Host 头和 Connection: close 头 发送请求: 使用 write() 将拼接好的请求报文通过套接字发送出去 接收响应: 使用一个循环和 read() 来不断从套接字读取服务器返回的数据，直到读取完成 解析响应: 首先，通过 strstr(buf, \\r \\r ) 找到HTTP头和响应体的分隔符，从而定位到真正的JSON数据 然后，使用 cJSON 库来解析JSON字符串，并通过 cJSON_GetObjectItem 等函数逐层提取出所需的天气信息字段（如 location, text, temperature） 这种实现方式虽然比使用库更复杂，但提供了最大的控制力，并且减少了项目的外部依赖"},{"title":"华为ICT网络赛道初级知识点汇总笔记","path":"/data/notebooks/华为ICT网络赛道初级知识点汇总笔记.html","content":"华为 ICT 网络赛道 初级 知识点汇总 建议先看这两个视频快速入门： 一个视频讲清楚家庭网络通信流程 [如何解决代理中的 DNS 泄漏问题？][https://youtu.be/fqREM6b25SY?si=oz90i_7ZOWAwBFtw](这个视频只用看 dns 的执行流程) 实践赛真题课程网址：https://talent.shixizhi.huawei.com/center/privateCenter.htm?schoolId=1365189427395223554type=studyCenter_LearningTasksxz-lang=zh_CNmapDetail=3mapDetailId=1838152212504219649 考前真题讲解-通义效率 IP 知识百科 - 华为 VRP 系统 VRP（Versatile Routing Platform，灵活路由平台）是华为自主开发的网络操作系统，广泛应用于其路由器、交换机、防火墙等网络设备上。VRP 系统的主要作用和特点包括： 路由管理：支持多种路由协议（如 OSPF、BGP、IS-IS 等），实现设备间路由信息的交换与管理。 交换与转发：支持数据帧的交换与数据包转发功能，可通过配置 VLAN、ACL 等模块实现流量控制。 安全管理：提供防火墙、VPN、AAA（认证、授权和计费）等安全功能，保障网络安全。 网络虚拟化和智能选路：支持网络虚拟化（如 VXLAN 等）与智能选路，优化资源利用与流量管理。 操作和监控：通过 CLI 进行设备配置与管理，支持 SNMP 等工具实现设备监控与故障排查。 VRP 用户等级： 访客用户（1 级）：仅能执行基本的查看命令，如 ping，tracert。 普通用户（2 级）：具备部分配置权限，可以配置路由的各个网络层次。 特权用户（3-15 级）：拥有最高权限，可以执行所有配置、维护和管理命令。 TCP/IP 四层模型概述 应用层： 功能：为应用程序提供通信服务。 协议：HTTP/HTTPS、FTP、DNS、SSH 等。 重点：用某种**应用协议**，决定数据如何格式化与传送。 传输层： 功能：提供端到端的进程间通信。 协议：TCP（可靠）和 UDP（不可靠），NAT（ip 转 ip），DHCP（自动分配 ip，子网掩码，默认网关） 端口号：使用源端口和目标端口标识应用进程。 重点：通过**端口号**确定进程间通信。 网络层： 功能：负责数据包的路由与转发，有多个路由器互相链接 协议： IPInternet Protocol 网络协议：使用 IP 地址区分不同网络设备（路由器，主机）。 ICMP：用于错误报告和网络诊断，如ping和tracert命令。 ARPAddress Resolution Protocol 地址解析协议：用于将 IP 地址转换为 MAC 地址 ACL：访问控制列表 OSPF：开放最短路径优先算法 重点：通过**IP 地址**确定数据传输路径和目标设备。 接口层（数据链路层）： 功能：处理局域网内的设备间数据传输，路由器下面有多个设备 协议：Ethernet（有线链接）、Wi-Fi（无线连接）。 VLAN：虚拟局域网 STP：生成树协议 MAC 地址：使用源 MAC 和目标 MAC 地址识别设备。 重点：通过**MAC地址**确保数据传输到正确的设备。 家庭网络通信图： 下面的内容按照 TCP/IP 四层模型的顺序编写 一, 接口层 掌握以太网交换的基本流程，学习 MAC 地址的概念及学习机制，包括 MAC 地址表的构建和维护原理。 CSMA/CD （Carrier Sense Multiple Access with Collision Detection，载波监听多路访问/碰撞检测） 用于解决多台设备在共享传输介质上发送数据时的冲突问题。 载波监听：设备在发送数据之前，先监听共享的网络介质（如以太网电缆），检查是否有其他设备在发送数据。 多路访问：多台设备都可以通过同一条物理链路发送数据，但需要确保没有冲突。 碰撞检测：如果两个设备同时开始发送数据，发生碰撞后，设备会停止发送，等待随机的一段时间后再重新尝试发送。 由于现在以太网大多采用交换机，实现了全双工通信，CSMA/CD 已经在现代交换式网络中逐渐不再使用。但在早期的共享式网络（如集线器网络）中，它是确保数据顺利传输的关键机制。 1. MAC 地址 Media Access Control Address，介质访问控制地址，是一个 12 位（十六进制）的硬件地址 主要用于标识具体设备。 MAC 地址的结构可以分为前 3 字和后 3 字节： MAC 地址结构详解 前 24 位（组织唯一标识符，OUI）： 用于标识设备制造商OUI（Organizationally Unique Identifier，组织唯一标识符），由 IEEE（Institute of Electrical and Electronics Engineers，电气与电子工程师协会）分配给不同制造商。 后 24 位（设备唯一标识符，Device Identifier）： 用于标识设备。厂商会确保分配的每个设备都有唯一的标识符。 前两字节特殊位解释 举例说明： 02:00:00:00:00:01 —— 第一个字节是 02，二进制为 00000010，最后一位是 0，表示单播地址（点对点传输） 01:00:5E:00:00:01 —— 第一个字节是 01，二进制为 00000001，最后一位是 1，表示组播地址（发送给一组设备） 如果第一个字节最后一位是 1,通常表示组播地址 交换机的工作原理 交换机根据 MAC 地址表 决定如何处理数据帧，主要包括以下操作： 学习 MAC 地址： 交换机通过接收帧时的源 MAC 地址学习设备位置，并将其记录在 MAC 地址表中。 MAC 地址表查找： 如果目标 MAC 地址在 MAC 地址表中，数据帧会被转发到对应的出接口。 如果目标 MAC 地址不在 MAC 地址表中，数据帧会进行泛洪，即发送到除接收端口以外的所有端口。 如果是广播帧或组播帧，默认会进行泛洪处理。 数据帧处理： 如果帧有错误（如 CRC 校验失败）或受到访问控制列表（ACL）限制，数据帧会被丢弃。 在某些情况下（如无效帧类型），数据帧可能被不处理。 2. VLAN-虚拟局域网 （Virtual Local Area Network，虚拟局域网）：包括VLANIF（VLAN Interface，VLAN 接口）、MUX VLAN（Multiplex VLAN，多路复用 VLAN，用于隔离 VLAN 间的通信）和VLAN 聚合的技术原理及应用场景。 VLAN 经常用于隔离广播域！！！ 链路聚合、堆叠和集群： Trunk-聚合链路 Eth-Trunk（Ethernet Trunk，以太网汇聚链路）也是同一个意思 是一种交换机端口模式（注意是交换机的物理端口），用于多个 VLAN 的数据通过一个物理链路传输（用于聚合链路）。 Trunk 端口在数据帧中插入 VLAN 标签，以标识数据属于哪个 VLAN，确保数据包可以正确路由到目标 VLAN。 Trunk 的原理 Trunk 端口的主要作用是通过 VLAN 标签（Tagging）在一个物理接口上承载多个 VLAN 的数据。 用以下关键元素来实现其功能： VLAN Tagging（VLAN 标记）： 在 Trunk 端口上传输的数据帧中会插入一个 VLAN 标签字段，称为802.1Q 标签。 VLAN 标签在数据帧的源地址和以太网类型字段之间插入，包含 VLAN ID 等信息。 VLAN ID：使用 12 位字段，范围从 0 到 4095，标识数据包属于哪个 VLAN。 当数据帧在 Trunk 端口上传输时，源交换机会根据该帧的 VLAN 标签识别其 VLAN，确保数据到达目标交换机后可以正确路由到对应的 VLAN。 Native VLAN（本地 VLAN）： Trunk 端口可以设置一个 Native VLAN，默认情况下 Native VLAN 的数据帧不携带 VLAN 标签。 通常用于传输不打标签的数据流量或不支持 VLAN 的旧设备。 Native VLAN 通常设置为与其他 VLAN 隔离的数据流量，以防止标签未匹配的流量进入不正确的 VLAN。 VLAN 帧封装方式： 常见的 Trunk 帧封装方式是802.1Q，即 IEEE 定义的标准方式，支持 VLAN ID 的打标签。 Trunk 的配置方法 假设在交换机上配置端口为 Trunk 模式，允许 VLAN 10、20 和 30 通过，Native VLAN 为 99，配置示例如下： # 进入接口配置模式Switch(config)# interface GigabitEthernet0/1# 将端口设置为Trunk模式Switch(config-if)# switchport mode trunk# 指定允许通过的VLAN列表Switch(config-if)# switchport trunk allowed vlan 10,20,30 完成配置后，GigabitEthernet0/1 端口将作为 Trunk 端口，允许 VLAN 10、20 和 30 的数据帧通过 iStack（Intelligent Stack，智能堆叠）：将多个交换机虚拟成一个逻辑交换机以便统一管理。 CSS（Cluster Switching System，集群交换系统）：将多台设备集群为一体。 3. STP-生成树协议 STP（Spanning Tree Protocol，生成树协议）是一种在网络中用于防止环路的协议，适用于交换机。当网络中存在多个冗余链路时，可能会形成网络环路，导致广播风暴、MAC 地址表异常等问题。STP 通过选择性地阻塞冗余路径，确保网络中只有一条无环路径到达每一个网络节点，形成一棵“生成树”。 STP 协议主要通过桥协议数据单元（BPDU, Bridge Protocol Data Unit）进行通信和决策。BPDU 是一种包含拓扑信息的帧，用于交换机之间的通信，以确定网络拓扑和优先路径。下面我们详细介绍 STP 的工作原理和 BPDU 的组成及其功能。 STP 的工作原理 STP 的基本过程包括选择根桥、确定每个非根交换机的根端口和指定端口，并通过阻塞不必要的链路来避免环路。以下是 STP 的主要步骤： 根桥的选举： 在 STP 网络中，所有交换机会通过 BPDU 的交换来选举根桥（Root Bridge）。根桥是整个生成树的中心，所有的网络路径都会以根桥为基准建立。 每个交换机在启动后都会认为自己是根桥，并发送 BPDU 进行“竞选”。最终 BPDU 中具有最低桥 ID（Bridge ID）的交换机会成为根桥。 桥 ID由桥优先级（Bridge Priority）和 MAC 地址组成，优先级较低的交换机更容易成为根桥。 根端口的选择： 在每个非根交换机上选择一个最短路径到达根桥的端口，称为根端口（Root Port）。 根端口是非根交换机上连接到根桥的最佳路径，用于转发到根桥的流量。 指定端口的选择： 在每个网络段中，选出唯一一个交换机端口作为该网络段的指定端口（Designated Port），负责为该段提供到根桥的最短路径。 指定端口通常是该网络段中连接到根桥路径最短的端口，用于转发流量。 非根桥上的阻塞端口： 非根桥上，除了根端口和指定端口之外的其他端口将被置为阻塞状态，不转发流量。 阻塞端口用于防止形成环路，但在主链路故障时可以自动激活以维持连通性。 IEEE 802.1D IEEE 802.1D 是关于 STP 的一种标准，主要用于局域网（LAN）中防止环路的出现。 BPDU-生成树协议的数据包 BPDU（Bridge Protocol Data Unit）桥协议数据单元。是生成树协议（STP）中的一种数据包，用于交换机之间传递信息，以维护生成树拓扑和防止环路。 BPDU 里面最重要的参数是 BID（Bridge ID，桥接 ID），BID 由两部分组成：优先级（默认值为 32768，范围 0-65535）和 MAC 地址。 较小的 BID 值优先级更高，优先级最小的会被选做为根桥 TCN BPDU TCN BPDU（Topology Change Notification BPDU）（拓扑更改通知 BPDU）是特殊的 BPDU 数据包，用于通知网络拓扑结构发生了变化。STP 网络中的交换机发生端口状态变化时，会生成 TCN BPDU，以便让根桥更新拓扑信息并通知其他交换机进行调整。 当一个交换机检测到链路变化时（例如端口从阻塞状态变为转发状态，或者反之），会发送 TCN BPDU 给其上行设备，逐跳发送至根桥。 根桥收到 TCN BPDU 后，将触发网络中所有交换机缩短其 MAC 地址表的老化时间，使网络迅速适应新拓扑。 STP 端口状态 STP 端口的状态转换帮助避免环路，端口在 STP 中的典型状态如下： 阻塞（Blocking）：初始状态，阻塞状态不转发数据流量，只监听 BPDU。 侦听（Listening）：交换机检测到拓扑变更后进入侦听状态，接收和发送 BPDU，不学习 MAC 地址表。 学习（Learning）：继续监听 BPDU，同时开始学习 MAC 地址表，但不转发数据流量。 转发（Forwarding）：正常工作状态，转发数据流量并学习 MAC 地址表。 禁用（Disabled）：端口被手动禁用或无连接，不参与 STP 过程。 4. RSTP-快速生成树协议 RSTP（Rapid Spanning Tree Protocol，快速生成树协议）是对传统生成树协议（STP）的改进，比 STP 更快更好。 RSTP 的主要特点与改进 RSTP 在 STP 的基础上做了以下几个关键改进： 更快的收敛时间： RSTP 通过将端口直接从阻塞状态转换到转发状态，无需像 STP 那样等待侦听（Listening）和学习（Learning）两个阶段，这样能够加速网络故障恢复时间。 可设置备用端口： 简化的端口状态： RSTP 将端口状态从 STP 的五种状态减少为三种：丢弃（Discarding）、学习（Learning）和转发（Forwarding）。丢弃状态相当于 STP 中的阻塞状态。 丢弃状态避免了数据包的转发，但仍然允许 BPDU 的处理和交换。 边缘端口（Edge Port）： RSTP 的边缘端口（Edge Port）类似于 STP 的 PortFast 端口。边缘端口直接连接终端设备，可直接进入转发状态，不做生成树计算 只有在检测到环路时边缘端口会退出快速模式，进入普通的 RSTP 计算。 RSTP 的 BPDU类型和改进 RSTP 的 BPDU 格式与 STP 类似，但包含了额外的字段以支持快速收敛机制。 BPDU 类型和拓扑变化通知： RSTP 的 BPDU 始终以“Hello”方式发送，每隔 2 秒发送一次，不像 STP 需要等待上行设备来中继 TCN BPDU（拓扑变化通知）。 当发生拓扑变化时，RSTP 直接通过 BPDU 通知邻居交换机，并触发相邻设备更新拓扑状态。 快速回收： RSTP 交换机能够通过检测链路的物理状态变化来判断端口是否断开或重新连接。这样，在端口恢复时，不需要依赖配置 BPDU 的老化时间，即可判断链路状态并快速转为转发。 在 RSTP（快速生成树协议）的 BPDU 报文中，Flag 字段的总长度为 8 比特（即 1 字节）。 该字段包含了多个用于拓扑管理的信息位，其中包括指示拓扑变化、端口角色、端口状态等关键位，帮助 RSTP 实现快速收敛和拓扑更新。 5. MSTP （Multiple Spanning Tree Protocol，多生成树协议）不考 6.LACP（Link Aggregation Control Protocol，链路聚合控制协议） LACP 是 IEEE 802.1AX 标准的一部分，用于在交换机或网络设备之间聚合多个物理链路形成一个逻辑链路，从而提高带宽和冗余性。 LACP 通过自动协商链路聚合的配置，增强了链路的可靠性和传输效率。 二, 网络层 IP 数据报 ip 数据包首部部分详解 1、版本：从图中可以看到，版本字段占 4 位。记录着通信双方使用的 IP 协议版本，比如 IPv4、IPv6，目前广泛使用的是IPv4。 2、首部长度：占 4 位，表示的单位为 4 字节，比如 1111（十进制的 15）就代表首部长度为 60 字节（15*4=60）.以 4 字节的整数倍划分，不足则填充。最常用的首部长度为 0101（20 字节）。 3、区分服务：占 8 位： DSCP（Differentiated Services Code Point，区分服务代码点） 功能：为 IP 数据包设置优先级，提供 QoS 管理 以便网络设备（如路由器、交换机等）可以根据这些优先级来调度和管理流量，从而实现网络资源的合理分配，满足各种应用对带宽、延迟、抖动等的要求。 DSCP 字段位置： 对于**IPv4 数据包，DSCP 使用8位的服务字段中的前**6 位；对于 IPv6 数据包，它位于流量分类字段中。 DSCP 值的定义： DSCP 的 6 个位可组合成 64 个不同的值（从 0 到 63），每个值可以用来代表不同的流量优先级。通常，网络管理员会将这些值划分为若干类，如“默认流量”、“保障流量”、“最高优先级”等，以区分不同的数据流。比如，语音和视频流量一般会被设置为较高的优先级，以减少延迟和抖动，而普通的网页浏览和邮件流量则优先级较低。 常用在： 企业网络：在企业网络中，可以通过 DSCP 对语音、视频和数据流量进行分类，确保语音和视频等延迟敏感的应用优先通过，提升通话和会议质量。 ISP 网络：在 ISP（互联网服务提供商）网络中，DSCP 可以用于管理客户流量，确保高优先级的客户业务在网络高负载时仍能得到保障。 数据中心：数据中心内部流量种类繁多，通过 DSCP 区分不同流量（如存储数据、虚拟机迁移等）可以有效保证各类业务的服务质量。 配置 DSCP DSCP 配置通常在网络设备的 QoS 配置中完成。管理员可以在数据包进入网络时根据应用类型或用户需求为数据包设定 DSCP 值，也可以通过网络设备（如路由器、交换机）对经过的流量自动设置或重写 DSCP 值。 示例： //复制代码在网络设备上，为所有发往特定应用服务器的数据包标记DSCP为“EF”（即DSCP值为46）：policy-map voice-policy class voice set dscp ef 4、总长度 即首部长度和数据长度之和。占 16 位。因此，最大长度可知为 16 位都是 1，就是65535 字节。 在 IP 层下层数据链路层存在自己的帧格式，帧格式的数据字段最大传送单元（MTU）是 1500 字节。尽可能长的数据报能够提高传输效率，实际中数据报长度很少大于 1500 字节。所以，IP 标准规定：所有主机和路由器的 IP 数据报长度不能小于 576 字节。 如果数据报长度超过 MTU，则将进行分片后再传送，与后面的片偏移相关。然后总长度就成了分片后每个分片的首部和数据的长度之和。 5、标识 占 16 位。在实际 IP 中，维持了一个计数器，每产生一个数据报，计数其加 1，存放到该字段。IP 是无连接服务，不存在按序接收问题，该标识不是序号，而是在进行分片之后对相同的数据报进行标识，属于同一个数据报的标识相同，以便到达目的后被重新封装为原来的数据报。 6、标志 占 3 位。目前使用 2 两位有意义的。 最低位：MF（More Fragment）还有分片，MF=0 时说明是最后一个分片。 中间位：DF（Don‘t Fragment）不能分片，DF=0 时才能分片。 7、片偏移 占 13 位。用于记录较长分组中，一个分片在原数据报中的相对位置。片偏移以 8 字节为单位，长度是 8 字节的整数倍。 假设一个数据报总长度为 3820 字节。首部 20 字节和数据 3800 字节。现在要求长度不超过 1420 字节，那么它的每个分片为多少呢？ 我们简单分析一下，数据部分尽可能长的可以分为 1400,1400,1000 三个分片，这样再加上首部满足小于 1420 字节。 分片一：0-1399 字节，因此片偏移=0/8=0 分片二：1400-2799 字节,片偏移=1400/8=175 分片三：2800-3800 字节,片偏移=2800/8=350 很容易就计算出每个分片的片偏移。 8、生存时间 **TTL（Time To Live）**占 8 位。最大值 255.是一个用于限制数据包生存时间的计数器 它表示数据包可以经过的**最大路由跳数**（可以经过多少个路由器）。 不同操作系统发送 ICMP 报文的 TTL 默认值不同，例如： Windows 系统的默认 TTL 是 128。 Linux 和 Unix 系统的默认 TTL 是 64。 9、协议 占 8 位。指明数据报携带的数据是使用什么协议，方便目的主机的 IP 层将数据交给对应的程序处理，这里列举常用的几个。 协议 ICMP IGMP TCP UDP OSPF 字段值 1 2 6 17 89 10、首部检验和 占 16 位。只校验数据报首部，不包括数据部分。这样可以减少计算量，同时不采用复杂的 CRC 检验码，而是使用简单的**反码算术运算**。 反码算术运算：将数据报首部划分为多个 16 位的序列，16 位序列相加之和取反码，写入检验和。接收方再将首部 16 位序列（包含检验和的 16 位）相加之和取反码，结果为 0 则说明数据报正确，否则丢弃。 ip 地址，子网，广播地址计算题举例 IPSec（Internet Protocol Security，IP 包加密） 是一套协议和标准，用于在 IP 网络（如互联网或私有网络）上实现数据包的加密、认证、数据完整性验证和重放保护。 主要应用于 VPN（虚拟专用网络）中，确保在公网传输的数据安全可靠。 IPSec 工作在网络层，能够保护所有基于 IP 的应用，不需要应用层的额外支持。 IPSec 的两种工作模式 传输模式（Transport Mode）：IPSec 只加密 IP 数据包的数据部分，而保留 IP 头部。 这种模式通常用于端到端的加密通信，适合在两个主机之间的直接通信中使用。 隧道模式（Tunnel Mode）：IPSec 将整个 IP 数据包（包括头部和有效负载）进行加密，并封装在一个新的 IP 头部中。 这种模式常用于 VPN 应用，因为它可以保护整个数据包在不安全的网络中传输，适合网关到网关的加密通信。 ICMP（Internet Control Message Protocol，互联网控制消息协议） 是互联网协议族中的一种核心协议，位于 IP 协议的上层。 它主要用于传输控制信息和错误报告，以帮助管理和诊别网络中的问题。 ICMP 是一种特殊的数据，用来报告网络通信中的错误情况或传递控制消息。 ICMP 协议的功能： 错误报告：当 IP 层无法传输数据时，ICMP 协议会通知源主机，以便做出相应的调整。 网络诊断：如**ping**命令测试和目标 ip 的连通性 . 路由诊断：通过“路由跟踪”命令（tracert）诊断数据包经过了那些路由器 路由技术 路由负责在不同网段之间转发数据包 1. 静态路由 静态路由是手动配置的路由。 IPv4 静态路由配置： 配置命令通常为ip route 目标网段 子网掩码 下一跳地址。 例如：ip route 192.168.1.0 255.255.255.0 192.168.2.1。 IPv6 静态路由配置： IPv6 静态路由的配置类似于 IPv4，但需要使用 IPv6 地址。 配置命令为ipv6 route 目标IPv6网段 下一跳IPv6地址。 例如：ipv6 route 2001:db8:1::/64 2001:db8:2::1。 IPv4 地址分类： 类别 地址范围 默认子网掩码 用途 起始位 A 类 0.0.0.0 - 127.255.255.255 255.0.0.0 适用于大型网络（公网），最多可容纳 1677 万个主机 0 B 类 128.0.0.0 - 191.255.255.255 255.255.0.0 适用于中型网络（大型局域网），最多可容纳 6.5 万个主机 10 C 类 192.0.0.0 - 223.255.255.255 255.255.255.0 适用于小型网络（局域网），最多可容纳 254 个主机 110 D 类 224.0.0.0 - 239.255.255.255 不适用 多播地址，专用于组播 1110 E 类 240.0.0.0 - 255.255.255.255 不适用 预留地址，通常用于科研实验和未来用途 1111 2. OSPF（Open Shortest Path First，开放最短路径优先算法） 和 ICMP 一样，存在 IP 数据报最后的数据部分。 OSPF是一种链路状态协议，通过路由协议实现最佳路由路径选择。 OSPF 的基本原理： 将网络划分为不同区域，每个区域使用链路状态广告（LSA）传播拓扑信息。 每个路由器都维护一个链路状态数据库（LSDB），并使用该数据库计算最佳路径。 其有五种主要报文： Hello 报文（Hello Packet）：用于邻居发现和维持邻居关系。 DBD 报文（Database Description Packet）：描述链路状态数据库概要信息，用于同步状态数据库。 LSR 报文（Link State Request Packet）：请求缺失的链路状态信息。 LSU 报文（Link State Update Packet）：传输链路状态更新信息。 LSAck 报文（Link State Acknowledgment Packet）：确认接收到的链路状态信息。 OSPF 邻居状态： Down：没有收到 Hello 报文，邻居关系尚未建立。 Init：接收到 Hello 报文，但未确认双向通信。 2-Way：确认双向通信，邻居关系建立，但未进行数据库同步。 ExStart：确定主从关系，开始交换数据库信息。 Exchange：交换 DBD 报文，同步链路状态数据库概要信息。 Loading：通过 LSR 和 LSU 报文请求并补充缺失的链路状态信息。 Full：邻居同步完成，达到完全邻接状态。 发送顺序说明： OSPF 首先通过 Hello 报文 建立并维护邻居关系（从 Down 到 2-Way）。 邻居关系建立后，路由器进入 ExStart 和 Exchange 状态，交换 DBD 报文，同步链路状态数据库的概要信息。 如果数据库中有缺失信息，路由器进入 Loading 状态，发送 LSR 报文 请求补充。 收到 LSR 后，邻居通过 LSU 报文 提供更新的链路状态信息。 最后，接收方通过 LSAck 报文 确认收到的 LSU，确保数据一致性，进入 Full 状态。 在 OSPF（Open Shortest Path First）协议中，DR（Designated Router，指定路由器）是一种特殊的路由器角色，主要用于多访问（Multi-Access）网络类型，例如互联网。DR 的引入可以减少 OSPF 邻居关系的数量，从而降低网络的开销和收敛时间。下面是 DR 的详细解释： 2.1 DR（Designated Router，指定路由器） 在一个多访问网络上，每台路由器都可以与其它路由器建立邻居关系。如果不使用 DR，N 台路由器会形成 (N×(N−1)/2)(N \\times (N - 1) / 2)(N×(N−1)/2)个邻居关系，这样会带来大量的 Hello、LSA（Link State Advertisement，链路状态通告）和 LSU（Link State Update，链路状态更新）信息，影响网络性能。DR 的引入简化了这些情况情况： DR 在该多访问网络上集中管理和维护所有 OSPF 邻居关系。 其它路由器只需与 DR（以及备份 DR，BDR）建立邻居关系，而不必直接与网络中的所有其它路由器建立关系。 DR 负责在网络中生成和分发该网络的 LSA，使所有路由器能够了解该网络的状态信息。 . DR 选举 在 OSPF 网络启动时，每台路由器在网络中通过 Hello 报文参与 DR 和BDR（Backup Designated Router，备份指定路由器）的选举过程。选举基于以下两个条件： 优先级：路由器接口的 OSPF 优先级（Priority）决定选举的优先级。值越大，优先级越高。优先级范围为 0 到 255，缺省值为 1。如果优先级设置为 0，则该路由器不会参与 DR 或 BDR 的选举。 Router ID：如果优先级相同，则根据 Router ID（通常为路由器最高 IP 地址）选择优先级更高的路由器。 在完成选举后，DR 负责维护网络的 OSPF 状态和拓扑变化，BDR 在 DR 失效时自动接替 DR 的角色，以保证网络稳定性。 DR 和 BDR 的工作方式 在多访问网络中，除 DR 和 BDR 以外的所有路由器都称为 DROther。 DROther 路由器只与 DR 和 BDR 建立邻居关系，并将所有的 LSA 更新发送给 DR。 DR 接收 DROther 路由器的更新后，将其转发给整个多访问网络的其他路由器。 BDR不主动参与数据转发，但在 DR 故障时会立即接管成为新的 DR。 配置示例！！！！！ 在 OSPF 配置中，可以通过设置接口的优先级来影响 DR 选举。例如： interface GigabitEthernet0/0ip ospf priority 100 此配置将接口的优先级设置为 100，使其更可能被选举为 DR。 3. OSPFv3（OSPF 协议的 IPv6 版本） OSPFv3是 OSPF 协议的 IPv6 版本，用于 IPv6 网络中，实现了对 IPv6 地址格式的支持。 OSPFv3 的基本原理： 类似于 OSPF，OSPFv3 也使用 LSA 广播链路状态。 OSPFv3 的路由器 ID 仍然是 32 位，与 IPv4 无关。 OSPFv3 配置： 进入 OSPFv3 配置模式：ipv6 router ospf 进程号。 配置网络：在接口模式下使用ipv6 ospf 进程号 area 区域号。 例如： ipv6 router ospf 1interface GigabitEthernet0/0ipv6 ospf 1 area 0 缺省情况下，在以太网链路上发送 OSPFv3 Hello 报文的周期为 10 秒。这个时间间隔用于 OSPFv3 邻居之间的状态保持和链路检测，确保邻居关系的正常建立和维持。 4. IS-IS（Intermediate System to Intermediate System，中间系统到中间系统） IS-IS是一种链路状态路由协议，广泛应用于服务提供商网络中。IS-IS 最初设计用于 OSI 网络模型，后续加入了对 IPv4 和 IPv6 的支持。 IS-IS 的基本原理： 使用 CLNS（Connectionless Network Service）协议承载路由信息。 IS-IS 将网络划分为不同等级（Level），支持多层级结构。 IS-IS 配置： 基本配置：进入 IS-IS 进程router isis 进程号。 配置网络：进入接口模式，指定接口类型。 例如： router isis 1net 49.0001.1921.6800.1001.00interface GigabitEthernet0/0isis enable 5. BGP（Border Gateway Protocol，边界网关协议） BGP是一种自治系统间的路由协议，用于跨多个自治系统传输路由信息。 更注重路由的可靠性和安全性，以及大规模网络的可扩展性 BGP 的两个版本包括 BGP4（IPv4 路由）和 BGP4+（IPv6 路由）。 BGP 的基本原理： 使用路径向量协议，包含自治系统路径信息以避免环路。 BGP 通常应用于大型互联网或运营商网络中，提供灵活的路径选择能力。 BGP 配置： 例如： #启用BGP（Border Gateway Protocol，边界网关协议），并设置本地自治系统（AS）编号为100#格式：router bgp AS号router bgp 100#配置一个BGP邻居，其IP地址为192.168.1.1，远程自治系统（AS）编号为200#格式：neighbor 邻居地址 remote-as 邻居AS号neighbor 192.168.1.1 remote-as 200 6. ACL（Access Control List，访问控制列表） ACL 在路由器上用于控制网络流量，可以基于源/目的地址、端口等条件对数据包进行允许或拒绝操作。ACL 广泛用于流量过滤和访问控制。 ACL 的原理： 类型分类： 标准 ACL：仅基于源地址进行匹配。 扩展 ACL：可基于源/目的地址、协议类型、端口号等多种条件匹配。 匹配机制： 缺省情况下，ACL 的规则按照配置顺序（即 config 模式）进行匹配。 匹配顺序与规则的精确度无关，不会按精确度从高到低进行匹配。 报文一旦匹配某条规则（无论是允许 permit 还是拒绝 deny），则停止匹配后续规则。 不论匹配结果是 permit 还是 deny，只要匹配到规则，就视为成功匹配。 ACL 的分类与编号范围： 四层 ACL： 基本 ACL（2000-2999）：基于源 IP 地址。 高级 ACL（3000-3999）：基于五元组（源/目的地址、端口号、协议等）。 二层 ACL（4000-4999）：基于链路层（如 MAC 地址）。 用户自定义 ACL（5000-5999）：灵活定义匹配规则。 用户 ACL（6000-6999）：特定用途的访问控制规则。 ACL 的应用场景： 流量过滤：控制进出接口的数据流量，提升网络安全性。 访问权限控制：限制特定设备或用户的网络访问权限。 ACL 配置： #创建一个标准访问控制列表（ACL），编号为10，允许来自192.168.1.0/24子网的流量#格式为：access-list 编号 permit/deny 条件access-list 10 permit 192.168.1.0 0.0.0.255#进入GigabitEthernet0/1接口的配置模式interface GigabitEthernet0/1#在GigabitEthernet0/1接口上应用编号为10的ACL，方向为入站（in），即控制进入该接口的流量#ip access-group 编号 in/outip access-group 10 in 7. IP Prefix List （前缀列表） IP Prefix List 是一种更精细的 ACL，用于定义 IP 前缀和长度范围，以便灵活控制路由选择。 IP Prefix List 的原理： 前缀列表提供了一种比 ACL 更有效的路由过滤方式，特别是在 BGP 环境中。 IP Prefix List 配置： 创建前缀列表：ip prefix-list 名称 seq 序号 permit/deny 前缀。 应用到路由协议：在 BGP 配置模式中应用前缀列表。 例如： #创建一个名为FILTER的前缀列表，序列号为5，允许192.168.0.0/16网段内前缀长度不超过24的路由#格式为：ip prefix-list 名称 seq 序号 permit/deny 前缀ip prefix-list FILTER seq 5 permit 192.168.0.0/16 le 24#进入BGP模式，AS号为100router bgp 100#对邻居192.168.1.1应用名为FILTER的前缀列表，方向为入站（in），即控制从该邻居接收的路由neighbor 192.168.1.1 prefix-list FILTER in 8. 路由策略和策略路由 路由策略和策略路由用于控制路由表的生成和路由选择，帮助管理员在复杂网络中自定义流量转发行为。 路由策略和策略路由配置： 例如： # 创建名为SET_METRIC的路由映射，允许符合条件的流量。route-map SET_METRIC permit 10# 匹配访问列表10中的IP地址。match ip address 10# 将匹配到的路由度量值设为50。set metric 50# 进入GigabitEthernet0/1接口配置。interface GigabitEthernet0/1# 在GigabitEthernet0/1接口上应用SET_METRIC路由映射。ip policy route-map SET_METRIC 广域网技术 广域网（WAN）是连接多个局域网（LAN）或城域网（MAN）的大范围网络 1. PPP（Point-to-Point Protocol，点对点协议） PPP 是一种用于在两个网络节点之间建立直接连接的协议，适合通过电话线、串口、光纤或无线链路进行通信。PPP 的典型应用是拨号连接，广泛用于宽带拨号上网以及远程访问等场景。 工作过程 PPP 的工作过程可分为以下几个阶段： 链路建立阶段：双方节点通过链路控制协议LCP（Link Control Protocol）进行协商，建立并配置链路的参数（如最大传输单元 MTU、链路质量等）。 鉴权阶段：LCP 链路建立后，双方根据需要进行身份验证，确保合法访问。通常使用 PAP 或 CHAP 进行认证。 网络层协议协商阶段：链路建立并通过鉴权后，网络控制协议 NCP（Network Control Protocol）协商使用的网络层协议（如 IPv4 或 IPv6），配置 IP 地址等。 数据传输阶段：完成链路建立和协议协商后，双方可以在链路上进行数据传输。PPP 将上层协议数据帧封装后传输，具备一定的安全和传输稳定性。 链路终止阶段：传输完成后，LCP 终止链路，断开连接。 LCP（Link Control Protocol，链路控制） LCP 是 PPP 协议的一部分，负责在两台设备之间建立、配置、测试和维护点对点链路。 LCP 使用 魔术字（Magic Number） 参数来检测链路环路和其他异常情况。 魔术字是 LCP 协议在协商时使用的一个随机数，用来检测环路和其他链路问题。 在 LCP 协商过程中，每一端都会生成一个唯一的魔术字并将其附加到数据包中。 如果一端设备接收到的数据包中的魔术字和自己发送的一致，意味着数据包被环回了，可能存在链路环路或其他异常。 2. PPPoE（Point-to-Point Protocol over Ethernet，以太网点对点协议） 在以太网链路上运行 PPP 协议，用于在宽带连接中实现用户认证和计费功能，适用于 DSL 或光纤接入的用户。 PPPoE 能够在广域网环境中有效管理网络连接，支持多个用户通过单一物理连接接入广域网。 以太网类型 0x8863：这个值标识了 PPPoE 的**发现阶段通信**，即客户端和服务器之间用来发现、建立连接的报文类型。 PPPoE 发现阶段（Discovery Phase）的所有报文都使用此以太网类型值。 以太网类型 0x8864：用于 PPPoE**会话阶段**的通信，指的是在客户端和 PPPoE 服务器建立会话后进行的数据传输阶段。 IPv6 技术 太复杂了，不想学 IPv6 基础知识：了解 IPv6 协议及地址相关概念 IPv6 地址配置：了解 ICMPv6 和 IPv6 无状态自动配置 IPv6 过渡技术：掌握双栈、6PE、6VPE、NAT64 等过渡技术的原理及配置 三, 传输层 TCP/IP 协议 TCP/IP 协议架构是网络通信的基础，它是互联网和局域网（LAN）通信的核心协议。TCP/IP 架构由多个协议层次组成，每个层次负责不同的网络任务，确保数据从源端传输到目的端的正确性和可靠性。 TCP/IP 协议体系结构通常分为四层： 应用层：包括最接近用户的协议，处理具体应用的数据传输。例如：HTTP、FTP、SMTP 等。 传输层：主要负责端到端的数据传输，确保数据包的可靠性。包括 TCP（传输控制协议）和 UDP（用户数据报协议）。 网络层：负责数据包的路由选择与转发，确保数据从源端到目的端。最重要的协议是 IP（互联网协议）。 数据链路层：包括物理层和数据链路层，负责数据帧的封装和传输，确保数据在物理网络中传递，常用协议如 Ethernet。 各种协议技术 TCP（Transmission Control Protocol，传输控制协议） TCP 是面向连接的协议，提供可靠的数据传输。 工作原理： 三次握手：客户端向服务器发送连接请求，服务器确认后再返回确认，最后客户端再确认，建立连接。 数据传输：传输的数据被分为多个数据包，按顺序发送，接收端通过确认应答（ACK）确认数据包接收。 四次挥手：当传输结束时，客户端和服务器通过四次挥手断开连接。 配置：在应用程序中使用socket()调用创建 TCP 连接，通过端口号进行通信。 UDP（User Datagram Protocol，用户数据报协议） UDP 是无连接协议，它提供数据报文传输，但不可靠。主要用于那些对实时性要求高、允许丢包的应用，如视频流、语音通话等。 工作原理：数据包通过 IP 层发送，但不进行握手或错误恢复。UDP 数据包通过源端口和目标端口识别应用进程。 配置：在应用程序中使用socket()创建 UDP 连接，发送和接收数据报文。 ARP（Address Resolution Protocol，地址解析协议） ARP 用于将 IP 地址转换为 MAC 地址。网络中设备通过 ARP 请求可以得知其他设备的 MAC 地址，从而能够在数据链路层发送数据帧。 配置：ARP 通常自动运行，但可使用arp命令查看或手动修改 ARP 表。 免费 ARP（Gratuitous ARP） **是设备通过广播发送的一种特殊 ARP 报文，用于主动通知网络中其他设备自己的 IP 和 MAC 地址。**它主要用于检测 IP 地址冲突、更新 ARP 缓存表、支持冗余设备切换（如 VRRP），以及维护网络通信一致性。免费 ARP 的目标地址是自己，接收设备无需回复，常见于设备上线、IP 地址变更或冗余切换场景中。 IP（Internet Protocol，互联网协议） IP 协议的目标是将数据包从源地址发送到目标地址，依赖路由器进行路径选择。 工作原理：IP 将数据分成数据包，并根据目的地址路由。常见的版本为 IPv4（32 位）和 IPv6（128 位）。 配置：可以手动进行 IP 地址的配置，或通过 DHCP 动态获取 IP。 NAT（Network Address Translation，网络地址转换） 功能：NAT 协议用于**将私有 IP 地址转换为公网 IP 地址，允许多个设备共享一个公网 IP 地址访问互联网。它通常在路由器**中实现。 工作原理：当内网设备请求访问外部网络时，NAT 会将内部私有 IP 地址转换为一个公网 IP 地址，确保外部网络能识别请求来源。 配置：NAT 在路由器或防火墙中配置，常见配置如源地址转换（SNAT）和目的地址转换（DNAT）。 Telnet（远程终端协议） Telnet 协议用于远程访问设备和管理服务器，以用于执行命令行操作。 它是无加密的协议，不安全，已逐渐被 SSH 取代。 通过 Telnet 客户端连接到远程设备的**23 端口**，进行命令输入和输出。 FTP（File Transfer Protocol，文件传输协议） FTP 客户端连接 FTP 服务器的**21 端口** FTP主动模式：服务器通过默认端口 21 接受客户端连接，并使用端口 20 进行数据传输。在此模式下，客户端需要开放一个端口，以便服务器主动连接以传输数据。 被动模式：手动配置客户端使用服务器开放的某个端口进行数据连接。客户端主动发起连接，适合在有防火墙的环境中使用。 DHCP（Dynamic Host Configuration Protocol，动态主机配置协议） 功能：DHCP 用于**自动为设备分配 IP 地址、子网掩码、默认网关**等网络配置，简化网络管理。 工作原理：设备启动时，DHCP 客户端通过广播向 DHCP 服务器请求配置，服务器分配一个 IP 地址及其他信息，并将配置返回给客户端。 配置：在 DHCP 服务器上配置地址池、租约时间等参数；客户端通常自动配置为 DHCP 模式，无需手动设置。 NAK （Negative Acknowledgement） 否定 DHCP 确认消息 当客户端收到 DHCP NAK 消息后，必须放弃原请求，重新开始 DHCP 流程，发送 DHCP Discover 消息，重新申请新的 IP 地址和网络配置信息。 四, 应用层 网络管理与网络编程自动化技术 网络管理与监控技术 1. SNMP（Simple Network Management Protocol，简单网络管理协议）： 功能：SNMP 是一种网络管理协议，用于在网络设备（如路由器、交换机、服务器）与管理系统之间传输管理信息。它允许管理员查看设备状态、性能数据并进行故障检测。SNMP 的工作通过管理信息库（MIB）进行，MIB 存储着设备的管理数据。 工作原理：SNMP 主要通过“请求-响应”机制工作。管理系统发送请求查询或设置设备信息，而设备返回相应数据。SNMP 的三种基本操作包括 GET（获取信息）、SET（设置信息）、TRAP（主动通知）。 配置：配置通常包括设定 SNMP 代理、MIB、访问控制等，确保监控数据的收集和传输安全有效。 1.1 NMS（Network Management System，网络管理系统） **NMS 是用于监控和管理计算机网络的工具或系统。**它的作用是监控网络设备（如路由器、交换机、服务器等）的状态、性能、故障等，确保网络的正常运行。NMS 可以进行设备配置、故障检测、性能分析以及安全管理。 2. LLDP（Link Layer Discovery Protocol，链路层发现协议） 功能：LLDP 是一种数据链路层协议，允许网络设备共享信息，自动发现和识别相邻的设备。它帮助管理员了解网络拓扑结构，提高网络管理和故障排查的效率。 工作原理：LLDP 通过在网络上周期性地发送 LLDP 数据单元（LLDPDU）进行邻居发现。这些数据包含设备标识、端口、系统信息等。每个 LLDPDU 通过一个特定的时间间隔更新，设备定期广播这些信息给相邻设备。 配置：管理员可以启用或禁用 LLDP 的广播，设定更新频率等。 3. NQA（Network Quality Analysis，网络质量分析） 功能：NQA 是用来分析和评估网络性能的工具。它通过定期发送探测数据包，收集网络时延、抖动、丢包率等信息，帮助管理员判断网络的整体健康状况和性能瓶颈。 工作原理：NQA 在指定的时间间隔内发送探测数据包到目标节点，然后根据响应的时间和质量来分析网络连接的性能参数。 配置：管理员需要设定目标 IP、测试类型、探测周期等，以便 NQA 能够在网络中执行监控任务。 网络安全技术 AAA（3A 安全认证） （Authentication, Authorization, Accounting，用户验证、用户授权和用户计费）： 功能：AAA 是一种网络安全框架，用于管理用户身份验证、权限控制和操作审计。它在确保网络资源安全的同时，使管理员能够追踪用户活动、控制权限及记录日志。 原理： 身份验证（Authentication）：用户通过提供凭据（如用户名、密码）来确认身份，服务器验证其身份以允许或拒绝访问。 授权（Authorization）：在验证身份后，服务器会根据用户角色分配适当的资源访问权限，确保用户仅能访问其权限范围内的资源。 计费（Accounting）：记录用户在系统中的操作日志，如访问时间、使用资源等，便于后续的审计和分析。 配置：AAA 通常通过 RADIUS 或 TACACS+等协议配置，管理员设定用户组权限、审计参数等，使 AAA 实现有效的访问控制和操作跟踪。 信息安全 信息安全基础 了解 TCP/IP 和 OSI 模型：掌握网络通信中的分层模型，特别是 TCP/IP 协议栈和 OSI 参考模型，为信息安全防护提供技术基础。 熟悉网络安全威胁防范：了解并防御常见安全威胁，如 DDoS 攻击、恶意软件、钓鱼网站，以及使用网络防护工具检测和防范威胁。 熟悉网络安全设备：掌握防火墙、入侵检测系统（IDS）、入侵防御系统（IPS）等设备的原理与配置。例如，防火墙可根据安全策略对流量进行过滤、转发或阻止，确保网络的边界安全。 信息安全管理技术 防火墙防护与趋势： 安全区域优先级：在华为防火墙中，每个安全区域都有一个唯一的优先级。 区域之间默认优先级从高到低的排序为：Local Trust DMZ Untrust。 其中： Local：设备自身的管理接口，优先级最高（优先级为 100）。 Trust：内部可信网络（优先级为 85）。 DMZ（Demilitarized Zone，非军事区）：半可信区，用于托管公开服务（优先级为 50）。 Untrust：外部不可信网络，优先级最低（优先级为 5）。 下一代防火墙：结合 AI 和大数据技术，增强对高级威胁的检测能力，如 APT（高级持续性威胁）。 信息安全管理与标准： 实施基于 ISO 27001 的信息安全管理体系，包含风险评估、应急响应和数据保护等方面，确保企业信息安全。 隐私保护及相关法律手段： 采用数据加密、匿名化等技术保护用户隐私。 遵守《网络安全法》和《通用数据保护条例》（GDPR），保障数据合法合规使用。 安全通信 网络安全基础 防火墙安全策略、地址转换、双机热备、用户管理和入侵防御 防火墙高级特性 防火墙高可靠性、流量管理、虚拟防御、智能选路 安全组网规划部署 全场景安全解决方案、防火墙技术综合应用、IPv6 安全技术 VPN 技术 VPN 基础(加解密) 加密技术原理、PKI 证书体系、VPN 应用、IPv6 安全技术 SSL VPN 应用 SSL VPN 技术与应用 VPN 高可用技术 VPN 高可靠技术、双机场景 VPN 技术与应用 攻击与防御 安全区域边界防护技术 网络攻击与防御、漏洞防御、内容安全过滤 攻击与防御技术 信息收集、网络探测、Web 安全、病毒防范、DoS/DDoS 攻击防御、主机安全、数据安全 WLAN 基础业务 WLAN 工作原理 CAPWAP 隧道： （Control and Provisioning of Wireless Access Points， 无线接入点的控制与配置协议） 用于无线控制器（AC）与接入点（AP）之间的隧道协议，分为控制隧道和数据隧道： 控制隧道：用于 AP 和 AC 之间交互管理。 数据隧道：用于用户数据的转发。 工作流程： AP 通过 DHCP 或静态方式获取 IP 地址。 AP 与 AC 建立 CAPWAP 隧道，完成控制和数据路径。 隧道建立成功，AP 上线，并可服务终端。 WLAN 关键报文：用于控制连接的建立、维护和终端的接入，如认证、关联和数据传输控制报文。 STA 上线流程：终端接入无线网络的流程，包括扫描、认证、关联、IP 获取等步骤。 WLAN 组网架构 FAT AP：独立运行的 AP，负责所有无线功能，适合小型网络。 Leader AP：在多 AP 网络中充当管理者，分担部分控制功能。 WAC+FIT AP：WAC（无线控制器）集中管理 FIT AP，适用于大规模部署。 WLAN 安全 WLAN 接入安全 链路认证：通过加密认证用户设备，如 802.1X、PSK 等。 802.1X 是一种网络接入控制协议 它通过对接入设备进行身份验证，确保只有授权用户或设备才能连接到网络。工作流程包括以下三部分： 客户端（Supplicant）：需要知道你是谁。 认证服务器（RADIUS Server）：需要知道你是找我的吗。 网络接入设备（Authenticator）：需要知道你是怎么找我的。 在 802.1X 认证过程中，客户端向认证服务器发送**用户名和密码**，认证服务器验证后，允许或拒绝设备接入网络。 用户接入安全：确保合法用户接入，防止未授权用户访问网络。 终端黑白名单：通过 MAC 地址控制设备接入权限。 安全策略：基于用户、设备或应用设置访问控制规则。 WLAN 数据安全 Open：无加密，适用于开放网络。 WEP：基础加密方式，已不安全，但仍用于兼容性。 WPA/WPA2（Wi-Fi Protected Access） 增强的安全协议，使用动态密钥加密，推荐使用 WPA2。 WPA：采用 TKIP（临时密钥完整性协议）加密，相比 WEP 更安全，但仍存在一些漏洞。 WPA2：增强版，使用更强的AES（高级加密标准）加密，是目前最推荐的安全标准，提供更高的保护。 AES（Advanced Encryption Standard）是一种对称加密算法，特点是安全高效。 WLAN 安全与防御 WLAN 安全威胁及方案：针对非法 AP、恶意攻击等威胁提供检测与防御。 安全平面控制：通过网络分层保护不同级别的数据和用户。 WLAN 高级特性 WLAN 漫游 概述：用户在多个 AP 之间移动时无缝切换连接。 流量转发：保证数据流在切换期间不中断。 优化技术：如快速漫游、漫游策略配置等，提高用户体验。 WLAN 网络规划 WLAN 网络规划基础 WLAN 覆盖设计：根据场景需求设计信号覆盖范围和强度。 容量设计：基于用户数量、设备并发性和应用需求规划网络容量。 原题举例： 工程师正在无线控制器上配置无线业务，配置命令行如下，那么以下关于该配置的描述，错误的是哪一项？ [AC-wlan-view] security-profile name wlan-net# 创建一个名为 wlan-net 的安全配置文件。[AC-wlan-sec-prof-wlan-net] security wpa-wpa2 dot1x aes# 配置安全模式为 WPA-WPA2，认证方式为 802.1X，数据加密方式为 AES。[AC-wlan-sec-prof-wlan-net] quit# 退出安全配置文件视图。[AC-wlan-view] ssid-profile name wlan-net# 创建一个名为 wlan-net 的 SSID 配置文件。[AC-wlan-ssid-prof-wlan-net] ssid wlan-net# 配置无线网络的 SSID 名称为 wlan-net。[AC-wlan-ssid-prof-wlan-net] quit# 退出 SSID 配置文件视图。[AC-wlan-view] vap-profile name wlan-net# 创建一个名为 wlan-net 的 VAP（虚拟接入点）配置文件。[AC-wlan-vap-prof-wlan-net] forward-mode direct-forward# 配置用户数据的转发模式为直接转发（Direct-Forward），即数据不经过无线控制器。[AC-wlan-vap-prof-wlan-net] service-vlan vlan-id 101# 将无线用户的业务流量映射到 VLAN 101。[AC-wlan-vap-prof-wlan-net] security-profile wlan-net# 关联安全配置文件 wlan-net。[AC-wlan-vap-prof-wlan-net] authentication-profile wlan-net# 关联认证配置文件 wlan-net。[AC-wlan-vap-prof-wlan-net] ssid-profile wlan-net# 关联 SSID 配置文件 wlan-net。[AC-wlan-vap-prof-wlan-net] quit# 退出 VAP 配置文件视图。 A. 当前配置的无线信号的名称为 wlan-net B. 终端接入无线网络需进行 802.1X 认证 C.用户数据转发方式为隧道转发（错，写的是直连） D.用户的业务 VLAN 为 101","tags":[null],"categories":[null]},{"title":"Vue组件说明","path":"/wiki/Smart_Home_System/components.html","content":"Web 端的 UI 和逻辑主要由一个核心组件 src/components/MqttDemo.vue 承载。这个组件内部被划分为几个功能明确的区域。 以下是对MqttDemo.vue组件内部各个 UI 面板的功能分析： 1. 连接配置 (Connection Panel) UI: 显示当前与 MQTT Broker 的连接状态（“已连接”/“未连接”）以及服务器地址和端口。 提供 “连接” 和 “断开” 按钮来手动控制连接。 逻辑: 该部分负责建立和维护与 MQTT Broker 的 WebSocket 连接，是所有后续功能的基础。 2. 灯光控制 (Light Control Panel) UI: 全局控制: “全开”、“全关”、“刷新” 三个按钮，用于批量操作和同步状态。 设备列表: 通过 v-for 循环遍历一个名为 lights 的数组，动态生成每一个灯光的控制卡片。 单个设备: 每个卡片都包含一个图标 (light.icon)、设备名称 (light.name) 和一个状态切换开关，直观地显示并控制灯光的“开启”或“关闭”。 逻辑: 点击开关会发布一条控制单个灯光的 MQTT 消息。点击“刷新”按钮则会发布一条查询指令（如 command: list），嵌入式端收到后会上报所有灯光的状态，Web 端监听并更新 lights 数组，从而刷新界面。 3. 警报控制 (Alarm Control Panel) UI: 一个“刷新”按钮用于同步状态。 一个醒目的铃铛图标 (🔔)。 一个状态切换开关，用于控制警报系统的“开启”或“关闭”。 逻辑: 与灯光控制类似，开关会发布控制指令，刷新按钮会发布查询指令。 4. 文件管理 (File Management Panel) 这是一个相对高级的功能，提供了与嵌入式设备进行文件交互的能力。 UI: 文件上传区: 一个支持点击选择或拖拽文件的区域。可以显示当前选中文件的名称和大小。 操作按钮: “上传文件”和“取消”按钮。 服务器文件列表: 显示从嵌入式设备获取的文件列表 (fileList)。 逻辑: “刷新”按钮会通过 MQTT 请求嵌入式设备上报文件列表。 当用户选择文件并点击上传后，会通过一个特定的 MQTT 主题，以某种协议（可能是分块传输）将文件数据发送到嵌入式设备。 5. 消息日志 (Message Log) UI: 一个用于显示文本信息的区域和一个“清空”按钮。 逻辑: 该区域会订阅所有 MQTT 主题，并将收到的消息内容实时显示出来，是开发和调试过程中的重要工具"},{"title":"ARM 交叉编译指南","path":"/wiki/Smart_Home_System/cross-compilation.html","content":"项目的CMake构建系统原生支持交叉编译。所有交叉编译相关的配置都集中在 arm.cmake 文件中，通过在运行cmake时指定它为工具链文件来启用。 1. 工具链配置文件 (arm.cmake) 该文件的核心是告诉CMake在哪里找到交叉编译器以及如何设置环境。 # 设置目标系统名称set(CMAKE_SYSTEM_NAME Linux)set(CMAKE_SYSTEM_PROCESSOR arm)# 指定交叉编译工具链的路径set(TOOLCHAIN_DIR /usr/local/arm/5.4.0/usr/)# 指定编译器set(CMAKE_C_COMPILER $TOOLCHAIN_DIR/bin/arm-linux-gcc)set(CMAKE_CXX_COMPILER $TOOLCHAIN_DIR/bin/arm-linux-g++)set(CMAKE_C_FLAGS-Wl -rpath=.)# 指定 find_* 命令的搜索路径模式# 从不搜索宿主系统路径set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)# 只在工具链路径中找库和头文件set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY) 关键配置说明: TOOLCHAIN_DIR: 硬编码了交叉编译工具链的根目录。在您的环境中，您需要修改此路径，使其指向您自己的工具链位置。 CMAKE_C_COMPILER: 明确指定了C编译器为 arm-linux-gcc。 CMAKE_FIND_ROOT_PATH_MODE_*: 这是交叉编译最关键的设置。它强制CMake只在 TOOLCHAIN_DIR 指定的路径下查找库和头文件，从而避免了将在PC上编译的宿主系统库链接到ARM程序中的问题。 2. 如何进行交叉编译 确保您已经正确修改了 arm.cmake 文件中的 TOOLCHAIN_DIR 路径。 在项目根目录下，执行以下命令：# 创建构建目录mkdir -p build cd build# 运行CMake，并使用-D参数指定工具链文件cmake .. -DCMAKE_TOOLCHAIN_FILE=../arm.cmake# 开始编译make -j$(nproc) 编译成功后，bin/ 目录下生成的 main 可执行文件就是适用于您的ARM目标平台的程序。"},{"title":"项目依赖项说明","path":"/wiki/Smart_Home_System/dependencies.html","content":"本项目根据编译目标平台的不同，依赖于不同的库。 1. PC (Linux) 平台依赖 在PC上编译时，项目依赖于您系统上已经安装好的开发库。您需要通过包管理器（如apt）来安装它们。 核心库: build-essential, cmake, pkg-config LVGL 模拟器: libsdl2-dev LVGL 字体与图片: libfreetype6-dev, libpng-dev, zlib1g-dev 网络与通信: libssl-dev, libcurl4-openssl-dev, libmosquitto-dev, libcjson-dev 您可以使用以下命令在Debian/Ubuntu系统上一次性安装所有依赖： sudo apt install build-essential cmake pkg-config libsdl2-dev libfreetype6-dev libpng-dev zlib1g-dev libssl-dev libcurl4-openssl-dev libmosquitto-dev libcjson-dev 2. ARM 平台依赖 在为ARM平台交叉编译时，CMake被配置为不使用系统库，而是链接项目 libs/ 目录下预编译好的静态库。 这些库包括: libs/freetype/lib/arm/libfreetype.a libs/libpng_ARM/libpng16.a libs/openssl/libcrypto.a 和 libssl.a libs/mosquitto/lib/libmosquitto.a libs/curl/lib/libcurl.a 这种方式的好处是，您无需在交叉编译环境中为目标平台逐一编译这些依赖库，项目本身已经自带了这些“干粮”。 3. 库版本说明 所有使用的第三方库（如LVGL, cJSON, mosquitto等）直接使用其最新稳定版即可，项目没有对特定旧版本的依赖"},{"title":"嵌入式端编译与运行","path":"/wiki/Smart_Home_System/compilation.html","content":"本项目使用CMake进行构建，可以轻松地在PC上进行模拟，或为嵌入式目标进行交叉编译 1. 克隆仓库 打开支持git的命令行界面，粘贴以下内容： git clone https://github.com/zhangwei43721/Smart_Home_System.gitcd Smart_Home_System 2. 在Linux PC上模拟运行 这是一种无需硬件即可快速验证UI和业务逻辑的方法 创建构建目录： mkdir buildcd build 运行CMake生成Makefile： cmake .. 编译项目： make -j8 -j8 表示使用8个线程并行编译，可以加快速度。 运行可执行文件： 编译成功后，build 目录下会生成一个名为 Smart_Home 的可执行文件。 ./Smart_Home 此时，您应该能看到一个SDL窗口弹窗，显示项目的LVGL界面。 3. 交叉编译 (嵌入式目标) 当您需要为ARM等嵌入式平台编译时，需要指定交叉编译工具链。 准备工具链文件: 修改 arm-gcc.cmake 工具链文件，内容如下，你需要指定这些工具链到自己安装的目录下： set(CMAKE_SYSTEM_NAME Generic)set(CMAKE_C_COMPILER arm-none-eabi-gcc)set(CMAKE_CXX_COMPILER arm-none-eabi-g++)# ... 其他工具链相关设置 运行CMake并指定工具链: 在build目录下，执行： cmake .. -DCMAKE_TOOLCHAIN_FILE=../path/to/arm-gcc.cmake 编译: make 编译完成后，将生成适用于目标平台的二进制文件到 bin/ 目录下，您可以通过烧录工具将其下载到硬件中运行。"},{"title":"数据持久化模块","path":"/wiki/Smart_Home_System/data-persistence.html","content":"为了让智能家居系统在断电或重启后能恢复到之前的状态，项目设计了一个数据持久化模块，源码位于 obj/data/state_store.c。 使用到的知识点为 文件IO 该模块的核心职责是将应用的关键状态（如灯的开关/亮度、安防模式、警报状态）以文件的形式保存在本地文件系统上。 实现机制 文件存储: 每一种需要持久化的状态都对应一个独立的文本文件，如 lighting_state.txt, security_state.txt。所有文件都存放在程序运行目录下的 data/ 文件夹中。 自动目录创建: 在进行任何文件操作前，ensure_data_dir() 函数会检查 data/ 目录是否存在，如果不存在则会自动创建，增强了程序的健壮性。 简洁的API: 模块提供了成对的 ss_xxx_load() 和 ss_xxx_save() 函数接口。 save 函数负责将内存中的数据结构（如灯光状态数组）格式化为文本并写入文件。 load 函数在程序启动时被调用，负责读取文件内容，解析后填充到内存的数据结构中。 默认值处理: 如果在 load 时发现状态文件不存在（通常是第一次运行时），函数不会报错，而是会返回一个预设的默认值，并立即调用 save 函数将这个默认值写入文件。这简化了首次运行的初始化流程。 数据格式 数据以易于读写的纯文本格式存储。例如，lighting_state.txt 的每一行代表一个灯，内容是 [是否开启] [亮度] [色温]，由空格分隔的三个整数。这种格式不仅实现简单，也方便开发者直接打开文件查看和调试。"},{"title":"嵌入式端总体介绍","path":"/wiki/Smart_Home_System/embedded-overview.html","content":"嵌入式应用程序是本项目的核心，入口为 /main.c。 它负责初始化系统、驱动UI、并在一个主循环中处理所有事件。 设计核心是平台无关性，通过CMake和C预处理器宏，实现了PC与ARM平台的代码复用 应用程序启动流程 程序启动后，严格遵循以下初始化顺序（具体代码看项目根目录下的main.c文件）： LVGL核心初始化: lv_init(): 初始化LVGL库。 lv_log_register_print_cb(): 注册日志回调，以便在 printf 中看到LVGL的内部日志。 lv_fs_posix_init(): 初始化基于Posix的文件系统接口，供LVGL使用。 平台特定初始化 (Platform-Specific Init): 用以下配置，给不同平台注入不同的初始化代码 时间同步 (仅ARM): 在ARM平台上，会调用 sync_time_on_startup() 函数，通过执行 ntpd 等shell命令来同步网络时间并更新硬件时钟(RTC)。 HAL初始化 (hal_init): 这是平台适配的关键。内部通过 #if USE_SDL 宏来判断： PC平台: 调用 sdl_init() 并注册SDL的显示和输入（鼠标、键盘）驱动。 ARM平台: 调用 fbdev_init() 和 evdev_init() 并注册Linux Framebuffer显示驱动和evdev触摸/鼠标输入驱动。 服务与模块初始化 (Services Modules Init): lv_png_init(): 初始化LVGL的PNG图片解码器 hardware_init(): 初始化硬件抽象层，打开 /dev/Led 等设备文件 restore_persisted_states(): 关键步骤。调用state_store模块的load函数，读取上次保存的状态，并立即通过 control_led/buzzer 函数将硬件恢复到该状态 mqtt_client_start(): 启动MQTT客户端，使其在后台线程开始连接并处理网络消息 UI加载与主循环: demo_dashboard(): 调用此函数来创建并显示初始界面（仪表盘） 进入主循环: 程序进入 while(1) 无限循环，在循环中以5毫秒的间隔不断调用 lv_timer_handler()。这是LVGL的心跳，负责驱动所有UI渲染、动画和事件处理"},{"title":"常见问题解答","path":"/wiki/Smart_Home_System/faq.html","content":"这里整理了一些新手在编译和理解本项目时最可能遇到的问题。 Q1: 环境太复杂，不知道怎么配置？ A: 环境配置分为两种情况： 在PC (Linux)上模拟运行: 这是最简单的方式。你只需要安装CMake和一系列开发库即可。具体请参考 项目依赖项说明 页面，里面有一条可以直接复制粘贴的apt install命令，适用于Debian/Ubuntu系统。 为ARM开发板交叉编译: 这种方式需要你预先准备好一个交叉编译工具链（如 arm-linux-gcc）。然后，你需要修改项目根目录下的 arm.cmake 文件，将 TOOLCHAIN_DIR 变量的值改成你自己的工具链路径。 Q2: 不知道怎么编译项目？ A: 本项目使用标准的CMake流程编译： mkdir -p build cd build (创建并进入构建目录) cmake .. (生成Makefile) make -j$(nproc) (执行编译) 如果是为ARM交叉编译，第2步需要改成 cmake .. -DCMAKE_TOOLCHAIN_FILE=../arm.cmake，以告诉CMake使用交叉编译配置。 编译成功后，可执行文件 main 会出现在项目根目录的 bin/ 文件夹下。 Q3: main.c 里的 #if USE_SDL 是如何与CMake配合的？ A: 这是本项目跨平台设计的核心，是一个“动态配置”的自动化流程： 当你运行 cmake .. 时，CMakeLists.txt 脚本会首先检测你的平台。如果你是直接在PC上运行，它知道是PC平台；如果你使用了 -DCMAKE_TOOLCHAIN_FILE=../arm.cmake，它就知道是ARM平台。 根据检测到的平台，CMake脚本会在编译前动态地修改 lv_drv_conf.h 这个文件。 如果是PC平台，它会把 #define USE_SDL 0 这行改成 #define USE_SDL 1。 如果是ARM平台，它会确保这行是 #define USE_SDL 0。 当C编译器开始编译 main.c 时，它看到的 lv_drv_conf.h 已经是被CMake修改过的版本了。 因此，#if USE_SDL 这个预处理指令就能正确地选择应该编译哪一段代码：在PC上，USE_SDL 的值是1，于是SDL相关的代码被编译；在ARM上，值是0，于是Framebuffer相关的代码被编译。 总结：CMake负责在编译前“配置”好宏，C编译器负责根据宏的值“选择”代码。 Q4: 头文件 .h 和源文件 .c 是什么关系？ A: 这是C语言模块化编程的基本思想： .h (头文件): 相当于一个模块的**“公开接口”或“说明书”**。它告诉其他模块：“我这里有这些函数（只写函数名、参数、返回值，不写实现）和这些数据结构可供你们使用”。在本项目中，这些文件大多集中在 obj/Include/ 目录下。 .c (源文件): 相当于模块的**“内部实现”**。它包含头文件中声明的那些函数的具体代码。 举例: obj/hardware/hardware.c 实现了 control_led 函数的具体逻辑（如何调用ioctl等）。然后，它在 obj/Include/Hardware.h 中写下 int control_led(int led_num, int on); 这句声明。当 main.c 需要控制LED时，它只需要 #include obj/Include/Hardware.h，然后就可以直接调用 control_led() 函数了，它不需要知道这个函数内部是怎么实现的。"},{"title":"MQTT 通信协议与实现","path":"/wiki/Smart_Home_System/mqtt-communication.html","content":"MQTT是本项目实现设备与云端/Web端双向同步的核心。相关代码封装在 obj/MQTT/MQTT.c 中。 使用的知识点为MQTT通信 1. 核心库 项目使用业界主流的 libmosquitto 作为C语言的MQTT客户端库。 2. 异步回调机制 非阻塞设计: 通过调用 mosquitto_loop_start()，MQTT客户端在一个独立的后台线程中运行其网络循环。这确保了MQTT的连接、消息收发和心跳维持都不会阻塞UI主线程。 事件回调: 客户端的工作模式是事件驱动的。代码中定义了一系列回调函数： on_connect: 当成功连接到Broker后被调用。在此函数中，会集中订阅所有需要监听的主题（如灯光控制 MQTT_SUB_LIGHT_TOPIC）。 on_message: 当任何已订阅的主题收到新消息时被调用。这是远程控制逻辑的核心入口。 on_publish: 当一条消息成功发布出去后被调用，用于确认。 3. 消息协议与分发 JSON 负载: 与服务端/Web端之间的通信数据格式为JSON字符串。 主题分发: 在 on_message 回调函数中，程序通过 strcmp(msg-topic, ...) 来判断消息来自哪个主题，然后将消息分发给不同的处理逻辑。 指令解析: 对于收到的JSON字符串，程序使用 cJSON 库进行解析，提取出 “command”, “led”, “state” 等字段，并根据这些字段的值执行相应的操作，如调用 lighting_set_from_mqtt() 控制灯光。 4. 状态同步 该模块不仅接收指令，也负责响应查询。例如，当收到 “list” 命令时，它会从 state_store 模块加载当前所有设备的状态，然后构建一个JSON响应并将其发布回相应的主题，从而让Web端获取到设备的最新状态。"},{"title":"首页","path":"/wiki/Smart_Home_System/index.html","content":"Smart_Home_System 是一个功能全面、界面精美的嵌入式智能家居控制终端。本项目基于 GEC6818开发版，使用 C 语言和 LVGL 图形库构建，通过 MQTT 协议与云端及 Web 端实时同步，旨在为您提供一个集中、高效、智能的家居管理新体验 项目由两部分组成： 嵌入式主控终端 (Embedded Terminal)：运行于嵌入式 Linux 设备，负责设备控制、UI 渲染和核心业务逻辑。 Web 控制端 (Web Control Panel)：一个基于 Vue 和 TypeScript 的现代化 Web 应用，让您能随时随地远程控制您的家 Web端使用MQTT官方开源代码修改而来 📸 界面展示 系统拥有基于 LVGL 精心设计的嵌入式 UI 和现代化的 Web 控制面板，两者界面清晰、操作直观、状态实时同步。 主仪表盘 (Dashboard)实时天气、时间与快捷入口 安防系统 (Security)三种布防模式，一键报警 智能照明 (Lighting)多路灯光，亮度色温精细调节 影音娱乐 (Entertainment)集成图片、音乐、视频播放 AI 智能助手 (AI Assistant)集成 DeepSeek API，提供智能问答 Web 控制端 (Vue + TS)简洁高效的远程监控面板 ✨ 项目亮点 双端同步：无论是通过嵌入式触摸屏还是 Web 端进行操作，设备状态都能通过 MQTT 协议在所有客户端之间实时同步，确保数据一致性。 跨平台构建：借助 CMake 实现高度自动化配置，一套代码库可无缝编译于 Linux PC、ARM 嵌入式平台和 Windows，极大提升了开发和调试效率。 状态持久化：关键设备状态（如灯光、安防模式）会被保存至本地文件系统，系统断电重启后可自动恢复，增强了系统的可靠性。 全功能集成：不仅涵盖了照明、安防、环境控制等核心家居功能，还集成了影音娱乐和 AI 智能助手，打造一体化的智能生活中心。 现代化技术栈：嵌入式端采用成熟的 C 语言与 LVGL，保证性能与稳定性；Web 端则采用 Vue 3 + TypeScript + Vite，带来流畅的开发与用户体验。 🏗️ 系统架构 本系统采用经典的“端-云-端”物联网架构，各部分职责清晰，分层解耦。 +------------------------+ +------------------+ +--------------------------+| | | | | || Web 控制端 (Vue+TS) |----| MQTT Broker |----| 嵌入式主控终端 (C+LVGL) || (Smt-Home-MQTT-Control)| | (Mosquitto/EMQX)| | (Smt_Home_System) || | | | | |+------------------------+ +------------------+ +--------------------------+ (WebSocket/MQTT) (TCP/MQTT) 嵌入式主控终端技术栈 核心语言: C 构建系统: CMake UI 框架: LVGL v8.2 网络通信: paho-mqtt: 实现 MQTT 客户端功能。 libcurl: 用于发起 HTTP 请求（获取天气、调用 AI API）。 数据解析: cJSON 多线程: Pthreads 媒体播放: mplayer (视频), madplay (音频) Web 控制端技术栈 核心框架: Vue.js (Vue 3) 开发语言: TypeScript 构建工具: Vite MQTT 通信: MQTT.js 🚀 快速开始 环境准备 硬件: 适用于 Linux 的 PC、ARM 嵌入式开发板或 Windows PC。 软件: 嵌入式端: Linux PC: 安装 build-essential, cmake, pkg-config 及下文提到的开发库。 ARM 交叉编译: 准备好您的 ARM GCC 工具链。 Windows: 安装 MinGW 或 MSVC。 Web 端: 安装 Node.js 和 npm / pnpm / yarn。 云端: 一个正在运行的 MQTT Broker (如 Mosquitto 或 EMQX)。 编译与运行 (嵌入式主控终端) 克隆项目 git clone https://github.com/zhangwei43721/Smart_Home_System.gitcd Smart_Home_System 配置 在 obj/Include/config.h 文件中，填入您的 MQTT 服务器地址、天气 API Key 和 DeepSeek API Key。 编译 注意编译以前，你可能需要先安装依赖，往下翻可以看到需要哪些依赖 mkdir -p build cd build# 方式一: 本地 Linux PC 编译# (请先根据下方指引安装依赖)cmake ..# 方式二: ARM 交叉编译# (需在 arm.cmake 中配置好您的工具链路径)cmake .. -DCMAKE_TOOLCHAIN_FILE=../arm.cmakemake -j$(nproc) 运行 可执行文件 main 将生成于 bin 目录下。 cd ../bin./main 运行 (Web 控制端) 进入目录 cd Smart-Home-MQTT-Control 安装依赖 npm install 配置 修改代码中的 MQTT 连接配置，使其指向您的 MQTT Broker 地址（注意使用 WebSocket 端口）。 启动 npm run dev 在浏览器中打开提示的本地地址即可访问。 🛠️ 构建与依赖 本项目使用 CMake 作为构建系统，能够智能检测目标平台并自动配置 LVGL 驱动及相关依赖。 依赖项说明 1. Linux (PC) 平台 在此模式下，项目依赖于系统已安装的动态库。 安装示例 (Debian / Ubuntu): sudo apt updatesudo apt install build-essential cmake pkg-config \\ libsdl2-dev libfreetype6-dev libpng-dev zlib1g-dev \\ libssl-dev libcurl4-openssl-dev libmosquitto-dev libcjson-dev 2. ARM 与 Windows 平台 为了方便交叉编译和 Windows 开发，这两个平台会优先使用项目 libs/ 目录下提供的预编译静态库。您无需额外安装依赖，只需确保编译工具链可用。 注意: Windows 模式默认仅链接 UI 相关库，主要用于界面开发调试，网络功能默认关闭。 自动化配置 CMakeLists.txt 会在编译前自动修改 LVGL 的配置文件 (lv_conf.h 等)，以适配不同平台： PC/Windows: 自动启用 SDL 驱动。 ARM: 自动启用 Framebuffer (FBDEV) 和 EVDEV 驱动，以直接与屏幕和输入设备交互。 这个自动化过程确保了您无需手动修改 LVGL 配置即可在不同平台上无缝编译。 📂 目录结构 .├── Smart-Home-MQTT-Control/ # Web 控制端 (Vue + TS)├── arm.cmake # ARM 交叉编译工具链文件├── bin/ # 存放可执行文件及运行时资源 (字体、媒体)├── build/ # 编译产物目录├── data/ # 存放持久化的设备状态文件├── libs/ # 第三方预编译静态库├── lvgl/ # LVGL 核心库├── lv_drivers/ # LVGL 驱动├── obj/ # 项目 C 源码│ ├── AI/ # AI 聊天模块│ ├── data/ # 数据持久化模块│ ├── hardware/ # 硬件控制模块│ ├── http/ # HTTP API 封装 (天气等)│ ├── Include/ # 项目头文件│ ├── MQTT/ # MQTT 通信模块│ └── screen/ # LVGL 屏幕界面代码├── CMakeLists.txt # CMake 配置文件├── main.c # 程序主入口└── README.md # 本文档"},{"title":"硬件控制与外设驱动","path":"/wiki/Smart_Home_System/peripheral-control.html","content":"硬件控制模块是连接上层应用逻辑与底层物理设备的桥梁，其代码位于 obj/hardware/hardware.c。它遵循了典型的硬件抽象层（HAL）设计思想。 使用到的知识点是Linux驱动开发 1. 硬件抽象 该模块将底层的硬件设备（如开发板上的LED和蜂鸣器）抽象为标准的Linux字符设备文件。 LED设备对应 /dev/Led。 蜂鸣器设备对应 /dev/beep。 这种设计使得上层代码无需关心硬件驱动的具体实现，只需像操作普通文件一样来操作硬件。 2. 控制接口 ioctl 系统调用: 与硬件驱动的通信完全通过标准的 ioctl (Input/Output Control) 系统调用来完成。 自定义命令: 针对不同的操作，代码中定义了一系列 ioctl 命令码，例如 LED1_IOCTL 就是控制第一个LED的特定命令。开启或关闭则作为参数传递。 文件描述符管理: hardware_init() 函数负责打开设备文件并获取文件描述符（g_led_fd, g_buzzer_fd），这些描述符在后续的 ioctl 调用中使用。hardware_deinit() 则负责安全地关闭它们。 3. 统一API 模块向上层提供了非常简洁和统一的API： hardware_init(): 初始化所有硬件。 hardware_deinit(): 释放所有硬件资源。 control_led(int led_num, int on): 控制指定编号的LED亮或灭。 control_buzzer(int on): 控制蜂鸣器响或停。 通过这层封装，项目的其他部分（如MQTT模块或UI模块）可以简单地通过调用这些函数来控制物理设备，而无需了解 ioctl 的复杂细节。"},{"title":"LVGL UI 设计与实现","path":"/wiki/Smart_Home_System/ui-design.html","content":"本项目的用户界面完全由 LVGL (v8) 驱动，源码位于 obj/screen/ 目录下。以 screen_dashboard.c 为例，可以看出UI设计的核心思想。 1. 动态创建与布局 组件创建: 所有UI组件（对象）均通过代码动态创建，如 lv_obj_create, lv_label_create, lv_img_create 等，提供了极高的灵活性。 Flexbox 布局: 仪表盘页面的卡片布局广泛采用了 LVGL 的 Flexbox 布局 (LV_FLEX_FLOW_ROW_WRAP)。这使得多个大小不一的卡片能够在一个可滚动的容器内自动对齐和换行，完美适配不同内容。 样式驱动: 通过自定义的样式 (sh_style_card, sh_style_text_zh 等) 来统一控件的外观，实现了UI的视觉一致性。 2. 事件驱动交互 事件回调: 用户的交互（如点击）是通过事件回调机制处理的。lv_obj_add_event_cb 函数为一个对象（如卡片 card_climate）绑定一个 LV_EVENT_CLICKED 事件和对应的处理函数 (on_card_climate_clicked)，从而实现页面跳转或功能触发。 3. 异步UI更新（多线程安全） 为了防止网络请求等耗时操作阻塞UI线程导致界面卡顿，项目采用了安全的多线程UI更新机制： 创建后台线程: 天气信息获取功能在一个独立的 pthread 线程 (weather_thread) 中运行。这个线程可以安全地执行 sleep 或进行阻塞的网络IO，而不会影响LVGL主循环。 lv_async_call 安全通信: 当后台线程成功获取数据并需要更新UI（如天气图标和温度）时，它不能直接调用LVGL的函数。而是通过 lv_async_call 将一个更新函数 (apply_weather_cb) 和所需数据“派发”给LVGL的主循环。LVGL会在安全的时机（下一个 lv_timer_handler() 周期）执行这个函数，从而避免了多线程冲突。这是在LVGL中进行线程安全UI更新的标准范式。"},{"title":"Web端配置与启动","path":"/wiki/Smart_Home_System/web-setup.html","content":"Web控制端位于仓库的 Smart-Home-MQTT-Control 目录下，是一个基于 Vue 的前端项目 1. 进入Web目录 cd Smart-Home-MQTT-Control 2. 安装依赖 使用 npm 或 yarn 安装项目所需的所有依赖库。 # 使用 npmnpm install# 或者使用 yarnyarn install 3. 配置MQTT服务器信息 打开 src/component/MqttDemo.vue 文件，找到MQTT连接配置部分（大概在282行左右） 根据您的实际情况修改 options 对象中的服务器地址、端口、用户名和密码。 // src/component/MqttDemo.vueconst connection = reactive( protocol: ws, host: 输入你的ip地址, port: 8083, // 使用WebSocket协议连接，端口一般为8083 clientId: emqx_vue3_ + Math.random().toString(16).substring(2, 8), // 生成随机客户端id username: test, // 用户名 password: 123456, // 密码 clean: true, connectTimeout: 30 * 1000, reconnectPeriod: 4000,);// ... 注意: Web端通常通过WebSocket连接MQTT服务器，请确保端口号正确。 4. 启动开发服务器 配置完成后，运行以下命令启动本地开发服务器： # 使用 npmnpm run serve# 或者使用 yarnyarn serve 命令执行成功后，您会在终端看到类似以下的输出： App running at:- Local: http://localhost:5174/- Network: http://192.168.x.x:5174/ 在浏览器中打开http://localhost:5174，即可访问Web控制端界面。如果一切正常，它应该能与您的嵌入式设备进行实时通信。"},{"title":"环境准备","path":"/wiki/Smart_Home_System/prerequisites.html","content":"在编译和运行本项目之前，请确保您的开发环境满足以下要求 1. 硬件要求 主控：任何能够运行C代码并驱动显示屏的微控制器或开发板（如 ESP32、STM32、Raspberry Pi 等）。本项目基于 GEC6818 开发板 显示屏：带触摸功能的 LCD 显示屏，并已正确配置 LVGL 驱动 网络模块：具备网络连接能力（Wi-Fi 或以太网），用于连接 MQTT 服务器 可选传感器/执行器：LED 灯、蜂鸣器、温湿度传感器、继电器模块等，用于与物理世界交互 2. 嵌入式端软件要求 在开发主机（如 Linux PC）上安装以下软件： Git：用于克隆仓库和子模块。 CMake (= 3.16)：用于构建项目。 GCC 或交叉编译工具链：C 编译器。 在 Linux PC 上模拟运行：gcc 嵌入式目标编译：arm-none-eabi-gcc 等交叉编译器 Make（或其他构建工具）：执行 CMake 生成的构建指令 SDL2（可选）：在 PC 上模拟嵌入式程序运行时需要 # Debian/Ubuntu 安装示例sudo apt-get updatesudo apt-get install build-essential git cmake libsdl2-dev 配置好环境后，即可编译并运行。 3. Web端软件要求 Node.js (LTS版本)：JavaScript 运行环境 npm 或 yarn：包管理器 4. MQTT服务器 本项目通过 MQTT 协议进行设备间的通信，因此您需要一个正在运行的 MQTT 服务器。您可以根据需求选择以下任意一种方式进行部署 步骤 1：选择并部署 MQTT 服务器 您可以选择使用公共云服务，也可以在本地或服务器上自行部署 选项 A：使用公共云服务 (推荐新手) 对于快速开发和测试，可以直接使用成熟的云服务，无需自己维护服务器 服务商：阿里云、EMQX Cloud、OneNet 等都提供公共 MQTT 服务 优点：开箱即用，稳定可靠。 教程参考：您可以参考这篇详细教程来学习如何连接到公共云服务： STM32连接 – EMQX/阿里云/OneNET（MQTT协议）详细教程 选项 B：本地自行部署 (推荐局域网开发) 在本地（如PC、虚拟机或树莓派）部署 MQTT 服务器，适合在局域网内进行开发和调试。这里我们推荐使用 Mosquitto，它轻量、开源且稳定 推荐软件：Mosquitto 备选软件：EMQX。请注意，EMQX 从版本 5 开始其开源协议有所变更，部分高级功能可能需要商业许可。 下面以在 Ubuntu/Debian 系统上安装并配置 Mosquitto 为例： 安装 Mosquitto sudo apt-get updatesudo apt-get install -y mosquitto mosquitto-clients 配置密码验证 (推荐) 为了安全，我们启用密码验证。创建或编辑配置文件 /etc/mosquitto/conf.d/local.conf： # MQTT 默认端口listener 1883protocol mqtt # WebSocket 端口 (如果需要)listener 8083protocol websockets# 禁止匿名访问allow_anonymous false# 指定密码文件路径password_file /etc/mosquitto/passwd 创建用户和密码 使用 mosquitto_passwd 工具创建一个用户（例如 test）。-c 参数表示创建新文件，仅在首次添加用户时使用。 # 首次创建密码文件时使用 -csudo mosquitto_passwd -c /etc/mosquitto/passwd test# 之后再添加新用户，请不要带 -c 参数# sudo mosquitto_passwd /etc/mosquitto/passwd new_user 执行后，根据提示输入两次密码（例如 123456）。 修改权限并重启服务 # 确保密码文件归 mosquitto 用户所有sudo chown mosquitto:mosquitto /etc/mosquitto/passwdsudo chmod 640 /etc/mosquitto/passwd# 重启 Mosquitto 服务使配置生效sudo systemctl restart mosquitto 步骤 2：在项目中配置 MQTT 连接信息 无论您选择哪种方式部署服务器，都需要将服务器的地址、端口和凭据信息配置到项目中。 编辑 obj/Include/config.h 文件，修改以下宏定义： #define MQTT_BROKER_HOST 192.168.1.100 // MQTT 服务器的 IP 地址或域名#define MQTT_BROKER_PORT 1883 // 端口，默认为 1883#define MQTT_KEEPALIVE 60 // 心跳超时时间#define MQTT_USERNAME test // 用户名 (如果服务器需要)#define MQTT_PASSWORD 123456 // 密码 (如果服务器需要) 提示：如果您的服务器部署在运行代码的同一台机器上，地址可以是 127.0.0.1。如果是局域网内的另一台设备，请填写其局域网IP地址。 步骤 3：测试服务器连通性 在运行主项目前，您可以使用命令行工具 mosquitto_sub 和 mosquitto_pub 来验证服务器是否正常工作。 打开一个终端，订阅主题 该命令会监听多个主题，等待消息。 mosquitto_sub -h 127.0.0.1 -p 1883 -u test -P 123456 \\ -t smart_home/# -q 1 -v -h: 主机地址 -p: 端口 -u, -P: 用户名和密码 -t smart_home/#: 订阅 smart_home/下的所有主题 -v: 打印主题和消息内容 打开另一个终端，发布消息 向 smart_home/light 主题发送一条消息。 mosquitto_pub -h 127.0.0.1 -p 1883 -u test -P 123456 \\ -t smart_home/light -m turn on 如果在第一个终端（订阅端）能看到成功打印出 smart_home/light turn on，说明您的 MQTT 服务器已配置成功并正常工作： 5. 天气API 这个项目使用了心知天气API ，可以点击进入官网注册，免费使用 注册并申请了免费版产品后，获得自己的私钥，配置到项目的obj\\Include\\config.h里面： #define WEATHER_CITY guangzhou // 城市名#define WEATHER_API_KEY xxxxxxxxx // 自己的私钥 6. AI API 这个项目使用的DeepseekAPI，需要付费使用，但已经是所有平台当中最便宜的了 DeepseekAPI申请地址：https://platform.deepseek.com/api_keys 实测演示一次效果花费不超过两分钱，往里面充一块钱就可以使用 获取到APIkey后，将APIkey配置到项目的obj\\Include\\config.h里面： #define OPENAI_API_KEY sk-xxxxxxxxx 如果需要用其它平台的ai，可以： 在obj\\AI\\src\\chat.c文件的第43行左右调整api接口地址 在obj\\screen\\screen_ai_chat.c文件的第126行左右调整模型类型"},{"title":"Web端总体介绍","path":"/wiki/Smart_Home_System/web-overview.html","content":"Web 控制端 (Smart-Home-MQTT-Control) 是一个现代化的单页面应用 (SPA)，为用户提供了通过浏览器远程监控和管理智能家居系统的能力。它与嵌入式主控终端通过 MQTT 协议进行实时、双向的通信。 技术栈 根据项目的文件结构 (vite.config.ts, main.ts 等)，可以确定其技术栈如下： 核心框架: Vue.js (从构建工具和文件结构看，应为 Vue 3) 开发语言: TypeScript 构建工具: Vite 通信协议: MQTT (通过 WebSocket 连接) 核心功能 Web 端的核心功能都集中在一个统一的仪表盘界面中，主要包括： MQTT 连接管理: 提供 UI 界面，用于配置并连接到 MQTT Broker。 灯光控制: 实时显示所有灯光的状态，并提供单独开关、一键全开/全关和刷新状态的功能。 警报系统控制: 显示和控制安防警报系统的开启与关闭状态。 文件管理: 能够列出嵌入式设备上的文件，并提供了文件上传的交互界面。 实时日志: 显示所有收发的 MQTT 消息，方便调试和监控。 项目结构 该项目是一个标准的 Vite + Vue + TS 项目，结构简洁清晰： src/main.ts: 应用程序的入口文件。 src/App.vue: Vue 应用的根组件。 src/components/MqttDemo.vue: 核心业务组件，几乎所有的 UI 和业务逻辑都在这个组件内实现。"},{"title":"ERP系统开发实训笔记","path":"/data/notebooks/ERP系统开发实训笔记.html","content":"ERP 系统开发实训笔记 笔记按照前后端的实现时间编写 代码开源地址 前端：客户管理系统前端 后端：客户管理系统后端 Day1 环境初始化 后端搭建 1.项目环境搭建 1）idea 初始化 类型选择 Maven，jdk 选 17 idea 可以自动安装 Java 包，不要去手动下载 . 下面这个 Springboot 要求选择 3.0.2！！！ . 2）依赖下载 下载太慢了？看这个配置阿里云镜像的教程，不要像老师一样手动安装配置 maven IDEA 自带 Maven 添加阿里镜像 3）配置工程 application.properties 文件配置如下 spring.application.name=demo# 应用服务web访问端口server.port=8080# mysql信息spring.datasource.url=jdbc:mysql://localhost:3306/erp?useUnicode=truecharacterEncoding=utf8serverTimezone=UTCspring.datasource.username=rootspring.datasource.password=134679spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver# 指定mybatis的mapper文件 (XML文件路径)mybatis.mapper-locations=classpath*:mapper/**/*Mapper.xml# 或者如果您使用Java配置Mapper (指定Mapper接口所在的包)# mybatis.type-aliases-package=com.example.demo.mapper# MyBatis 日志配置mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl 4）配置 Maven 确保 pom.xml 有以下依赖： dependencies !-- web -- dependency groupIdorg.springframework.boot/groupId artifactIdspring-boot-starter-web/artifactId /dependency !-- mybatis -- dependency groupIdorg.mybatis.spring.boot/groupId artifactIdmybatis-spring-boot-starter/artifactId version3.0.4/version /dependency !-- 数据库驱动 -- dependency groupIdcom.mysql/groupId artifactIdmysql-connector-j/artifactId scoperuntime/scope /dependency !-- lombok -- dependency groupIdorg.projectlombok/groupId artifactIdlombok/artifactId optionaltrue/optional /dependency !-- 测试 -- dependency groupIdorg.springframework.boot/groupId artifactIdspring-boot-starter-test/artifactId scopetest/scope /dependency !-- mybatis测试 -- dependency groupIdorg.mybatis.spring.boot/groupId artifactIdmybatis-spring-boot-starter-test/artifactId version3.0.4/version scopetest/scope /dependency !-- mysql驱动 -- dependency groupIdmysql/groupId artifactIdmysql-connector-java/artifactId version8.0.33/version /dependency !--mybatisPlus-- dependency groupIdcom.baomidou/groupId artifactIdmybatis-plus-boot-starter/artifactId version3.5.5/version /dependency /dependencies 5）安装插件 IDEA 插件之 mybatisx 插件使用教程 如何在 IntelliJ IDEA 中安装通义灵码 - AI 编程助手提升开发效率 6）中文乱码问题 直接在文件-设置里搜索 utf-8，把文件编码的三个位置都调成 utf-8 就行 . 2.配置数据库 先使用 navicat 创建数据库 往数据库里新建以下表，这些表是需求分析后分析出来的 CREATE TABLE `t_after_sales` ( `id` int NOT NULL AUTO_INCREMENT COMMENT 服务单号 (主键), `cust_id` int DEFAULT NULL COMMENT 关联的客户ID (关联t_customer.id), `question` varchar(50) DEFAULT NULL COMMENT 售后问题类型或简述, `state` varchar(50) DEFAULT NULL COMMENT 售后处理状态 (如：待处理、处理中、已解决), `record` varchar(200) DEFAULT NULL COMMENT 售后处理过程或回访记录详情, `level` int DEFAULT NULL COMMENT 问题严重性或优先级 (可用于内部评估), PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT=售后服务记录表 (客户服务);CREATE TABLE `t_customer` ( `id` int NOT NULL AUTO_INCREMENT COMMENT 客户ID (主键), `cust_name` varchar(50) DEFAULT NULL COMMENT 客户名称或公司名称, `address` varchar(100) DEFAULT NULL COMMENT 客户联系地址, `phone` varchar(11) DEFAULT NULL COMMENT 客户联系电话, `cust_type` varchar(50) DEFAULT NULL COMMENT 客户类型或分组 (如：所属行业、区域), `grade` int DEFAULT NULL COMMENT 客户等级 (评估客户价值), `his_total` double DEFAULT NULL COMMENT 历史交易总额 (用于客户价值分析), PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT=客户信息表 (客户档案);CREATE TABLE `t_item` ( `id` int NOT NULL AUTO_INCREMENT COMMENT 商品ID (主键), `item_name` varchar(50) DEFAULT NULL COMMENT 商品名称, `price` double DEFAULT NULL COMMENT 商品单价, `item_date` date DEFAULT NULL COMMENT 商品生产日期或上架日期, `hot_title` varchar(100) DEFAULT NULL COMMENT 促销活动标题或描述, `facturer` varchar(100) DEFAULT NULL COMMENT 生产厂家或品牌商, `store` int DEFAULT NULL COMMENT 商品当前库存数量, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT=商品信息表 (产品库);CREATE TABLE `t_menu` ( `id` int NOT NULL AUTO_INCREMENT COMMENT ID (主键), `label` varchar(50) DEFAULT NULL COMMENT 导航名称, `component` int DEFAULT NULL COMMENT 子id, `pid` int DEFAULT NULL COMMENT 父id, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT=前端菜单表;CREATE TABLE `t_order` ( `id` int NOT NULL AUTO_INCREMENT COMMENT 订单ID (主键), `cust_id` int DEFAULT NULL COMMENT 下单客户ID (关联t_customer.id), `item_id` int DEFAULT NULL COMMENT 购买的商品ID (关联t_item.id), `order_date` datetime DEFAULT NULL COMMENT 订单创建日期和时间, `state` varchar(50) DEFAULT NULL COMMENT 订单状态 (如：待付款、待发货、已完成), `pay` varchar(50) DEFAULT NULL COMMENT 支付方式 (如：支付宝、微信、银行卡), `pay_money` double DEFAULT NULL COMMENT 订单实际支付金额, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT=订单信息表 (交易记录);CREATE TABLE `t_sell_jh` ( `id` int NOT NULL AUTO_INCREMENT COMMENT 机会或计划ID (主键), `custid` int DEFAULT NULL COMMENT 关联的客户ID, `channel_id` int DEFAULT NULL COMMENT 销售机会来源渠道ID (可关联渠道表), `money` double DEFAULT NULL COMMENT 预计成交金额, `now_step` varchar(50) DEFAULT NULL COMMENT 当前销售阶段 (如：初步接触、报价、签约), `emp_id` int DEFAULT NULL COMMENT 负责该机会的销售员工ID, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=14 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT=销售机会/计划表 (销售过程管理); 然后在 idea 里新加一个数据源 . 填写用户名，密码，数据库名 . 3.用 mybatiesx 生成三个层级代码 使用步骤： 1、安装 MybatisX 插件；IDEA 插件之 mybatisx 插件使用教程 2、idea 的 database 连接数据库； 3、数据库表上右键，点击 MybatisX-Generator； 。 4、 进行生成代码的配置，按自己的项目项目修改如图三个位置的路径，配置完成后点击 Next . 下面是老师的截图： . 5.按照下面的截图调整 . 6.运行代码，看有什么问题 注意启动类要添加扫描 mapper 的代码 @SpringBootApplication@MapperScan(com.example.demo.mapper)//添加这句话public class DemoApplication public static void main(String[] args) SpringApplication.run(DemoApplication.class, args); 4.写测试代码测试增删改查是否正常 1）mapper 测试 右键括号内-生成-测试 . 就会生成对应测试，修改对应测试方法即可 . package com.example.demo.mapper;import com.baomidou.mybatisplus.core.conditions.update.UpdateWrapper;import com.example.demo.pojo.User;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.util.List;@SpringBootTestclass UserMapperTest @Autowired private UserMapper userMapper; private Integer userId; @Test void contextLoads() /*添加用户信息*/ @Test void saveUser() User user = new User(); user.setUsername(testUser); user.setEmail(test@example.com); user.setPhone(1234567890); user.setPassword(password123); userMapper.insert(user); userId = user.getId(); /*查询单条用户信息*/ @Test void getOne() User user = userMapper.selectById(userId); System.out.println(user); /*查询用户集合*/ @Test void getList() UpdateWrapperUser wrapper = new UpdateWrapper(); wrapper.eq(username, testUser); ListUser users = userMapper.selectList(wrapper); for (User u : users) System.out.println(u); /*修改用户信息*/ @Test void updateUser() User user = new User(); user.setId(userId); user.setUsername(updatedUser); user.setEmail(updated@example.com); userMapper.updateById(user); /*删除用户信息*/ @Test void deleteUser() userMapper.deleteById(userId); 2）service 测试 package com.example.demo.service;import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;import com.example.demo.pojo.User;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.util.List;@SpringBootTestclass UserServiceTest @Autowired private UserService userService; private Integer userId; @Test void contextLoads() /*测试数据库添加*/ @Test void saveUserService() User user = new User(); user.setUsername(testUser); user.setEmail(test@example.com); user.setPhone(1234567890); user.setPassword(password123); userService.saveOrUpdate(user); userId = user.getId(); /*测试单条查询*/ @Test void getOneService() User user = userService.getById(userId); System.out.println(user= + user); /*测试多条查询*/ @Test void getListService() QueryWrapperUser wrapper = new QueryWrapper(); wrapper.eq(username, testUser); ListUser list = userService.list(wrapper); for (User u : list) System.out.println(u); /*测试修改*/ @Test void updateUserService() User user = new User(); user.setId(userId); user.setUsername(updatedUser); user.setEmail(updated@example.com); userService.updateById(user); /*测试删除*/ @Test void deleteUserService() userService.removeById(userId); 5.实现基本代码 1）对客户管理系统做需求分析，写出以下表 CREATE TABLE `t_after_sales` ( `id` int NOT NULL AUTO_INCREMENT COMMENT 服务单号 (主键), `cust_id` int DEFAULT NULL COMMENT 关联的客户ID (关联t_customer.id), `question` varchar(50) DEFAULT NULL COMMENT 售后问题类型或简述, `state` varchar(50) DEFAULT NULL COMMENT 售后处理状态 (如：待处理、处理中、已解决), `record` varchar(200) DEFAULT NULL COMMENT 售后处理过程或回访记录详情, `level` int DEFAULT NULL COMMENT 问题严重性或优先级 (可用于内部评估), PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT=售后服务记录表 (客户服务);CREATE TABLE `t_customer` ( `id` int NOT NULL AUTO_INCREMENT COMMENT 客户ID (主键), `cust_name` varchar(50) DEFAULT NULL COMMENT 客户名称或公司名称, `address` varchar(100) DEFAULT NULL COMMENT 客户联系地址, `phone` varchar(11) DEFAULT NULL COMMENT 客户联系电话, `cust_type` varchar(50) DEFAULT NULL COMMENT 客户类型或分组 (如：所属行业、区域), `grade` int DEFAULT NULL COMMENT 客户等级 (评估客户价值), `his_total` double DEFAULT NULL COMMENT 历史交易总额 (用于客户价值分析), PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT=客户信息表 (客户档案);CREATE TABLE `t_item` ( `id` int NOT NULL AUTO_INCREMENT COMMENT 商品ID (主键), `item_name` varchar(50) DEFAULT NULL COMMENT 商品名称, `price` double DEFAULT NULL COMMENT 商品单价, `item_date` date DEFAULT NULL COMMENT 商品生产日期或上架日期, `hot_title` varchar(100) DEFAULT NULL COMMENT 促销活动标题或描述, `facturer` varchar(100) DEFAULT NULL COMMENT 生产厂家或品牌商, `store` int DEFAULT NULL COMMENT 商品当前库存数量, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT=商品信息表 (产品库);CREATE TABLE `t_order` ( `id` int NOT NULL AUTO_INCREMENT COMMENT 订单ID (主键), `cust_id` int DEFAULT NULL COMMENT 下单客户ID (关联t_customer.id), `item_id` int DEFAULT NULL COMMENT 购买的商品ID (关联t_item.id), `order_date` datetime DEFAULT NULL COMMENT 订单创建日期和时间, `state` varchar(50) DEFAULT NULL COMMENT 订单状态 (如：待付款、待发货、已完成), `pay` varchar(50) DEFAULT NULL COMMENT 支付方式 (如：支付宝、微信、银行卡), `pay_money` double DEFAULT NULL COMMENT 订单实际支付金额, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT=订单信息表 (交易记录);CREATE TABLE `t_sell_jh` ( `id` int NOT NULL AUTO_INCREMENT COMMENT 机会或计划ID (主键), `custid` int DEFAULT NULL COMMENT 关联的客户ID, `channel_id` int DEFAULT NULL COMMENT 销售机会来源渠道ID (可关联渠道表), `money` double DEFAULT NULL COMMENT 预计成交金额, `now_step` varchar(50) DEFAULT NULL COMMENT 当前销售阶段 (如：初步接触、报价、签约), `emp_id` int DEFAULT NULL COMMENT 负责该机会的销售员工ID, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT=销售机会/计划表 (销售过程管理); 2）在数据库里创建以上表后，再去 idea 里通过 mybatiesx 生成表格对应的增删改查代码 上面学了什么内容？ 指导你如何从零开始搭建一个基于 Spring Boot 框架的后端 Java 项目，并使用 MyBatis-Plus 作为数据访问层框架，连接 MySQL 数据库 MyBatis-Plus 代码用法 Mapper 层 (UserMapper)： MyBatis-Plus 会为你的每个数据库表生成一个对应的 Mapper 接口（例如 UserMapper 对应 t_user 表，尽管 t_user 表的创建 SQL 未在文档中给出，但测试代码中使用了 User 类和 UserMapper，可以推断）。 这个 Mapper 接口通常会继承 MyBatis-Plus 提供的 BaseMapperEntity 接口，这里的 Entity 就是对应数据库表的 Java 类（例如 User）。 通过继承 BaseMapper，你的 Mapper 接口会自动拥有许多常用的 CRUD 方法，你无需自己编写这些方法的 SQL。 文档中 UserMapperTest 测试代码展示了如何使用这些自动拥有的方法： userMapper.insert(user): 插入一条数据到数据库。 userMapper.selectById(userId): 根据主键 ID 查询单条数据。 userMapper.selectList(wrapper): 根据条件 查询多条数据。这里的 wrapper (如 UpdateWrapper 或 QueryWrapper) 是 MyBatis-Plus 提供的用于构建查询条件的工具。 userMapper.updateById(user): 根据 Entity 对象的主键 ID 更新数据。 userMapper.deleteById(userId): 根据主键 ID 删除数据。 核心用法： 你不再需要写 XML 文件或注解来定义基本的 CRUD SQL，直接调用继承自 BaseMapper 的方法即可完成数据库操作。 Service 层 (UserService)： MyBatis-Plus 同样提供了一个 IServiceEntity 接口。MyBatisX 插件通常会生成一个对应的 Service 接口（例如 UserService）和其实现类（例如 UserServiceImpl），Service 接口通常会继承 IServiceEntity。 Service 层封装了更高级的业务逻辑，它可能会调用一个或多个 Mapper 方法来完成一个更复杂的业务操作。 继承 IService 后，你的 Service 接口会自动拥有许多常用的 Service 层方法，它们底层调用了对应的 Mapper 方法，并可能包含事务管理等功能。 文档中 UserServiceTest 测试代码展示了如何使用这些方法： userService.saveOrUpdate(user): 保存或更新数据。如果 user 对象有 ID 则更新，没有 ID 则插入。 userService.getById(userId): 根据 ID 查询单条数据。 userService.list(wrapper): 根据条件查询多条数据。 userService.updateById(user): 根据 ID 更新数据。 userService.removeById(userId): 根据 ID 删除数据。 核心用法： Service 层提供了比 Mapper 层更高层级的操作方法，通常用于处理业务逻辑，MyBatis-Plus 也为 Service 层提供了很多基础方法，进一步简化了开发。 后端代码分层解释 Entity 层 (也被称为 POJO 层 或 Domain 层) 功能： 这一层包含对应数据库表的 Java 类（例如文档中测试代码里的 User 类）。每个类的属性对应数据库表的字段。这些类主要用于封装数据，在不同的层之间传递数据。它们通常是简单的 Java Bean，包含私有属性和公有的 getter/setter 方法（使用 Lombok 注解的**@Data**可以进一步简化这些）。 文档中的体现： 测试代码中出现了 com.example.demo.pojo.User 类，这就是 Entity 层的一个例子。 Mapper 层 (也被称为 DAO 层 - Data Access Object) 功能： 这一层是数据访问层，直接负责与数据库进行交互。它定义了对数据库执行各种操作的方法（如插入、删除、更新、查询）。MyBatis-Plus 的 Mapper 接口通常继承 BaseMapper，从而自动获得基础的 CRUD 能力。这个层只关注如何存取数据，不包含业务逻辑。 文档中的体现： UserMapperTest 使用了 UserMapper 接口，并调用了它的方法。 @MapperScan(com.example.demo.mapper) 也表明存在一个 mapper 包存放 Mapper 接口。 Service 层 功能： 这一层是业务逻辑层。它封装了具体的业务处理流程。Service 层的方法会调用一个或多个 Mapper 层的方法来完成一个完整的业务功能。例如，“注册用户”这个业务可能需要先调用 Mapper 插入用户数据，然后调用另一个 Mapper 插入用户的默认设置。Service 层是协调数据访问和实现业务规则的地方。它不直接与数据库交互，而是通过调用 Mapper 来实现。MyBatis-Plus 的 Service 接口通常继承 IService，提供了一些常用的业务方法。 文档中的体现： UserServiceTest 使用了 UserService 接口，并调用了它的方法。这表明存在一个 Service 层来处理用户相关的业务操作。 4. Controller 层 (也被称为 Web 层) 功能： 这一层是应用程序的入口点，直接处理来自客户端（比如浏览器、手机 App、其他服务）的 HTTP 请求。 它负责接收请求参数。 它根据请求的 URL 找到对应的处理方法。 它调用 Service 层的方法来执行具体的业务逻辑。 它处理 Service 层返回的结果。 它准备并返回响应给客户端（通常是 JSON 格式的数据，或者是一个网页）。 重要的原则是： Controller 层应该尽可能“薄”，它只负责接收请求、调用 Service、返回响应，不应该包含复杂的业务逻辑。业务逻辑应该全部放在 Service 层。 前端搭建 1.安装 Node.js 下载地址：下载 Node.js-Node.js 中文网 1）配置镜像 参考：npm 最新国内镜像源设置 2025 以管理员身份进入命令窗口。 执行以下命令为 npm 配置国内镜像： npm config set registry https://registry.npmmirror.com 命令执行完毕后，可用以下命令检测配置： npm config get registry 2）安装 Vue 脚手架 执行以下命令全局安装 Vue CLI： npm install -g @vue/cli [!CAUTION] 如果安装失败，需要关掉终端再进入，才能让镜像配置生效 3）创建 Vue 工程 进入到工程所在的目录。 执行以下命令创建 Vue 项目，注意 projectName 改为你的前端项目名： vue create erpfront 选择第三个手动配置 按下空格选择 router，取消选择 liner，按 enter 进行下一步 版本选择 3.x，询问 y/n 全部填 n 这个位置选择最后一个 2.根据工程下面的 readme 文档启动项目 运行这两个命令 1）安装依赖 yarn install 2）编译并启动开发服务器 yarn serve . 3.配置需要的包 1）安装 element-plus 官方文档-安装教程 npm install element-plus --save 2）安装 axios axios 官方文档 npm install axios 上面学了什么内容？ 前端项目主要代码在 src 文件夹里。 在 src 里面，main.js 是程序的启动点，App.vue 是最外层的页面框架。 src 下面还有几个子文件夹： assets 放图片等资源。 components 放页面里重复使用的小模块。 router 放页面跳转（路由）的设置。 views 放组成整个页面的大模块。 node_modules 放项目用到的各种第三方库。 public 放一些直接复制到最终项目里的文件。 其他文件是项目配置和依赖管理文件。 📦 project-root (项目根目录 - 截图中最顶层) ├─ 📂 node_modules (存放项目依赖库的文件夹) ├─ 📂 public (存放不需要打包处理的静态资源的文件夹) ├─ 📂 src (存放项目核心源代码的文件夹，这是重点) │ ├─ 📂 assets (放在 src/ 下面的一个子文件夹，存放需要打包的静态资源，如图片、字体等) │ ├─ 📂 components (放在 src/ 下面的一个子文件夹，存放可复用的、小的 Vue 组件) │ │ └─ 📄 HelloWorld.vue (一个示例组件文件) │ ├─ 📂 router (放在 src/ 下面的一个子文件夹，存放前端路由配置相关的文件) │ │ └─ 📄 index.js (通常是路由定义文件) │ ├─ 📂 views (放在 src/ 下面的一个子文件夹，存放页面级别的 Vue 组件) │ │ ├─ 📄 AddCustomer.vue (添加客户页面) │ │ ├─ 📄 AddSellJh.vue (添加销售机会页面) │ │ ├─ 📄 ListAfterSale.vue (售后列表页面) │ │ ├─ 📄 ListCustomer.vue (客户列表页面) │ │ ├─ 📄 ListCustOrder.vue (客户订单列表页面) │ │ └─ 📄 ListSellJh.vue (销售机会列表页面) │ ├─ 📄 App.vue (直接放在 src/ 下面的文件，整个应用的根组件) │ └─ 📄 main.js (直接放在 src/ 下面的文件，整个应用的入口文件，负责初始化 Vue) ├─ 📄 .gitignore (Git 版本控制忽略文件) ├─ 📄 babel.config.js (Babel 配置文件，用于 JavaScript 编译) ├─ 📄 jsconfig.json (JavaScript 项目配置) ├─ 📄 package-lock.json (记录安装依赖时的精确版本信息) ├─ 📄 package.json (项目信息和依赖列表文件) ├─ 📄 README.md (项目说明文件) ├─ 📄 vue.config.js (Vue CLI 项目自定义配置文件) └─ 📄 yarn.lock (Yarn 依赖管理器的锁文件) Day2 菜单功能 后端实现 对前端提供 menu 参数 1）新建 menu 表 CREATE TABLE `t_menu` ( `id` int NOT NULL AUTO_INCREMENT COMMENT ID (主键), `label` varchar(50) DEFAULT NULL COMMENT 导航名称, `component` int DEFAULT NULL COMMENT 子id, `pid` int DEFAULT NULL COMMENT 父id, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT=前端菜单表; 2）对表插入数据 insert into `t_menus`(`id`,`label`,`component`,`pid`) values (1,客户管理,NULL,0),(2,添加客户,0,1),(3,查询客户,1,1),(4,售后服务,2,1),(5,客户订单,3,1),(6,客户跟踪,4,1),(7,数据统计,NULL,0),(8,客户统计,5,7),(9,库存统计,6,7); 3）生成代码 在数据库里创建 menu 表后，再去 idea 里通过 mybatiesx 生成表格对应的增删改查代码 4）定义 vo 类 定义一个 vo 类，方便把数据打包发给前端 为什么这样定义：阿里巴巴 Java 开发手册中的 DO、DTO、BO、AO、VO、POJO 定义 更深层次的意义在于数据模型在不同层之间传递时可能需要转换**。** t_menu 表的数据对应一个简单的 Menu POJO，它只有 id, label, component, pid 字段。但为了前端的菜单树结构，你需要把它转换成 MenuVo，增加了一个 subMenu 列表字段。并且通过 BeanUtils.copyProperties 实现了基础字段的复制。 这种从数据库模型 (POJO) 到视图展示模型 (VO) 的转换，是后端开发中处理数据流时的一个常见且必要的逻辑。 . package com.example.demo.vo;import lombok.Data;import java.util.List;@Datapublic class MenuVo private Integer id; private String label; private Integer component; private ListMenuVo subMenu; 5）修改服务层代码 实现将菜单返回给前端的功能 服务接口代码： /*** @author skyforever* @description 针对表【t_menu(前端菜单表)】的数据库操作Service* @createDate 2025-05-13 16:01:20*/public interface MenuService extends IServiceMenu /** * 查询并构建菜单树列表 * @return 菜单树结构的Vo列表 */ ListMenuVo queryMenuListService(); 服务实现代码： 下面的 buildSubmenu 方法是一个典型的递归函数的应用。它通过不断调用自身来处理树形结构（子菜单）。 /*** @author skyforever* @description 针对表【t_menu(前端菜单表)】的数据库操作Service实现* @createDate 2025-05-13 16:01:20*/@Servicepublic class MenuServiceImpl extends ServiceImplMenuMapper, Menu implements MenuService @Override public ListMenuVo queryMenuListService() // 1. 查询所有菜单数据 ListMenu allMenu = this.list(); return buildSubmenu(allMenu, 0); /** * 递归构建子菜单树 * * @param allMenu 所有菜单的列表 * @param parentId 当前要查找的父菜单ID * @return 指定父菜单ID下的子菜单树列表 */ private ListMenuVo buildSubmenu(ListMenu allMenu, Integer parentId) ListMenuVo submenuTree = new ArrayList(); for (Menu menu : allMenu) // 检查当前菜单的父ID是否与传入的parentId匹配 if (menu.getPid() != null menu.getPid().equals(parentId)) MenuVo menuVo = new MenuVo(); BeanUtils.copyProperties(menu, menuVo); // 将 POJO属性 复制到 VO // 递归查找当前菜单的子菜单 menuVo.setSubMenu(buildSubmenu(allMenu, menu.getId())); submenuTree.add(menuVo); return submenuTree; 6）控制层代码 . @Autowired 注解被用在了 UserMapper 和 UserService 上，但没有用老式 Java 代码手动写代码去 new 出一个 UserMapper 或 UserService 对象。 这是 Spring 框架依赖注入 (Dependency Injection - DI) 的体现。Spring Boot 会自动扫描并创建这些类的实例（称为 Bean），并在需要的地方自动把它们“装配”进去。 @RestControllerpublic class MenusController @Autowired private MenuService menusService; /*定义方法处理，加载左侧菜单节点的请求*/ @CrossOrigin @RequestMapping(/listMenus) public ListMenuVo listMenus() return menusService.queryMenuListService(); 7）修改启动类 添加对 mapper 的扫描注解 . 8）启动并测试 成功启动后，检验后端是否能返回预期数据 9）配合前端调试 实现前端控制台输出菜单 id 只需要在控制层（MenusController）里加一个函数获取菜单 id /*定义方法处理，加载左侧菜单节点的对应的组件下标的请求*/@CrossOrigin@RequestMapping(/compIndex)public Integer compIndex(Integer id) Menu menus = menusService.getById(id); return menus.getComponent(); 上面学了什么内容？ 上面的过程清晰地展示了Controller、Service、Mapper 和 VO 这几个层级如何协作： Controller (MenusController)：接收前端请求 (/listMenus)，调用 Service 层方法。 Service (MenuServiceImpl)：调用 Mapper 获取所有原始数据，执行业务逻辑（将平铺数据构建成树状），准备好适合前端的 VO 数据。 Mapper (MenuMapper)：通过 MyBatis-Plus 的 list() 方法从数据库获取原始 Menu (POJO) 数据。 VO (MenuVo)：作为 Service 层处理后、Controller 层返回给前端的最终数据格式。 前端实现 从后端获取 menu 参数 1）修改 main.js 添加对饿了么 ui 的引用 // 引入 ElementPlus 组件库import ElementPlus from element-plus;// 引入 ElementPlus 的默认样式文件import element-plus/dist/index.css;// 创建 Vue 应用实例，注册 ElementPlus 和路由，并挂载到 #app 元素createApp(App).use(ElementPlus).use(router).mount(#app); 2）修改 index.js 把 index.vue 页面文件加入页面路由中 import index from ../views/index.vue//注意前面需要导入页面, path: /index, // 定义路由路径为 /index name: index, // 给该路由起一个名字，便于在组件中引用 component: index // 指定该路由对应的组件为 index 3）实现 index.vue 实现之前，需要设置两个没有设置逻辑的页面AddCustomer.vue和ListCustomer.vue script setup lang=ts/scripttemplate /templatestyle scoped/style index.vue 的具体实现 响应式系统 (ref, shallowRef): 使用 ref 来创建响应式数据（menus），当这些数据变化时，UI 会自动更新。 shallowRef 和 markRaw 让你初步了解了 Vue 3 针对复杂对象或组件引用的性能优化和更细粒度的响应式控制。 生命周期钩子 (onMounted): 学会了在组件的特定阶段（DOM 挂载后）执行代码，比如在这里用于在页面加载完成后立即发起数据请求。 客户端路由 (vue-router): 通过修改 router/index.js 和使用 (虽然代码中没直接展示 ，但动态组件 承担了类似角色)，学到了如何在前端实现页面间的无刷新跳转和导航，以及如何将 URL 路径映射到特定的 Vue 组件（页面） script setup import AddCustomer from @/views/AddCustomer.vue; import ListCustomer from @/views/ListCustomer.vue; //导入要跳转的两个页面 import onMounted, ref from vue; import axios from axios; import markRaw, shallowRef from vue; // 声明数组保存所有组件，按后端component值顺序映射 const views = [markRaw(AddCustomer), markRaw(ListCustomer)]; const currentComponent = shallowRef(views[0]); const menus = ref([]); /* menu组件选中叶子节点触发的函数，参数index：菜单节点的id */ const handlerSelect = function (index) // 查找对应菜单项的component值 let componentIndex = 0; menus.value.forEach((menu) = menu.subMenu.forEach((subMenu) = if (subMenu.id === parseInt(index)) componentIndex = subMenu.component; ); ); // 动态设置currentComponent currentComponent.value = views[componentIndex]; ; onMounted(() = axios .get(http://localhost:8080/listMenus) .then((response) = menus.value = response.data; ) .catch((error) = console.log(error); ); );/scripttemplate div class=common-layout el-container el-header class=topERP-ikun小组/el-header el-container el-aside width=240px class=left 系统菜单 el-menu class=el-menu-vertical-demo @select=handlerSelect //绑定事件 el-sub-menu v-for=menu in menus :index=menu.id.toString() template #title span menu.label /span /template el-menu-item v-for=subMenu in menu.subMenu :index=subMenu.id.toString() subMenu.label /el-menu-item /el-sub-menu /el-menu /el-aside el-main class=right component :is=currentComponent/component /el-main /el-container /el-container /div/templatestyle scoped .top background-color: azure; .left background-color: blanchedalmond; height: 600px; .right background-color: cornsilk; /style 4）启动项目 看看能不能实现从后端获取菜单并加载 5）配合后端 实现获取当前菜单选项 id 需要在后端菜单控制层代码加方法 然后，前端代码修改 handlerSelect 方法即可： /* menu组件选中叶子节点触发的函数，参数index：菜单节点的id */const handlerSelect = function (index) console.log(选择的页面id:, index); // 用于调试 id axios .get(http://localhost:8080/compIndex?id= + index) .then((response) = console.log(后端返回的id值:, response.data); // 调试后端返回的值 const componentIndex = response.data; currentComponent.value = views[componentIndex]; ) .catch((error) = console.log(Error:, error); // 捕获并显示错误 );; 上面学了什么内容？ 从这份前端代码学到了如何从“静态网页”转向“动态、交互式、模块化”的现代前端开发，了解了 Vue.js 框架、路由、组件化、状态管理（简单响应式）、数据请求与处理、UI 库使用以及事件响应等核心技能，这是构建一个功能性 Web 应用前端的重要基础。 Day3 1 增删改查客户信息 后端实现 1. 添加 Mybatis 配置 在后端实现客户列表的查询时，为了避免一次性加载所有数据导致性能问题，我们通常需要进行分页。MyBatis-Plus 的分页拦截器 (PaginationInnerInterceptor) 就是用来自动化实现这个功能的。 它的核心作用是拦截你使用 MyBatis-Plus 标准方法（如 selectList(page, ...)）执行的 SQL 查询。在执行数据库查询之前，这个拦截器会检查你是否传入了一个 Page 对象。如果传入了，它就会自动修改你原始的 SQL 语句，在后面添加 LIMIT 子句。 例如，如果你原始的查询是 SELECT * FROM t_customer WHERE ...，分页拦截器可能会根据你传入的页码和每页大小，将其改写为 SELECT * FROM t_customer WHERE ... LIMIT offset, pageSize。 这样就无需手动编写分页的 SQL 逻辑。你只需要配置好分页拦截器，并在 Service 层调用 Mapper 方法时传入 Page 对象，MyBatis-Plus 就会自动帮你处理底层数据库的分页细节，大大简化了分页功能的开发。 配置它的方式就是创建一个 @Configuration 类 (MybatisPlusPageConfig)，定义一个 @Bean 方法返回 MybatisPlusInterceptor，并在其中添加 PaginationInnerInterceptor。 import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class MybatisPlusPageConfig /*给mybatisplus注册拦截器，修改sql语句，给sql语句添加limit关键字*/ @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor(); mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor()); return mybatisPlusInterceptor; 2. 实现增删改查 对前端提供客户列表的增删改查方法 Controller 层 @RestController@CrossOriginpublic class CustomerController @Autowired private CustomerService customerService; /*增 添加客户信息*/ @PostMapping(/saveCust) public MapString, Object saveCustomer(@RequestBody Customer customer) System.out.println(customer); MapString, Object result = new HashMap(); result.put(code, 400); customerService.save(customer); result.put(code, 200); return result; /*查 处理客户信息分页查询请求*/ @GetMapping(/listCust) public MapString, Object queryCustList( @RequestParam(defaultValue = 1) Integer pageNum, @RequestParam(defaultValue = 10) Integer pageSize) return customerService.queryCustListService(pageNum, pageSize); /*删 删除客户信息*/ @DeleteMapping(/deleteCust/id) public MapString, Object deleteCustomer(@PathVariable Integer id) MapString, Object result = new HashMap(); try customerService.removeById(id); result.put(code, 200); result.put(message, 删除成功); catch (Exception e) result.put(code, 400); result.put(message, 删除失败); return result; /*改 修改客户信息*/ @PutMapping(/updateCust) public MapString, Object updateCustomer(@RequestBody Customer customer) MapString, Object result = new HashMap(); try customerService.updateById(customer); result.put(code, 200); result.put(message, 修改成功); catch (Exception e) result.put(code, 400); result.put(message, 修改失败); return result; Service 层实现分页查询 /*** @author skyforever* @description 针对表【t_customer(客户表)】的数据库操作Service实现* @createDate 2025-05-13 10:05:12*/@Servicepublic class CustomerServiceImpl extends ServiceImplCustomerMapper, Customer implements CustomerService // 注入CustomerMapper @Autowired private CustomerMapper customerMapper; @Override public MapString, Object queryCustListService(Integer pageNum, Integer pageSize) MapString, Object result = new HashMap(); // 初始化分页对象 Page page = new Page(pageNum, pageSize); System.out.println(page.getTotal()); List list = customerMapper.selectList(page, null); System.out.println(page.getTotal()); result.put(custlist, list); result.put(total, page.getTotal()); return result; 对应服务添加接口 public interface CustomerService extends IServiceCustomer /** * 查询客户列表，并支持分页 * * @param pageNum 当前页码 * @param pageSize 每页显示数量 * @return 包含客户列表和总数的结果Map */ MapString, Object queryCustListService(Integer pageNum, Integer pageSize); 前端实现 写两个页面，分别实现查和增删改 昨天在 index.vue 添加了 AddCustomer 页面和 ListCustomer 页面，这里不重复 1. 客户信息页实现 AddCustomer.vue script setup // --- 模块导入 --- import reactive from vue; // reactive: 用于创建响应式对象 import axios from axios; // axios: 用于发送HTTP请求 // --- 响应式状态定义 --- // 初始化响应式表单数据对象 (custForm) const custForm = reactive( custName: , // 客户名称 address: , // 联系地址 phone: , // 联系电话 custType: , // 客户职业 grade: , // 客户等级 ); // --- 方法定义 --- // 声明提交表单的函数 (subCustForm) function subCustForm() // 使用axios发送POST请求到后端API /saveCust，请求体为custForm对象 axios .post(http://localhost:8080/saveCust, custForm) .then((response) = // 请求成功的回调 console.log(response.data); // 打印后端返回的数据 // 提交成功后，清空表单各项数据 Object.assign(custForm, custName: , address: , phone: , custType: , grade: , ); ) .catch((error) = // 请求失败的回调 console.error(提交失败:, error); // 在控制台打印错误信息 // 实际项目中，这里通常会显示错误提示给用户 ); // 定义重置表单的函数 (resetForm) function resetForm() // 将表单各项数据重置为空字符串 (或初始默认值) Object.assign(custForm, custName: , address: , phone: , custType: , grade: , ); /scripttemplate !-- 页面主标题 -- h2添加客户信息/h2 !-- Element Plus 表单组件 (el-form) -- !-- :model=custForm 将表单数据模型绑定到script部分的custForm响应式对象 -- !-- label-width=120px 设置表单项标签的统一宽度 -- el-form :model=custForm label-width=120px !-- 表单项 (el-form-item): 每个表单项包含一个标签(label)和一个输入控件 -- el-form-item label=客户名称 !-- Element Plus 输入框 (el-input) -- !-- v-model=custForm.custName 双向绑定输入框的值到custForm对象的custName属性 -- el-input v-model=custForm.custName style=width: 80% / /el-form-item el-form-item label=联系地址 el-input v-model=custForm.address style=width: 80% / /el-form-item el-form-item label=联系电话 el-input v-model=custForm.phone style=width: 80% / /el-form-item el-form-item label=客户职业 !-- Element Plus 选择器 (el-select) -- !-- v-model=custForm.custType 双向绑定选择器的值到custForm对象的custType属性 -- !-- placeholder 设置未选择时的提示文本 -- el-select v-model=custForm.custType placeholder=请选择职业…… style=width: 80% !-- 下拉选项 (el-option): label为显示文本, value为实际选中值 -- el-option label=保密 value=保密 / el-option label=金融 value=金融 / el-option label=互联网 value=互联网 / el-option label=IT value=IT / el-option label=能源 value=能源 / /el-select /el-form-item el-form-item label=客户等级 el-input v-model=custForm.grade style=width: 80% / /el-form-item !-- 表单操作按钮区域 -- el-form-item !-- Element Plus 按钮 (el-button) -- !-- type=primary 设置按钮主题色为主色调 -- !-- @click=subCustForm 点击时调用subCustForm方法 -- el-button type=primary @click=subCustForm保存/el-button !-- @click=resetForm 点击时调用resetForm方法 -- el-button @click=resetForm取消/el-button /el-form-item /el-form/templatestyle scoped /* scoped样式: CSS只作用于当前组件 */ /* 设置表单的最大宽度并使其居中显示 */ .el-form max-width: 600px; /* 限制表单最大宽度 */ margin: 20px auto; /* 上下20px外边距，左右自动外边距实现水平居中 */ /style 2.删改查客户页实现 ListCustomer.vue template !-- 1. 模板区域: 定义组件的HTML结构 -- h2客户列表/h2 !-- 2. 客户信息展示表格 (饿了么Plus组件 el-table) -- !-- :data绑定客户列表数据, stripe开启斑马纹, style设置宽度 -- el-table :data=custList stripe style=width: 100% !-- el-table-column: 定义表格列。prop指定数据源的字段名, label指定列头文本 -- el-table-column prop=id label=客户编号 / el-table-column prop=custName label=客户姓名 / el-table-column prop=address label=客户地址 / el-table-column prop=phone label=客户电话 / el-table-column prop=custType label=客户职业 / el-table-column prop=grade label=客户等级 / el-table-column prop=hisTotal label=消费总额 / !-- 操作列: fixed固定在右侧, width设置宽度, #default作用域插槽自定义内容 (row代表当前行数据) -- el-table-column fixed=right label=操作 width=120 template #default= row !-- 饿了么按钮: link类型像链接, 小按钮样式，@click绑定点击事件 -- el-button link type=primary size=small @click=deleteCustomer(row.id) 删除/el-button el-button link type=primary size=small @click=openCustDialog(row) 修改/el-button /template /el-table-column /el-table hr / !-- 3. 分页组件 (饿了么Plus组件 el-pagination) -- !-- small小型分页, background带背景色, :page-size每页条数, :pager-count页码按钮数, layout组件布局, :total总条数, @current-change页码改变事件 -- el-pagination size=small background :page-size=10 :pager-count=5 layout=prev, pager, next :total=total class=mt-4 @current-change=handlerPageChange / !-- 4. 修改客户信息对话框 (饿了么Plus组件 el-dialog) -- !-- v-model控制显示/隐藏, width宽度, title标题 -- el-dialog v-model=dialogCustVisible width=80% title=修改客户信息 !-- 客户信息表单 (饿了么Plus组件 el-form) -- !-- :model绑定表单数据对象, label-width标签宽度, :rules绑定验证规则, ref用于访问表单实例 -- el-form :model=custForm label-width=120px :rules=rules ref=custFormRef !-- el-form-item: 表单项。label标签文本, prop关联数据和规则 -- el-form-item label=客户名称 prop=custName !-- el-input: 输入框, v-model双向绑定数据 -- el-input v-model=custForm.custName style=width: 80% / /el-form-item el-form-item label=联系地址 prop=address el-input v-model=custForm.address style=width: 80% / /el-form-item el-form-item label=联系电话 prop=phone el-input v-model=custForm.phone style=width: 80% / /el-form-item el-form-item label=客户职业 prop=custType !-- el-select: 下拉选择框 -- el-select v-model=custForm.custType placeholder=请选择职业.... style=width: 80% !-- el-option: 下拉选项, label显示文本, value实际值 -- el-option label=保密 value=保密 / el-option label=金融 value=金融 / el-option label=互联网 value=互联网 / el-option label=IT value=IT / el-option label=能源 value=能源 / /el-select /el-form-item el-form-item label=客户等级 prop=grade !-- .number修饰符, 输入值自动转为数字 -- el-input v-model.number=custForm.grade style=width: 80% / /el-form-item /el-form !-- 对话框底部操作区域 (el-dialog的#footer插槽) -- template #footer el-button @click=cancelForm取消/el-button el-button type=primary @click=subCustForm保存/el-button /template /el-dialog/template!-- 5. Script区域 (Vue 3 Composition API setup语法糖) --script setup // 导入Vue核心API, Axios HTTP库, Element Plus组件 import onMounted, ref, reactive from vue; import axios from axios; import ElMessage, ElMessageBox from element-plus; // --- 响应式状态定义 --- const custList = ref([]); // 客户列表数据 const total = ref(0); // 客户总记录数 (用于分页) const dialogCustVisible = ref(false); // 控制修改对话框的显示/隐藏 const custFormRef = ref(null); // 表单DOM引用 (用于调用表单方法如validate, resetFields) // 客户表单数据模型 (响应式对象) const custForm = reactive( id: null, custName: , address: , phone: , custType: , grade: 1, hisTotal: 0, ); // 表单验证规则 const rules = custName: [ required: true, message: 请输入客户名称, trigger: blur ], address: [ required: true, message: 请输入联系地址, trigger: blur ], phone: [ required: true, message: 请输入联系电话, trigger: blur , pattern: /^\\d11$/, message: 请输入11位数字电话, trigger: blur , ], custType: [ required: true, message: 请选择客户职业, trigger: change , ], grade: [ required: true, message: 请输入客户等级, trigger: blur , type: number, message: 等级必须为数字, trigger: blur , ], ; // --- 方法定义 --- // 查询客户列表 (pageNum: 请求的页码) function custListQeury(pageNum) // 使用 axios 发送 GET 请求到后端 API axios .get(`http://localhost:8080/listCust?pageNum=$pageNum`) .then((response) = // 请求成功的回调 custList.value = response.data.custlist; // 更新客户列表数据 total.value = response.data.total; // 更新总记录数 ) .catch((error) = // 请求失败的回调 ElMessage.error(查询失败); // 使用 Element Plus 的 ElMessage 显示错误提示 console.log(error); // 在控制台打印错误信息 ); // 删除客户 (id: 客户ID) function deleteCustomer(id) ElMessageBox.confirm(确定删除该客户吗？, 提示, confirmButtonText: 确定, cancelButtonText: 取消, type: warning, ) .then(() = axios .delete(`http://localhost:8080/deleteCust/$id`) .then(() = ElMessage.success(删除成功); custListQeury(1); // 刷新列表 ) .catch((error) = ElMessage.error(删除失败); console.log(error); ); ) .catch(() = ElMessage.info(取消删除); ); // 打开修改对话框并填充数据 (row: 当前行数据) function openCustDialog(row) dialogCustVisible.value = true; // 使用Object.assign将行数据安全地复制到表单模型，提供默认值以防row中字段缺失 Object.assign(custForm, id: row.id, custName: row.custName || , address: row.address || , phone: row.phone || , custType: row.custType || , grade: row.grade || 1, hisTotal: row.hisTotal || 0, ); // 提交修改表单 function subCustForm() custFormRef.value.validate((valid) = // 调用表单验证 if (valid) axios .put(http://localhost:8080/updateCust, custForm) .then(() = ElMessage.success(修改成功); dialogCustVisible.value = false; //关闭弹窗 custListQeury(1); // 刷新列表 ) .catch((error) = ElMessage.error(修改失败); console.log(error); ); else ElMessage.error(请填写完整信息); ); // 取消修改 (关闭对话框并重置表单) function cancelForm() dialogCustVisible.value = false; custFormRef.value.resetFields(); // 重置表单项到初始值并移除校验结果 // --- 生命周期钩子 --- // 组件挂载后执行: 初始化加载第一页数据 onMounted(() = custListQeury(1); ); // 处理分页页码变化 (value: 新的页码) function handlerPageChange(value) custListQeury(value); /script!-- 6. Style区域 (scoped表示样式仅作用于当前组件) --style scoped /* 此处可添加组件特定样式 *//style 2 增删改查销售过程信息 实现销售机会过程数据维护，销售过程数据和客户信息表存在主外键关系。 后端实现 1.为销售机会页面提供下拉列表内容查询 Customer 添加相关方法 服务层接口 /*查询所有客户Id和姓名*/public ListCustomer queryCustIdNameListService(); 服务层实现 @Overridepublic ListCustomer queryCustIdNameListService() QueryWrapperCustomer wrapper=new QueryWrapper(); //指定列的投影，指定select id,cust_name wrapper.select(id,cust_name); ListCustomer customerList = customerMapper.selectList(wrapper); return customerList; 控制层实现 /*处理加载所有客户列表请求*/@GetMapping(/listAllCust)public ListCustomer listAllCust() return customerService.queryCustIdNameListService(); 2.为销售机会页面实现保存功能 新增 SellJhController @RestController@CrossOriginpublic class SellJhController @Autowired private SellJhService sellJhService; /*添加销售计划*/ @PostMapping(/saveSellJh) public MapString, Object saveSellJh(@RequestBody SellJh sellJh) MapString, Object result = new HashMap(); try sellJhService.save(sellJh); result.put(code, 200); result.put(message, 添加成功); catch (Exception e) result.put(code, 400); result.put(message, 添加失败); return result; 前端实现 1. 添加销售机会页面 AddSellJh.vue 代码： template h2销售开发/h2 el-form :model=sellForm label-width=120px el-form-item label=客户名称 !-- 客户选择下拉框: 选项动态从后端获取 -- !-- v-model绑定的是选中客户的ID -- el-select v-model=sellForm.custid class=m-2 placeholder=请选择客户 size=large style=width: 80% !-- v-for遍历custList (从后端获取的客户列表) 来动态生成选项 -- !-- :key为每个选项提供唯一标识, :label显示客户名称, :value是客户的ID -- el-option v-for=item in custList :key=item.id :label=item.custName :value=item.id / /el-select /el-form-item el-form-item label=销售渠道 el-select v-model=sellForm.channelId placeholder=请选择渠道.... style=width: 80% el-option label=自媒体 value=0 / el-option label=网络推广 value=1 / el-option label=老客户介绍 value=2 / el-option label=陌拜 value=3 / el-option label=二次客户 value=4 / /el-select /el-form-item el-form-item label=销售金额 el-input v-model=sellForm.money style=width: 80% / /el-form-item el-form-item label=开发阶段 el-select v-model=sellForm.nowStep placeholder=请选择.... style=width: 80% el-option label=解除 value=解除 / el-option label=报价 value=报价 / el-option label=签约 value=签约 / /el-select /el-form-item el-form-item label=业务员 el-input v-model=sellForm.empId style=width: 80% / /el-form-item el-form-item el-button type=primary @click=subSellForm保存/el-button el-button取消/el-button /el-form-item /el-form/templatescript setup import onMounted, reactive, ref from vue; import axios from axios; //定义销售过程表单 const sellForm = reactive( custid: , // 存储选中的客户ID channelId: , money: 0.0, nowStep: , empId: 100, // 业务员ID，默认为100 ); //创建数组，用于封装从后端获取的所有客户信息 (用于客户名称下拉列表) const custList = ref([]); //页面挂载时执行: 发送ajax请求，查询所有客户信息，用于填充客户名称的下拉列表框 onMounted(function () axios .get(http://localhost:8080/listAllCust) // API端点，获取所有客户列表 .then((response) = custList.value = response.data; // 将获取的客户数据赋值给custList ) .catch((error) = console.log(error); ); ); function subSellForm() axios .post(http://localhost:8080/saveSellJh, sellForm) .then((response) = // 检查后端返回的业务状态码，确保操作成功 if (response.data.code === 200) console.log(response.data); // 成功后清空表单, custid设为null，empId恢复默认值 Object.assign(sellForm, custid: null, channelId: , money: 0.0, nowStep: , empId: 100, ); ) .catch((error) = console.error(提交失败:, error); ); /scriptstyle scoped/style 2.注册销售机会页面 修改 index.vue，将上面的 AddSellJh.vue 页面加入进去 import AddSellJh from @/views/AddSellJh; //添加页面//如果是老师的方案，就修改数组const views = [AddCustomer, ListCustomer, , , AddSellJh]; //声明数组保存所有组件，将AddSellJh页面放到下标为四的位置//如果是我的方案（用markRaw），则直接加多个占位符import axios from axios;import markRaw, shallowRef from vue;// 声明数组保存所有组件，按后端component值顺序映射const views = [ markRaw(AddCustomer), markRaw(ListCustomer), markRaw(AddSellJh), markRaw(AddSellJh), markRaw(AddSellJh),]; Day3 学了什么 从基础的项目搭建和 Mybatis-Plus 的基本增删改查使用，进步到了实现完整的、带有实际业务功能的客户信息管理。 学会了如何在后端实现客户信息的增、删、改、查 API，并在前端构建了对应的页面，利用 Vue.js 和 Element Plus UI 组件库实现了数据的展示（表格）、表单的提交、修改对话框和删除确认，以及前后端通过 HTTP 请求进行数据交互来完成这些操作。 特别是学会了处理数据分页和动态加载下拉列表数据，让应用更能应对实际数据量。 Day4 1.统计每个客户历史消费总额 通过订单表统计每个客户历史消费总额，更新到客户信息表 以下全部针对后端操作 创建 HisData 实体类 package com.example.demo.dto;import lombok.Data;@Datapublic class HisData private Long custId; private Double hisTotal; OrderMapper 接口添加方法 public interface OrderMapper extends BaseMapperOrder /* 查询统计每个客户历史消费总额 */ ListHisData queryCountHisDataMapper(); OrderMapper.xml 定义 SQL 写出带有 GROUP BY 和 SUM() 聚合函数的 SQL 语句。 这是 MyBatis-Plus 自动生成的简单 CRUD 无法覆盖的，需要你根据业务需求手写 SQL 来实现更复杂的数据库查询。 !-- 顶级sql统计客户历史消费总额 --select id=queryCountHisDataMapper resultType=com.example.demo.dto.HisData select cust_id custId, sum(pay_money) hisTotal from t_order group by cust_id/select 实现客户信息表更新 修改 CustomerServiceImpl 中分页查询方法： 在 CustomerServiceImpl 的 queryCustListService 方法中，先调用了 OrderMapper 的方法查询统计数据，然后遍历这个结果，再逐条针对每个客户调用 CustomerMapper 的 updateById 方法来更新客户表中的历史消费总额。这展示了在一个业务流程中，如何协调不同表（通过不同 Mapper）的数据操作。 事务管理 (@Transactional)： 在这个更新操作的方法上添加了 @Transactional 注解。这是一个非常重要的进步，它保证了在更新客户历史消费总额这一系列数据库操作中，要么所有更新都成功，要么如果中途发生任何错误，所有已做的更新都会回滚。 这确保了数据的一致性和完整性。 // 注入 Mapper@Autowiredprivate CustomerMapper customerMapper;@Autowiredprivate OrderMapper orderMapper;@Transactional@Overridepublic MapString, Object queryCustListService(Integer pageNum, Integer pageSize) MapString, Object result = new HashMap(); System.out.println(==================); // 将客户历史消费信息更新到客户信息表 ListHisData hisDatas = orderMapper.queryCountHisDataMapper(); for (HisData hisData : hisDatas) Customer cust = new Customer(); cust.setId(hisData.getCustId()); cust.setHisTotal(hisData.getHisTotal()); customerMapper.updateById(cust); // 创建封装分页查询参数的 Page 对象 Page page = new Page(pageNum, pageSize); System.out.println(page.getTotal()); List list = customerMapper.selectList(page, null); System.out.println(page.getTotal()); result.put(custList, list); result.put(total, page.getTotal()); return result; 2.实现销售过程表的增删改查 后端实现 在服务层添加分页方法接口 public interface SellJhService extends IServiceSellJh /*定义分页查询方法*/ public MapString,Object querySellJhListService(Integer pageNum, Integer pageSize); 实现此接口 @Autowiredprivate SellJhMapper sellJhMapper;@Overridepublic MapString, Object querySellJhListService(Integer pageNum, Integer pageSize) MapString, Object result=new HashMap(); PageSellJh page=new Page(pageNum,pageSize); System.out.println(1---------+page.getTotal()); ListSellJh sellJhs = sellJhMapper.selectList(page, null); System.out.println(2---------+page.getTotal()); result.put(sellJhList,sellJhs); result.put(total,page.getTotal()); return result; 添加控制层接口相关方法 /*处理销售计划分页查询请求*/@GetMapping(/sellJhList)public MapString, Object querySellJhList( @RequestParam(defaultValue = 1) Integer pageNum, @RequestParam(defaultValue = 10) Integer pageSize) return sellJhService.querySellJhListService(pageNum, pageSize); 前端实现 添加销售计划列表页面 在以下页面中，对于销售渠道 (channelId)，没有直接显示数据库中存储的数字 ID，而是通过一个 getChannelName(channelId) 方法将其转换为用户友好的文本描述（如 “自媒体”, “网络推广”）。这是一种常见的前端数据格式化或转换技巧，用于提升用户体验。 ListSellJh.vue template h2销售计划列表/h2 el-table :data=sellJHList stripe style=width: 100% el-table-column prop=id label=计划编号 width=180 / el-table-column prop=custName label=客户 width=180 / el-table-column prop=channelId label=销售渠道 template #default=scope getChannelName(scope.row.channelId) /template /el-table-column el-table-column prop=money label=销售金额 / el-table-column prop=nowStep label=销售阶段 / el-table-column prop=empId label=业务员 / el-table-column fixed=right label=操作 width=120 template #default=scope el-button link type=primary size=small @click=deleteSellJh(scope.row.id) 删除/el-button el-button link type=primary size=small @click=openSellJhDialog(scope.row) 修改/el-button /template /el-table-column /el-table hr / el-pagination small background :page-size=10 :pager-count=5 layout=prev, pager, next :total=total class=mt-4 @current-change=handlerPageChange / el-dialog v-model=dialogSellJhVisible width=80% h2修改销售计划/h2 el-form :model=sellJhForm label-width=120px :rules=rules ref=sellJhFormRef el-form-item label=客户名称 el-select v-model=sellJhForm.custid class=m-2 placeholder=请选择客户 size=large style=width: 80% el-option v-for=item in custList :key=item.id :label=item.custName :value=item.id / /el-select /el-form-item el-form-item label=销售渠道 prop=channelId el-select v-model=sellJhForm.channelId placeholder=请选择渠道.... style=width: 80% el-option v-for=opt in channelList :key=opt.id :label=opt.label :value=opt.id / /el-select /el-form-item el-form-item label=销售金额 prop=money el-input v-model.number=sellJhForm.money style=width: 80% / /el-form-item el-form-item label=开发阶段 prop=nowStep el-select v-model=sellJhForm.nowStep placeholder=请选择.... style=width: 80% el-option label=接触 value=接触 / el-option label=报价 value=报价 / el-option label=签约 value=签约 / /el-select /el-form-item el-form-item label=业务员 prop=empId el-input v-model.number=sellJhForm.empId style=width: 80% readonly=readonly / /el-form-item el-form-item el-button type=primary @click=subSellJhForm保存/el-button el-button @click=cancelForm取消/el-button /el-form-item /el-form /el-dialog/templatescript setup import onMounted, ref, reactive from vue; import axios from axios; import ElMessage, ElMessageBox from element-plus; const sellJHList = ref([]); const total = ref(0); const dialogSellJhVisible = ref(false); const sellJhFormRef = ref(null); const custList = ref([]); const channelList = ref([ id: 0, label: 自媒体 , id: 1, label: 网络推广 , id: 2, label: 老客户介绍 , id: 3, label: 陌拜 , id: 4, label: 二次客户 , ]); const sellJhForm = reactive( id: null, custid: null, channelId: null, money: 0, nowStep: , empId: null, custName: , ); const rules = custid: [ required: false, message: 请选择客户, trigger: change ], channelId: [ required: true, message: 请选择渠道, trigger: change ], money: [ required: true, message: 请输入金额, trigger: blur , type: number, message: 金额必须为数字, trigger: blur , ], nowStep: [ required: true, message: 请选择开发阶段, trigger: change ], empId: [ required: true, message: 请输入业务员ID, trigger: blur , type: number, message: 业务员ID必须为数字, trigger: blur , ], ; function getChannelName(channelId) switch (channelId) case 0: return 自媒体; case 1: return 网络推广; case 2: return 老客户介绍; case 3: return 陌拜; case 4: return 二次客户; default: return 未知; function sellJhListQuery(pageNum) axios .get(`http://localhost:8080/sellJhList?pageNum=$pageNum`) .then((response) = sellJHList.value = response.data.sellJhList; total.value = response.data.total; ) .catch((error) = ElMessage.error(查询失败); console.log(error); ); function deleteSellJh(id) ElMessageBox.confirm(确定删除该销售计划吗？, 提示, confirmButtonText: 确定, cancelButtonText: 取消, type: warning, ) .then(() = axios .delete(`http://localhost:8080/deleteSellJh/$id`) .then(() = ElMessage.success(删除成功); sellJhListQuery(1); ) .catch((error) = ElMessage.error(删除失败); console.log(error); ); ) .catch(() = ElMessage.info(取消删除); ); function openSellJhDialog(row) dialogSellJhVisible.value = true; axios .get(http://localhost:8080/listAllCust) .then((response) = custList.value = response.data; Object.assign(sellJhForm, id: row.id, custid: row.custid ?? null, channelId: row.channelId ?? null, money: row.money || 0, nowStep: row.nowStep || , empId: row.empId || null, custName: row.custName || , ); ) .catch((error) = console.log(error); ); function subSellJhForm() sellJhFormRef.value.validate((valid) = if (valid) axios .put(http://localhost:8080/updateSellJh, sellJhForm) .then(() = ElMessage.success(修改成功); dialogSellJhVisible.value = false; sellJhListQuery(1); ) .catch((error) = ElMessage.error(修改失败); console.log(error); ); else ElMessage.error(请填写完整信息); ); function cancelForm() dialogSellJhVisible.value = false; sellJhFormRef.value.resetFields(); onMounted(() = sellJhListQuery(1); ); function handlerPageChange(pageNum) sellJhListQuery(pageNum); /scriptstyle scoped/style 在数据库中加入这个页面 INSERT INTO `t_menu` (`label`, `component`, `pid`) VALUES (销售过程列表, 7, 1); 修改 index.vue 页面，将 ListSellJh 页面注册进来 import ListSellJh from @/views/ListSellJh; // 导入 销售计划列表 视图组件//老师的方法像下面这样改const views = [AddCustomer, ListCustomer, , , AddSellJh, , , ListSellJh];//我的方法像下面这样改const views = [ markRaw(AddCustomer), markRaw(ListCustomer), markRaw(AddSellJh), markRaw(AddSellJh), markRaw(AddSellJh), markRaw(AddSellJh), markRaw(AddSellJh), markRaw(ListSellJh),]; 3.销售过程页客户 id 和名称映射 后端实现 在 pom.xml 里新增 PageHelper 分页插件方便实现自定义 sql 分页查询 PageHelper 的一个重要特点是它对于手写的、非 MyBatis-Plus 自动生成的 SQL 也能很好地实现分页。 !--PageHelper分页插件--dependency groupIdcom.github.pagehelper/groupId artifactIdpagehelper-spring-boot-starter/artifactId version1.4.7/version/dependency SellJh 类添加客户名字段 给 SellJh 类添加了一个非数据库表字段的 custName 属性，并使用 @TableField(exist = false) 注解告诉 MyBatis-Plus 这个字段不参与数据库表的映射。这是处理关联查询结果的一种常见方式，将关联表的信息直接封装到主表的实体对象中。 @TableField(exist = false)private static final long serialVersionUID = 1L;@TableField(exist = false)//扩展属性，封装客户名字private String custName; mapper 接口里添加自定义查询方法 /*查询客户销售过程记录列表*/public ListSellJh querySellJhListMapper(); xml 里添加自定义方法的 sql 这里编写了多表关联查询INNER JOIN SQL 语句，将销售机会表 (t_sell_jh) 和客户表 (t_customer) 关联起来，以便在销售机会列表中直接显示客户名称 用到了之前在 SellJh 里加的非数据库表字段属性，方便封装数据 !--定义sql查询销售记录列表--select id=querySellJhListMapper resultType=com.example.demo.pojo.SellJh select sell.*,customer.cust_name custName from t_sell_jh sell inner join t_customer customer on sell.custid=customer.id/select 修改 serviceimpl 原本的实现方法 在 新的 SellJhServiceImpl 中，调用的是 sellJhMapper.querySellJhListMapper() 这个自定义的 Mapper 方法（对应 XML 中的手写 SQL）。 通过在调用这个方法之前执行 PageHelper.startPage(pageNum, pageSize)，PageHelper 就能拦截这个自定义的 SQL 并在其后添加分页逻辑。 @Overridepublic MapString, Object querySellJhListService(Integer pageNum, Integer pageSize) MapString, Object result=new HashMap(); //PageSellJh page=new Page(pageNum,pageSize); //使用PageHelper分页,指定分页查询参数 PageSellJh page = PageHelper.startPage(pageNum, pageSize); System.out.println(1---------+page.getTotal()); //ListSellJh sellJhs = sellJhMapper.selectList(page, null); ListSellJh sellJhs = sellJhMapper.querySellJhListMapper(); System.out.println(2---------+page.getTotal()); result.put(sellJhList,sellJhs); result.put(total,page.getTotal()); return result; 前端实现 将 ListSellJh.vue 页面里的 custid 改为 custName 即可 将下面这个el-table-column prop=custid label=客户ID /改为这个即可el-table-column prop=custName label=客户 / Day4 学了什么 处理更复杂的业务逻辑，如跨表数据统计更新和事务管理。 掌握手写复杂 SQL (聚合、多表连接) 并将其与 MyBatis 结合使用。 理解并使用另一种流行的分页解决方案 PageHelper，特别是在自定义 SQL 场景下的应用。 如何在 POJO 中扩展属性来封装关联查询的结果。 前端如何对从后端获取的数据进行格式化展示以优化用户体验。 Day5 1.实现订单数据增删改查 后端实现 修改 Order 类 在 Order 类的 orderDate (订单日期) 字段上，添加了 @JsonFormat(pattern = “yyyy-MM-dd HH:mm:ss”) 注解。 作用： 这个注解（通常来自 Jackson 库，Spring Boot 默认的 JSON 处理库）指示了当这个 Order 对象被序列化为 JSON 字符串（例如，后端返回给前端时）或者从 JSON 反序列化时，日期类型的 orderDate 字段应该按照 “yyyy-MM-dd HH:mm:ss” 这种格式进行转换。这有助于确保前后端日期格式的一致性，避免因格式问题导致的解析错误或显示异常。 Order 实体类中也相应地添加了 @TableField(exist = false) 注解的 custName 和 itemName 属性来承载这些关联查询的结果。这是对 Day 4 学习内容的应用和巩固。 /** * 下单时间 */ @JsonFormat(pattern = yyyy-MM-dd HH:mm:ss)//新增映射注释 private Date orderDate;//添加sql查询需要的字段 @TableField(exist = false)//不映射到类本身 private static final long serialVersionUID = 1L; @TableField(exist = false) private Integer num; @TableField(exist = false) private String custName; @TableField(exist = false) private String itemName; Ordermapper 添加自定义查询方法 再次使用了 INNER JOIN 来关联客户表和商品表，以便在订单列表中显示客户名称和商品名称 select id=queryOrderListMapper resultType=com.example.demo.pojo.Order select ord.*,customer.cust_name custName, item.item_name itemName from t_customer customer inner join t_order ord on customer.id=ord.cust_id inner join t_item item on item.id=ord.item_id /select 在对应 mapper 接口里添加接口 /** * 查询订单列表 * @return */public ListOrder queryOrderListMapper(); 在对应 service 里添加接口 /*处理订单数据动态多条件分页查询*/ public MapString,Object queryOrderListService(Integer pageNum, Integer pageSize); 在对应 servicimpl 里实现对应方法 @Autowired private OrderMapper orderMapper; @Override public MapString, Object queryOrderListService(Integer pageNum, Integer pageSize) //指定分页参数 PageObject page = PageHelper.startPage(pageNum, pageSize); //查询数据库 ListOrder orderList = orderMapper.queryOrderListMapper(); MapString, Object result=new HashMap(); result.put(orderList,orderList); result.put(total,page.getTotal()); return result; 新建 Controller 类，实现增删改查 package com.example.demo.Controller;import com.example.demo.pojo.Order;import com.example.demo.service.OrderService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import java.util.HashMap;import java.util.Map;@RestController@CrossOriginpublic class OrderController @Autowired private OrderService orderService; /* 处理分页查询请求 */ @GetMapping(/listOrder) public MapString, Object listOrders( @RequestParam(defaultValue = 1) Integer pageNum, @RequestParam(defaultValue = 3) Integer pageSize) return orderService.queryOrderListService(pageNum, pageSize); /* 添加订单 */ @PostMapping(/saveOrder) public MapString, Object saveOrder(@RequestBody Order order) MapString, Object result = new HashMap(); try orderService.save(order); result.put(code, 200); result.put(message, 添加成功); catch (Exception e) result.put(code, 400); result.put(message, 添加失败); return result; /* 删除订单 */ @DeleteMapping(/deleteOrder/id) public MapString, Object deleteOrder(@PathVariable Integer id) MapString, Object result = new HashMap(); try orderService.removeById(id); result.put(code, 200); result.put(message, 删除成功); catch (Exception e) result.put(code, 400); result.put(message, 删除失败); return result; /* 修改订单 */ @PutMapping(/updateOrder) public MapString, Object updateOrder(@RequestBody Order order) MapString, Object result = new HashMap(); try orderService.updateById(order); result.put(code, 200); result.put(message, 修改成功); catch (Exception e) result.put(code, 400); result.put(message, 修改失败); return result; 前端实现 添加销售计划列表页面 在表格上方添加了由多个输入框 (el-input) 和下拉选择框 (el-select) 组成的查询表单 (el-form :inline=“true” 表示行内表单)。 用户可以在这些表单项中输入查询条件，点击“查询”按钮后，前端会将这些条件收集起来（绑定到 condForm 这个响应式对象），然后通过 POST 请求发送给后端。 ListCustOrder.vue template h2客户订单列表/h2 el-table :data=orderList stripe style=width: 100% el-table-column prop=id label=订单编号 / el-table-column prop=custName label=客户姓名 / el-table-column prop=itemName label=商品名称 / el-table-column prop=orderDate label=订单日期 width=180 / el-table-column prop=state label=订单状态 / el-table-column prop=num label=数量 / el-table-column prop=pay label=支付方式 / el-table-column prop=payMoney label=支付金额 / el-table-column fixed=right label=操作 width=120 template #default=scope el-button link type=primary size=small @click=deleteOrder(scope.row.id) 删除/el-button el-button link type=primary size=small @click=openOrderDialog(scope.row) 修改/el-button /template /el-table-column /el-table hr / el-pagination small background :page-size=3 :pager-count=10 layout=prev, pager, next :total=total class=mt-4 @current-change=handlerOrderPageChange / el-dialog v-model=dialogOrderVisible width=80% title=修改订单信息 el-form :model=orderForm label-width=120px el-form-item label=客户姓名 el-input v-model=orderForm.custName style=width: 80% / /el-form-item el-form-item label=商品名称 el-input v-model=orderForm.itemName style=width: 80% / /el-form-item el-form-item label=订单日期 el-input v-model=orderForm.orderDate style=width: 80% / /el-form-item el-form-item label=订单状态 el-input v-model=orderForm.state style=width: 80% / /el-form-item el-form-item label=数量 el-input v-model.number=orderForm.num style=width: 80% / /el-form-item el-form-item label=支付方式 el-input v-model=orderForm.pay style=width: 80% / /el-form-item el-form-item label=支付金额 el-input v-model.number=orderForm.payMoney style=width: 80% / /el-form-item el-form-item el-button type=primary @click=saveOrder保存/el-button el-button @click=cancelOrder取消/el-button /el-form-item /el-form /el-dialog/templatescript setup import onMounted, ref, reactive from vue; import axios from axios; import ElMessage, ElMessageBox from element-plus; // 定义订单列表 const orderList = ref([]); const total = ref(0); const dialogOrderVisible = ref(false); // 表单数据 const orderForm = reactive( id: null, custName: , itemName: , orderDate: , state: , num: 0, pay: , payMoney: 0, ); // 加载订单列表 function loadOrderList(pageNum) axios .get(`http://localhost:8080/listOrder?pageNum=$pageNum`) .then((response) = orderList.value = response.data.orderList; total.value = response.data.total; ) .catch((error) = console.log(error); ); // 删除订单 function deleteOrder(id) ElMessageBox.confirm(确定删除该订单吗？, 提示, confirmButtonText: 确定, cancelButtonText: 取消, type: warning, ) .then(() = axios .delete(`http://localhost:8080/deleteOrder/$id`) .then(() = ElMessage.success(删除成功); loadOrderList(1); ) .catch((error) = ElMessage.error(删除失败); console.log(error); ); ) .catch(() = ElMessage.info(取消删除); ); // 打开修改对话框 function openOrderDialog(row) dialogOrderVisible.value = true; Object.assign(orderForm, id: row.id, custName: row.custName, itemName: row.itemName, orderDate: row.orderDate, state: row.state, num: row.num, pay: row.pay, payMoney: row.payMoney, ); // 保存修改 function saveOrder() axios .put(http://localhost:8080/updateOrder, orderForm) .then(() = ElMessage.success(修改成功); dialogOrderVisible.value = false; loadOrderList(1); ) .catch((error) = ElMessage.error(修改失败); console.log(error); ); // 取消修改 function cancelOrder() dialogOrderVisible.value = false; // 页面加载 onMounted(() = loadOrderList(1); ); // 分页处理 function handlerOrderPageChange(pageNum) loadOrderList(pageNum); /scriptstyle scoped/style 修改 index.vue 页面，将 ListCustOrder 页面注册进来 import ListCustOrder from ./views/ListCustOrder.vue; // 导入 客户订单列表 视图组件//老师的方法像下面这样改const views = [ AddCustomer, ListCustomer, , ListCustOrder, AddSellJh, , , ListSellJh,];//我的方法像下面这样改const views = [ markRaw(AddCustomer), markRaw(ListCustomer), markRaw(AddSellJh), markRaw(ListCustOrder), markRaw(AddSellJh), markRaw(AddSellJh), markRaw(AddSellJh), markRaw(ListSellJh),]; 2.实现订单数据多条件分页查询 后端实现 修改原本的 order 实体类，添加分页查询参数 @TableField(exist = false)private Integer pageNum=1;@TableField(exist = false)private Integer pageSize=3; 修改对应 mapper 接口，用 order 实体类封装动态 where 条件 /*实现订单数据动态多条件分页查询 * order:封装动态where条件 * */public ListOrder queryOrderListMapper(Order order); 修改 mapper 对应 xml，添加条件查询 where-if 字句 这是 Day 5 最显著的特色之一。在实现订单数据和售后数据的“多条件分页查询”时，在 Mapper XML 文件中使用了 MyBatis 的动态 SQL 功能： 标签：MyBatis 会智能地处理 标签内部 AND 或 OR 的前缀。如果内部有条件成立，它会自动加上 WHERE 关键字；如果内部所有条件都不成立，则 标签本身不会渲染。 标签：根据传入参数对象的属性值是否满足 test 中的条件（例如 id!=null 或 state!=null and state!=‘’），来决定是否将该 标签内部的 SQL 片段拼接到最终的 SQL 语句中。 将查询条件封装到实体对象中： 在 Order 和 AfterSales 实体类中添加了用于承载查询条件的属性 (如 id, state, custName, itemName 等)，以及分页参数 (pageNum, pageSize)。在 Service 层和 Mapper 接口中，直接传递这个包含所有查询条件的实体对象。 !-- 顶级sql统计客户历史消费总额 --select id=queryCountHisDataMapper resultType=com.example.demo.dto.HisData select cust_id custId, sum(pay_money) hisTotal from t_order group by cust_id/selectselect id=queryOrderListMapper resultType=com.example.demo.pojo.Order select ord.*,customer.cust_name custName, item.item_name itemName from t_customer customer inner join t_order ord on customer.id=ord.cust_id inner join t_item item on item.id=ord.item_id where if test=id!=null ord.id=#id /if if test=state!=null and state!= and state=#state /if if test=custName!=null and custName!= and cust_name=#custName /if if test=itemName!=null and itemName!= and item_name=#itemName /if /where/select 修改对应 service 接口，用 order 实体类封装 /*处理订单数据动态多条件分页查询*/public MapString,Object queryOrderListService(Integer pageNum,Integer pageSize,Order order); 修改 service 对应实现，用 order 实体类封装 @Overridepublic MapString, Object queryOrderListService(Integer pageNum, Integer pageSize,Order order) //封装 //指定分页参数 PageObject page = PageHelper.startPage(pageNum, pageSize); //查询数据库 ListOrder orderList = orderMapper.queryOrderListMapper(order);//封装 MapString, Object result=new HashMap(); result.put(orderList,orderList); result.put(total,page.getTotal()); return result; 修改对应 Controller，改用 post 请求方法，用 order 封装参数 引用外部资源方便理解： 面试突击 71：GET 和 POST 有什么区别？ 节选内容：两个方法最本质的区别 GET 和 POST 最本质的区别是“约定和规范”上的区别，在规范中，定义 GET 请求是用来获取资源的，也就是进行查询操作的，而 POST 请求是用来传输实体对象的，因此会使用 POST 来进行添加、修改和删除等操作。 当然如果严格按照规范来说，删除操作应该使用 DELETE 请求才对，但在实际开发中，使用 POST 来进行删除的用法更常见一些。 按照约定来说，GET 和 POST 的参数传递也是不同的，GET 请求是将参数拼加到 URL 上进行参数传递的，而 POST 是将请参数写入到请求正文中传递的， 虽然 GET 也可以传递复杂对象（通过序列化到 URL），但 POST 更符合将“实体对象”作为请求体传输的语义，尤其当查询条件较多或可能包含特殊字符时，POST 更为健壮和推荐。同时，这也为将来可能的更复杂查询参数（比如范围查询、排序等）留下了扩展空间。 /* 处理分页查询请求 */// @GetMapping(/listOrder)// public MapString, Object listOrders(// @RequestParam(defaultValue = 1) Integer pageNum,// @RequestParam(defaultValue = 3) Integer pageSize) // return orderService.queryOrderListService(pageNum, pageSize);// @PostMapping(/listOrder) public MapString,Object listOrders(@RequestBody Order order) return orderService.queryOrderListService(order.getPageNum(),order.getPageSize(),order); 前端实现 修改对应页面代码 template h2客户订单列表/h2 !-- 添加条件查询表单 -- el-form :inline=true :model=condForm el-form-item label=订单号 el-input v-model=condForm.id / /el-form-item el-form-item label=订单状态 style=width: 22% el-select v-model=condForm.state placeholder=请选择订单状态.... el-option label=未出库 value=未出库 / el-option label=已出库 value=已出库 / el-option label=配送中 value=配送中 / el-option label=已收货 value=已收货 / /el-select /el-form-item br / el-form-item label=客户姓名 el-input v-model=condForm.custName / /el-form-item el-form-item label=商品名称 el-input v-model=condForm.itemName / /el-form-item br / el-form-item el-button type=primary @click=subQueryCond查询/el-button /el-form-item /el-form hr//template 修改对应方法： // 加载订单列表function loadOrderList(pageNum) condForm.pageNum = pageNum; axios // .get(`http://localhost:8080/listOrder?pageNum=$pageNum`) .post(http://localhost:8080/listOrder, condForm) .then((response) = orderList.value = response.data.orderList; total.value = response.data.total; ) .catch((error) = console.log(error); ); 添加条件查询方法 //声明保存查询条件的表单数据const condForm = reactive( id: , state: , custName: , itemName: ,);//定义函数提交动态查询条件function subQueryCond() condForm.pageNum = 1; //将原来页码重置为1 axios .post(http://localhost:8080/listOrder, condForm) .then((response) = orderList.value = response.data.orderList; total.value = response.data.total; ) .catch((error) = console.log(error); ); 3.实现客户投诉页的基本显示 后端实现 修改数据库，把 record 字段名改为 grade 修改对应实体类的相关字段，添加几个字段 /** * 紧急程度 */ private String grade;//添加字段 @TableField(exist = false) private String custName; @TableField(exist = false) private Integer pageNum=1; @TableField(exist = false) private Integer pageSize=3; 在对应 mapper 接口里新增方法 /*实现售后数据多条件分页查询*/public ListAfterSales queryAfterSaleMapper(AfterSales afterSales); 在 mapper.xml 里实现方法 select id=queryAfterSaleMapper resultType=com.example.demo.pojo.AfterSales select aft.*,customer.cust_name custName from t_customer customer inner join t_after_sales aft on customer.id=aft.cust_id where if test=id!=null aft.id=#id /if if test=question!=null and question!= and question=#question /if if test=state!=null and state!= and state=#state /if if test=grade!=null and grade!= and aft.grade=#grade /if /where/select 在对应 service 接口里新增方法 /*实现客户投诉信息分页查询*/public MapString,Object queryAfterSaleListService(AfterSales afterSales); 在对应 impl 里实现 service 方法 @Autowiredprivate AfterSalesMapper afterSalesMapper;@Overridepublic MapString, Object queryAfterSaleListService(AfterSales afterSales) //指定分页查询参数 PageObject page = PageHelper.startPage(afterSales.getPageNum(), afterSales.getPageSize()); //查询数据库 ListAfterSales afterSalesList = afterSalesMapper.queryAfterSaleMapper(afterSales); MapString, Object result=new HashMap(); result.put(afterSalesList,afterSalesList); result.put(total,page.getTotal()); return result; 添加并实现 AfterSaleController @RestController@CrossOriginpublic class AfterSaleController @Autowired private AfterSalesService afterSalesService; /*处理投诉信息分页查询请求*/ @PostMapping(/listAfterSale) public MapString,Object listAfterSales(@RequestBody AfterSales afterSales) return afterSalesService.queryAfterSaleListService(afterSales); 前端实现 新增 ListAfterSale.vue 页面 template h2客户投诉列表/h2 el-form :inline=true :model=condForm el-form-item label=投诉单号 el-input v-model=condForm.id / /el-form-item el-form-item label=问题描述 el-input v-model=condForm.question / /el-form-item br/ el-form-item label=紧急程度 style=width: 22% el-select v-model=condForm.grade placeholder=请选择.... el-option label=普通 value=普通 / el-option label=加急 value=加急 / /el-select /el-form-item el-form-item label=处理状态 style=width: 22% el-select v-model=condForm.state placeholder=请选择.... el-option label=未处理 value=未处理 / el-option label=已处理 value=已处理 / el-option label=未回访 value=未回访 / el-option label=已回访 value=已回访 / /el-select /el-form-item br/ el-form-item el-button type=primary @click=subQueryAfter查询/el-button /el-form-item /el-form hr/ el-table :data=afterSaleList stripe style=width: 100% el-table-column prop=id label=投诉编号/ el-table-column prop=custName label=客户姓名/ el-table-column prop=question label=问题类型/ el-table-column prop=state label=处理状态/ el-table-column prop=grade label=紧急程度/ el-table-column prop=level label=投诉满意度/ el-table-column fixed=right label=操作 width=200 template #default=scope el-button link type=primary size=small处理 /el-button el-button link type=primary size=small查看处理详情 /el-button /template /el-table-column /el-table hr/ el-pagination small background :page-size=3 :pager-count=10 layout=prev, pager, next :total=total class=mt-4 @current-change=handlerSalePageChange//templatescript setupimport onMounted, reactive, ref from vue;import axios from axios; //数据库总记录数 const total=ref(0) //声明投诉列表集合 const afterSaleList=ref([]); //定义封装查询条件的表单对象 const condForm=reactive( id:, question:, grade:, level: ); //定义函数发生ajax请求 function queryAfterSaleList(pageNum) condForm.pageNum=pageNum; axios.post(http://localhost:8080/listAfterSale, condForm) .then((response)= afterSaleList.value=response.data.afterSalesList; total.value=response.data.total; ) .catch((error)= console.log(error); ); //加载视图进行调用 onMounted(function() queryAfterSaleList(1); ); //定义函数提交分页请求 function handlerSalePageChange(pageNum) queryAfterSaleList(pageNum); //定义函数提交查询条件 function subQueryAfter() queryAfterSaleList(1); /scriptstyle scoped/style 在主页中注册新增页面 import ListAfterSale from @/views/ListAfterSale.vue; // 导入 客户投诉列表 视图组件//老师的方法，修改以下内容:const views = [ AddCustomer, ListCustomer, ListAfterSale, ListCustOrder, AddSellJh, , , ListSellJh,];//我的方法，修改以下内容：const views = [ markRaw(AddCustomer), markRaw(ListCustomer), markRaw(ListAfterSale), markRaw(ListCustOrder), markRaw(AddSellJh), markRaw(AddSellJh), markRaw(AddSellJh), markRaw(ListSellJh),]; Day5 学了什么 实现更强大和灵活的后端动态条件查询，使用 MyBatis 的 和 标签，并将查询条件封装在实体对象中。 理解并实践了后端接口接收复杂查询参数的不同方式 (从 GET + @RequestParam 到 POST + @RequestBody)。 前端如何构建多条件查询界面，并收集用户输入的条件发送给后端。 初步了解了后端如何通过注解（如 @JsonFormat）控制数据（如日期）在 JSON 序列化时的格式。 进一步熟练了多表关联查询和在 POJO 中添加非数据库字段来封装结果。 Day6 1.客户投诉页添加处理操作 后端实现 新增用户反馈表 CREATE TABLE `t_replay` ( `id` int NOT NULL COMMENT 反馈/评价ID (主键), `content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT 反馈或评价内容, `redate` datetime DEFAULT NULL COMMENT 反馈或评价日期时间, `score` int DEFAULT NULL COMMENT 评分 (如：1-5分), `ques_id` int DEFAULT NULL COMMENT 问题ID，对应after_sales表, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT=用户反馈/评价表; 在 idea 里用 mybatiesx 生成此表的三个层级代码 新增对应控制层代码 @RestController@CrossOriginpublic class ReplayController @Autowired private ReplayService replayService; /*定义方法处理投诉回复的请求*/ @PostMapping(/saveReplay) public MapString, Object saveReplay(@RequestBody Replay replay) MapString, Object result = new HashMap(); result.put(code, 400); result.put(msg, 操作失败.....); try replay.setRedate(new Date()); replay.setScore(ThreadLocalRandom.current().nextInt(1,6)); replayService.save(replay); result.put(code,200); result.put(msg,处理投诉回复成功......); catch (Exception ex) ex.printStackTrace(); return result; 前端实现 添加处理按钮绑定事件 el-button link type=primary size=small @click=openReplayDialog(scope.row.id) 处理/el-button 添加对话框 el-pagination small background :page-size=3 :pager-count=10 layout=prev, pager, next :total=total class=mt-4 @current-change=handlerSalePageChange/!-- 添加对话框控件 --!-- 回显客户信息的对话框 --el-dialog v-model=dialogReplayVisible width=80% h2恢复客户投诉/h2 !-- 对话框中添加form -- el-form :model=replayForm label-width=120px el-form-item label=回复内容 el-input v-model=replayForm.content style=width: 80%;height: 120px type=textarea / /el-form-item el-form-item el-button type=primary @click=subReplayForm保存/el-button el-button取消/el-button /el-form-item /el-form/el-dialog 添加相关触发逻辑 //定义对话框状态 const dialogReplayVisible=ref(false); //定义对话框中form表单 const replayForm=reactive( content: ); //定义函数打开对话框 function openReplayDialog(qid) dialogReplayVisible.value=true; replayForm.quesId=qid; 添加发送请求到后端的代码 //发送ajax请求function subReplayForm() //发送aajx请求 axios .post(http://localhost:8081/saveReplay, replayForm) .then((response) = if (response.data.code == 200) dialogReplayVisible.value = false; ElMessage(response.data.msg); else ElMessage(response.data.msg); ) .catch((error) = console.log(error); ); 2.加载问题回复列表 后端实现 修改 Replay 实体类，使前端能正确解析时间 /** * 反馈或评价日期时间 */@JsonFormat(pattern = yyyy-MM-dd HH:mm:ss)private Date redate; service 接口添加 /*根据投诉id。查询投诉回复列表*/public MapString,Object queryReplayListService(Integer id , Integer pageNum, Integer pageSize); 实现 service 方法 @Autowired private ReplayMapper replayMapper; @Override public MapString, Object queryReplayListService(Integer id , Integer pageNum, Integer pageSize) PageReplay page=new Page(pageNum,pageSize); //封装whrer条件 QueryWrapperReplay wrapper =new QueryWrapper(); wrapper.eq(ques_id,id); //where ques_id=? //指定分页参数 ListReplay replayList = replayMapper.selectList(page, wrapper); MapString, Object result=new HashMap(); result.put(total,page.getTotal()); result.put(replayList,replayList); return result; 添加 Controller 接口 /*处理回复列表分页查询请求*/@GetMapping(/listReplay)public MapString, Object listReplay(Integer id , @RequestParam(defaultValue = 1) Integer pageNum , @RequestParam(defaultValue = 3) Integer pageSize) return replayService.queryReplayListService(id, pageNum, pageSize); 前端实现 添加对话框组件 !-- 添加对话框控件 --!-- 回复列表对话框 --el-dialog v-model=dialogReplayListVisible width=80% h2回复列表/h2 div style=text-align: left el-text投诉人:question.custName/el-textbr / el-text投诉问题:question.quesDesc/el-text !-- table -- el-table :data=replaysList stripe style=width: 100% el-table-column prop=id label=编号 / el-table-column prop=redate label=时间 / el-table-column prop=score label=评分 / el-table-column prop=content label=内容 / !-- el-table-column fixed=right label=操作 width=200 template #default=scope el-button link type=primary size=small @click=openReplayDialog(scope.row.id)处理 /el-button el-button link type=primary size=small @click=loadQuestionReplayList(scope.row)查看处理详情 /el-button /template /el-table-column-- /el-table !-- 分页 -- hr / el-pagination small background :page-size=3 :pager-count=10 layout=prev, pager, next :total=totalReplay class=mt-4 @current-change=handlerReplayPageChange / /div/el-dialog 添加对应处理方法 //定义回复列表对话框状态const dialogReplayListVisible = ref(false);//定义回显投诉人和投诉内容的对象数据const question = reactive( custName: , quesDesc: ,);//定义total。保存回复总记录数const totalReplay = ref(0);//定义回复列表数据const replaysList = ref([]);//声明变量保存投诉idlet qid = 0;//打开对话框加载恢复列表function loadQuestionReplayList(row) dialogReplayListVisible.value = true; question.custName = row.custName; question.quesDesc = row.question; qid = row.id; //发送ajax请求 axios .get(http://localhost:8081/listReplay?id= + row.id) .then((response) = replaysList.value = response.data.replayList; totalReplay.value = response.data.total; ) .catch((error) = console.log(error); );//提交分页查询参数的请求function handlerReplayPageChange(pageNum) //发送ajax请求 axios .get(http://localhost:8081/listReplay?id= + qid + pageNum= + pageNum) .then((response) = replaysList.value = response.data.replayList; totalReplay.value = response.data.total; ) .catch((error) = console.log(error); ); 3.RBAC 权限控制 权限控制： 不同用户登录系统可以使用的系统资源不一样。 不同用户登录系统看到的左边菜单不一样。 建立起用户和菜单表的关系，建立用户表和菜单表的关联关系。 后端实现 添加四个表 这些表共同构建了一个基于角色的权限控制 (RBAC) 系统： t_user 存储用户账号， t_roler 定义不同的角色， 之前的t_menus 表示系统中的菜单或资源。 t_user_role 表连接用户和他们拥有的角色（一个用户可有多个角色）， 而 t_role_menu 表连接角色和他们被授权访问的菜单（一个角色可访问多个菜单），从而决定了用户通过角色能够看到和操作哪些菜单功能。 CREATE TABLE `t_role_menu` ( `id` int NOT NULL AUTO_INCREMENT COMMENT 关联ID (主键), `rid` int NULL DEFAULT NULL COMMENT 角色ID (关联t_roler.id), `mid` int NULL DEFAULT NULL COMMENT 菜单ID (关联t_menus.id), PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic COMMENT = 角色菜单关联表 (定义角色拥有的菜单权限);CREATE TABLE `t_roler` ( `id` int NOT NULL AUTO_INCREMENT COMMENT 角色ID (主键), `rname` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT 角色名称, `rdesc` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT 角色描述, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic COMMENT = 角色信息表 (权限管理);CREATE TABLE `t_user` ( `id` int NOT NULL AUTO_INCREMENT COMMENT 用户ID (主键), `uname` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT 用户名, `upwd` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT 用户密码, `phone` varchar(11) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT 手机号, `edu` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT 学历, `age` int NULL DEFAULT NULL COMMENT 年龄, `title` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT 职位, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic COMMENT = 用户信息表 (系统用户);CREATE TABLE `t_user_role` ( `id` int NOT NULL AUTO_INCREMENT COMMENT 关联ID (主键), `uid` int NULL DEFAULT NULL COMMENT 用户ID (关联t_user.id), `rid` int NULL DEFAULT NULL COMMENT 角色ID (关联t_roler.id), PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic COMMENT = 用户角色关联表 (分配用户角色); 用 mybatiesx 插件生成对应代码 Day7 0.美化主页 主页代码修改： script setup // --- 模块导入 --- import AddCustomer from @/views/Custom_Manage/AddCustomer.vue; import ListCustomer from @/views/Custom_Manage/ListCustomer.vue; import AddSellJh from @/views/Custom_Manage/AddSellJh.vue; import ListSellJh from @/views/Custom_Manage/ListSellJh.vue; import ListCustOrder from @/views/Custom_Manage/ListCustOrder.vue; import ListAfterSale from @/views/Custom_Manage/ListAfterSale.vue; import AddMenus from @/views/Sys_Manage/AddMenus.vue; // Vue核心 import computed, onMounted, ref, watch from vue; import markRaw, shallowRef from vue; // HTTP客户端 import axios from axios; // Element Plus 图标 import Folder, Document, Menu as MenuIcon, HomeFilled, Refresh, from @element-plus/icons-vue; // API基础URL const API_BASE_URL = http://localhost:8080; // --- 组件映射与状态定义 --- const viewComponents = addCustomer: markRaw(AddCustomer), listCustomer: markRaw(ListCustomer), listAfterSale: markRaw(ListAfterSale), listCustOrder: markRaw(ListCustOrder), addSellJh: markRaw(AddSellJh), addMenus: markRaw(AddMenus), listSellJh: markRaw(ListSellJh), ; const views = [ viewComponents.addCustomer, viewComponents.listCustomer, viewComponents.listAfterSale, viewComponents.listCustOrder, viewComponents.listSellJh, viewComponents.addSellJh, viewComponents.addSellJh, viewComponents.addSellJh, viewComponents.addMenus, viewComponents.addSellJh, ]; const currentComponent = shallowRef(views[0]); const currentComponentIndex = ref(0); const menus = ref([]); const isLoading = ref(false); const error = ref(null); // --- 方法定义 --- const handlerSelect = async (index) = try error.value = null; const response = await axios.get(`$API_BASE_URL/compIndex`, params: id: index , timeout: 5000, ); const compIndex = response.data; if (compIndex = 0 compIndex views.length) currentComponentIndex.value = compIndex; currentComponent.value = views[compIndex]; else console.warn(`Invalid component index received: $compIndex`); error.value = 无法加载请求的组件; catch (err) console.error(Failed to fetch component index:, err); error.value = 加载组件失败，请稍后再试; ; const fetchMenus = async () = try isLoading.value = true; error.value = null; const response = await axios.get(`$API_BASE_URL/listMenus`, timeout: 5000, ); menus.value = response.data; isLoading.value = false; catch (err) console.error(Failed to fetch menus:, err); error.value = 加载菜单失败，请刷新页面重试; menus.value = []; isLoading.value = false; ; const hasMenus = computed(() = menus.value menus.value.length 0); watch(error, (newError) = if (newError) setTimeout(() = error.value = null; , 5000); ); // 定义默认展开的菜单项 const defaultOpeneds = computed(() = menus.value.map((menu) = menu.id.toString()) ); onMounted(() = fetchMenus(); );/scripttemplate div class=app-container el-container class=main-container !-- 顶部Header区域 -- el-header class=app-header div class=header-content el-icon class=header-iconHomeFilled //el-icon h1 class=app-titleERP管理系统/h1 span class=app-subtitleikun小组/span /div /el-header el-container class=content-container !-- 左侧Aside区域 (导航菜单) -- el-aside width=240px class=app-sidebar div class=menu-header el-iconMenuIcon //el-icon 系统菜单 /div !-- 加载状态 -- el-skeleton :loading=isLoading !hasMenus animated :count=3 v-if=isLoading !hasMenus template #template div style=padding: 12px el-skeleton-item variant=text style=width: 90% / div style=margin-left: 24px; margin-top: 12px el-skeleton-item variant=text style=width: 80% / el-skeleton-item variant=text style=width: 80%; margin-top: 8px / /div /div /template /el-skeleton !-- 错误提示 -- el-alert v-if=error !hasMenus :title=error type=error show-icon @close=error = null / !-- 菜单内容 -- el-menu class=app-menu @select=handlerSelect v-if=hasMenus :default-active=1 unique-opened :default-openeds=defaultOpeneds el-sub-menu v-for=menu in menus :key=menu.id :index=menu.id.toString() template #title el-iconFolder //el-icon span menu.label /span /template el-menu-item v-for=subMenu in menu.subMenu :key=subMenu.id :index=subMenu.id.toString() el-iconDocument //el-icon span subMenu.label /span /el-menu-item /el-sub-menu /el-menu !-- 空菜单提示 -- el-empty v-if=!isLoading hasMenus === false !error description=暂无菜单数据 el-button type=primary :icon=Refresh @click=fetchMenus 刷新/el-button /el-empty /el-aside !-- 主内容区域 -- el-main class=app-main !-- 加载状态 -- div v-if=isLoading class=loading-overlay el-skeleton animated :rows=8 / /div !-- 错误提示 -- el-alert v-if=error currentComponent.value :title=error type=error show-icon style=margin-bottom: 16px @close=error = null / !-- 动态组件渲染 -- div class=component-container keep-alive component :is=currentComponent/component /keep-alive /div /el-main /el-container /el-container /div/templatestyle scoped /* 全局布局 */ .app-container height: 100vh; display: flex; flex-direction: column; background-color: #f0f2f5; .main-container height: 100%; overflow: hidden; .content-container height: calc(100vh - 64px); /* 头部样式 */ .app-header height: 64px; background: linear-gradient(90deg, #2b5aff, #409eff); color: #ffffff; display: flex; align-items: center; padding: 0 24px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1); .header-content display: flex; align-items: center; gap: 12px; .header-icon font-size: 24px; .app-title margin: 0; font-size: 1.6rem; font-weight: 700; letter-spacing: 0.5px; .app-subtitle font-size: 0.95rem; font-weight: 400; opacity: 0.85; /* 侧边栏样式 */ .app-sidebar background-color: #ffffff; border-right: 1px solid #e8ecef; overflow-y: auto; height: 100%; transition: width 0.3s ease; box-shadow: 2px 0 8px rgba(0, 0, 0, 0.05); scrollbar-width: none; /* Firefox */ -ms-overflow-style: none; /* IE and Edge */ .app-sidebar::-webkit-scrollbar display: none; /* Chrome, Safari, Opera */ .menu-header padding: 16px 20px; font-weight: 600; font-size: 1.15rem; color: #303133; border-bottom: 1px solid #e8ecef; display: flex; align-items: center; gap: 8px; .app-menu border-right: none; background-color: transparent; .app-menu :deep(.el-sub-menu__title), .app-menu :deep(.el-menu-item) color: #303133; font-size: 0.95rem; .app-menu :deep(.el-sub-menu__title:hover), .app-menu :deep(.el-menu-item:hover) background-color: #e6f0ff; color: #2b5aff; .app-menu :deep(.el-menu-item.is-active) background-color: #e6f0ff; color: #2b5aff; font-weight: 500; /* 主内容区域 */ .app-main background-color: #ffffff; padding: 24px; overflow-y: auto; height: 100%; position: relative; border-radius: 8px; margin: 16px; box-shadow: 0 2px 12px rgba(0, 0, 0, 0.06); scrollbar-width: none; /* Firefox */ -ms-overflow-style: none; /* IE and Edge */ .app-main::-webkit-scrollbar display: none; /* Chrome, Safari, Opera */ /* 加载状态 */ .loading-overlay position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(255, 255, 255, 0.95); z-index: 10; padding: 24px; display: flex; flex-direction: column; justify-content: center; /* 组件容器 */ .component-container width: 100%; height: 100%; /* 响应式调整 */ @media (max-width: 768px) .app-sidebar width: 200px !important; .app-header padding: 0 16px; .app-title font-size: 1.3rem; .app-main margin: 8px; padding: 16px; /style 1.接口测试工具 Postman 的安装和使用 API 测试之 Postman 使用完全指南(Postman 教程，这篇文章就够了) 建议使用 Apifox，对中文友好 Apifox 下载地址 Apifox 如何发送 json 格式的 post 请求？ 什么是 RESTful API 2 实现系统菜单节点管理页面 根据教程树形结构的菜单表设计与查询和 ai 辅助，修改方法如下 后端实现 数据库修改菜单表，添加几个条目 DROP TABLE IF EXISTS `t_menu`;CREATE TABLE `t_menu` ( `id` int NOT NULL AUTO_INCREMENT COMMENT ID (主键), `label` varchar(50) DEFAULT NULL COMMENT 导航名称, `component` int DEFAULT NULL COMMENT 子id, `pid` int DEFAULT NULL COMMENT 父id, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=22 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT=前端菜单表;INSERT INTO `t_menu` (`id`, `label`, `component`, `pid`) VALUES (1, 客户管理, NULL, 0);INSERT INTO `t_menu` (`id`, `label`, `component`, `pid`) VALUES (2, 添加客户, 0, 1);INSERT INTO `t_menu` (`id`, `label`, `component`, `pid`) VALUES (3, 查询客户, 1, 1);INSERT INTO `t_menu` (`id`, `label`, `component`, `pid`) VALUES (4, 售后服务, 2, 1);INSERT INTO `t_menu` (`id`, `label`, `component`, `pid`) VALUES (5, 客户订单, 3, 1);INSERT INTO `t_menu` (`id`, `label`, `component`, `pid`) VALUES (6, 销售过程, 4, 1);INSERT INTO `t_menu` (`id`, `label`, `component`, `pid`) VALUES (7, 销售过程列表, 7, 1);INSERT INTO `t_menu` (`id`, `label`, `component`, `pid`) VALUES (8, 数据统计, NULL, 0);INSERT INTO `t_menu` (`id`, `label`, `component`, `pid`) VALUES (9, 客户统计, 5, 8);INSERT INTO `t_menu` (`id`, `label`, `component`, `pid`) VALUES (10, 库存统计, 6, 8);INSERT INTO `t_menu` (`id`, `label`, `component`, `pid`) VALUES (11, 系统管理, NULL, 0);INSERT INTO `t_menu` (`id`, `label`, `component`, `pid`) VALUES (12, 添加菜单, 8, 11);INSERT INTO `t_menu` (`id`, `label`, `component`, `pid`) VALUES (13, 用户管理, 9, 11);INSERT INTO `t_menu` (`id`, `label`, `component`, `pid`) VALUES (14, 角色管理, 10, 11); MenuService 添加接口 /*添加菜单节点*/public void saveMenusService(Menu menu); MenuServiceImpl 实现接口 @Overridepublic void saveMenusService(Menu menu) QueryWrapperMenu wrapper=new QueryWrapper(); wrapper.select(max(component) maxv); //获得component的最大值 Menu ms = MenuMapper.selectOne(wrapper); //component组件属性的值，是数据库最大值加1 menu.setComponent(ms.getMaxv()+1); MenuMapper.insert(menu); MenusController 添加增删改方法 @Autowired private MenuService menusService;/*处理菜单节点信息的添加请求*/ @CrossOrigin @PostMapping(/saveMenus) public MapString,Object saveMenus(@RequestBody Menu menu) MapString,Object result=new HashMap(); result.put(code,400); result.put(msg,操作失败......); try menusService.saveMenusService(menu); result.put(code,200); result.put(msg,添加菜单节点成功.......); catch (Exception ex) ex.printStackTrace(); return result; /*处理菜单节点信息的修改请求*/ @CrossOrigin @PutMapping(/updateMenus) public MapString,Object updateMenus(@RequestBody Menu menu) MapString,Object result=new HashMap(); result.put(code,400); result.put(msg,操作失败......); try menusService.updateById(menu); result.put(code,200); result.put(msg,修改菜单节点成功.......); catch (Exception ex) ex.printStackTrace(); return result; /*处理菜单节点信息的删除请求*/ @CrossOrigin @DeleteMapping(/deleteMenus) public MapString,Object deleteMenus(Integer id) MapString,Object result=new HashMap(); result.put(code,400); result.put(msg,操作失败......); try menusService.removeById(id); result.put(code,200); result.put(msg,删除菜单节点成功.......); catch (Exception ex) ex.printStackTrace(); return result; 前端实现 实现 AddMenus.vue 页面 template h2管理菜单/h2 div style=text-align: left h4选择新增节点的父节点:/h4 el-tree :props=props :data=treeNodeList node-key=id default-expand-all :expand-on-click-node=false ref=treeRef @node-click=hanldNodeClick highlight-current=true template #default= node, data span class=custom-tree-node span node.label /span span a @click.stop=openEditDialog(data) style=color: var(--el-color-primary) 修改 /a a style=margin-left: 8px; color: var(--el-color-danger) @click.stop=delMenus(node, data) 删除 /a /span /span /template /el-tree /div hr / !-- 添加表单控件 -- el-form :model=menuForm label-width=120px el-form-item label=新增菜单名称 el-input v-model=menuForm.label style=width: 50% / /el-form-item el-form-item el-button type=primary @click=subMenuForm保存/el-button el-button @click=resetForm取消/el-button /el-form-item /el-form !-- 修改弹窗 -- el-dialog title=修改菜单 v-model=dialogVisible width=30% el-form :model=editForm label-width=120px el-form-item label=菜单名称 el-input v-model=editForm.label style=width: 50% / /el-form-item /el-form template #footer el-button @click=dialogVisible = false取消/el-button el-button type=primary @click=updateMenu更新/el-button /template /el-dialog/templatescript setup import onMounted, reactive, ref from vue; import axios from axios; import ElMessage from element-plus; // 定义tree控件的配置参数 const props = id: id, label: label, children: subMenu, ; // 定义tree控件节点的集合 const treeNodeList = ref([]); // 定义添加菜单的form表单 const menuForm = reactive( id: null, label: , component: null, ); // 添加弹窗状态和编辑表单数据 const dialogVisible = ref(false); const editForm = reactive( id: null, label: , component: null, ); // 发送ajax请求，加载菜单节点树 function loadMenuTree() axios .get(http://localhost:8080/listMenus) .then((response) = treeNodeList.value = response.data; ) .catch((error) = console.log(error); ); onMounted(() = loadMenuTree(); ); // 声明变量保存当前选中树节点的id let id = 0; // 定义tree控件节点的点击回调函数 function hanldNodeClick(node) id = node.id; // 打开编辑弹窗 function openEditDialog(data) editForm.id = data.id; editForm.label = data.label; editForm.component = data.component; dialogVisible.value = true; // 更新菜单 function updateMenu() axios .put(http://localhost:8080/updateMenus, editForm) .then((response) = if (response.data.code === 200) loadMenuTree(); dialogVisible.value = false; ElMessage( type: response.data.code === 200 ? success : error, message: response.data.msg || 更新成功, ); ) .catch((error) = console.log(error); ElMessage.error(修改失败，请稍后重试); ); // 重置表单 function resetForm() menuForm.id = null; menuForm.label = ; menuForm.component = null; id = 0; // 发送保存菜单的请求 function subMenuForm() if (id === 0) ElMessage(请选择当前新增菜单节点的父节点......); return; menuForm.pid = id; axios .post(http://localhost:8080/saveMenus, menuForm) .then((response) = if (response.data.code === 200) loadMenuTree(); resetForm(); ElMessage( type: response.data.code === 200 ? success : error, message: response.data.msg || 添加成功, ); ) .catch((error) = console.log(error); ElMessage.error(添加失败，请稍后重试); ); // 删除菜单 function delMenus(node, data) if (data.subMenu data.subMenu.length 0) ElMessage(data.label + ,节点存在子节点不能删除.......); return; axios .delete(http://localhost:8080/deleteMenus?id= + data.id) .then((response) = if (response.data.code === 200) loadMenuTree(); ElMessage( type: response.data.code === 200 ? success : error, message: response.data.msg, ); ); /scriptstyle scoped ::v-deep .el-tree-node.is-current .el-tree-node__content background-color: var(--el-color-primary-light-9); color: var(--el-color-primary); ::v-deep .el-tree-node__content:hover background-color: var(--el-fill-color-light); ::v-deep .el-tree --el-tree-node-hover-bg-color: var(--el-fill-color-light); --el-tree-text-color: var(--el-text-color-regular); --el-tree-expand-icon-color: var(--el-text-color-placeholder); .custom-tree-node flex: 1; display: flex; align-items: center; justify-content: space-between; font-size: 14px; padding-right: 8px; /style 在主页中注册新增页面 import ListAfterSale from @/views/AddMenus.vue; // 导入 管理菜单 视图组件//老师的方法，修改以下内容:const views = [ AddCustomer, ListCustomer, ListAfterSale, ListCustOrder, AddSellJh, , , ListSellJh, AddMenus,];//我的方法，修改以下内容：const views = [ markRaw(AddCustomer), markRaw(ListCustomer), markRaw(ListAfterSale), markRaw(ListCustOrder), markRaw(AddSellJh), markRaw(AddSellJh), markRaw(AddSellJh), markRaw(ListSellJh), markRaw(AddMenus),]; 3.实现菜单拖拽改变顺序和父子关系 后端实现 表格添加顺序列 ALTER TABLE `t_menu`ADD COLUMN `sort_order` INT DEFAULT 0 COMMENT 同一父节点下的排序字段，值越小越靠前; 修改对应 pojo，添加排序字段 /** * 排序 */private Integer sortOrder; 修改对应 vo，添加父节点字段和排序字段，方便前端修改 @Datapublic class MenuVo private Integer id; private Integer pid; private String label; private Integer component; private ListMenuVo subMenu; private Integer sortOrder; service 添加接口 /*更新菜单顺序*/ void updateMenusOrder(ListMenuVo menuUpdates); 实现该方法，修改之前的排序等方法 @Servicepublic class MenuServiceImpl extends ServiceImplMenuMapper, Menu implements MenuService @Autowired private MenuMapper menuMapper; @Override public ListMenuVo queryMenuListService() QueryWrapperMenu queryWrapper = new QueryWrapper(); // 按 pid 升序，再按 sort_order 升序 queryWrapper.orderByAsc(pid, sort_order); ListMenu allMenu = this.list(queryWrapper); return buildSubmenu(allMenu, 0); // 假设根节点的 pid 为 0 private ListMenuVo buildSubmenu(ListMenu allMenu, Integer parentId) ListMenuVo submenuTree = new ArrayList(); // 直接从已排序的 allMenu 中筛选，它们自然保持了 sort_order 的顺序 for (Menu menu : allMenu) if (menu.getPid() != null menu.getPid().equals(parentId)) MenuVo menuVo = new MenuVo(); BeanUtils.copyProperties(menu, menuVo); // 递归查找子菜单时，子菜单也已经是排序好的了 menuVo.setSubMenu(buildSubmenu(allMenu, menu.getId())); submenuTree.add(menuVo); return submenuTree; @Override public void saveMenusService(Menu menu) QueryWrapperMenu wrapper = new QueryWrapper(); wrapper.select(max(component) maxv); Menu ms = menuMapper.selectOne(wrapper); menu.setComponent(ms == null || ms.getMaxv() == null ? 0 : ms.getMaxv() + 1); // 处理ms或maxv为null的情况 // 设置新菜单的 sort_order，例如排在同级最后 QueryWrapperMenu countWrapper = new QueryWrapper(); countWrapper.eq(pid, menu.getPid()); long count = this.count(countWrapper); menu.setSortOrder((int) count); menuMapper.insert(menu); // 新增方法：用于处理前端拖拽后的顺序更新 @Transactional // 保证操作的原子性 @Override public void updateMenusOrder(ListMenuVo menuUpdates) // 直接使用MenuVo作为DTO，或者创建一个专门的DTO if (menuUpdates == null || menuUpdates.isEmpty()) return; for (MenuVo menuUpdate : menuUpdates) if (menuUpdate.getId() == null) continue; // ID 不能为空 UpdateWrapperMenu updateWrapper = new UpdateWrapper(); updateWrapper.eq(id, menuUpdate.getId()) .set(pid, menuUpdate.getPid()) .set(sort_order, menuUpdate.getSortOrder()); this.update(null, updateWrapper); 添加 Controller 方法 /*处理菜单节点信息的修改请求*/@CrossOrigin@PostMapping(/updateMenusOrder)public MapString,Object updateMenusOrder(@RequestBody ListMenuVo menuUpdates) MapString,Object result=new HashMap(); result.put(code,400); result.put(msg,菜单顺序更新失败!); try menuService.updateMenusOrder(menuUpdates); result.put(code,200); result.put(msg,菜单顺序更新成功!); catch (Exception ex) ex.printStackTrace(); return result; 前端实现 修改 Vue 页面，使其能把调整的顺序和父子关系传到后端 拖拽功能 (draggable, allow-drop, allow-drag, @node-drop)： allowDrag: 控制哪些节点可以被拖拽。 allowDrop: 定义复杂的拖拽放置规则（例如，限制层级深度，判断是否允许成为子节点等）。这部分的逻辑 (getNodeLevel, isPidOfLevelOneNode 等辅助函数以及 allowDrop 内部的规则判断) 体现了对树形结构操作的细致思考。 @node-drop: 当拖拽操作完成并释放后触发此事件。在此事件的回调函数 (handleDrop) 中，处理了前端树结构的变化，并收集变更信息发送给后端进行持久化。 前后端数据同步的复杂性处理 (拖拽后)： 前端先行，后端确认： el-tree 组件在拖拽操作完成后，会首先在前端内部更新其数据模型（treeNodeList.value 的结构会发生变化）。 收集变更并发送： 在 @node-drop 事件触发后，前端代码需要基于这个已经变化的前端数据结构，重新计算每个节点的 pid 和 sort_order，然后将这些变更信息 (updatesToSendToBackend) 发送给后端。 后端批量更新： 后端接收到这些变更信息后，进行批量数据库更新。 错误处理与回滚： 如果后端更新失败，前端需要有机制从后端重新加载数据以恢复到正确的状态 (loadMenuTree())。 template h2管理菜单/h2 div style=text-align: left h4选择新增节点的父节点（支持拖拽调整顺序）/h4 el-tree :props=props :data=treeNodeList node-key=id default-expand-all :expand-on-click-node=false ref=treeRef @node-click=hanldNodeClick :highlight-current=true draggable :allow-drop=allowDrop :allow-drag=allowDrag @node-drop=handleDrop template #default= node, data span class=custom-tree-node span node.label /span span a @click.stop=openEditDialog(data) style=color: var(--el-color-primary) 修改 /a a style=margin-left: 8px; color: var(--el-color-danger) @click.stop=delMenus(node, data) 删除 /a /span /span /template /el-tree /div hr / !-- 添加表单控件 -- el-form :model=menuForm label-width=120px el-form-item label=新增菜单名称 el-input v-model=menuForm.label style=width: 50% / /el-form-item el-form-item el-button type=primary @click=subMenuForm保存/el-button el-button @click=resetForm取消/el-button el-button @click=clearTreeSelection style=margin-left: 10px; 取消当前选中节点/el-button /el-form-item /el-form !-- 修改弹窗 -- el-dialog title=修改菜单 v-model=dialogVisible width=30% el-form :model=editForm label-width=120px el-form-item label=菜单名称 el-input v-model=editForm.label style=width: 50% / /el-form-item /el-form template #footer el-button @click=dialogVisible = false取消/el-button el-button type=primary @click=updateMenu更新/el-button /template /el-dialog/templatescript setup import onMounted, reactive, ref, nextTick from vue; import axios from axios; import ElMessage, ElMessageBox from element-plus; const props = label: label, children: subMenu, ; const treeNodeList = ref([]); const treeRef = ref(null); const menuForm = reactive( id: null, label: , component: null, pid: 0, ); const dialogVisible = ref(false); const editForm = reactive( id: null, label: , component: null, ); function loadMenuTree() axios .get(http://localhost:8080/listMenus) .then((response) = treeNodeList.value = response.data; ) .catch((error) = console.log(error); ElMessage.error(菜单加载失败); ); onMounted(() = loadMenuTree(); ); let currentSelectedPidForAdd = 0; function hanldNodeClick(data) currentSelectedPidForAdd = data.id; // console.log(Selected parent for new node:, currentSelectedPidForAdd); function openEditDialog(data) editForm.id = data.id; editForm.label = data.label; editForm.component = data.component; dialogVisible.value = true; function updateMenu() axios .put(http://localhost:8080/updateMenus, editForm) .then((response) = if (response.data.code === 200) loadMenuTree(); dialogVisible.value = false; ElMessage( type: response.data.code === 200 ? success : error, message: response.data.msg || (response.data.code === 200 ? 更新成功 : 更新失败), ); ) .catch((error) = console.log(error); ElMessage.error(修改失败，请稍后重试); ); function resetForm() menuForm.label = ; menuForm.component = null; currentSelectedPidForAdd = 0; if (treeRef.value) treeRef.value.setCurrentKey(null); // --- 取消树节点选中 --- function clearTreeSelection() if (treeRef.value) treeRef.value.setCurrentKey(null); // 取消 Element Plus Tree 的当前高亮节点 currentSelectedPidForAdd = 0; // 重置用于添加新节点的父节点ID ElMessage.info(已取消节点选择); // 可选：给用户一个反馈 function subMenuForm() if (!menuForm.label.trim()) ElMessage.warning(菜单名称不能为空); return; menuForm.pid = currentSelectedPidForAdd; axios .post(http://localhost:8080/saveMenus, menuForm) .then((response) = if (response.data.code === 200) loadMenuTree(); resetForm(); ElMessage( type: response.data.code === 200 ? success : error, message: response.data.msg || (response.data.code === 200 ? 添加成功 : 添加失败), ); ) .catch((error) = console.log(error); ElMessage.error(添加失败，请稍后重试); ); async function delMenus(node, data) if (data.subMenu data.subMenu.length 0) ElMessage.warning(data.label + , 节点存在子节点不能删除!); return; try await ElMessageBox.confirm(`确定要删除菜单 $data.label 吗?`, 提示, confirmButtonText: 确定, cancelButtonText: 取消, type: warning, ); const response = await axios.delete( http://localhost:8080/deleteMenus?id= + data.id ); if (response.data.code === 200) loadMenuTree(); ElMessage( type: response.data.code === 200 ? success : error, message: response.data.msg, ); catch (error) if (error !== cancel error !== close) console.error(删除失败:, error); ElMessage.error(删除操作失败); else ElMessage.info(已取消删除); // --- 拖拽相关方法 --- const allowDrag = (draggingNode) = return true; ; // 辅助函数，用于getNodeLevel const isPidOfLevelOneNode = (pidToCheck) = if (!treeNodeList.value || treeNodeList.value.length === 0) return false; return treeNodeList.value.some( (levelOneNode) = levelOneNode.id === pidToCheck ); ; const getNodeLevel = (node) = if (!node || !node.data || typeof node.data.pid === undefined) return 0; if (node.data.pid === 0) return 1; // 直接判断pid是否为0 if (node.data.pid !== 0 isPidOfLevelOneNode(node.data.pid)) // isPidOfLevelOneNode 遍历 treeNodeList return 2; return 0; // 未知或无效层级 ; const allowDrop = (draggingNode, dropNode, type) = const draggingLevel = getNodeLevel(draggingNode); const dropLevel = getNodeLevel(dropNode); // 节点是否有子节点 (基于 draggingNode.data.subMenu，这依赖于后端返回的数据结构) // 或者直接检查 draggingNode (Node对象) 的 childNodes const draggingNodeHasChildren = draggingNode.childNodes draggingNode.childNodes.length 0; // 基本校验：无效层级或拖拽自身 if ( draggingLevel === 0 || dropLevel === 0 || draggingNode.key === dropNode.key ) return false; // --- 规则开始 --- // 规则1: 拖拽一级节点 (父节点) if (draggingLevel === 1) if (dropLevel === 1) // 目标也是一级节点 if (type === inner) // 条件：允许一级节点A放入一级节点B内部，前提是A没有子节点 // 此时A将从一级降为二级 if (draggingNodeHasChildren) // ElMessage.warning(有子节点的父菜单不能直接成为其他父菜单的子菜单。); return false; // 有子节点的一级不能直接降级并带子节点进入 (避免三级) return true; // 允许无子节点的一级节点成为另一一级节点的子节点 return true; // 允许一级节点之间同级排序 (prev/next) if (dropLevel === 2) // 目标是二级节点 // 通常不允许一级节点直接操作二级节点来改变层级或排序，除非特定场景 // 例如：如果想把一级节点P1放到二级节点S1的父节点下，与S1同级， // 这种情况应该通过拖拽P1到S1的父节点P2的 prev/next/inner 来实现。 // 这里先保守禁止，一级节点不能直接以二级节点为目标改变结构。 return false; // 规则2: 拖拽二级节点 (子节点) if (draggingLevel === 2) if (dropLevel === 1) // 目标是一级节点 (父节点) // 二级节点可以拖入一级节点内部成为其子节点 (type === inner) // 二级节点也可以拖到一级节点的前后，实现升级为新的一级节点 if (type === prev || type === next) // 允许二级节点升级为一级节点，与目标一级节点同级 return true; // type === inner，成为其子节点 return true; if (dropLevel === 2) // 目标也是二级节点 if (type === inner) // 严格禁止二级节点下面再有子节点 (防止三级) return false; // 允许二级节点之间同级排序 (prev/next) return true; return false; // 其他未明确定义的拖拽均不允许 ; const handleDrop = async (draggingNode, dropNode, dropType, ev) = if (dropType === none) return; // ElMessage.info(`节点 $draggingNode.data.label 已拖拽到 $dropNode.data.label $dropType`); // Element Plus 的 el-tree 会在触发此事件前，在内部更新其数据模型 (treeNodeList.value 的结构)。 // 我们需要确保基于这个新结构，节点的 pid 也被正确更新。 await nextTick(); // 等待DOM和el-tree内部数据更新 // 重新构建树的PID和排序信息，并直接更新到 treeNodeList.value 中的节点 // 这一步至关重要，确保后续的 getNodeLevel 能获取到最新的 pid const updateNodePidsAndCollectChanges = (nodes, parentId) = const changes = []; nodes.forEach((nodeData, index) = // 直接更新前端数据中的 pid 和 sortOrder (如果需要) nodeData.pid = parentId; changes.push( id: nodeData.id, pid: parentId, sortOrder: index, label: nodeData.label, ); if (nodeData.subMenu nodeData.subMenu.length 0) // 递归调用，并将其子节点收集的变更合并 changes.push( ...updateNodePidsAndCollectChanges(nodeData.subMenu, nodeData.id) ); else if (!nodeData.subMenu) // 确保空的父节点在拖拽后仍然有 subMenu: [] nodeData.subMenu = []; ); return changes; ; // 基于当前 treeNodeList.value (el-tree 拖拽后更新的结构) 来更新 PID 并收集变更 const updatesToSendToBackend = updateNodePidsAndCollectChanges( treeNodeList.value, 0 ); if (updatesToSendToBackend.length 0) try const response = await axios.post( http://localhost:8080/updateMenusOrder, updatesToSendToBackend ); if (response.data.code === 200) ElMessage.success(菜单顺序已同步到后端); // 通常不需要刷新，因为 treeNodeList.value 已是最新。 // 若后端有其他副作用或为了绝对保险，可以取消注释下一行 // loadMenuTree(); else ElMessage.error(response.data.msg || 后端同步失败，正在还原...); loadMenuTree(); // 同步失败，从后端恢复 catch (error) console.error(Error updating menu order:, error); ElMessage.error(同步菜单顺序失败，正在还原...); loadMenuTree(); // 网络错误等，也从后端恢复 ;/scriptstyle scoped ::v-deep .el-tree-node.is-current .el-tree-node__content background-color: var(--el-color-primary-light-9); color: var(--el-color-primary); ::v-deep .el-tree-node__content:hover background-color: var(--el-fill-color-light); ::v-deep .el-tree --el-tree-node-hover-bg-color: var(--el-fill-color-light); .custom-tree-node flex: 1; display: flex; align-items: center; justify-content: space-between; font-size: 14px; padding-right: 8px; /style 4.实现主页菜单同步修改 跨组件状态同步 (Event Bus - mitt)： 问题场景： 当在 AddMenus.vue 页面修改了菜单结构（增、删、改、拖拽排序）后，主页 (index.vue，假设它也展示了菜单) 的菜单显示需要同步更新。由于这两个组件可能没有直接的父子关系，简单的 props/emit 可能不适用。 解决方案： 引入了事件总线 (Event Bus) 机制，这里使用了 mitt 库。 创建一个全局的事件总线实例 (src/eventBus.js)。 在菜单结构发生变化的组件 (AddMenus.vue) 中，当操作成功后，通过 emitter.emit(‘menu-structure-changed’) 发布一个事件。 在需要响应这个变化的组件（主页 index.vue）中，通过 emitter.on(‘menu-structure-changed’, handleMenuStructureChanged) 订阅这个事件，并在事件触发时执行相应的更新逻辑 (如重新获取菜单 fetchMenus())。 生命周期管理： 在订阅事件的组件卸载前 (onBeforeUnmount)，需要通过 emitter.off() 移除监听器，以防止内存泄漏。 这里学会了一种在 Vue 应用中进行非父子组件间通信和状态同步的常用方法。事件总线提供了一种解耦的通信方式，使得组件间不需要直接相互依赖。 修改前端代码 根据教程vue – 事件总线 EventBus和 ai 辅助，得知可以添加Event Bus (事件总线)，以同步更新 首先，安装依赖 npm install mitt 创建一个事件总线文件，如 src/eventBus.js import mitt from mitt;const emitter = mitt();export default emitter; 主页代码修改如下 import emitter from @/eventBus;// Vue核心引入onBeforeUnmountimport computed, onMounted, ref, watch, onBeforeUnmount from vue;//修改以下方法，已实现和AddMenus.vue同步更改// 定义默认展开的菜单项const defaultOpeneds = computed(() = // 当 menus 更新时，这个计算属性会自动重新计算 return menus.value.map((menu) = menu.id.toString()););// --- 事件处理函数，用于响应菜单结构变化 ---const handleMenuStructureChanged = () = fetchMenus(); // 重新获取菜单;onMounted(() = fetchMenus(); // 页面加载时获取菜单 emitter.on(menu-structure-changed, handleMenuStructureChanged); // --- 监听事件);onBeforeUnmount(() = emitter.off(menu-structure-changed, handleMenuStructureChanged); // --- 组件卸载前移除监听器，防止内存泄漏); AddMenus.vue 代码修改如下 import emitter from @/eventBus; //同样引入依赖//在每一个修改相关操作成功时添加下面这句话触发更新事件，例如我之前的updateMenu，subMenuForm，delMenus，handleDrop这些方法emitter.emit(menu-structure-changed); Day8 0.实现后端存 icon，前端显示 后端存储图标名称： 在 t_menu 表和对应的 POJO/VO 中增加了 icon_name 字段，用于存储 Element Plus 图标的名称 (如 “User”, “Setting”)。 前端动态渲染图标： 在主页 (index.vue) 中，不再写死菜单图标，而是通过 :is=“getIcon(menu.iconName)” 动态地渲染 内部的组件。 getIcon 函数负责根据后端返回的 iconName 从 @element-plus/icons-vue 中查找并返回对应的图标组件。如果找不到或 iconName 为空，则返回一个默认图标 (如 Document)。 后端实现 数据库对 menu 表添加图标字段 ALTER TABLE `t_menu`ADD COLUMN `icon_name` VARCHAR(50) DEFAULT NULL COMMENT Element Plus 图标名称 (例如 User, Setting, Folder) AFTER `sort_order`; menu pojo 添加对应字段 /** 图标名称 */@TableField(icon_name)private String iconName; menu vo 添加字段 private String iconName; mapper 添加字段 resultMap id=BaseResultMap type=com.example.demo.pojo.Menu id property=id column=id / result property=label column=label / result property=component column=component / result property=pid column=pid / result property=icon_name column=icon_name//resultMapsql id=Base_Column_List id,label,component,pid,icon_name/sql serviceimpl 添加一行映射图标 private ListMenuVo buildSubmenu(ListMenu allMenu, Integer parentId) ListMenuVo submenuTree = new ArrayList(); for (Menu menu : allMenu) if (menu.getPid() != null menu.getPid().equals(parentId)) MenuVo menuVo = new MenuVo(); BeanUtils.copyProperties(menu, menuVo); menuVo.setIconName(menu.getIconName()); // 手动赋值 icon_name menuVo.setSubMenu(buildSubmenu(allMenu, menu.getId())); submenuTree.add(menuVo); return submenuTree; 前端实现 // Element Plus 图标，修改引入依赖import * as ElementPlusIconsVue from @element-plus/icons-vue;// 新增图标映射函数const getIcon = (iconName) = // 如果没有图标名称，返回默认图标 if (!iconName) return ElementPlusIconsVue.Document; // 尝试获取图标组件 const icon = ElementPlusIconsVue[iconName]; // 如果图标存在则返回，否则返回默认图标 return icon || ElementPlusIconsVue.Document;; 修改写死的图标映射方式 el-menu class=app-menu @select=handlerSelect v-if=hasMenus :default-active=1 unique-opened :default-openeds=defaultOpeneds el-sub-menu v-for=menu in menus :key=menu.id :index=menu.id.toString() template #title el-icon !-- 动态渲染主菜单图标 -- component :is=getIcon(menu.iconName) / /el-icon span menu.label /span /template el-menu-item v-for=subMenu in menu.subMenu :key=subMenu.id :index=subMenu.id.toString() el-icon !-- 动态渲染子菜单图标 -- component :is=getIcon(subMenu.iconName) / /el-icon span subMenu.label /span /el-menu-item /el-sub-menu/el-menu 1.实现角色增删改查 后端实现 Roleservice 添加接口 public MapString,Object queryRolePageListService(Integer pageNum, Integer pageSize); 实现接口方法 @Autowired private RolerMapper rolerMapper; @Override public MapString, Object queryRolePageListService(Integer pageNum, Integer pageSize) //指定分页查询参数 PageRoler page=new Page(pageNum,pageSize); ListRoler rolerList = rolerMapper.selectList(page, null); MapString, Object result=new HashMap(); result.put(total,page.getTotal()); result.put(rolerList,rolerList); return result; 实现控制层 @RestController@CrossOriginpublic class RolerController @Autowired private RolerService rolerService; /*处理分页查询请求*/ @GetMapping(/rolerList) public MapString,Object rolerList( @RequestParam(defaultValue = 1) Integer pageNum , @RequestParam(defaultValue = 3) Integer pageSize) return rolerService.queryRolePageListService(pageNum,pageSize); /*处理角色信息修改的请求*/ @PostMapping(/updateRoler) public MapString,Object updateRoler(@RequestBody Roler roler) MapString,Object result=new HashMap(); result.put(code,400); result.put(msg,操作失败.......); try rolerService.updateById(roler); result.put(code,200); result.put(msg,更新角色信息成功......); catch(Exception ex) ex.printStackTrace(); return result; /*处理角色信息添加的请求*/ @PostMapping(/saveRoler) public MapString,Object saveRoler(@RequestBody Roler roler) MapString,Object result=new HashMap(); result.put(code,400); result.put(msg,操作失败.......); try rolerService.save(roler); result.put(code,200); result.put(msg,保存角色信息成功......); catch(Exception ex) ex.printStackTrace(); return result; /*处理角色信息删除的请求*/ @PostMapping(/deleteRoler) public MapString,Object deleteRoler(@RequestBody Roler roler) MapString,Object result=new HashMap(); result.put(code,400); result.put(msg,操作失败.......); try rolerService.removeById(roler.getId()); result.put(code,200); result.put(msg,删除角色信息成功......); catch(Exception ex) ex.printStackTrace(); return result; 前端实现 实现了一种表格内编辑的功能。通过点击“编辑”按钮，行内对应的 el-input 变为可编辑状态，编辑完成后点击“保存”按钮提交更新。这是通过在行数据 (scope.row) 上添加一个 edit 标志位来控制的。 特色（表格内编辑）： 这种交互方式比传统的“点击编辑 - 打开新对话框/页面 - 保存” 更为直接和便捷，尤其适用于少量字段的快速修改。 添加 RolerManager.vue 页面 template h2角色管理/h2 div style=text-align: left el-button type=primary @click=openRoleDialog添加角色/el-button /div el-table :data=rolerList stripe style=width: 100% el-table-column prop=id label=编号 width=180 / el-table-column label=角色 width=260 template #default=scope el-input v-if=scope.row.edit v-model=scope.row.rname/el-input span v-else scope.row.rname /span /template /el-table-column el-table-column label=描述 template #default=scope el-input v-if=scope.row.edit v-model=scope.row.rdesc/el-input span v-else scope.row.rdesc /span /template /el-table-column el-table-column align=right template #header span操作/span /template template #default=scope el-button v-if=!scope.row.edit size=mini @click=handleEdit(scope.row) 编辑/el-button el-button v-else size=mini type=success @click=handleSave(scope.row) 保存/el-button el-button size=mini type=danger @click=handleDelete(scope.row) 删除/el-button /template /el-table-column /el-table !-- 分页组件 -- hr / el-pagination small background :page-size=3 :pager-count=10 layout=prev, pager, next :total=total class=mt-4 @current-change=rolerPageChange / !-- 角色信息对话框 -- !-- 回显客户信息的对话框 -- el-dialog v-model=dialogRoleVisible width=80% h2角色信息/h2 !-- 对话框中添加form -- el-form :model=rolerForm label-width=120px el-form-item label=角色名称 el-input v-model=rolerForm.rname style=width: 80% / /el-form-item el-form-item label=角色描述 el-input v-model=rolerForm.rdesc style=width: 80% / /el-form-item el-form-item el-button type=primary @click=saveRoleForm保存/el-button el-button取消/el-button /el-form-item /el-form /el-dialog/templatescript setup import onMounted, reactive, ref from vue; import axios from axios; import ElMessage, ElMessageBox from element-plus; //定义角色集合列表数据 const rolerList = ref([]); const total = ref(0); //发送请求加载角色列表 function queryRoleList(pageNum) axios .get(http://localhost:8080/rolerList?pageNum= + pageNum) .then((response) = rolerList.value = response.data.rolerList; total.value = response.data.total; ) .catch((error) = console.log(error); ); //加载页码调用函数 onMounted(function () queryRoleList(1); ); //定义分页按钮函数 function rolerPageChange(pageNum) queryRoleList(pageNum); //定义函数实现表格编辑效果 function handleEdit(row) row.edit = true; //定义函数实现编辑后保存 function handleSave(row) //row.edit=false; //console.log(row); //发送ajax请求进行数据更新 axios .post(http://localhost:8080/updateRoler, row) .then((response) = if (response.data.code == 200) row.edit = false; ElMessage(response.data.msg); ) .catch((error) = console.log(error); ); //定义函数实现删除角色 function handleDelete(row) ElMessageBox.confirm(确认要删除该角色吗？, 警告, confirmButtonText: 确定, cancelButtonText: 取消, type: warning, ) .then(() = axios .post(http://localhost:8080/deleteRoler, row) .then((response) = if (response.data.code == 200) queryRoleList(1); ElMessage(response.data.msg); ) .catch((error) = console.log(error); ElMessage(删除失败，请稍后重试); ); ) .catch(() = ElMessage(已取消删除); ); //定义对话框状态 const dialogRoleVisible = ref(false); //定义form表单 const rolerForm = reactive( rname: , rdesc: , ); //定义打开添加角色信息的对话框 function openRoleDialog() dialogRoleVisible.value = true; //定义函数提交角色信息保存的ajax请求 function saveRoleForm() axios .post(http://localhost:8080/saveRoler, rolerForm) .then((response) = if (response.data.code == 200) dialogRoleVisible.value = false; rolerForm.rname = ; rolerForm.rdesc = ; queryRoleList(1); ElMessage(response.data.msg); ) .catch((error) = console.log(error); ); /scriptstyle scoped/style 注册此页面 import ListAfterSale from @/views/RolerManager.vue; // 导入 管理菜单 视图组件//老师的方法，修改以下内容:const views = [ AddCustomer, ListCustomer, ListAfterSale, ListCustOrder, AddSellJh, , , ListSellJh, AddMenus, RolerManager,];//我的方法，修改以下内容：const views = [ markRaw(AddCustomer), markRaw(ListCustomer), markRaw(ListAfterSale), markRaw(ListCustOrder), markRaw(AddSellJh), markRaw(AddSellJh), markRaw(AddSellJh), markRaw(ListSellJh), markRaw(AddMenus), markRaw(RolerManager),]; 2.实现角色权限管理 后端实现 listRoleMenus (GET): 根据角色 ID (roleId) 查询该角色已经拥有的菜单 ID 列表。这对应 RoleMenuMapper.xml 中的 getMenusByRoleId。 grantRoleMenus (POST): 接收一个包含角色 ID 和多个菜单 ID 的数组，为该角色重新授权菜单。这对应 RoleMenuMapper.xml 中的 deleteByRoleId (先删除旧权限) 和 batchInsert (批量插入新权限)。这个操作同样使用了 @Transactional 来保证原子性。 RoleMenuMapper.xml 添加方法 !-- 根据角色ID获取菜单ID列表 --select id=getMenusByRoleId resultType=java.lang.Integer SELECT mid FROM t_role_menu WHERE rid = #roleId/select!-- 删除角色所有权限 --delete id=deleteByRoleId DELETE FROM t_role_menu WHERE rid = #roleId/delete!-- 批量插入角色菜单权限 --insert id=batchInsert INSERT INTO t_role_menu(rid, mid) VALUES foreach collection=menuIds item=mid separator=, (#roleId, #mid) /foreach/insert 对应 RoleMenuService 接口添加方法 ListInteger getMenusByRoleId(Integer roleId);boolean grantRoleMenus(Integer[] ids); 实现方法 @Overridepublic ListInteger getMenusByRoleId(Integer roleId) return baseMapper.getMenusByRoleId(roleId);@Overridepublic boolean grantRoleMenus(Integer[] ids) if (ids.length 0) Integer roleId = ids[0]; ListInteger menuIds = new ArrayList(); for(int i=1; iids.length; i++) menuIds.add(ids[i]); // 先删除原有权限 baseMapper.deleteByRoleId(roleId); // 批量插入新权限 if (menuIds != null !menuIds.isEmpty()) return baseMapper.batchInsert(roleId, menuIds) 0; return true; return false; 在 RolerController 添加方法（注意不是 RolerMenuController） @Autowiredprivate RoleMenuService roleMenuService;/*获取角色菜单权限接口*/ @GetMapping(/listRoleMenus) public ListInteger listRoleMenus(Integer roleId) return roleMenuService.getMenusByRoleId(roleId); /*授予角色菜单权限接口*/ @PostMapping(/grantRoleMenus) public MapString,Object grantRoleMenus(@RequestBody Integer[] ids) MapString,Object result=new HashMap(); result.put(code,400); result.put(msg,授权失败......); try if(roleMenuService.grantRoleMenus(ids)) result.put(code,200); result.put(msg,授权成功.......); catch(Exception ex) ex.printStackTrace(); return result; 前端实现 点击“授权”按钮，弹出一个包含完整菜单树 (el-tree 且 show-checkbox 为 true) 的对话框。 加载并回显已有权限： 打开对话框时，会先加载完整的菜单树，然后调用 /listRoleMenus 接口获取当前角色已有的菜单 ID，并使用 treeRef.value.setCheckedKeys(leafNodeIds) 将这些菜单在树中设置为选中状态。 处理父子节点联动选中： el-tree 的 show-checkbox 默认会处理父子节点的联动选中。前端代码中 filterLeafNodeIds 的逻辑是为了确保只将叶子节点的 ID 传递给 setCheckedKeys，这样 Element Plus Tree 组件会自动处理父节点的半选中或全选中状态，符合用户直观的授权体验。 保存授权： 用户在树中勾选/取消勾选菜单后，点击“保存授权”按钮，前端会收集所有被选中的菜单节点的 ID (通过 treeRef.value.getCheckedNodes(false, true)，其中 false 表示不只获取叶子节点，true 表示获取包括半选中状态的父节点，这里可以根据实际需求调整)，连同角色 ID 一起发送给后端的 /grantRoleMenus 接口。 !-- 修改操作组件，添加按钮 --el-table-column align=right template #header span操作/span /template template #default=scope el-button size=small @click=handleAuthorize(scope.row)授权/el-button el-button v-if=!scope.row.edit size=small @click=handleEdit(scope.row) 编辑/el-button el-button v-else size=small type=success @click=handleSave(scope.row) 保存/el-button el-button size=small type=danger @click=handleDelete(scope.row) 删除/el-button /template/el-table-column!--在模版组件最后面添加授权对话框--el-dialog title=角色授权 v-model=authDialogVisible width=40% div style=text-align: left h4请选择该角色可访问的菜单/h4 el-tree :props=props :data=treeNodeList node-key=id show-checkbox default-expand-all ref=treeRef :highlight-current=true template #default= node, data span class=custom-tree-node span node.label /span /span /template /el-tree /div template #footer el-button @click=authDialogVisible = false取消/el-button el-button type=primary @click=saveRoleAuth保存授权/el-button /template/el-dialog //添加相关变量和方法// 树形菜单相关数据const treeNodeList = ref([]);const treeRef = ref(null);const props = label: label, children: subMenu, // 改为与后端返回的字段名一致;// 授权对话框状态const authDialogVisible = ref(false);const currentRoleId = ref(null);const currentRoleName = ref();// 处理授权按钮点击事件function handleAuthorize(row) currentRoleId.value = row.id; currentRoleName.value = row.rname; loadMenuTree(); loadRoleMenus(row.id); authDialogVisible.value = true;// 加载菜单树function loadMenuTree() axios .get(http://localhost:8080/listMenus) .then((response) = treeNodeList.value = response.data; ) .catch((error) = console.log(error); ElMessage.error(菜单加载失败); );// 加载角色已有的菜单权限function loadRoleMenus(roleId) axios .get(`http://localhost:8080/listRoleMenus?roleId=$roleId`) .then((response) = // 等待树加载完成后再设置选中状态 setTimeout(() = if (treeRef.value) // 清除之前的选择 treeRef.value.setCheckedKeys([]); // 设置新的选中项 if (response.data response.data.length 0) // 先找出只包含叶子节点的ID const leafNodeIds = filterLeafNodeIds( response.data, treeNodeList.value ); // 只选中叶子节点，父节点会自动变为半选中状态 treeRef.value.setCheckedKeys(leafNodeIds); , 100); ) .catch((error) = console.log(error); ElMessage.error(角色菜单权限加载失败); );// 递归检查节点ID是否为叶子节点，并过滤出叶子节点IDfunction filterLeafNodeIds(ids, nodes) // 存储所有非叶子节点的ID const parentIds = new Set(); // 递归收集所有非叶子节点ID function collectParentIds(nodeList) if (!nodeList || nodeList.length === 0) return; for (const node of nodeList) if (node.subMenu node.subMenu.length 0) // 这是一个父节点 parentIds.add(node.id); // 递归检查子节点 collectParentIds(node.subMenu); // 收集所有父节点ID collectParentIds(nodes); // 过滤出只有叶子节点的ID return ids.filter((id) = !parentIds.has(id));// 保存角色授权function saveRoleAuth() if (!treeRef.value || !currentRoleId.value) ElMessage.warning(请先选择角色和菜单); return; // 获取所有选中的节点（包含父节点） const nodes = treeRef.value.getCheckedNodes(false, true); const arr = [currentRoleId.value]; nodes.forEach((item) = arr.push(item.id); ); axios .post(http://localhost:8080/grantRoleMenus, arr) .then((response) = if (response.data.code === 200) ElMessage.success(授权成功); authDialogVisible.value = false; else ElMessage.error(response.data.msg || 授权失败); ) .catch((error) = console.log(error); ElMessage.error(授权失败，请稍后重试); ); Day9 补全昨天的逻辑 后端删除时，应该联级删除 当删除一个角色时，仅仅删除 t_roler 表中的记录是不够的，还需要删除 t_role_menu 表中与该角色相关的所有权限关联记录，否则会产生孤儿数据。 解决： 在 RolerController 的 deleteRoler 方法中，在删除角色本身 (rolerService.removeById(roler.getId())) 之前，先使用 QueryWrapper 构建条件，调用 roleMenuService.remove(queryWrapper) 来删除 t_role_menu 表中所有 rid 等于被删除角色 ID 的记录。 修改昨天的删除代码 /*处理角色信息删除的请求*/@PostMapping(/deleteRoler)public MapString, Object deleteRoler(@RequestBody Roler roler) MapString, Object result = new HashMap(); result.put(code, 400); result.put(msg, 操作失败.......); try QueryWrapperRoleMenu queryWrapper = new QueryWrapper(); queryWrapper.eq(rid, roler.getId()); roleMenuService.remove(queryWrapper); rolerService.removeById(roler.getId()); result.put(code, 200); result.put(msg, 删除角色信息成功......); catch (Exception ex) ex.printStackTrace(); return result; Day10 1.实现用户管理页 在添加这个功能之前，我简化了前后端的 api 调用代码方法，具体方法看杂项里的内容 后端实现 这个位置完整地实现了 RBAC 模型中“用户-角色”这一核心关联的管理。 用户与角色的多对多关系处理： 后端数据结构： 在 User 实体类中添加了 @TableField(exist = false) 的 rids (角色 ID 数组) 属性，用于在前端提交用户数据时，同时传递该用户被分配的角色信息。 后端保存逻辑 (saveUserRolerService)： 先保存用户基本信息到 t_user 表。一个重要的细节是，通过自定义 Mapper XML (saveUserMapper 使用 useGeneratedKeys=“true” keyProperty=“id”)，在插入用户数据后获取数据库自增生成的主键 ID。这个 ID 后续用于在 t_user_role 关联表中建立关系。 然后遍历 user.getRids()，将用户 ID 和每个角色 ID 插入到 t_user_role 表中，从而建立用户和角色的关联。 后端更新逻辑 (updateUserRoleService)： 先根据用户 ID 删除 t_user_role 表中该用户已有的所有角色关联（“先删后插”的策略）。 然后更新 t_user 表中的用户基本信息。 最后，根据 user.getRids() 重新插入新的用户角色关联。 后端删除逻辑 (deleteUserRoleService)： 删除用户时，除了删除 t_user 表中的用户记录，还需要级联删除 t_user_role 表中与该用户相关的所有角色关联记录。 后端查询用户已分配角色 (queryUserRids)： 提供接口根据用户 ID 查询其在 t_user_role 表中关联的所有角色 ID，用于前端编辑用户时回显已分配的角色。 修改 user 实体类 用户密码添加注解防止前端直接显示密码 扩展属性保存用户角色 id /** * 用户密码 */ @JsonIgnore private String upwd;//扩展属性保存用户角色id集合@TableField (exist = false)private Integer[] rids; usermapper 添加接口 /*保存用户信息*/public void saveUserMapper(User user); 实现此接口 !--定义sql保存用户信息 保存数据，数据库id自增，保存数据完成后产生的自增的id，封装到方法传入的 user参数的id属性--insert id=saveUserMapper parameterType=com.example.demo.pojo.User useGeneratedKeys=true keyProperty=id insert into t_user values(null,#uname,#upwd,#phone, #edu,#age,#title)/insert userservice 添加逻辑实现接口 /*实现用户信息分页查询*/MapString,Object queryUserListService(Integer pageNum, Integer pageSize);/*实现用户信息保存*/public void saveUserRolerService(User user);/*更新用户信息*/public void updateUserRoleService(User user);/*实现用户信息的删除*/public void deleteUserRoleService(Integer id); 实现接口 @Autowired private UserMapper userMapper; @Autowired private UserRoleMapper userRoleMapper; @Override public MapString, Object queryUserListService(Integer pageNum, Integer pageSize) MapString, Object result=new HashMap(); //指定分页参数 PageUser page=new Page(pageNum,pageSize); ListUser userList = userMapper.selectList(page, null); result.put(total,page.getTotal()); result.put(userList,userList); return result; @Transactional @Override public void saveUserRolerService(User user) System.out.println(1----+user.getId()); //保存用户基本信息后需要获得数据库自增产生的用户id //userMapper.insert(user); userMapper.saveUserMapper(user); //获得数据库自增产生的id System.out.println(2----+user.getId()); Integer uid=user.getId(); //获得当前用户分配的角色id的集合,从前台提交 Integer[] rids=user.getRids(); for(Integer rid:rids) //保存用户和角色的关系 UserRole ur=new UserRole(); ur.setUid(uid); //用户id赋值 ur.setRid(rid); //角色id赋值 userRoleMapper.insert(ur); @Transactional @Override public void updateUserRoleService(User user) //删除当前更新用户和角色的所有关系，断开关系 QueryWrapperUserRole del=new QueryWrapper(); del.eq(uid,user.getId()); //where uid=? userRoleMapper.delete(del); //更新用户信息 userMapper.updateById(user); //中间关系表重新添加数据 Integer[] rids = user.getRids(); for(Integer rid:rids) UserRole ur=new UserRole(); ur.setUid(user.getId()); ur.setRid(rid); userRoleMapper.insert(ur); @Transactional @Override public void deleteUserRoleService(Integer id) //删除用户 userMapper.deleteById(id); QueryWrapperUserRole wrapper=new QueryWrapper(); wrapper.eq(uid,id); //删除用户角色信息 userRoleMapper.delete(wrapper); 添加 UserController @RestController@CrossOriginpublic class UserController @Autowired private UserService userService; @Autowired private UserRoleService userRoleService; /*处理用户信息分页查询氢气*/ @GetMapping(/userList) public MapString,Object userList( @RequestParam(defaultValue = 1) Integer pageNum ,@RequestParam(defaultValue = 10) Integer pageSize) return userService.queryUserListService(pageNum,pageSize); /*添加方法处理用户信息添加请求*/ @PostMapping(/saveUser) public MapString,Object saveUser(@RequestBody User user) userService.saveUserRolerService(user); return ResponseUtil.success(保存用户信息成功); /*根据用户id查询某个用户的所有角色id*/ @GetMapping(/queryUserRids/id) public ListInteger queryUserRids(@PathVariable Integer id) QueryWrapper wrapper=new QueryWrapper(); wrapper.eq(uid,id); wrapper.select(rid); ListInteger list = userRoleService.listObjs(wrapper); return list; /*处理用户信息修改请求*/ @PostMapping(/updateUser) public MapString,Object updateUser(@RequestBody User user) userService.updateUserRoleService(user); return ResponseUtil.success(修改用户信息成功); /*处理用户信息删除请求*/ @PostMapping(/deleteUser) public MapString,Object deleteUser(@RequestBody User user) userService.deleteUserRoleService(user.getId()); return ResponseUtil.success(删除用户信息成功); 前端实现 添加页面 template h2用户列表/h2 !-- 添加按钮 -- div style=text-align: left el-button type=danger @click=openUserDialog添加用户/el-button /div !-- table组件 -- el-table :data=userList stripe style=width: 100% el-table-column prop=id label=用户编号 width=180 / el-table-column prop=uname label=用户名 width=180 / el-table-column prop=phone label=电话 / el-table-column prop=edu label=学历 / el-table-column prop=age label=年龄 / el-table-column prop=title label=部门 / el-table-column fixed=right label=操作 width=120 template #default=scope el-button link type=primary size=small @click=deleteUser(scope.row) 删除 /el-button el-button link type=primary size=small @click=showUserDialog(scope.row) 修改 /el-button /template /el-table-column /el-table hr / !-- page分页组件 -- el-pagination small background :page-size=pageSize :pager-count=10 layout=prev, pager, next :total=total class=mt-4 @current-change=handlerPageChange / !-- 添加用户信息对话框 -- el-dialog v-model=dialogUserVisible width=80% :title=userForm.id ? 修改用户信息 : 添加用户信息 @close=resetUserForm !-- 对话框中添加form -- el-form ref=userFormRef :model=userForm :rules=rules label-width=120px el-form-item label=用户名 prop=uname el-input v-model=userForm.uname style=width: 80% / /el-form-item el-form-item label=电话 prop=phone el-input v-model=userForm.phone style=width: 80% / /el-form-item el-form-item label=学历 prop=edu el-input v-model=userForm.edu style=width: 80% / /el-form-item el-form-item label=年龄 prop=age el-input v-model=userForm.age style=width: 80% / /el-form-item el-form-item label=部门 prop=title el-input v-model=userForm.title style=width: 80% / /el-form-item el-form-item label=角色 prop=rids el-select v-model=userForm.rids placeholder=请选择角色.... style=width: 80% multiple el-option v-for=opt in optRoles :label=opt.rname :value=opt.id :key=opt.id / /el-select /el-form-item el-form-item el-button type=primary @click=subUserForm保存/el-button el-button @click=cancelUserForm取消/el-button /el-form-item /el-form /el-dialog/templatescript setup import onMounted, reactive, ref from vue; import ElMessage, ElMessageBox from element-plus; import userApi from @/api/user; import roleApi from @/api/role; //声明user列表集合数据 const userList = ref([]); //声明总记录数 const total = ref(0); //声明分页大小 const pageSize = ref(10); //定义函数发送请求加载用户列表 function queryUserList(pageNum) userApi .getUserList(pageNum, pageSize.value) .then((response) = userList.value = response.data.userList; total.value = response.data.total; ) .catch((error) = console.log(error); ); //加载调用函数 onMounted(function () queryUserList(1); ); //定义分页按钮回调函数 function handlerPageChange(pageNum) //调用分页查询函数 queryUserList(pageNum); //定义添加用户信息对话框状态 const dialogUserVisible = ref(false); // 表单引用 const userFormRef = ref(null); //声明表单数据 const userForm = reactive( uname: , phone: , age: , edu: , title: , rids: [], ); // 表单验证规则 const rules = uname: [ required: true, message: 请输入用户名, trigger: blur , min: 2, max: 20, message: 长度应在 2 到 20 个字符之间, trigger: blur, , ], phone: [ required: true, message: 请输入电话号码, trigger: blur , pattern: /^1[3-9]\\d9$/, message: 请输入正确的手机号码, trigger: blur, , ], age: [ required: true, message: 请输入年龄, trigger: blur , type: number, message: 年龄必须为数字, trigger: blur , type: number, min: 18, max: 70, message: 年龄必须在18到70之间, trigger: blur, , ], edu: [ required: true, message: 请输入学历, trigger: blur ], title: [ required: true, message: 请输入部门, trigger: blur ], rids: [ required: true, message: 请选择角色, trigger: change ], ; // 定义重置表单的函数 const resetUserForm = () = // 重置表单的验证状态 if (userFormRef.value) userFormRef.value.resetFields(); // 重置表单数据 Object.assign(userForm, id: undefined, uname: , phone: , age: , edu: , title: , rids: [], ); ; //声明角色的集合 const optRoles = ref([]); const openUserDialog = () = // 先重置表单数据 resetUserForm(); // 再打开对话框 dialogUserVisible.value = true; //发送ajax请求加载所有角色信息 userApi .loadAllRoles() .then((response) = optRoles.value = response.data; ) .catch((error) = console.log(error); ElMessage.error(加载角色信息失败); ); ; const subUserForm = () = if (!userFormRef.value) ElMessage.error(表单未正确加载，请重试); return; userFormRef.value.validate((valid) = if (!valid) return; const operation = userForm.id ? userApi.updateUser(userForm) : userApi.saveUser(userForm); operation .then((response) = if (response.data.code == 200) //关闭对话框 dialogUserVisible.value = false; // 重置表单数据 resetUserForm(); // 刷新用户列表 queryUserList(1); ElMessage(response.data.message); ) .catch((error) = console.log(error); ElMessage.error(操作失败，请重试); ); ); ; // 取消按钮处理函数 const cancelUserForm = () = dialogUserVisible.value = false; resetUserForm(); ; //打开对话框实现用户信息修改 const showUserDialog = (row) = dialogUserVisible.value = true; //将row赋值给userForm表单 userForm.age = row.age; userForm.edu = row.edu; userForm.id = row.id; userForm.uname = row.uname; userForm.phone = row.phone; userForm.title = row.title; //加载下拉列表框所有角色信息 userApi .loadAllRoles() .then((response) = optRoles.value = response.data; //根据用户id查询用户的角色id集合 //将查询到的角色id集合赋值给表单的rids属性 userApi.queryUserRids(row.id).then((response) = //将响应的角色id的集合赋值给表单的数组 userForm.rids = response.data; ); ) .catch((error) = console.log(error); ); ; //删除用户信息 const deleteUser = (row) = ElMessageBox.confirm(是否删除该用户?, 提示, confirmButtonText: 确定, cancelButtonText: 取消, type: warning, ) .then(() = userApi .deleteUser(row.id) .then((response) = if (response.data.code == 200) queryUserList(1); //刷新列表 ElMessage(response.data.message); ) .catch((error) = console.log(error); ); ) .catch(() = ElMessage( type: info, message: 已取消删除, ); ); ;/scriptstyle scoped/style 在主页注册页面 import ListAfterSale from @/views/UserManager.vue; // 导入 用户管理 视图组件//老师的方法，修改以下内容:const views = [ AddCustomer, ListCustomer, ListAfterSale, ListCustOrder, AddSellJh, , , ListSellJh, AddMenus, RolerManager, UserManager,];//我的方法，修改以下内容：const views = [ markRaw(AddCustomer), markRaw(ListCustomer), markRaw(ListAfterSale), markRaw(ListCustOrder), markRaw(AddSellJh), markRaw(AddSellJh), markRaw(AddSellJh), markRaw(ListSellJh), markRaw(AddMenus), markRaw(RolerManager), markRaw(UserManager),]; 2.用 Echarts 组件渲染图表 前端实现 安装 Echarts npm install --save echarts 添加测试页面 因为估计下一次要实现库存统计页面，所以这里添加 StockStatistics.vue 页面 template div style=display: flex; div ref=pieChartContainer style=width: 50%; height: 400px;/div div ref=barChartContainer style=width: 50%; height: 400px;/div /div/templatescript setup import * as echarts from echarts; import onMounted, ref from vue; // 员工地区分布数据 const empData = ref([ name: 北京, value: 100 , name: 上海, value: 120 , name: 天津, value: 130 , name: 重庆, value: 70 , name: 武汉, value: 90 , ]); // 模拟销售数据 const sellData = ref( xdata: [ 1月, 2月, 3月, 4月, 5月, 6月, 7月, 8月, 9月, 10月, 11月, 12月, ], ydata: Array.from( length: 12 , () = Math.floor(Math.random() * (10000 - 500 + 1)) + 500 ), ); // DOM容器引用 const pieChartContainer = ref(null); const barChartContainer = ref(null); // 渲染饼图 function renderPieChart() const myEcharts = echarts.init(pieChartContainer.value); const option = tooltip: trigger: item , legend: top: 5%, left: center , series: [ name: 员工地区分布, type: pie, radius: [40%, 70%], avoidLabelOverlap: false, itemStyle: borderRadius: 10, borderColor: #fff, borderWidth: 2 , label: show: false, position: center , emphasis: label: show: true, fontSize: 40, fontWeight: bold , labelLine: show: false , data: empData.value, , ], ; myEcharts.setOption(option); // 渲染柱状图 function renderBarChart() const myCharts = echarts.init(barChartContainer.value); const option = xAxis: type: category, data: sellData.value.xdata , yAxis: type: value , series: [ data: sellData.value.ydata, type: bar, showBackground: true, backgroundStyle: color: rgba(180, 180, 180, 0.2) , , ], ; myCharts.setOption(option); onMounted(() = renderPieChart(); renderBarChart(); );/script 在主页注册页面 import ListAfterSale from @/views/StockStatistics.vue; // 导入 库存管理 视图组件//老师的方法，修改以下内容:const views = [ AddCustomer, ListCustomer, ListAfterSale, ListCustOrder, AddSellJh, StockStatistics, , ListSellJh, AddMenus, RolerManager, UserManager,];//我的方法，修改以下内容：const views = [ markRaw(AddCustomer), markRaw(ListCustomer), markRaw(ListAfterSale), markRaw(ListCustOrder), markRaw(AddSellJh), markRaw(StockStatistics), markRaw(AddSellJh), markRaw(ListSellJh), markRaw(AddMenus), markRaw(RolerManager), markRaw(UserManager),]; Day11 1.实现商品类别管理页 后端递归构建树形 VO： 再次使用了递归 (toListTreeVo) 将从数据库查询到的平铺的商品分类列表 (List) 转换为前端 el-tree 需要的树形结构 (List)。这与之前菜单管理的实现类似，是对树形数据处理能力的巩固。 数据库实现 先在菜单中添加条目 INSERT INTO `t_menu` (`id`, `label`, `component`, `pid`, `sort_order`, `icon_name`) VALUES(15, 商品管理, 11, 0, 3, Goods),(16, 商品分类, 12, 15, 0, Grid),(17, 商品入库, 13, 15, 1, Download),(18, 商品出库, 14, 15, 2, Upload); 添加商品类目表 CREATE TABLE `t_category` ( `id` int NOT NULL AUTO_INCREMENT COMMENT ID (主键), -- 自增主键 `isbn` varchar(255) NOT NULL COMMENT ISBN 编号, -- ISBN 编号，唯一标识 `cate_name` varchar(255) DEFAULT NULL COMMENT 分类名称, -- 商品分类名称 `remark` varchar(255) DEFAULT NULL COMMENT 备注信息, -- 备注说明 `pid` int DEFAULT NULL COMMENT 父分类ID, -- 父分类ID，用于构建分类层级 PRIMARY KEY (`id`) -- 设置主键) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT=商品分类表; -- 表注释 给这个表插入一些数据 INSERT INTO `t_category` (`id`, `isbn`, `cate_name`, `remark`, `pid`) VALUES(1, ISBN001, 电子产品, 主要分类, 0),(2, ISBN002, 手机, 子分类, 1),(3, ISBN003, 笔记本电脑, 子分类, 1),(4, ISBN004, 服装, 主要分类, 0),(5, ISBN005, 男装, 子分类, 4),(6, ISBN006, 女装, 子分类, 4); 后端实现 在 idea 里用 mybatiesx 生成代码 CategoryService 添加服务接口 /*加载商品类目树*/ListTreeVo queryCategoryListService(); 实现接口 @Autowiredprivate CategoryMapper categoryMapper;@Overridepublic ListTreeVo queryCategoryListService() //查询数据库获得所有商品类目 ListCategory categrories = categoryMapper.selectList(null); return toListTreeVo(categrories,0);// 声明方法，递归遍历categories集合，将该集合转化为ListTreeVoprivate ListTreeVo toListTreeVo(ListCategory categories ,Integer id) ListTreeVo result = new ArrayList(); System.out.println(转换开始 - 当前父ID: + id + , 总记录数: + categories.size()); for(Category category : categories) System.out.println(处理节点: + category.getCateName() + , PID: + (category.getPid() != null ? category.getPid().toString() : null) + , 当前ID: + category.getId()); if(Objects.equals(category.getPid(), id)) // 使用Objects.equals()避免空指针异常 System.out.println(匹配到子节点: + category.getCateName() + , PID: + id); TreeVo treeVo = new TreeVo(); treeVo.setId(category.getId()); treeVo.setLabel(category.getCateName()); treeVo.setChildren(toListTreeVo(categories, category.getId())); result.add(treeVo); else System.out.println(未匹配节点: + category.getCateName() + , PID: + category.getPid() + , 需要: + id); System.out.println(转换结束 - 结果数量: + result.size() + , 父ID: + id); return result; 添加 CategoryController 代码 @RestController@CrossOriginpublic class CategoryController @Autowired private CategoryService categoryService; /*处理加载商品类目树请求*/ @GetMapping(/categoryList) public ListTreeVo categoryList() return categoryService.queryCategoryListService(); /*处理商品类目添加请求*/ @PostMapping(/saveCategory) public MapString,Object saveCategory(@RequestBody Category category) categoryService.save(category); return ResponseUtil.success(添加商品类别成功); /*处理商品分类回显的请求*/ @GetMapping(/loadCategory/id) public Category loadCategory(@PathVariable Integer id) return categoryService.getById(id); /*处理商品类目更新更新请求*/ @PostMapping(/updateCategory) public MapString,Object updateCategory(@RequestBody Category category) categoryService.updateById(category); return ResponseUtil.success(更新商品类别成功); /*处理商品类目删除请求*/ @GetMapping(/deleteCategory/id) public MapString,Object deleteCategory(@PathVariable Integer id) categoryService.removeById(id); return ResponseUtil.success(删除商品类别成功); 前端实现 前端树形交互与表单联动： 使用 el-tree 展示商品分类，并允许用户点击节点进行选中。 将选中的树节点作为新增分类的父节点 (categoryForm.pid = node.id)。 在修改分类时，先根据 ID 从后端加载分类信息回显到表单。 删除分类时，增加了判断，如果分类下有子分类则不允许删除。 添加后端接口定义 import request from ./config;// 商品分类管理相关接口export const categoryApi = // 获取分类树 getCategoryTree() return request.get(/categoryList); , // 获取单个分类信息 getCategoryById(id) return request.get(`/loadCategory/$id`); , // 保存分类 saveCategory(data) return request.post(/saveCategory, data); , // 更新分类 updateCategory(data) return request.post(/updateCategory, data); , // 删除分类 deleteCategory(id) return request.get(`/deleteCategory/$id`); ,; 实现页面代码 template h2商品类目管理/h2 div style=text-align: left h4选择分类节点进行管理/h4 !-- tree控件 -- el-tree :props=config :data=categoryList default-expand-all node-key=id ref=treeRef :highlight-current=true :expand-on-click-node=false @node-click=handleClickNode template #default= node, data span class=custom-tree-node span node.label /span span class=operation-buttons el-button type=primary size=small link @click.stop=showCategory(node, data) 修改 /el-button el-button type=danger size=small link @click.stop=handleDelete(node, data) 删除 /el-button /span /span /template /el-tree /div hr / !-- 添加商品类目表单 -- el-form :model=categoryForm label-width=120px class=category-form el-form-item label=分类编号 el-input v-model=categoryForm.isbn style=width: 80% placeholder=请输入分类编号 / /el-form-item el-form-item label=分类名称 el-input v-model=categoryForm.cateName style=width: 80% placeholder=请输入分类名称 / /el-form-item el-form-item label=分类描述 el-input v-model=categoryForm.remark style=width: 80% placeholder=请输入分类描述 / /el-form-item el-form-item el-button type=primary @click=saveCategoryForm保存/el-button el-button @click=resetForm重置表单/el-button /el-form-item /el-form/templatescript setup import onMounted, reactive, ref from vue; import ElMessage, ElMessageBox from element-plus; import categoryApi from @/api/category; // --- 树配置 --- const config = id: id, label: label, children: children, ; const treeRef = ref(null); const categoryList = ref([]); // --- 数据加载 --- function queryCategoryTree() categoryApi .getCategoryTree() .then((response) = categoryList.value = response.data; ) .catch((error) = console.error(加载分类树失败:, error); ElMessage.error(加载分类树失败，请稍后重试); ); onMounted(() = queryCategoryTree(); ); // --- 表单处理 --- const categoryForm = reactive( id: 0, isbn: , cateName: , remark: , pid: 0, // 默认为0，表示一级节点 ); let pnode = null; // 记录当前选中的节点对象 // --- 节点操作函数 --- function handleClickNode(node) pnode = node; // 如果是新增模式，设置父节点 if (categoryForm.id === 0) categoryForm.pid = node.id; function resetForm() // 重置表单数据 categoryForm.id = 0; categoryForm.isbn = ; categoryForm.cateName = ; categoryForm.remark = ; categoryForm.pid = 0; // 重置为0，表示添加一级节点 // 重置树选择状态 if (treeRef.value) treeRef.value.setCurrentKey(null); pnode = null; // --- 保存操作 --- function saveCategoryForm() if (!categoryForm.cateName.trim()) ElMessage.warning(分类名称不能为空); return; if (categoryForm.id === 0) // 新增模式 // pid为0时表示添加一级节点，否则为选中节点的子节点 if (pnode) categoryForm.pid = pnode.id; const apiCall = categoryForm.id === 0 ? categoryApi.saveCategory(categoryForm) : categoryApi.updateCategory(categoryForm); apiCall .then((response) = if (response.data.code === 200) ElMessage.success(response.data.message); queryCategoryTree(); resetForm(); else ElMessage.error(response.data.message); ) .catch((error) = console.error(保存失败:, error); ElMessage.error(保存失败，请稍后重试); ); // --- 修改操作 --- function showCategory(node, data) categoryApi .getCategoryById(data.id) .then((response) = Object.assign(categoryForm, response.data); pnode = node; ) .catch((error) = console.error(加载分类信息失败:, error); ElMessage.error(加载分类信息失败，请稍后重试); ); // --- 删除操作 --- function handleDelete(node, data) if (data.children data.children.length 0) ElMessage.warning(该分类下还有子分类，不能删除); return; ElMessageBox.confirm(确定要删除该分类吗？, 警告, confirmButtonText: 确定, cancelButtonText: 取消, type: warning, ) .then(() = categoryApi .deleteCategory(data.id) .then((response) = if (response.data.code === 200) ElMessage.success(response.data.message); queryCategoryTree(); resetForm(); else ElMessage.error(response.data.message); ) .catch((error) = console.error(删除失败:, error); ElMessage.error(删除失败，请稍后重试); ); ) .catch(() = ElMessage.info(已取消删除); ); /scriptstyle scoped .custom-tree-node flex: 1; display: flex; align-items: center; justify-content: space-between; font-size: 14px; padding-right: 8px; /style 在主页注册页面 之前写过很多次，这里不重复 Day12-14 实现商品信息管理 数据库实现 为商品信息引入了多个关联表（品牌 t_brand, 产地 t_place, 仓库 t_store, 供货商 t_supply, 规格单位 t_unit）。这些表作为“字典数据”或“基础数据”，用于商品信息中的下拉选择。 添加 品牌表，产地表，仓库表，供货商表，规格单位表 t_brand, t_place, t_store, t_supply, t_unit CREATE TABLE `t_brand` ( `brand_id` int NOT NULL AUTO_INCREMENT COMMENT 品牌ID, `brand_name` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 品牌名称, `brand_leter` char(1) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 品牌首字母, `brand_desc` varchar(1000) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 品牌描述, PRIMARY KEY (`brand_id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 5 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = 品牌表 ROW_FORMAT = Dynamic;INSERT INTO `t_brand` VALUES (1, 东东果蔬, D, 别买了，不能吃...);INSERT INTO `t_brand` VALUES (2, 美的, M, 还可以);INSERT INTO `t_brand` VALUES (3, 海尔, H, 我家洗衣机就是海尔啊);INSERT INTO `t_brand` VALUES (4, 华为, H, 中华有为);CREATE TABLE `t_place` ( `place_id` int NOT NULL AUTO_INCREMENT COMMENT 产地ID, `place_name` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 产地名称, `place_num` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 产地编号, `introduce` varchar(300) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 产地介绍, `is_delete` char(1) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT 0 COMMENT 逻辑删除标记(0:可用 1:不可用), PRIMARY KEY (`place_id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 8 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = 产地表 ROW_FORMAT = Dynamic;INSERT INTO `t_place` VALUES (1, 湖南, hunan, 湖南挺好的啊, 0);INSERT INTO `t_place` VALUES (2, 湖北, hubei, 湖北没有湖南好, 0);INSERT INTO `t_place` VALUES (3, 陕西, shanxi, 还是陕西更好, 0);INSERT INTO `t_place` VALUES (4, 浙江, zhejiang, 好地方, 0);INSERT INTO `t_place` VALUES (5, 山东, shandong, 很好, 0);INSERT INTO `t_place` VALUES (6, 广东, guangdong, 非常好, 0);INSERT INTO `t_place` VALUES (7, 河北, hebei, 知道有个叫唐山的地方, 0);CREATE TABLE `t_store` ( `store_id` int NOT NULL AUTO_INCREMENT COMMENT 仓库ID, `store_name` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 仓库名称, `store_num` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 仓库编号, `store_address` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 仓库地址, `concat` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 联系人, `phone` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 联系电话, PRIMARY KEY (`store_id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 5 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = 仓库表 ROW_FORMAT = Dynamic;INSERT INTO `t_store` VALUES (1, 西安仓库, xa1, 西安市雁塔区, 张三, 13829086629);INSERT INTO `t_store` VALUES (2, 北京仓库, bj2, 北京市朝阳区 , 王麻子, 15229267291);INSERT INTO `t_store` VALUES (3, 上海仓库, sh3, 上海市浦东区, 李四, 18092647320);CREATE TABLE `t_supply` ( `supply_id` int NOT NULL AUTO_INCREMENT COMMENT 供应商ID, `supply_num` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 供应商编号, `supply_name` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 供应商名称, `supply_introduce` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT 供应商介绍, `concat` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 联系人, `phone` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 联系电话, `address` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 供应商地址, `is_delete` char(1) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT 0 COMMENT 逻辑删除标记(0:可用 1:不可用), PRIMARY KEY (`supply_id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = 供货商表 ROW_FORMAT = Dynamic;INSERT INTO `t_supply` VALUES (1, zjsh, 浙江三禾竹木有限公司, 贷款是否会为加快和规范健康环境如何根据, 任伟, 15287653921, 浙江省丽水市, 0);INSERT INTO `t_supply` VALUES (2, lqlo, 龙泉绿欧食品有限公司, NULL, 张三, 18134532830, 浙江省龙泉市, 0);INSERT INTO `t_supply` VALUES (3, dhgy, 帝豪供应链公司, NULL, 李四, 17493976543, 陕西省西安市, 0);INSERT INTO `t_supply` VALUES (4, haier, 海尔集团, 海尔智家为用户提供衣、食、住、娱的智慧全场景解决方案，全面提升用户生活品质，以“云”体验、全链路服务、个性化智慧终端，实现交互、体验、销售、服务于一体的全流程生态平台。, 周云杰, 4006999511, 山东省青岛市, 0);INSERT INTO `t_supply` VALUES (5, midea, 美的集团股份有限公司, 科技尽善，生活尽美”– 美的集团秉承用科技创造美好生活的经营理念，如今已成为一家集智能家居事业群、机电事业群、暖通与楼宇事业部、机器人及自动化事业部、数字化创新业务五大板块为一体的全球化科技集团，产品及服务惠及全球200多个国家和地区约4亿用户。形成美的、小天鹅、东芝、华凌、布谷、COLMO、Clivet、Eureka、库卡、GMCC、威灵在内的多品牌组合。, 方洪波, 075726338788, 广东省佛山市, 0);CREATE TABLE `t_unit` ( `unit_id` int NOT NULL AUTO_INCREMENT COMMENT 单位ID, `unit_name` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 单位名称, `unit_desc` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 单位描述, PRIMARY KEY (`unit_id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 8 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = 规格单位表 ROW_FORMAT = Dynamic;INSERT INTO `t_unit` VALUES (1, 箱/件, 箱/件);INSERT INTO `t_unit` VALUES (2, 个, 个);INSERT INTO `t_unit` VALUES (3, 公斤, 公斤);INSERT INTO `t_unit` VALUES (4, 只, 只);INSERT INTO `t_unit` VALUES (5, 克, 克);INSERT INTO `t_unit` VALUES (6, 台, 台); 后端实现 实现文件上传 外部教程：Spring 基础知识（19）- Spring MVC (九) | 文件上传、 文件下载 添加了 commons-io 和 commons-fileupload 依赖。 创建了 FileController，使用 MultipartFile 接收前端上传的文件。 实现了文件保存逻辑：生成唯一文件名 (UUID + 后缀)，创建保存目录，使用 FileUtils.copyInputStreamToFile 将文件保存到服务器指定位置。 返回文件的可访问 URL 给前端。 通过 WebMvcConfigurer 配置了静态资源处理器 (addResourceHandlers)，使得上传到服务器本地目录的图片可以通过 URL 被外部访问。 添加依赖 !-- 文件上传 --dependency groupIdcommons-io/groupId artifactIdcommons-io/artifactId version2.19.0/version/dependency!-- 文件上传 --dependency groupIdcommons-fileupload/groupId artifactIdcommons-fileupload/artifactId version1.5/version/dependency 添加 FileController，使后端能接收前端的信息并存储 @RestController@CrossOriginpublic class FileController private static final String UPLOAD_DIR = uploads/imgs/; @PostMapping(/uploadImg) public String uploadImg(MultipartFile file) // 检查文件是否为空 if (file == null || file.isEmpty()) return 文件为空; // 获取原始文件名 String originalName = file.getOriginalFilename(); if (originalName == null) return 文件名无效; // 生成新文件名 String uuid = UUID.randomUUID().toString(); String ext = originalName.substring(originalName.lastIndexOf(.)); String newName = uuid + ext; System.out.println(新文件名: + newName); // 创建保存目录 File dir = new File(UPLOAD_DIR); if (!dir.exists()) dir.mkdirs(); // 创建目标文件 File target = new File(dir, newName); try // 保存文件 FileUtils.copyInputStreamToFile(file.getInputStream(), target); catch (IOException e) e.printStackTrace(); return 上传失败: + e.getMessage(); // 返回访问 URL return http://localhost:8080/uploads/imgs/ + newName; 添加 WebConfig，以配置 springboot，使后端能正常访问图片 import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class WebConfig implements WebMvcConfigurer @Override public void addResourceHandlers(ResourceHandlerRegistry registry) registry.addResourceHandler(/uploads/**) .addResourceLocations(file:./uploads/); 实现前端字典接口 为上述每个关联表都创建了 Controller，提供了查询列表的接口（通常只查询 ID 和名称字段），专门用于前端的下拉框数据填充。这是典型的“数据字典”服务实现方式。 实现类似于字典的功能，方便前端展示下拉列表 以下代码及其雷同，都是去查各个表的 id 和对应名称 2. 创建 SupplyController @RestController@CrossOriginpublic class SupplyController @Autowired private SupplyService supplyService; /*加载供应商下拉列表框数据*/ @GetMapping(/supplyList) public ListSupply querySupplyList() QueryWrapperSupply wrapper=new QueryWrapper(); wrapper.select(supply_id,supply_name); ListSupply list = supplyService.list(wrapper); return list; 3. 创建 PlaceController @RestController@CrossOriginpublic class PlaceController @Autowired private PlaceService placeService; /*处理加载商品产地列表的请求*/ @GetMapping(/placeList) public ListPlace queryPlaceList() QueryWrapperPlace wrapper=new QueryWrapper(); wrapper.select(place_id,place_name); return placeService.list(wrapper); 4. 创建 UnitController @RestController@CrossOriginpublic class UnitController @Autowired private UnitService unitService; /*处理加载商品单位的列表*/ @GetMapping(/unitList) public ListUnit queryUnitList() QueryWrapperUnit wrapper=new QueryWrapper(); wrapper.select(unit_id,unit_name); return unitService.list(wrapper); 5.创建 BrandController @RestController@CrossOriginpublic class BrandController @Autowired private BrandService brandService; @GetMapping(/brandList) public ListBrand queryBrandList() QueryWrapperBrand wrapper=new QueryWrapper(); wrapper.select(brand_id,brand_name); return brandService.list(wrapper); 6.创建 StoreController @RestController@CrossOriginpublic class StoreController @Autowired private StoreService storeService; /*处理加载仓库选项的请求*/ @GetMapping(/storeList) public ListStore storeList() QueryWrapperStore wrapper=new QueryWrapper(); wrapper.select(store_id,store_name); return storeService.list(wrapper); 实现对 item 的增删改查 修改 Item 实体类 Item POJO 中添加了大量 @TableField(exist = false) 的扩展属性（如 brandName, placeName 等），用于在后端进行多表 INNER JOIN 查询后，将关联表的名称信息直接封装到 Item 对象中，方便前端直接展示。 添加注解，使前端能正常回显时间 /** * 生产日期 */@JsonFormat(pattern = yyyy-MM-dd)private Date itemDate;/** * 到期日期 */@JsonFormat(pattern = yyyy-MM-dd)private Date endDate; 添加字段，使其能回显字段对应名称 //扩展属性封装名称@TableField(exist = false)private String brandName;@TableField(exist = false)private String placeName;@TableField(exist = false)private String supplyName;@TableField(exist = false)private String unitName;@TableField(exist = false)private String cateName;@TableField(exist = false)private String storeName; 新建 ItemCond 类 @Datapublic class ItemCond private String itemNum; private String itemName; private Integer statue; private Integer pageNum=1; private Integer pageSize=3; 添加 mapper 方法 /*实现商品信息分页查询*/ListItem queryItemListMapper(ItemCond itemCond); 在 mapper.xml 里添加对应 sql 使用复杂的多表 INNER JOIN 和动态 及 条件（如按商品编号、名称、状态模糊查询），这比之前的动态查询更为复杂。 select id=queryItemListMapper resultType=com.example.demo.pojo.Item parameterType=com.example.demo.vo.ItemCond select item.*,type.cate_name,brand.brand_name,store.store_name, supply.supply_name,place.place_name,unit.unit_name from t_item item inner join t_categrory type on type.id=item.type_id inner join t_brand brand on brand.brand_id=item.brand_id inner join t_store store on store.store_id=item.store_id inner join t_supply supply on supply.supply_id=item.supply_id inner join t_place place on place.place_id=item.place_id inner join t_unit unit on unit.unit_id=item.unit_id where if test=itemNum!=null and itemNum!= item.item_num like concat(%, #itemNum, %) /if if test=itemName!=null and itemName!= and item.item_name like concat(%, #itemName, %) /if if test=statue!=null and item.statue=#statue /if /where/select 添加 service 接口 /*商品分页查询*/MapString,Object queryItemListService(ItemCond itemCond); 添加对应实现 @Override/* public MapString, Object queryItemListService(Integer pageNum, Integer pageSize) */public MapString, Object queryItemListService(ItemCond itemCond) /*PageObject page = PageHelper.startPage(pageNum, pageSize);*/ PageObject page = PageHelper.startPage(itemCond.getPageNum(), itemCond.getPageSize()); //查询数据库 /*ListItem items = itemMapper.queryItemListMapper();*/ ListItem items = itemMapper.queryItemListMapper(itemCond); MapString, Object result=new HashMap(); result.put(items,items); result.put(total,page.getTotal()); return result; 添加 CodeUtils，方便给前端生成产品编码 public class CodeUtils /*产生商品的编码*/ public static String toItemCode() SimpleDateFormat simpleDateFormat = new SimpleDateFormat(yyyyMMddHHmmssSSS); return simpleDateFormat.format(new Date()); public static void main(String[] args) String code = toItemCode(); System.out.println(code); 创建 ItemController，实现增删改查接口 @RestController@CrossOriginpublic class itemController @Autowired private ItemService itemService; /*处理产生商品编码的请求*/ @GetMapping(/getCode) public String toItemCode() return CodeUtils.toItemCode(); /*添加商品信息*/ @PostMapping(/saveItem) public MapString, Object saveItem(@RequestBody Item item) itemService.save(item); return ResponseUtil.success(添加商品成功); /*处理商品信息分页查询请求*/ @PostMapping(/itemList) public MapString,Object itemList(@RequestBody ItemCond itemCond) return itemService.queryItemListService(itemCond); /*删除商品信息*/ @DeleteMapping(/deleteItem/id) public MapString, Object deleteItem(@PathVariable Integer id) boolean removed = itemService.removeById(id); if (removed) return ResponseUtil.success(删除成功); else return ResponseUtil.error(400, 删除失败); /*修改商品信息*/ @PutMapping(/updateItem) public MapString, Object updateItem(@RequestBody Item item) boolean updated = itemService.updateById(item); if (updated) return ResponseUtil.success(修改成功); else return ResponseUtil.error(400, 修改失败); /*处理商量的下架请求*/ @GetMapping(/downItem/id) public MapString, Object downItem(@PathVariable Integer id) Item item = new Item(); item.setId(id); item.setStatue(1); // 1表示已下架状态 boolean updated = itemService.updateById(item); if (updated) return ResponseUtil.success(商品下架成功); else return ResponseUtil.error(400, 操作失败，请重试); /*处理商品上架请求*/ @GetMapping(/upItem/id) public MapString, Object upItem(@PathVariable Integer id) Item item = new Item(); item.setId(id); item.setStatue(0); // 0表示已上架状态 boolean updated = itemService.updateById(item); if (updated) return ResponseUtil.success(商品上架成功); else return ResponseUtil.error(400, 操作失败，请重试); 实现采购功能 创建采购表 CREATE TABLE `t_buy_list` ( `buy_id` int NOT NULL AUTO_INCREMENT COMMENT 采购单ID, `product_id` int DEFAULT NULL COMMENT 产品ID，关联产品表, `store_id` int DEFAULT NULL COMMENT 仓库ID，关联仓库表, `buy_num` int DEFAULT NULL COMMENT 计划采购数量, `fact_buy_num` int DEFAULT NULL COMMENT 实际采购数量, `buy_time` datetime DEFAULT NULL COMMENT 采购时间, `supply_id` int DEFAULT NULL COMMENT 供应商ID，关联供应商表, `place_id` int DEFAULT NULL COMMENT 采购地点ID，关联地点表, `buy_user` varchar(20) DEFAULT NULL COMMENT 采购人姓名, `phone` varchar(20) DEFAULT NULL COMMENT 采购人联系电话, `is_in` char(1) DEFAULT NULL COMMENT 是否入库：0-否，1-是, PRIMARY KEY (`buy_id`)) ENGINE=InnoDB AUTO_INCREMENT=49 DEFAULT CHARSET=utf8mb3 COMMENT=采购单表，记录商品采购信息; 用 mybatiesx 生成对应层级代码 BuyListService 添加方法 /*处理采购单需要自动带入的数据*/public MapString,Object queryAutoDataBuyService(Integer id); 在 impl 里实现方法 @Servicepublic class BuyListServiceImpl extends ServiceImplBuyListMapper, BuyList implements BuyListService @Autowired private ItemMapper itemMapper; @Autowired private StoreMapper storeMapper; @Autowired private SupplyMapper supplyMapper; @Autowired private PlaceMapper placeMapper; @Override public MapString, Object queryAutoDataBuyService(Integer id) MapString, Object result=new HashMap(); //查询商品信息 Item item = itemMapper.selectById(id); result.put(id,item.getId()); result.put(itemName,item.getItemName()); //查询仓库信息 Integer storeId = item.getStoreId(); Store store = storeMapper.selectById(storeId); result.put(storeId,store.getStoreId()); result.put(storeName,store.getStoreName()); //查询供应商信息 Integer supplyId = item.getSupplyId(); Supply supply = supplyMapper.selectById(supplyId); result.put(supplyId,supply.getSupplyId()); result.put(supplyName,supply.getSupplyName()); //查询产地信息 Integer placeId = item.getPlaceId(); Place place = placeMapper.selectById(placeId); result.put(placeId,place.getPlaceId()); result.put(placeName,place.getPlaceName()); return result; 添加 BuyListController 控制层代码 @RestController@CrossOriginpublic class BuyListController @Autowired private BuyListService buyListService; /*处理采购信息需要自动带入数据的请求*/ @GetMapping(/buyAutoInfo/id) public MapString,Object buyAutoInfo(@PathVariable Integer id) return buyListService.queryAutoDataBuyService(id); /*保存采购信息*/ @PostMapping(/saveBuy) public MapString,Object saveBuy(@RequestBody BuyList buyList) buyList.setBuyTime(new Date()); buyList.setIsIn(0); buyList.setFactBuyNum(0); return buyListService.save(buyList)? ResponseUtil.success(保存成功):ResponseUtil.error(保存失败); 前端实现 实现商品信息页面 ItemManager.vue 中的添加/修改商品表单包含了大量的输入项，包括多个下拉选择框（品牌、门店、供应商、产地、单位等），这些下拉框的数据都是通过调用后端提供的字典接口动态加载的 (loadAllData 使用 Promise.all 并行加载)。 使用 Element Plus 的 el-upload 组件实现图片上传界面 (list-type=“picture-card”)。 配置了 action (后端上传接口 URL)、:on-success (上传成功回调，将返回的图片 URL 保存到表单数据中)、:on-remove (移除图片回调)、:on-preview (图片预览)。 template h2商品信息/h2 div style=display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; el-button type=primary @click=openItemDialog添加商品/el-button el-form :inline=true :model=searchForm class=search-form ref=searchFormRef el-form-item label=商品编号 prop=itemNum el-input v-model=searchForm.itemNum placeholder=请输入商品编号 clearable / /el-form-item el-form-item label=商品名称 prop=itemName el-input v-model=searchForm.itemName placeholder=请输入商品名称 clearable / /el-form-item el-form-item label=状态 prop=statue el-select v-model=searchForm.statue placeholder=请选择 clearable style=width: 100px; el-option label=上架 :value=0 / el-option label=下架 :value=1 / /el-select /el-form-item el-form-item el-button type=primary @click=handleSearch查询/el-button el-button @click=resetSearchForm重置/el-button /el-form-item /el-form /div !-- 商品列表表格 -- el-table :data=itemList row-key=id stripe style=width: 100% el-table-column type=expand template #default= row el-descriptions :column=2 border style=margin: 10px 20px; el-descriptions-item label=商品图片 template v-if=row.imgs Array.isArray(row.imgs) row.imgs.length 0 div class=image-preview el-image v-for=(img, index) in row.imgs :key=index :src=img :preview-src-list=row.imgs :initial-index=index :preview-teleported=true :z-index=3000 class=table-image fit=cover style=width: 60px; height: 60px; margin-right: 5px; border-radius: 4px; @error=() = handleImageError(index) template #error div style=width: 60px; height: 60px; display: flex; align-items: center; justify-content: center; background: #f5f7fa; color: #909399; font-size: 12px; 加载失败br /或无图片 /div /template /el-image /div /template span v-else无图片/span /el-descriptions-item el-descriptions-item label=商品描述 row.itemDesc /el-descriptions-item el-descriptions-item label=进货价格 row.price /el-descriptions-item el-descriptions-item label=会员价格 row.vipPrice /el-descriptions-item el-descriptions-item label=供应商 row.supplyName /el-descriptions-item el-descriptions-item label=产地 row.placeName /el-descriptions-item el-descriptions-item label=单位 row.unitName /el-descriptions-item el-descriptions-item label=所属仓库 row.storeName /el-descriptions-item el-descriptions-item label=生产日期 row.itemDate /el-descriptions-item el-descriptions-item label=到期日期 row.endDate /el-descriptions-item el-descriptions-item label=促销标题 row.hotTitle /el-descriptions-item el-descriptions-item label=制造商 row.facturer /el-descriptions-item el-descriptions-item label=创建者 row.createBy /el-descriptions-item /el-descriptions /template /el-table-column el-table-column label=商品编号 prop=itemNum / el-table-column label=商品名称 prop=itemName / el-table-column label=商品类型 prop=cateName / el-table-column label=品牌 prop=brandName / el-table-column label=库存 prop=store width=80 / el-table-column label=销售价格 prop=sellPrice / el-table-column label=状态 prop=statue width=80 template #default= row el-tag :type=row.statue === 0 ? success : danger row.statue === 0 ? 上架 : 下架 /el-tag /template /el-table-column el-table-column fixed=right label=操作 width=180 template #default= row el-button link size=small type=primary @click=handleDeleteItem(row.id) 删除/el-button el-button link size=small type=primary @click=openUpdateDialog(row) 修改/el-button el-button link size=small type=primary @click=openPurchaseDialog(row) 采购/el-button el-button v-if=row.statue === 1 link size=small type=success @click=handleUpItem(row.id) 上架/el-button el-button v-if=row.statue === 0 link size=small type=warning @click=handleDownItem(row.id) 下架/el-button /template /el-table-column /el-table !-- 分页器 -- el-pagination :page-size=10 :pager-count=5 :total=total background class=mt-4 layout=prev, pager, next size=small @current-change=handlePageChange / !-- 添加商品对话框 -- el-dialog v-model=dialogItemVisible :width=dialogWidth title=添加商品 div style=margin-bottom: 20px; span商品图片:/span el-upload :action=uploadImageUrl :auto-upload=true :file-list=fileList :on-preview=handlePictureCardPreview :on-remove=handleRemove :on-success=handleAvatarSuccess list-type=picture-card method=post preview-teleported el-icon Plus / /el-icon /el-upload /div el-form ref=itemFormRef :model=itemForm :rules=itemRules label-width=120px el-row :gutter=20 el-col :md=8 :sm=12 :xs=24 el-form-item label=商品编号 prop=itemNum el-input v-model=itemForm.itemNum readonly / /el-form-item /el-col el-col :md=8 :sm=12 :xs=24 el-form-item label=商品名称 prop=itemName el-input v-model=itemForm.itemName / /el-form-item /el-col el-col :md=8 :sm=12 :xs=24 el-form-item label=商品类型 prop=typeId el-input v-model=selectedTypeName disabled placeholder=点击选择商品类型 / el-button size=small style=margin-left: 10px; type=primary @click=openTypeDialog 选择/el-button /el-form-item /el-col el-col :md=8 :sm=12 :xs=24 el-form-item label=库存数量 prop=store el-input v-model.number=itemForm.store type=number / /el-form-item /el-col el-col :md=8 :sm=12 :xs=24 el-form-item label=品牌 prop=brandId el-select v-model=itemForm.brandId placeholder=请选择品牌 el-option v-for=item in brandList :key=item.brandId :label=item.brandName :value=item.brandId / /el-select /el-form-item /el-col el-col :md=8 :sm=12 :xs=24 el-form-item label=门店 prop=storeId el-select v-model=itemForm.storeId placeholder=请选择门店 el-option v-for=item in storeList :key=item.storeId :label=item.storeName :value=item.storeId / /el-select /el-form-item /el-col el-col :md=8 :sm=12 :xs=24 el-form-item label=供应商 prop=supplyId el-select v-model=itemForm.supplyId placeholder=请选择供应商 el-option v-for=item in supplyList :key=item.supplyId :label=item.supplyName :value=item.supplyId / /el-select /el-form-item /el-col el-col :md=8 :sm=12 :xs=24 el-form-item label=产地 prop=placeId el-select v-model=itemForm.placeId placeholder=请选择产地 el-option v-for=item in placeList :key=item.placeId :label=item.placeName :value=item.placeId / /el-select /el-form-item /el-col el-col :md=8 :sm=12 :xs=24 el-form-item label=单位 prop=unitId el-select v-model=itemForm.unitId placeholder=请选择单位 el-option v-for=item in unitList :key=item.unitId :label=item.unitName :value=item.unitId / /el-select /el-form-item /el-col el-col :md=8 :sm=12 :xs=24 el-form-item label=进货价格 prop=price el-input v-model.number=itemForm.price type=number / /el-form-item /el-col el-col :md=8 :sm=12 :xs=24 el-form-item label=销售价格 prop=sellPrice el-input v-model.number=itemForm.sellPrice type=number / /el-form-item /el-col el-col :md=8 :sm=12 :xs=24 el-form-item label=会员价格 prop=vipPrice el-input v-model.number=itemForm.vipPrice type=number / /el-form-item /el-col el-col :md=24 :sm=24 :xs=24 el-form-item label=商品描述 prop=itemDesc el-input v-model=itemForm.itemDesc :rows=3 type=textarea / /el-form-item /el-col el-col :md=8 :sm=12 :xs=24 el-form-item label=生产日期 prop=itemDate el-date-picker v-model=itemForm.itemDate placeholder=选择生产日期 type=date / /el-form-item /el-col el-col :md=8 :sm=12 :xs=24 el-form-item label=到期日期 prop=endDate el-date-picker v-model=itemForm.endDate placeholder=选择到期日期 type=date / /el-form-item /el-col el-col :md=8 :sm=12 :xs=24 el-form-item label=促销标题 prop=hotTitle el-input v-model=itemForm.hotTitle / /el-form-item /el-col el-col :md=8 :sm=12 :xs=24 el-form-item label=制造商 prop=facturer el-input v-model=itemForm.facturer / /el-form-item /el-col el-col :md=8 :sm=12 :xs=24 el-form-item label=商品状态 prop=statue el-select v-model=itemForm.statue placeholder=请选择状态 el-option :value=0 label=上架 / el-option :value=1 label=下架 / /el-select /el-form-item /el-col el-col :md=8 :sm=12 :xs=24 el-form-item label=创建者 prop=createBy el-input v-model=itemForm.createBy / /el-form-item /el-col /el-row /el-form template #footer el-button @click=dialogItemVisible = false取消/el-button el-button type=primary @click=submitItem保存/el-button /template /el-dialog !-- 商品类型选择对话框 -- el-dialog v-model=dialogTypeVisible :width=dialogWidth title=选择商品类型 el-tree ref=typeTreeRef :data=typeList :expand-on-click-node=false :highlight-current=true :props=typeTreeConfig default-expand-all node-key=id @node-click=handleTypeNodeClick template #default= node span node.label /span /template /el-tree template #footer el-button @click=dialogTypeVisible = false取消/el-button el-button type=primary @click=confirmTypeSelection确认/el-button /template /el-dialog !-- 采购对话框 -- el-dialog v-model=buyDialog title=商品采购 :width=dialogWidth el-form :model=buyForm label-width=120px ref=buyFormRef el-form-item label=商品名称 el-input v-model=buyForm.itemName disabled / /el-form-item el-form-item label=门店 el-input v-model=buyForm.storeName disabled / /el-form-item el-form-item label=供应商 el-input v-model=buyForm.supplyName disabled / /el-form-item el-form-item label=产地 el-input v-model=buyForm.placeName disabled / /el-form-item el-form-item label=采购数量 prop=buyNum el-input v-model=buyForm.buyNum type=number / /el-form-item el-form-item label=采购人 prop=buyUser el-input v-model=buyForm.buyUser / /el-form-item el-form-item label=联系电话 prop=phone el-input v-model=buyForm.phone / /el-form-item /el-form template #footer el-button @click=buyDialog = false取消/el-button el-button type=primary @click=submitPurchase确认采购/el-button /template /el-dialog !-- 图片预览组件 -- el-image-viewer v-if=dialogVisible :hide-on-click-modal=false :initial-index=0 :teleported=true :url-list=[dialogImageUrl] :z-index=3000 :zoom-rate=1.2 @close=dialogVisible = false //templatescript setup import computed, nextTick, onMounted, reactive, ref from vue; import Plus from @element-plus/icons-vue; import ElMessage, ElMessageBox from element-plus; import categoryApi from @/api/category; import itemApi, uploadImageUrl from @/api/item; // 处理图片加载错误 function handleImageError(index) console.warn(`图片加载失败: $index`); // 对话框状态和图片上传相关 const dialogItemVisible = ref(false); const dialogTypeVisible = ref(false); const dialogVisible = ref(false); const dialogImageUrl = ref(); const itemFormRef = ref(null); const typeTreeRef = ref(null); const searchFormRef = ref(null); const fileList = ref([]); // 采购表单数据 const buyForm = reactive( productId: , storeId: , supplyId: , placeId: , itemName: , storeName: , supplyName: , placeName: , buyNum: , buyUser: , phone: , ); // 采购对话框状态 const buyDialog = ref(false); const buyFormRef = ref(null); // 列表数据 const itemList = ref([]); const total = ref(0); // 响应式对话框宽度 const dialogWidth = computed(() = return window.innerWidth 768 ? 90% : window.innerWidth 1024 ? 70% : 60%; ); // 树形结构配置 const typeTreeConfig = id: id, label: label, children: children, ; // 查询表单数据 const searchForm = reactive( itemNum: , itemName: , statue: null, ); // 商品表单数据 const initialItemFormState = itemNum: , itemName: , typeId: null, store: 0, brandId: null, storeId: null, supplyId: null, placeId: null, unitId: null, price: 0, sellPrice: 0, vipPrice: 0, itemDesc: , itemDate: null, endDate: null, hotTitle: , facturer: , statue: 1, imgs: [], createBy: , id: null, ; const itemForm = reactive( ...initialItemFormState ); // 显示选中的类型名称 const selectedTypeName = ref(); // 表单验证规则 const itemRules = itemNum: [ required: true, message: 请输入商品编号, trigger: blur ], itemName: [ required: true, message: 请输入商品名称, trigger: blur ], typeId: [ required: true, message: 请选择商品类型, trigger: change ], store: [ required: true, message: 请输入库存数量, trigger: blur ], brandId: [ required: true, message: 请选择品牌, trigger: change ], storeId: [ required: true, message: 请选择门店, trigger: change ], supplyId: [ required: true, message: 请选择供应商, trigger: change ], placeId: [ required: true, message: 请选择产地, trigger: change ], unitId: [ required: true, message: 请选择单位, trigger: change ], price: [ required: true, message: 请输入进货价格, trigger: blur ], sellPrice: [ required: true, message: 请输入销售价格, trigger: blur ], vipPrice: [ required: true, message: 请输入会员价格, trigger: blur ], itemDate: [ required: true, message: 请选择生产日期, trigger: change , ], endDate: [ required: true, message: 请选择到期日期, trigger: change ], statue: [ required: true, message: 请选择商品状态, trigger: change ], ; // 列表数据 const typeList = ref([]), supplyList = ref([]), placeList = ref([]), unitList = ref([]), brandList = ref([]), storeList = ref([]); // 重置与商品表单相关的状态（如选中的类型名称和文件列表） function resetItemRelatedState() selectedTypeName.value = ; fileList.value = []; // 打开商品信息对话框并加载所有数据 function openItemDialog() // 重置表单和相关状态 Object.assign(itemForm, ...initialItemFormState ); resetItemRelatedState(); //确保DOM更新完毕后再调用resetFields，以保证itemFormRef可用 nextTick(() = if (itemFormRef.value) itemFormRef.value.resetFields(); ); // 获取商品编号 itemApi .getItemCode() .then((response) = itemForm.itemNum = response.data; ) .catch(() = ElMessage.error(获取商品编号失败); ); dialogItemVisible.value = true; // 打开商品类型选择对话框 function openTypeDialog() dialogTypeVisible.value = true; // 处理类型树节点点击 function handleTypeNodeClick(data) if (data.children data.children.length 0) ElMessage.warning(只能选择叶子节点); typeTreeRef.value.setCurrentKey(null); else typeTreeRef.value.setCurrentKey(data.id); // 确认类型选择 function confirmTypeSelection() const selectedNode = typeTreeRef.value.getCurrentNode(); if (!selectedNode) ElMessage.warning(请选择一个商品类型); return; if (selectedNode.children selectedNode.children.length 0) ElMessage.warning(只能选择叶子节点); return; itemForm.typeId = selectedNode.id; selectedTypeName.value = selectedNode.label; dialogTypeVisible.value = false; // 图片上传成功回调 function handleAvatarSuccess(response) const imageUrl = typeof response === string ? response : response.url || ; if (imageUrl) if (!Array.isArray(itemForm.imgs)) itemForm.imgs = []; itemForm.imgs.push(imageUrl); fileList.value.push( url: imageUrl, status: success ); // 移除图片 function handleRemove(file) const index = fileList.value.indexOf(file); if (index !== -1) fileList.value.splice(index, 1); itemForm.imgs.splice(index, 1); // 图片预览 function handlePictureCardPreview(uploadFile) dialogImageUrl.value = uploadFile.url; dialogVisible.value = true; // 提交表单 function submitItem() itemFormRef.value.validate((valid) = if (valid) const apiCall = itemForm.id ? itemApi.updateItem(itemForm) : itemApi.saveItem(itemForm); apiCall .then((response) = if (response.data response.data.code === 500) ElMessage.error(response.data.message || 操作失败，请稍后重试); return; ElMessage.success(itemForm.id ? 修改成功 : 添加成功); dialogItemVisible.value = false; Object.assign(itemForm, ...initialItemFormState ); resetItemRelatedState(); loadItemList(1); ) .catch((error) = const errorMsg = error.response?.data?.message || 保存失败，请稍后重试; ElMessage.error(errorMsg); ); ); // 提交采购表单 function submitPurchase() buyFormRef.value.validate((valid) = if (valid) itemApi .saveBuy(buyForm) .then((response) = if (response.data.code === 200) ElMessage.success(response.data.message || 采购成功); buyDialog.value = false; loadItemList(1); // 刷新商品列表 Object.assign(buyForm, productId: , storeId: , supplyId: , placeId: , itemName: , storeName: , supplyName: , placeName: , buyNum: , buyUser: , phone: , ); else ElMessage.error(response.data.message || 采购失败); ) .catch((error) = console.error(采购失败:, error); ElMessage.error(采购失败，请稍后重试); ); else ElMessage.warning(请填写完整的采购信息); ); // 加载所有数据 function loadAllData() Promise.all([ categoryApi.getCategoryTree(), itemApi.getSupplyList(), itemApi.getPlaceList(), itemApi.getUnitList(), itemApi.getBrandList(), itemApi.getStoreList(), ]) .then(([typeRes, supplyRes, placeRes, unitRes, brandRes, storeRes]) = typeList.value = typeRes.data; supplyList.value = supplyRes.data; placeList.value = placeRes.data; unitList.value = unitRes.data; brandList.value = brandRes.data; storeList.value = storeRes.data; ) .catch(() = ElMessage.error(加载数据失败，请稍后重试); ); // 加载商品列表 function loadItemList(pageNum = 1, pageSize = 10) const params = pageNum, pageSize, itemNum: searchForm.itemNum, itemName: searchForm.itemName, statue: searchForm.statue, ; itemApi .getItemList(params) .then((response) = // 确保从后端正确解析数据 if (response.data response.data.items) itemList.value = response.data.items; total.value = response.data.total; else // 处理可能的空数据或错误格式 itemList.value = []; total.value = 0; ElMessage.warning(商品数据格式不正确或为空); ) .catch(() = ElMessage.error(加载商品列表失败); ); // 处理查询 function handleSearch() loadItemList(1); // 查询时总是从第一页开始 // 重置查询表单 function resetSearchForm() if (searchFormRef.value) searchFormRef.value.resetFields(); // 手动清空searchForm reactive对象的值，因为resetFields可能不会完全清空 searchForm.itemNum = ; searchForm.itemName = ; searchForm.statue = null; loadItemList(1); // 重置后重新加载数据 // 删除商品 function handleDeleteItem(id) ElMessageBox.confirm(确定要删除这个商品吗？, 提示, confirmButtonText: 确定, cancelButtonText: 取消, type: warning, ) .then(() = itemApi .deleteItem(id) .then((response) = if (response.data.code === 200) ElMessage.success(response.data.message || 删除成功); loadItemList(1); else ElMessage.error(response.data.message || 删除失败); ) .catch(() = ElMessage.error(删除失败); ); ) .catch(() = ElMessage.info(已取消删除); ); // 处理商品下架 function handleDownItem(id) itemApi .downItem(id) .then((response) = if (response.data.code === 200) ElMessage.success(response.data.message || 下架成功); loadItemList(1); else ElMessage.error(response.data.message || 下架失败); ) .catch(() = ElMessage.error(下架失败); ); // 处理商品上架 function handleUpItem(id) itemApi .upItem(id) .then((response) = if (response.data.code === 200) ElMessage.success(response.data.message || 上架成功); loadItemList(1); else ElMessage.error(response.data.message || 上架失败); ) .catch(() = ElMessage.error(上架失败); ); // 打开修改对话框 function openUpdateDialog(row) dialogItemVisible.value = true; Object.assign(itemForm, id: row.id, itemNum: row.itemNum || , itemName: row.itemName || , typeId: row.typeId, store: row.store || 0, brandId: row.brandId, storeId: row.storeId, supplyId: row.supplyId, placeId: row.placeId, unitId: row.unitId, price: row.price || 0, sellPrice: row.sellPrice || 0, vipPrice: row.vipPrice || 0, itemDesc: row.itemDesc || , itemDate: row.itemDate, endDate: row.endDate, hotTitle: row.hotTitle || , facturer: row.facturer || , statue: row.statue, imgs: row.imgs || [], createBy: row.createBy || , ); fileList.value = (row.imgs || []).map((url) = ( url, status: success, )); selectedTypeName.value = row.cateName || ; // 使用 cateName 对应后端的商品类型名称 loadAllData(); // 生命周期钩子 onMounted(() = loadItemList(1); loadAllData(); // 组件挂载时加载所有下拉列表数据 ); // 处理分页 function handlePageChange(value) loadItemList(value); // 打开采购对话框 function openPurchaseDialog(row) buyDialog.value = true; // 发送ajax请求，获取需要带入的数据 itemApi .getBuyAutoInfo(row.id) .then((response) = // 获取响应数据对象 const item = response.data; // 将响应数据赋值给buyForm表单 buyForm.productId = item.id; buyForm.itemName = item.itemName; buyForm.storeId = item.storeId; buyForm.storeName = item.storeName; buyForm.supplyId = item.supplyId; buyForm.supplyName = item.supplyName; buyForm.placeId = item.placeId; buyForm.placeName = item.placeName; ) .catch((error) = console.error(获取采购信息失败:, error); ElMessage.error(获取采购信息失败); ); /scriptstyle scoped/style 注册页面方法之前讲过，这里不重复 Day15 1.实现采购管理 采购单管理 (t_buy_list)： 实现了采购单的后端增删改查和前端列表展示、修改对话框等。 自动带入数据： 在商品列表页面点击“采购”按钮时，会弹出一个采购对话框，并通过调用后端接口 (/buyAutoInfo/{id}) 自动带入与该商品相关的默认信息（如商品名称、仓库、供应商、产地）。 后端实现 添加数据库表 CREATE TABLE `t_buy_list` ( `buy_id` int NOT NULL AUTO_INCREMENT COMMENT 采购单ID, `product_id` int DEFAULT NULL COMMENT 产品ID，关联产品表, `store_id` int DEFAULT NULL COMMENT 仓库ID，关联仓库表, `buy_num` int DEFAULT NULL COMMENT 计划采购数量, `fact_buy_num` int DEFAULT NULL COMMENT 实际采购数量, `buy_time` datetime DEFAULT NULL COMMENT 采购时间, `supply_id` int DEFAULT NULL COMMENT 供应商ID，关联供应商表, `place_id` int DEFAULT NULL COMMENT 采购地点ID，关联地点表, `buy_user` varchar(20) DEFAULT NULL COMMENT 采购人姓名, `phone` varchar(20) DEFAULT NULL COMMENT 采购人联系电话, `is_in` char(1) DEFAULT NULL COMMENT 是否入库：0-否，1-是, PRIMARY KEY (`buy_id`)) ENGINE=InnoDB AUTO_INCREMENT=49 DEFAULT CHARSET=utf8mb3 COMMENT=采购单表，记录商品采购信息; 用 mybatiesx 插件生成代码 生成的 Buylistpojo 添加属性 /** * 采购时间 */@JsonFormat(pattern = yyyy-MM-dd HH:mm:ss)//添加注释使前端能正常解析private Date buyTime;@TableField(exist = false)private static final long serialVersionUID = 1L;@TableField(exist = false)private String itemName;@TableField(exist = false)private String storeName; 对应 mapper 添加接口方法 /*实现采购单列表分页查询*/ListBuyList queryBuyListMapper(); 实现对应 sql !--实现采购单列表分页查询--select id=queryBuyListMapper resultType=com.example.demo.pojo.BuyList select buy.*, store.store_name, item.item_name from t_buy_list buy inner join t_store store on buy.store_id = store.store_id inner join t_item item on buy.product_id = item.id/select 添加 service 方法接口 /*处理采购单需要自动带入的数据*/MapString,Object queryAutoDataBuyService(Integer id);/*实现采购单分页查询*/MapString,Object queryBuyListService(Integer pageNum,Integer pageSize); 实现接口方法 private final ItemMapper itemMapper;private final StoreMapper storeMapper;private final SupplyMapper supplyMapper;private final PlaceMapper placeMapper;public BuyListServiceImpl(ItemMapper itemMapper, StoreMapper storeMapper, SupplyMapper supplyMapper, PlaceMapper placeMapper, BuyListMapper buyListMapper) this.itemMapper = itemMapper; this.storeMapper = storeMapper; this.supplyMapper = supplyMapper; this.placeMapper = placeMapper; this.buyListMapper = buyListMapper;@Overridepublic MapString, Object queryAutoDataBuyService(Integer id) MapString, Object result=new HashMap(); //查询商品信息 Item item = itemMapper.selectById(id); result.put(id,item.getId()); result.put(itemName,item.getItemName()); //查询仓库信息 Integer storeId = item.getStoreId(); Store store = storeMapper.selectById(storeId); result.put(storeId,store.getStoreId()); result.put(storeName,store.getStoreName()); //查询供应商信息 Integer supplyId = item.getSupplyId(); Supply supply = supplyMapper.selectById(supplyId); result.put(supplyId,supply.getSupplyId()); result.put(supplyName,supply.getSupplyName()); //查询产地信息 Integer placeId = item.getPlaceId(); Place place = placeMapper.selectById(placeId); result.put(placeId,place.getPlaceId()); result.put(placeName,place.getPlaceName()); return result;private final BuyListMapper buyListMapper;@Overridepublic MapString, Object queryBuyListService(Integer pageNum, Integer pageSize) //指定分页查询参数 PageObject page = PageHelper.startPage(pageNum, pageSize); //查询数据库 ListBuyList buyLists = buyListMapper.queryBuyListMapper(); MapString, Object result=new HashMap(); result.put(total,page.getTotal()); result.put(buyLists,buyLists); return result; 实现增删改查接口 @RestController@CrossOriginpublic class BuyListController private final BuyListService buyListService; public BuyListController(BuyListService buyListService) this.buyListService = buyListService; /*处理采购信息需要自动带入数据的请求*/ @GetMapping(/buyAutoInfo/id) public MapString,Object buyAutoInfo(@PathVariable Integer id) return buyListService.queryAutoDataBuyService(id); /*保存采购信息*/ @PostMapping(/saveBuy) public MapString,Object saveBuy(@RequestBody BuyList buyList) buyList.setBuyTime(new Date()); buyList.setIsIn(0); buyList.setFactBuyNum(0); return buyListService.save(buyList)? ResponseUtil.success(保存成功):ResponseUtil.error(保存失败); /*处理采购单分页查询请求*/ @GetMapping(/queryBuyList) public MapString,Object queryBuyList( @RequestParam(defaultValue = 1) Integer pageNum ,@RequestParam(defaultValue = 3) Integer pageSize) return buyListService.queryBuyListService(pageNum,pageSize); /*处理采购单修改请求*/ @PostMapping(/updateBuyList) public MapString,Object updateBuyList(@RequestBody BuyList buyList) return buyListService.updateById(buyList)? ResponseUtil.success(修改成功):ResponseUtil.error(修改失败); /*处理采购单删除请求*/ @PostMapping(/deleteBuy/id) public MapString,Object deleteBuy(@PathVariable Integer id) return buyListService.removeById(id)? ResponseUtil.success(删除成功):ResponseUtil.error(删除失败); 前端实现 修改昨天的商品信息页，添加采购功能，相关内容已经在之前的代码里实现了 添加 BuyListManager.vue template h2采购单列表/h2 !-- 采购单列表table -- el-table :data=buyList style=width: 100% el-table-column prop=storeName label=仓库名称 / el-table-column prop=itemName label=商品名称 / el-table-column prop=buyNum label=预计采购数量 / el-table-column prop=factBuyNum label=实际采购数量 / el-table-column prop=buyUser label=采购人 / el-table-column prop=buyTime label=采购时间 width=200px / el-table-column prop=phone label=采购人电话 / el-table-column prop=isIn label=状态 template #default=scope span v-if=scope.row.isIn == 0 style=color:green未入库/span span v-else style=color:red已入库/span /template /el-table-column el-table-column fixed=right label=操作 width=240 template #default=scope el-button link type=primary v-if=scope.row.factBuyNum == 0 size=small @click=showBuyListDialog(scope.row) 修改/el-button el-button link type=primary v-if=scope.row.factBuyNum == 0 size=small @click=delBuyList(scope.row.id) 删除/el-button el-button link type=primary size=small v-if=scope.row.isIn == 0 生成入库单/el-button /template /el-table-column /el-table !-- 分页组件 -- el-pagination small background :page-size=3 :pager-count=10 layout=prev, pager, next :total=total class=mt-4 @current-change=handlerPageChange / !-- 采购信息回显对话框 -- el-dialog v-model=buyListDialog width=60% h2商品采购/h2 el-form :model=buyForm label-width=120px el-form-item label=商品名称 buyForm.itemName /el-form-item el-form-item label=仓库 buyForm.storeName /el-form-item el-form-item label=供应商 buyForm.supplyName /el-form-item el-form-item label=产地 buyForm.placeName /el-form-item el-form-item label=预计采购量 el-input v-model=buyForm.buyNum style=width: 80% / /el-form-item el-form-item label=采购人 el-input v-model=buyForm.buyUser style=width: 80% / /el-form-item el-form-item label=采购人电话 el-input v-model=buyForm.phone style=width: 80% / /el-form-item el-form-item label=实际采购数 el-input v-model=buyForm.factBuyNum style=width: 80% / /el-form-item el-form-item el-button type=primary @click=updateBuyOrder保存/el-button el-button取消/el-button /el-form-item /el-form /el-dialog/templatescript setup import axios from axios; import onMounted, reactive, ref from vue; import ElMessage from element-plus; //声明列表集合数据 const buyList = ref([]); //声明total const total = ref(0); //定义函数发送请求，加载采购单列表 function queryBuyList(pageNum) axios .get(http://localhost:8080/queryBuyList?pageNum= + pageNum) .then((response) = buyList.value = response.data.buyLists; total.value = response.data.total; ); //加载页面调用函数 onMounted(function () queryBuyList(1); ); //分页按钮的回调函数 function handlerPageChange(pageNum) queryBuyList(pageNum); //////////////////////////////采购单信息回显/////////////////////////////// //定义采购单form表单 //声明商品采购表单 const buyForm = reactive( productId: , storeId: , supplyId: , placeId: , itemName: , storeName: , supplyName: , placeName: , buyNum: , buyUser: , phone: , factBuyNum: , ); //声明变量表示采购单回显对话框状态 const buyListDialog = ref(false); //声明函数打开采购数据回显对话框,row参数表示采购单对象。 function showBuyListDialog(row) var productId = row.productId; buyListDialog.value = true; axios .get(http://localhost:8080/buyAutoInfo/ + productId) .then((response) = //获得响应数据对象 var item = response.data; //将响应数据赋值给buyForm表单 buyForm.productId = item.id; buyForm.itemName = item.itemName; buyForm.storeId = item.storeId; buyForm.storeName = item.storeName; buyForm.supplyId = item.supplyId; buyForm.supplyName = item.supplyName; buyForm.placeId = item.placeId; buyForm.placeName = item.placeName; buyForm.buyUser = row.buyUser; buyForm.buyNum = row.buyNum; buyForm.factBuyNum = row.factBuyNum; buyForm.phone = row.phone; //表单中封装采购单id buyForm.buyId = row.buyId; ) .catch((error) = console.log(error); ); /*发送采购单更新的ajax请求*/ function updateBuyOrder() axios .post(http://localhost:8080/updateBuyList, buyForm) .then((response) = if (response.data.code == 200) buyListDialog.value = false; //刷新列表 queryBuyList(1); ElMessage(response.data.message); ) .catch((error) = console.log(error); ); //定义函数发生采购单删除的请求 function delBuyList(id) axios .get(http://localhost:8080/deleteBuyList/ + id) .then((response) = if (response.data.code == 200) //刷新列表 queryBuyList(1); ElMessage(response.data.message); ) .catch((ex) = console.log(ex); ); /scriptstyle scoped/style 2.实现商品入库管理 创建了入库表和相应的后端代码。 在采购单列表页面添加了“生成入库单”按钮。点击后，调用后端 /buyInStore 接口。 后端入库逻辑 (saveBuyOrderInStoreService)： 更新商品库存： 根据采购单的实际采购数量，增加对应商品的库存 (这里代码是 goods.getStore()-buyList.getFactBuyNum() 应该是 +，表示入库增加库存，或者需要根据实际业务是“减少未入库库存”等具体逻辑调整)。 更新采购单状态： 将采购单的 is_in 状态标记为“已入库”。 生成入库记录： 在 t_in_store 表中插入一条新的入库记录。 后端实现 添加入库表 CREATE TABLE `t_in_store` ( `ins_id` int NOT NULL AUTO_INCREMENT COMMENT 入库单ID, `store_id` int NULL DEFAULT NULL COMMENT 仓库ID(关联仓库表), `product_id` int NULL DEFAULT NULL COMMENT 商品ID(关联商品表), `in_num` int NULL DEFAULT NULL COMMENT 入库数量, `create_by` int NULL DEFAULT NULL COMMENT 创建人ID(关联用户表), `create_time` datetime NULL DEFAULT NULL COMMENT 创建时间, `is_in` char(1) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 入库状态(0-未入库，1-已入库), PRIMARY KEY (`ins_id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 50 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = 入库单表(记录商品入库信息) ROW_FORMAT = Dynamic; 用插件生成基础代码 添加 service 接口方法 /*实现采购采购信息入库*/void saveBuyOrderInStoreService(BuyList buyList); 实现方法 private final BuyListMapper buyListMapper;private final ItemMapper itemMapper;private final InStoreMapper inStoreMapper;public InStoreServiceImpl(BuyListMapper buyListMapper, ItemMapper itemMapper, InStoreMapper inStoreMapper) this.buyListMapper = buyListMapper; this.itemMapper = itemMapper; this.inStoreMapper = inStoreMapper;@Overridepublic void saveBuyOrderInStoreService(BuyList buyList) //获得商品id Integer productId = buyList.getProductId(); //通过商品id获得商品的库存 Item goods = itemMapper.selectById(productId); Item item =new Item(); item.setId(productId); item.setStore(goods.getStore()-buyList.getFactBuyNum()); //跟新商品库存 itemMapper.updateById(item); //获得采购单id Integer buyId=buyList.getBuyId(); //更新采购单状态 BuyList bl=new BuyList(); bl.setBuyId(buyId); bl.setIsIn(1); buyListMapper.updateById(bl); //查询记录形成入库单 InStore inStore=new InStore(); inStore.setStoreId(buyList.getStoreId()); inStore.setProductId(buyList.getProductId()); inStore.setInNum(buyList.getFactBuyNum()); inStore.setCreateBy(1009); inStore.setCreateTime(new Date()); inStore.setIsIn(1); inStoreMapper.insert(inStore); 添加 Controller @RestController@CrossOriginpublic class InStoreController @Autowired private InStoreService inStoreService; /*处理采购单入库请求*/ @PostMapping(/buyInStore) public MapString,Object buyInStore(@RequestBody BuyList buyList) inStoreService.saveBuyOrderInStoreService(buyList); return ResponseUtil.success(入库成功); 前端实现 采购管理页添加入库方法 //定义入库按钮函数function doInStore(row) axios .post(http://localhost:8080/buyInStore, row) .then((response) = if (response.data.code == 200) //刷新列表 queryBuyList(1); ElMessage(response.data.message); ) .catch((ex) = console.log(ex); ); 修改按钮，绑定事件方法 el-button link type=primary size=small v-if=scope.row.isIn == 0 @click=doInStore(scope.row) 生成入库单/el-button 3.实现表的导入导出 外部教程：java 导出 excel(一)：单 sheet 后端实现 添加了 Apache POI 依赖 (poi-ooxml)。 在 BuyListServiceImpl 中实现了 exportExcelService 方法： 创建 XSSFWorkbook (Excel 文件对象) 和 XSSFSheet (工作表)。 创建表头行并设置样式 (合并单元格、字体、对齐方式等)。 查询数据库获取采购单列表数据。 遍历数据，为每条记录创建数据行，并将数据填充到单元格中。特别注意了日期格式的处理。 在 BuyListController 中创建了 /exportExcel 接口： 调用 Service 获取 XSSFWorkbook 对象。 将 workbook 写入 ByteArrayOutputStream。 设置 HTTP 响应头 (HttpHeaders)，包括 Content-Type (application/octet-stream 表示二进制流) 和 Content-Disposition (attachment;filename=… 指定下载文件名，并进行了 URL 编码处理中文名)。 返回 ResponseEntitybyte[]，将 Excel 文件内容作为字节流响应给客户端。 Maven 添加依赖 !--导出excle poi依赖--dependency groupIdorg.apache.poi/groupId artifactIdpoi-ooxml/artifactId version5.4.0/version/dependency application.properties 添加 pagehelper 配置 这个配置防止 pageSizeZero 不可以为零导致返回出错的情况 # 添加 PageHelper 的配置 (如果需要，特别是 pageSizeZero)pagehelper.helper-dialect=mysqlpagehelper.reasonable=falsepagehelper.support-methods-arguments=truepagehelper.params=count=countSqlpagehelper.page-size-zero=true BuyListService 添加方法 /*实现采购单数据导出到excel*/XSSFWorkbook exportExcelService(); 实现接口方法 //XSSFWorkbook 返回的是一个XSSFWorkbook对象，表示一个excel文件@Overridepublic XSSFWorkbook exportExcelService() //创建XSSFWorkbook对象，形成一个excel文件 XSSFWorkbook xwb = new XSSFWorkbook(); //在excel文件中添加sheet表 XSSFSheet sheet = xwb.createSheet(采购单信息); //sheet添加行,当一行 XSSFRow row0 = sheet.createRow(0); //给第一行添加列 XSSFCell row0cell0 = row0.createCell(0); row0cell0.setCellValue(采购单列表); //设置单元格内容居中 XSSFCellStyle style = xwb.createCellStyle(); style.setAlignment(HorizontalAlignment.CENTER); style.setFillBackgroundColor(new XSSFColor( new java.awt.Color(255, 0, 0), null)); XSSFFont font = new XSSFFont(); font.setFontHeight(30); style.setFont(font); row0cell0.setCellStyle(style); //合并第一行，扩列合并列,从第一行合并8列 sheet.addMergedRegion(new CellRangeAddress(0, 0, 0, 8)); ////////////////////////////////设置表头/////////////////////////////// //创建第二行表头 XSSFRow row1 = sheet.createRow(1); //创建第一行，8个列，并填充数据 row1.createCell(0).setCellValue(仓库名称); row1.createCell(1).setCellValue(商品名称); row1.createCell(2).setCellValue(预计采购数量); row1.createCell(3).setCellValue(实际采购数量); row1.createCell(4).setCellValue(采购人); row1.createCell(5).setCellValue(采购时间); row1.createCell(6).setCellValue(采购人电话); row1.createCell(7).setCellValue(状态); //查询数据库，获得需要填充的数据 //指定分页查询参数 PageHelper.startPage(1, 0); //查询数据库 ListBuyList buyLists = buyListMapper.queryBuyListMapper(); //debug看数据 System.out.println(buyLists); int index = 2; for (BuyList buy : buyLists) //每循环遍历一次，创建一行 XSSFRow rown = sheet.createRow(index); rown.createCell(0).setCellValue(buy.getStoreName()); rown.createCell(1).setCellValue(buy.getItemName()); rown.createCell(2).setCellValue(buy.getBuyNum()); rown.createCell(3).setCellValue(buy.getFactBuyNum()); rown.createCell(4).setCellValue(buy.getBuyUser()); XSSFCell cell = rown.createCell(5); // 创建一个日期样式 CellStyle dateStyle = xwb.createCellStyle(); short dateFormat = xwb.getCreationHelper().createDataFormat() .getFormat(yyyy-MM-dd HH:mm:ss); // 设置日期格式 dateStyle.setDataFormat(dateFormat); cell.setCellStyle(dateStyle); cell.setCellValue(buy.getBuyTime()); rown.createCell(6).setCellValue(buy.getPhone()); //判断采购单准提 // 判断采购单准提状态（安全处理 null） String isIn = buy.getIsIn(); String result = 0.equals(isIn) ? 未入库 : 已入库; // 或使用显式判空 rown.createCell(7).setCellValue(result); index++; return xwb; 添加对于 controller 接口 /*处理数据导出excel请求，下载excel文件*/@GetMapping(/exportExcel)public ResponseEntity exportExcel() XSSFWorkbook workbook = buyListService.exportExcelService(); //将workbook，excel文件对象，封装到字节数组 ByteArrayOutputStream baos = new ByteArrayOutputStream(); try workbook.write(baos); catch (IOException e) e.printStackTrace(); //获得字节数组中封装的文件,响应体 byte[] bytes = baos.toByteArray(); //创建HttpHeaders对象封装响应头 HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_OCTET_STREAM); //响应体的类型 //设置下载的文件的名字 //headers.setContentDisposition(attachment;filename=采购单列表); String name = 采购单列表.xlsx; name = URLEncoder.encode(name, StandardCharsets.UTF_8); System.out.println(name= + name); headers.add(HttpHeaders.CONTENT_DISPOSITION, attachment;filename= + name); //创建对象，封装响应体，响应头，状态吗 return (ResponseEntitybyte[]) new ResponseEntity(bytes, headers, HttpStatus.CREATED); 前端实现 添加一个“导出数据”按钮。 点击按钮时，通过 location.href=“http://localhost:8081/exportExcel” 直接请求后端导出接口，浏览器会自动触发表单下载。 添加导出按钮 div style=text-align: left el-button type=success @click=exportData导出数据/el-button/div 实现绑定的事件 //发送请求进行数据导出function exportData() location.href = http://localhost:8081/exportExcel; Day16 1.实现入库单列表增删改查 后端实现 InStore 实体类添加属性 @Serial@TableField(exist = false)private static final long serialVersionUID = 1L;@TableField(exist = false)private String storeName;@TableField(exist = false)private String itemName; InStoreMapper 添加方法 /*完成入库单列表分页查询*/public ListInStore queryInStoreListMapper(); 实现 mapper 接口 !--实现入库单列表查询--select id=queryInStoreListMapper resultType=com.example.demo.pojo.InStore select inst.*,store.store_name,item.item_name from t_in_store inst inner join t_item item on item.id=inst.product_id inner join t_store store on store.store_id=inst.store_id/select 对应 service 添加方法接口 /*实现入库单列表分页查询*/ public MapString,Object queryInStoreListService(Integer pageNum, Integer pageSize); 实现接口 @Overridepublic MapString, Object queryInStoreListService(Integer pageNum, Integer pageSize) //指定分页查询参数 PageObject page = PageHelper.startPage(pageNum, pageSize); ListInStore inStores = inStoreMapper.queryInStoreListMapper(); MapString,Object result=new HashMap(); result.put(total,page.getTotal()); result.put(inStores,inStores); return result; InStoreController 添加方法 /*处理入库单列表分页查询请求*/@GetMapping(/queryInList)public MapString,Object queryInStoreList( @RequestParam(defaultValue = 1) Integer pageNum ,@RequestParam(defaultValue = 10) Integer pageSize) return inStoreService.queryInStoreListService(pageNum,pageSize);/*处理入库单删除请求*/@PostMapping(/deleteInList/id)public MapString, Object deleteInList(@PathVariable Integer id) return inStoreService.removeById(id) ? R.success(删除成功) : R.error(删除失败); /*处理入库单修改请求*/@PostMapping(/updateInList) public MapString, Object updateInList(@RequestBody InStore inStore) return inStoreService.updateById(inStore) ? R.success(修改成功) : R.error(修改失败); /*处理入库单确认请求*/@PostMapping(/updateInStore/id)public MapString,Object updateInStore(@PathVariable Integer id) InStore inStore=new InStore(); inStore.setInsId(id); inStore.setIsIn(0); return inStoreService.updateById(inStore)? R.success(确认成功): R.error(确认失败); 前端实现 创建 InStoreList.vue 组件 template h2入库单列表/h2 !-- 入库单列表table -- el-table :data=inStoreList style=width: 100% el-table-column prop=storeName label=仓库名称 / el-table-column prop=itemName label=商品名称 / el-table-column prop=inNum label=入库数量 / el-table-column prop=createBy label=创建人ID / el-table-column prop=createTime label=创建时间 width=200px / el-table-column prop=isIn label=状态 template #default=scope span v-if=scope.row.isIn == 0 style=color:green未入库/span span v-else style=color:red已入库/span /template /el-table-column el-table-column fixed=right label=操作 width=180 template #default=scope el-button link type=primary size=small @click=showInStoreDialog(scope.row) 修改/el-button el-button link type=primary size=small @click=delInStore(scope.row.insId) 删除/el-button el-button link type=primary size=small v-if=scope.row.isIn == 1 @click=confirmIsIn(scope.row.insId) 确认入库/el-button /template /el-table-column /el-table !-- 分页组件 -- el-pagination small background :page-size=pageSize :pager-count=10 layout=prev, pager, next :total=total class=mt-4 @current-change=handlerPageChange / !-- 入库信息回显对话框 -- el-dialog v-model=inStoreDialog width=60% h2入库单信息/h2 el-form :model=inStoreForm label-width=120px el-form-item label=商品名称 inStoreForm.itemName /el-form-item el-form-item label=仓库 inStoreForm.storeName /el-form-item el-form-item label=入库数量 el-input v-model=inStoreForm.inNum style=width: 80% / /el-form-item el-form-item label=创建人ID el-input v-model=inStoreForm.createBy style=width: 80% / /el-form-item el-form-item label=创建时间 el-input v-model=inStoreForm.createTime style=width: 80% disabled / /el-form-item el-form-item label=状态 el-select v-model=inStoreForm.isIn style=width: 80% el-option label=未入库 value=0 / el-option label=已入库 value=1 / /el-select /el-form-item el-form-item el-button type=primary @click=updateInStore保存/el-button el-button @click=inStoreDialog = false取消/el-button /el-form-item /el-form /el-dialog/templatescript setup import onMounted, reactive, ref from vue; import ElMessage from element-plus; import InStoreApi from @/api/InStore; // 入库单列表数据 const inStoreList = ref([]); const total = ref(0); const pageSize = 10; // 查询入库单列表 function queryInStoreList(pageNum) InStoreApi.queryInList(pageNum, pageSize) .then((response) = // 正确映射后端 inStores 字段 inStoreList.value = response.data.inStores || []; total.value = response.data.total; ) .catch((error) = console.error(获取入库单列表失败:, error); ElMessage.error(获取入库单列表失败); ); onMounted(function () queryInStoreList(1); ); function handlerPageChange(pageNum) queryInStoreList(pageNum); // 入库单表单 const inStoreForm = reactive( insId: , storeId: , productId: , inNum: , createBy: , createTime: , isIn: , storeName: , itemName: , ); const inStoreDialog = ref(false); // 打开入库单编辑对话框 function showInStoreDialog(row) Object.assign(inStoreForm, row); inStoreDialog.value = true; // 更新入库单 function updateInStore() InStoreApi.updateInList(inStoreForm) .then((response) = if (response.data.code == 200) inStoreDialog.value = false; queryInStoreList(1); ElMessage(response.data.message); ) .catch((error) = console.error(更新入库单失败:, error); ElMessage.error(更新入库单失败); ); // 删除入库单 function delInStore(id) InStoreApi.deleteInList(id) .then((response) = if (response.data.code == 200) queryInStoreList(1); ElMessage(response.data.message); ) .catch((error) = console.error(删除入库单失败:, error); ElMessage.error(删除入库单失败); ); //定义函数发生入库单确认请求 function confirmIsIn(id) InStoreApi.updateInStore(id) .then((response) = if (response.data.code == 200) queryInStoreList(1); //刷新 ) .catch((error) = console.log(error); ); /scriptstyle scoped/style 在菜单表里添加菜单 在主页代码中注册页面 之前写过很多次，这里不重复 2.实现商品信息页的出库功能 后端实现 创建 t_out_store 表 -- 创建出库单表CREATE TABLE `t_out_store` ( `outs_id` int NOT NULL AUTO_INCREMENT COMMENT 出库单ID，主键，自增, -- 出库单唯一标识 `product_id` int DEFAULT NULL COMMENT 产品ID, -- 关联的产品ID `store_id` int DEFAULT NULL COMMENT 仓库ID, -- 关联的仓库ID `tally_id` int DEFAULT NULL COMMENT 理货ID, -- 关联的理货记录ID `out_price` decimal(8,2) DEFAULT NULL COMMENT 出库单价, -- 出库产品的单价，保留两位小数 `out_num` int DEFAULT NULL COMMENT 出库数量, -- 出库的产品数量 `create_by` int DEFAULT NULL COMMENT 创建人ID, -- 创建该出库单的用户ID `create_time` datetime DEFAULT NULL COMMENT 创建时间, -- 出库单创建时间 `is_out` char(1) DEFAULT NULL COMMENT 是否出库：0 否，1 是, -- 出库状态标记 PRIMARY KEY (`outs_id`) -- 设置outs_id为主键) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8mb3 COMMENT=出库单; 在 idea 用 mybatiesx 生成代码 OutStoreService 添加方法 /*实现商品出库*/public void saveOutStoreService(OutStore outStore); 实现方法 private final ItemMapper itemMapper;private final OutStoreMapper outStoreMapper;public OutStoreServiceImpl(ItemMapper itemMapper, OutStoreMapper outStoreMapper) this.itemMapper = itemMapper; this.outStoreMapper = outStoreMapper;@Transactional@Overridepublic boolean saveOutStoreService(OutStore outStore) //根据商品查询对应商品的库存 Item product = itemMapper.selectById(outStore.getProductId()); Item item =new Item(); item.setId(outStore.getProductId()); item.setStore(product.getStore()-outStore.getOutNum()); //实现商品信息的更新 itemMapper.updateById(item); outStore.setIsOut(0); outStore.setCreateTime(new Date()); outStore.setCreateBy(101010); outStore.setOutPrice(BigDecimal.valueOf(product.getSellPrice())); outStore.setStoreId(product.getStoreId()); outStore.setProductId(product.getId()); //实现出库单信息的保存 outStoreMapper.insert(outStore); return false; 创建 OutStoreController @RestController@CrossOriginpublic class OutStoreController @Autowired private OutStoreService outStoreService; /*处理商品信息出库请求*/ @PostMapping(/doItemOutStore) public MapString,Object doItemOutStore(@RequestBody OutStore outStore) if (outStoreService.saveOutStoreService(outStore)) return R.success(商品出库成功); else return R.error(商品出库失败); /*处理出库单分页查询请求*/ @GetMapping(/outStoreList) public MapString,Object outStoreList( @RequestParam(defaultValue = 1) Integer pageNum ,@RequestParam(defaultValue = 3) Integer pageSize) return outStoreService.queryOutStoreListMapper(pageNum,pageSize); /*处理出库单确认请求*/ @GetMapping(/updateOutStore) public MapString,Object updateOutStore(Integer id) OutStore os=new OutStore(); os.setOutsId(id); os.setIsOut(1); if(outStoreService.updateById(os)) return R.success(确认成功); else return R.error(确认失败); 前端实现 在商品信息页添加按钮和对应事件 添加出库按钮 el-button link type=primary size=small @click=openOutDialog(row) 出库/el-button 添加出库对话框 !-- 出库对话框组件 --el-dialog v-model=itemOutDialog width=60% h2商品采购/h2 el-form :model=outForm label-width=120px el-form-item label=商品名称 outForm.itemName /el-form-item el-form-item label=仓库 outForm.storeName /el-form-item el-form-item label=商品库存 outForm.store /el-form-item el-form-item label=出库数量 el-input v-model=outForm.outNum style=width: 80% / /el-form-item el-form-item el-button type=primary @click=saveOutOrder保存/el-button el-button取消/el-button /el-form-item /el-form/el-dialog 添加相关变量和函数实现 //声明出库对话框状态const itemOutDialog = ref(false);//声明商品出库form表单const outForm = reactive( itemName: , storeName: , store: 0, outNum: 0, productId: undefined,);//定义函数打开商品出库对话框function openOutDialog(row) itemOutDialog.value = true; outForm.itemName = row.itemName; outForm.store = row.store; outForm.storeName = row.storeName; outForm.productId = row.id; outForm.outNum = 0;//定义函数发生商品出库请求function saveOutOrder() if (!outForm.outNum || outForm.outNum = 0) ElMessage.warning(请输入正确的出库数量); return; if (outForm.outNum outForm.store) ElMessage.warning(出库数量不能大于库存); return; itemApi .doItemOutStore(outForm) .then((response) = if (response.data.code == 200) itemOutDialog.value = false; loadItemList(1); // 出库成功后刷新商品列表 ElMessage(response.data.message); ) .catch((error) = console.log(error); ); 3.实现出库单分页查询和出库确认 后端实现 OutStore 实体类添加属性 @TableField(exist = false)private String itemName;@TableField(exist = false)private String storeName; OutStoreMapper 接口定义方法 /*实现入库单信息分页查询*/ListOutStore queryOutStorListeMapper(); 实现接口方法 select id=queryOutStorListeMapper resultType=com.example.demo.pojo.OutStore select ose.*, item.item_name, store.store_name from t_out_store ose inner join t_item item on ose.product_id = item.id inner join t_store store on ose.store_id = store.store_id/select OutStoreService 添加方法 /*实现入库单列表分页查询*/MapString,Object queryOutStoreListMapper(Integer pageNum,Integer pageSize); 实现方法 @Overridepublic MapString, Object queryOutStoreListMapper(Integer pageNum, Integer pageSize) //创建Map MapString,Object result=new HashMap(); PageObject page = PageHelper.startPage(pageNum, pageSize); //查询数据库 ListOutStore outStoreList = outStoreMapper.queryOutStorListeMapper(); result.put(total,page.getTotal()); result.put(outStoreList,outStoreList); return result; OutStoreController 添加方法 /*处理出库单分页查询请求*/ @GetMapping(/outStoreList) public MapString,Object outStoreList( @RequestParam(defaultValue = 1) Integer pageNum ,@RequestParam(defaultValue = 3) Integer pageSize) return outStoreService.queryOutStoreListMapper(pageNum,pageSize); /*处理出库单确认请求*/ @GetMapping(/updateOutStore) public MapString,Object updateOutStore(Integer id) MapString,Object result=new HashMap(); result.put(code,400); result.put(msg,操作失败......); try OutStore os=new OutStore(); os.setOutsId(id); os.setIsOut(1); outStoreService.updateById(os); result.put(code,200); result.put(msg,出库单确认成功.......); catch (Exception ex) ex.printStackTrace(); return result; 前端实现 菜单表添加数据 实现前端页面 template h2出库单列表/h2 !-- table -- el-table :data=outStoreList style=width: 100% el-table-column prop=storeName label=仓库名称 / el-table-column prop=itemName label=商品名称 / el-table-column prop=outNum label=出库数量 / el-table-column prop=createBy label=出库人 / el-table-column prop=createTime label=采购时间 width=200px / el-table-column prop=isOut label=状态 template #default=scope span v-if=scope.row.isOut == 0 style=color:green未确认/span span v-else style=color:red已确认/span /template /el-table-column el-table-column fixed=right label=操作 width=240 template #default=scope el-button link type=primary size=small v-if=scope.row.isOut == 0 @click=confirmIsOut(scope.row.outsId) 确认出库/el-button /template /el-table-column /el-table !-- 分页组件 -- el-pagination small background :page-size=3 :pager-count=10 layout=prev, pager, next :total=total class=mt-4 @current-change=handlerOutStorePageChange //templatescript setup import onMounted, ref from vue; import axios from axios; import ElMessage from element-plus; //声明出库单集合 const outStoreList = ref([]); const total = ref(0); //定义汉法发生分页查询的请求 function queryItmOutServiceList(pageNum) axios .get(http://localhost:8080/outStoreList?pageNum= + pageNum) .then((response) = outStoreList.value = response.data.outStoreList; total.value = response.data.total; ) .catch((error) = console.log(error); ); //加载调用函数 onMounted(function () queryItmOutServiceList(1); ); //定义分页按钮的回调函数 function handlerOutStorePageChange(pageNum) queryItmOutServiceList(pageNum); //定义函数发生入库单确认请求 function confirmIsOut(id) axios .get(http://localhost:8080/updateOutStore?id= + id) .then((response) = if (response.data.code == 200) queryItmOutServiceList(1); //刷新列表 ElMessage(response.data.message); ) .catch((err) = console.log(err); ); /scriptstyle scoped/style 4.实现仓库数据增删改查 后端实现 StoreController 添加方法 /*处理仓库数据分页查询请求*/@GetMapping(/storePageList)public MapString, Object queryStoreList( @RequestParam(defaultValue = 1) Integer pageNum , @RequestParam(defaultValue = 10) Integer pageSize) PageStore page = new Page(pageNum, pageSize); ListStore storeList = storeService.list(page); MapString, Object result = new HashMap(); result.put(total, page.getTotal()); result.put(storeList, storeList); return result;/*添加方法处理仓库信息的添加请求*/@PostMapping(/saveStore)public MapString, Object saveStore(@RequestBody Store store) return storeService.save(store) ? R.success(保存仓库信息成功) : R.error(保存仓库信息失败);/*处理仓库信息的修改请求*/@PostMapping(/updateStore)public MapString, Object updateStore(@RequestBody Store store) return storeService.updateById(store) ? R.success(修改仓库信息成功) : R.error(修改仓库信息失败);/*处理仓库信息的删除请求*/@PostMapping(/deleteStore)public MapString, Object deleteStore(@RequestBody Store store) return storeService.removeById(store) ? R.success(删除仓库信息成功) : R.error(删除仓库信息失败); 前端实现 创建页面 template h2仓库列表/h2 div style=text-align: left el-button type=primary @click=openStoreDialog添加仓库/el-button /div !-- table组件 -- el-table :data=storeList style=width: 100% el-table-column prop=storeName label=仓库名称 / el-table-column prop=storeNum label=仓库编号 / el-table-column prop=storeAddress label=仓库地址 / el-table-column prop=concat label=联系人 / el-table-column prop=phone label=联系电话 / el-table-column fixed=right label=操作 width=240 template #default=scope el-button link type=primary size=small @click=openEditStore(scope.row) 修改/el-button el-button link type=primary size=small @click=deleteStore(scope.row.storeId) 删除/el-button /template /el-table-column /el-table !-- 分页组件 -- el-pagination background :page-size=3 :total=total size=small :pager-count=5 layout=prev, pager, next class=mt-4 @current-change=handlerStorePageChange / !-- 添加仓库信息对话框 -- el-dialog v-model=dialogStoreVisible width=80% h2 operationType === add ? 添加仓库信息 : 修改仓库信息 /h2 !-- 对话框中添加form -- el-form :model=storeForm label-width=120px el-form-item label=仓库名称 el-input v-model=storeForm.storeName style=width: 80% / /el-form-item el-form-item label=仓库编号 el-input v-model=storeForm.storeNum style=width: 80% / /el-form-item el-form-item label=仓库地址 el-input v-model=storeForm.storeAddress style=width: 80% / /el-form-item el-form-item label=联系人 el-input v-model=storeForm.concat style=width: 80% / /el-form-item el-form-item label=联系电话 el-input v-model=storeForm.phone style=width: 80% / /el-form-item el-form-item el-button type=primary @click=subStoreForm保存/el-button el-button取消/el-button /el-form-item /el-form /el-dialog/templatescript setup import onMounted, reactive, ref from vue; import ElMessage from element-plus; import storeApi from @/api/store; //声明列表集合数据 const storeList = ref([]); //声明total总记录数 const total = ref(0); //定义函数发生请求，加载列表 function queryStoreList(pageNum) storeApi .queryStoreList(pageNum) .then((response) = storeList.value = response.data.storeList; total.value = response.data.total; ) .catch((err) = console.log(err); ); //加载调用 onMounted(function () queryStoreList(1); ); //定义分页按钮回调函数 function handlerStorePageChange(pageNum) queryStoreList(pageNum); /////////////////////////添加仓库信息////////////////////////////////// //声明对话框状态 const dialogStoreVisible = ref(false); // 当前操作类型：add 或 edit const operationType = ref(add); //声明表单数据 const storeForm = reactive( storeId: , // 添加 storeId 字段 storeName: , storeNum: , storeAddress: , concat: , phone: , ); // 重置表单数据 function resetForm() storeForm.storeId = ; storeForm.storeName = ; storeForm.storeNum = ; storeForm.storeAddress = ; storeForm.concat = ; storeForm.phone = ; //声明函数打开添加仓库信息对话 function openStoreDialog() dialogStoreVisible.value = true; operationType.value = add; // 清空表单 resetForm(); //定义函数提交仓库信息保存的请求 function subStoreForm() const submitData = ...storeForm ; // 添加时删除 storeId if (operationType.value === add) delete submitData.storeId; storeApi .saveStore(submitData) .then((response) = if (response.data.code == 200) //刷新列表 queryStoreList(1); //关闭对话框 dialogStoreVisible.value = false; //清空表单 resetForm(); ElMessage(response.data.message); ) .catch((error) = console.log(error); ); else storeApi .updateStore(submitData) .then((response) = if (response.data.code == 200) //刷新列表 queryStoreList(1); //关闭对话框 dialogStoreVisible.value = false; //清空表单 resetForm(); ElMessage(response.data.message); ) .catch((error) = console.log(error); ); //实现仓库信息的回显 function openEditStore(row) operationType.value = edit; dialogStoreVisible.value = true; //将当前行数据赋值给表单进行回显 Object.assign(storeForm, row); //定义函数发生删除的ajax请求 function deleteStore(id) storeApi .deleteStore(id) .then((response) = if (response.data.code == 200) //刷新 queryStoreList(1); ElMessage(response.data.message); ) .catch((error) = console.log(error); ); /scriptstyle scoped/style Day17 1.实现客户地区分布统计 后端实现 创建 CountResult 实体类 package com.erp.dto;import lombok.Data;@Datapublic class CountResult private String name; private Integer value; CustomerMapper 添加方法 /*实现客户地区分布统计*/public ListCountResult countCustomerAreaMapper(); CustomerMapper.xml 定义 sql !--实现客户地区分布统计--select id=countCustomerAreaMapper resultType=com.erp.dto.CountResult select address name,count(0) value from t_customer group by address/select CustomerService 添加方法 /*实现客户地区分布统计*/ public ListCountResult countCustService(); CustomerServiceImpl 实现方法 @Override public ListCountResult countCustService() return customerMapper.countCustomerAreaMapper(); CustomerController 添加方法 /*处理客户地区分布统计请求*/@GetMapping(/countCust)public ListCountResult countCust() return customerService.countCustService(); 前端实现 新建 CustomerArea.vue 页面 template !-- div容器用来渲染echarts控件 -- div id=main style=width: 100%;height: 100%/div/templatescript setupimport * as echarts from echarts;import onMounted from vue;import axios from axios;//定义函数统计客户地区分布function countCustomerArea() //发送ajax请求，获得统计数据 axios .get(http://localhost:8081/countCust) .then((response) = //响应成功渲染图表 var custDom = document.getElementById(main); var custChart = echarts.init(custDom); var option = title: text: 客户地区分布统计, left: center, , tooltip: trigger: item, formatter: a br/b : c (d%), , toolbox: show: true, feature: mark: show: true , dataView: show: true, readOnly: false , restore: show: true , saveAsImage: show: true , , , series: [ name: 客户分布, type: pie, radius: [20, 140], center: [50%, 50%], roseType: area, itemStyle: borderRadius: 5, , data: response.data, , ], ; option custChart.setOption(option); ) .catch((error) = console.log(error); );//加载视图调用函数onMounted(function () countCustomerArea(););/scriptstyle scoped/style 2.实现年-月销售统计 后端实现(年统计) OrderMapper 接口定义方法 /*统计查询销售数据的年份*/ public ListInteger querySellYearMapper(); 实现接口 sql !--定义sql统计年份-- select id=querySellYearMapper resultType=java.lang.Integer select distinct year(order_date) from t_order /select OrderService 添加方法 /*统计销售数据年份*/public ListMapString, Object querySellYearService(); OrderServiceImpl 实现方法 @Override public ListMapString, Object querySellYearService() ListInteger integerList = orderMapper.querySellYearMapper(); ListMapString, Object list=new ArrayList(); for(Integer year:integerList) MapString, Object result=new HashMap(); result.put(year,year); result.put(label,year+年); list.add(result); return list; OrderController 添加方法 /*处理加载销售数据年份请求*/ @GetMapping(/queryYear) public ListMapString, Object queryYear() return orderService.querySellYearService(); 后端实现(月统计) 创建 SellResult 实体类 package com.erp.dto;import lombok.Data;@Datapublic class SellResult private Integer mth; private Double mny; OrderMapper 添加方法 /*统计查询某个年份12个月销售额*/ public ListSellResult countSellMonthMapper(String year); OrderMapper.xml 定义 sql !--统计某年12个月销售额--select id=countSellMonthMapper resultType=com.erp.dto.SellResult parameterType=java.lang.String select month(order_date) mth ,sum(pay_money) mny from t_order where year(order_date) =#year group by mth order by mth/select OrderService 添加方法 public MapString,Object queryYearMonthService(String year); OrderServiceImpl 实现方法 @Override public MapString, Object queryYearMonthService(String year) ListSellResult sellResults = orderMapper.countSellMonthMapper(year); MapString, Object result=new HashMap(); //创建封装月份数据集合 ListString mths=new ArrayList(); //封装月份销售额数据集合 ListDouble mnys=new ArrayList(); for(int m=1;m=12;m++) mths.add(m+月); mnys.add(0.0); for(SellResult sr:sellResults) System.out.println(sr=====+sr); if(sr!=null) System.out.println(sr.getMth()-1+------+sr.getMny()); Integer mth = sr.getMth(); mnys.set(mth-1,sr.getMny()); //如果某个月份存在数据，覆盖默认值0.0 result.put(xdata,mths); result.put(ydata,mnys); return result; OrderController 添加方法 /*处理某年12个月销售额的请求*/@GetMapping(/countSell)public MapString,Object countYearSell(String year) return orderService.queryYearMonthService(year); 前段实现 template h2请选择年份/h2 el-form :model=yearForm label-width=120px :inline=true el-form-item label=年份 style=width: 34% el-select v-model=yearForm.year class=m-2 placeholder=请选择年份 @change=handleYearMthSell el-option v-for=item in yearList :key=item.year :label=item.label :value=item.year / /el-select /el-form-item /el-form div id=sellCharts style=width: 100%; height: 100%/div/templatescript setup import onMounted, reactive, ref from vue; import axios from axios; import * as echarts from echarts; //声明表单数据 const yearForm = reactive( year: , ); //声明选项集合 const yearList = ref([]); //定义发送请求，加载年份数据 function loadYear() axios .get(http://localhost:8081/queryYear) .then((response) = yearList.value = response.data; ) .catch((error) = console.log(error); ); //页面加载调用函数 onMounted(function () loadYear(); ); //下拉列表框选择内容发生变化的回调函数 function handleYearMthSell(year) console.log(year); //发生请求加载数据 axios .get(http://localhost:8081/countSell?year= + year) .then((response) = var sellDom = document.getElementById(sellCharts); var sellChart = echarts.init(sellDom); var option = xAxis: type: category, data: response.data.xdata, , yAxis: type: value, , series: [ data: response.data.ydata, type: bar, showBackground: true, backgroundStyle: color: rgba(180, 180, 180, 0.2), , , ], ; option sellChart.setOption(option); ) .catch((error) = ); /scriptstyle scoped/style Day18 1.实现员工信息统计 后端实现（年龄分布统计） UserMapper 接口添加方法 /* 实现员工按照年龄段分布统计 */public ListCountResult countEmployeeAageMapper(); UserMapper.xml 定义 SQL !-- 实现员工年龄段分布统计 --select id=countEmployeeAageMapper resultType=com.erp.dto.CountResult select count(id) value, CASE WHEN age between 18 and 25 THEN [18 TO 25] WHEN age between 26 and 30 THEN [26 TO 30] WHEN age between 31 and 35 THEN [31 TO 35] WHEN age between 36 and 40 THEN [36 TO 40] WHEN age between 41 and 45 THEN [41 TO 45] ELSE [56 TO 100] END name from t_user group by name/select UserService 添加方法 /* 实现员工按照年龄段分布统计 */public ListCountResult countEmployeeAageService(); UserServiceImpl 实现方法 @Overridepublic ListCountResult countEmployeeAageService() return userMapper.countEmployeeAageMapper(); UserController 添加方法 /* 处理员工年龄分布统计请求 */@GetMapping(/countEmpAge)public ListCountResult countEmpAge() return userService.countEmployeeAageService(); 后端实现（学历分布统计） UserMapper 添加方法 /* 实现员工按照学历统计 */public ListCountResult countEmployeeEduMapper(); UserMapper.xml 定义 sql !-- 定义sql统计员工学历分布 --select id=countEmployeeEduMapper resultType=com.erp.dto.CountResult select edu name, count(id) value from t_user group by edu/select UserService 添加方法 /* 实现员工学历分布统计 */public ListCountResult countEmployeeEduService(); UserServiceImpl 实现方法 @Overridepublic ListCountResult countEmployeeEduService() return userMapper.countEmployeeEduMapper(); UserController 添加方法 /* 处理员工学历分布统计的请求 */@GetMapping(/countEmpEdu)public ListCountResult countEmpEdu() return userService.countEmployeeEduService(); 前端实现 在 menu 表中注册页面 实现员工信息统计页面 template h2员工信息统计/h2 el-button type=success @click=countEmpAge年龄分布统计/el-button el-button type=success @click=countEmpEdu学历分布统计/el-button hr / div id=empInfo style=width:100%;height: 100%/div/templatescript setup //定义函数发生请求，统计年龄分部 import * as echarts from echarts; import onMounted from vue; import axios from axios; function countEmpAge() axios .get(http://localhost:8081/countEmpAge) .then((response) = //获得显示echarts控件的dom var empDom = document.getElementById(empInfo); //创建echarts对象 var ageEcharts = echarts.init(empDom); var option = tooltip: trigger: item, , legend: top: 5%, left: center, , series: [ name: 员工年龄分部, type: pie, radius: [40%, 70%], avoidLabelOverlap: false, padAngle: 5, itemStyle: borderRadius: 10, , label: show: false, position: center, , emphasis: label: show: true, fontSize: 40, fontWeight: bold, , , labelLine: show: false, , data: response.data, , ], ; option ageEcharts.setOption(option); ) .catch((error) = ); //页面加载调用函数 onMounted(function () countEmpAge(); ); //定义函数统计员工学历分布 function countEmpEdu() axios .get(http://localhost:8081/countEmpEdu) .then((response) = //实现echarts控件数据的渲染 //获得显示echarts控件的dom var empDom = document.getElementById(empInfo); //创建echarts对象 var eudEcharts = echarts.init(empDom); var option = tooltip: trigger: item, , legend: top: 5%, left: center, , series: [ name: 员工学历分部, type: pie, radius: [40%, 70%], avoidLabelOverlap: false, padAngle: 5, itemStyle: borderRadius: 10, , label: show: false, position: center, , emphasis: label: show: true, fontSize: 40, fontWeight: bold, , , labelLine: show: false, , data: response.data, , ], ; option eudEcharts.setOption(option); ) .catch((error) = console.log(error); ); /scriptstyle scoped/style 修改 index.vue，注册页面 2.实现投诉问题统计 后端实现（问题类型统计） AfterSalesMapper 添加方法 /* 实现投诉按照类型统计 */public ListCountResult countQuestionTypeService(); AfterSalesMapper.xml 定义 sql select id=countQuestionTypeMapper resultType=com.erp.dto.CountResult select sum value, concat(question, : , TRUNCATE(sum/total*100, 2), %) name from ( select question, count(id) sum, (select count(id) from t_after_sales) total from t_after_sales group by question ) out_table/select AfterSalesService 添加方法 /* 实现投诉按照类型统计 */public ListCountResult countQuestionTypeService(); AfterSalesServiceImpl 实现方法 @Overridepublic ListCountResult countQuestionTypeService() return afterSalesMapper.countQuestionTypeMapper(); AfterSalesController 添加方法 /* 处理投诉问题类型统计请求 */@GetMapping(/countQuestionType)public ListCountResult countQuestionType() return afterSalesService.countQuestionTypeService(); 后端实现（问题状态统计） AfterSalesMapper 添加方法 /* 按照处理状态进行投诉统计 */public ListCountResult countQuestionStateMapper(); AfterSalesMapper.xml 顶级 sql !-- 定义sql按照投诉处理状态，进行统计 --select id=countQuestionStateMapper resultType=com.erp.dto.CountResult select sum value, concat( [ , state, ] , TRUNCATE(sum/total*100, 2), %) name from ( select state, count(id) sum, (select count(id) from t_after_sales) total from t_after_sales group by state ) out_table/select AfterSalesService 添加方法 /* 实现投诉按照处理状态统计 */public ListCountResult countQuestionStateService(); AfterSalesServiceImpl 实现方法 @Overridepublic ListCountResult countQuestionStateService() return afterSalesMapper.countQuestionStateMapper(); AfterSalesController 添加方法 /* 处理投诉问题按照处理状态进行统计的请求 */@GetMapping(/countQuestionState)public ListCountResult countQuestionState() return afterSalesService.countQuestionStateService(); 前端实现 在 menu 表中注册页面 实现投诉问题统计页面 template h2投诉统计/h2 el-button type=success @click=questionTypeCount投诉类型统计/el-button el-button type=success @click=questionStateCount回复状态统计/el-button div id=questionInfo style=width:100%;height: 100%/div/templatescript setup //定义函数发生请求，加载投诉类型统计数据 import * as echarts from echarts; import onMounted from vue; import axios from axios; function questionTypeCount() axios .get(http://localhost:8081/countQuestionType) .then((response) = //获得显示echarts控件的dom var questionDom = document.getElementById(questionInfo); //创建echarts对象 var typeEcharts = echarts.init(questionDom); var option = tooltip: trigger: item, , legend: top: 5%, left: center, , series: [ name: 投诉问题类型数据, type: pie, radius: [40%, 70%], avoidLabelOverlap: false, padAngle: 5, itemStyle: borderRadius: 10, , label: show: false, position: center, , emphasis: label: show: true, fontSize: 40, fontWeight: bold, , , labelLine: show: false, , data: response.data, , ], ; option typeEcharts.setOption(option); ) .catch((error) = console.log(error); ); //页面加载调用函数 onMounted(function () questionTypeCount(); ); //定义函数发生按照回复状态进行统计的请求 function questionStateCount() axios .get(http://localhost:8081/countQuestionState) .then((response) = //获得dom对象 var quesDom = document.getElementById(questionInfo); //初始化echarts对象 var stateEcharts = echarts.init(quesDom); var option = //完成echarts控件渲染的配置 tooltip: trigger: item, , legend: top: 5%, left: center, , series: [ name: 回复状态统计, type: pie, radius: [40%, 70%], avoidLabelOverlap: false, padAngle: 5, itemStyle: borderRadius: 10, , label: show: false, position: center, , emphasis: label: show: true, fontSize: 40, fontWeight: bold, , , labelLine: show: false, , data: response.data, , ], ; option stateEcharts.setOption(option); ) .catch((error) = console.log(error); ); /scriptstyle scoped/style 修改 index.vue，注册页面 3.实现统计 12 个月销售量 后端实现 OrderMapper 添加方法 /*实现年12个月销售商品数量的统计*/ public ListSellResult countSellNumMapper(String year); OrderMapper.xml 定义 sql !-- 实现某年12个月，每个月销售量的统计 --select id=countSellNumMapper resultType=com.erp.dto.SellResult select month(order_date) mth, sum(num) mny from t_order where year(order_date)=#year group by mth order by mth/select OrderService 添加方法 /* 统计年每个月销售商品的数量 */public MapString, Object querySellNumService(String year); OrderServiceImpl 实现方法 @Overridepublic MapString, Object querySellNumService(String year) // 查询数据库 ListSellResult sellResults = orderMapper.countSellNumMapper(year); // 创建List集合封装每年12个月 ListString mths = new ArrayList(); // 创建List集合封装每个12个月的销售数量 ListDouble nums = new ArrayList(); // 初始化集合 for (int x = 1; x = 12; x++) mths.add(x + 月); nums.add((double) 0); // 根据对应月份的具体的销售数量，覆盖默认数量0 for (SellResult sr : sellResults) if (sr != null) nums.set(sr.getMth() - 1, sr.getMny()); // 将响应数据放入Map集合 MapString, Object result = new HashMap(); result.put(xdata, mths); result.put(ydata, nums); return result; OrderController 添加方法 /* 处理年12个月，每个月销售数量统计的请求 */@GetMapping(/countNum)public MapString, Object countNum(String year) return orderService.querySellNumService(year); 前端实现 在 menu 表中注册页面 实现销售额统计页面 template !-- 后台主页布局 -- div class=common-layout el-container el-header class=topERP-欢乐斗地主小组/el-header el-container el-aside width=240px class=left 系统菜单 !--添加Menu菜单组件-- el-menu class=el-menu-vertical-demo @select=handlerSelect el-sub-menu v-for=menu in menus :index=String(menu.id) template #title span menu.label /span /template el-menu-item v-for=subMenu in menu.subMenus :index=String(subMenu.id) subMenu.label /el-menu-item /el-sub-menu /el-menu /el-aside el-main class=right !--通过点击左边菜单，动态显示不同组件 -- !-- component :is=currentComponent/component-- component :is=currentComponent/component /el-main /el-container /el-container /div/templatescript setup import AddCustomer from @/views/AddCustomer; import ListCustomer from @/views/ListCustomer; import AddSellJh from @/views/AddSellJh; import ListSellJh from @/views/ListSellJh; import ListCustOrder from @/views/ListCustOrder; import ListAfterSale from @/views/ListAfterSale; import TreeDemo from @/views/TreeDemo; import AddMenus from @/views/AddMenus; import RoleManager from @/views/RoleManager; import UserManager from @/views/UserManager; import CategoryManager from @/views/CategoryManager; import ItemManager from @/views/ItemManager; import BuyListManager from @/views/BuyListManager; import InStoreList from @/views/InStoreList; import ListOutStore from @/views/ListOutStore; import ListStore from @/views/ListStore; import CustomerArea from @/views/CustomerArea; import YearMonthCount from @/views/YearMonthCount; import EmployeeCount from @/views/EmployeeCount; import AfterSaleCount from @/views/AfterSaleCount; import YearNumCount from @/views/YearNumCount; import onMounted, ref from vue; import axios from axios; //声明数组保存所有组件 const views = [ AddCustomer, ListCustomer, ListAfterSale, ListCustOrder, AddSellJh, CustomerArea, YearMonthCount, ListSellJh, AddMenus, UserManager, RoleManager, , TreeDemo, , CategoryManager, ItemManager, BuyListManager, InStoreList, ListOutStore, ListStore, EmployeeCount, AfterSaleCount, YearNumCount, ]; //声明变量保存当前需要显示的组件名 const currentComponent = ref(views[0]); //声明菜单对象集合数据 const menus = ref([]); /*menu组件选中叶子节点触发的函数，参数index：菜单节点的index值，对应数据库菜单节点的id*/ const handlerSelect = function (id) console.log(id); //发生ajax请求，加载组件下标 axios .get(http://localhost:8081/compIndex?id= + id) .then((response) = //动态该currentComponent赋值,从组件集合views中获取的组件名字 currentComponent.value = views[response.data]; ) .catch((error) = console.log(error); ); ; //页面加载，发生ajax请求加载左侧菜单信息 onMounted(function () axios .get(http://localhost:8081/listMenus) .then((response) = console.log(response); //将响应的数据绑定到menus，实现数据渲染 menus.value = response.data; ) .catch((error) = console.log(error); ); );/scriptstyle scoped .top background-color: azure; padding-top: 15px; .left background-color: blanchedalmond; height: 600px; .right background-color: cornsilk; /style 修改 index.vue，注册页面 Day22 1.实现 session 会话跟踪 为什么前后分离会导致 Session 失效？ 现象：在前后分离项目（如 Vue + Spring Boot）中，客户端每次向后端发送请求，后端都会创建一个全新的 Session 对象。这导致无法通过 Session 跟踪用户的登录状态等会话信息。 根本原因： Session 机制依赖于 Cookie。服务器首次创建 Session 后，会将 Session ID 放在 Cookie 中返回给浏览器。 浏览器在后续请求中，会自动携带这个 Cookie，服务器通过 Cookie 中的 Session ID 找到对应的 Session。 但在前后分离架构下，前端（如 http://localhost:8080）和后端（如 http://localhost:8888）属于跨域。出于安全策略，浏览器默认不会在跨域请求中发送 Cookie 等凭证信息。 结果：后端收不到 Session ID，只能把每次请求都当作新客户端，从而创建新的 Session。 解决方案：前后端协同，开启凭证（Cookie）传递 要解决此问题，必须让浏览器在跨域请求时携带 Cookie，同时让服务器允许接收这个跨域的 Cookie。这需要前后端共同配置。 后端实现 放弃在每个 Controller 上写 @CrossOrigin 注解。通过 WebMvcConfigurer 实现全局配置，并通过配置文件管理 URL，实现与代码解耦。 第一步：在 application.properties 中定义前端地址 # 允许跨域的前端源地址，多个用逗号隔开cors.allowed-origins=http://localhost:8080,https://your.production.site 第二步：创建全局跨域配置类 @Configurationpublic class CrossOriginConfig implements WebMvcConfigurer // 从配置文件动态读取允许的源 @Value($cors.allowed-origins) private String[] allowedOrigins; @Override public void addCorsMappings(CorsRegistry registry) registry.addMapping(/**) // 匹配所有接口 .allowedOrigins(allowedOrigins) // 使用动态配置的源 .allowedMethods(GET, POST, PUT, DELETE) .allowedHeaders(*) .allowCredentials(true); // 核心：允许服务器处理凭证(Cookie) 前端实现 在全局统一的 Axios 实例中进行配置，让所有请求自动携带凭证，无需改动任何业务组件。 修改全局 Axios 实例 (request.js 或类似文件) import axios from axios;// 创建 axios 实例const request = axios.create( // baseURL, timeout等配置保持不变... baseURL: process.env.NODE_ENV === production ? /api : http://localhost:8888, timeout: 5000, withCredentials: true, // 核心：让所有请求自动携带Cookie);export default request; 一句话总结：后端配置 allowCredentials(true)，前端配置 withCredentials: true，并将具体 URL 写入配置文件中，实现代码与环境的完全分离。 2.实现用户登录 暂时省略 3 查询当前登录用户菜单 后端实现 UserMapper 添加方法 /\\*加载当前登录用户菜单信息\\*/ public List queryUserMenusMapper(Integer uid); 4.2UserMapper.xml 定义 sql select distinct menus.\\* from t_menus menus inner join t_role_menu rm on menus.id=rm.mid inner join t_user_role ur on rm.rid=ur.rid where ur.uid=#uid 4.3UserService 添加方法 /\\*加载左侧导航菜单，根据当前用户加载\\*/ public List queryUserMenusListService(Integer uid); 4.4UserServiceImpl 实现方法 @Override public List queryUserMenusListService(Integer uid) List menus = userMapper.queryUserMenusMapper(uid); return doListMenus(menus,0); private List doListMenus(List menus,Integer id) //创建集合对象保存返回值 List result=new ArrayList(); //遍历menus集合获得每个菜单节点对象，m每个菜单节点对象 for(Menus m:menus) //m菜单节点对象的父节点id，是否和传入id相等，如果相等说明当前遍历的节点m，是id对应的菜单节点的子节点 if(m.getPid().equals(id)) MenusVo menusVo=new MenusVo(); BeanUtils.copyProperties(m,menusVo); //进行递归遍历 menusVo.setSubMenus(doListMenus(menus,m.getId())); result.add(menusVo); return result; 4.5UserController 添加方法 /\\*处理加载当前登录用户菜单的请求\\*/ @GetMapping(/queryUserMenus) public List queryUserMenus(HttpSession session) //获得系统当前登录用户 User user= (User) session.getAttribute(online); return userService.queryUserMenusListService(user.getId()); 4.6 修改 index.vue 杂项 0.配置编辑器提升编码体验 格式化代码 教程：VS Code 批量格式化文件 IDEA 格式化项目中所有文件的方法 自动导包 IDEA 自动导包删除包（图文讲解） 多文件搜索 在写 java 代码的时候，经常需要找到某个实体类相关的 mapper，service 和 controller 代码 在 idea 中，可以双击shift按钮打开全局搜索，搜索该层级代码即可快速找到并打开相关代码文件 1.屏蔽某些不影响程序的警告 前端 改变窗口大小时弹出黑框警告 按照下面的教程在 main.js 里加代码就行 element-plus 的 el-select 报 ResizeObserver loop completed with undelivered notifications 错的一种可能原因及解决方案 样式定义错误警告 如果遇到以下报错 runtime-core.esm-bundler.js:238 [Vue warn]: Invalid prop: custom validator check failed for prop pagerCount. at ElPagination small= background= page-size=10 ... 需要看看相关定义是不是缺少属性值 例如我这里就是没有指定是 size 属性，而是直接写了 small 值 错误代码： el-pagination small background :page-size=10 :pager-count=7 layout=prev, pager, next :total=total class=mt-4 @current-change=rolerPageChange/ 正确代码： el-pagination size=small background :page-size=10 :pager-count=7 layout=prev, pager, next :total=total class=mt-4 @current-change=rolerPageChange/ Invalid prop 警告 遇到类似下面这种警告 runtime-core.esm-bundler.js:238 [Vue warn]: Invalid prop: custom validator check failed for prop pagerCount.at ElPagination size=small background= page-size=10 ... 这是应为pagerCount 属性必须是 5 到 21 之间的奇数 例如下面这个位置，pager-count 必须为奇数 el-pagination size=small background :page-size=10 :pager-count=7 layout=prev, pager, next :total=totalReplay class=mt-4 @current-change=handlerReplayPageChange/ 后端 解决 mybatis 的 mapper 文件中错误 报错提示：应为 ＜ statement ＞ 或 DELIMITER，得到 ‘id‘ 解决方法 2.优化接口的定义 后端优化 优化策略与辅助工具： 在进行 Controller 精简时，引入以下辅助机制： 统一响应工具类 (ResponseUtil)： 创建一个工具类来生成标准的成功和失败响应体。这个类包含静态方法，用于构建包含 code（状态码）、message（/msg，提示信息）以及可选的 data（业务数据）字段的 MapString, Object 或自定义响应对象。这样避免在每个 Controller 方法中手动创建和填充 HashMap。 我用的ResponseUtil 方法如下： package com.example.demo.util;import java.util.HashMap;import java.util.Map;public class ResponseUtil private static final String KEY_CODE = code; private static final String KEY_MESSAGE = message; public static MapString, Object success(String message) MapString, Object result = new HashMap(); result.put(KEY_CODE, 200); result.put(KEY_MESSAGE, message); return result; public static T MapString, Object success(String message, T data) MapString, Object result = success(message); result.put(data, data); return result; public static MapString, Object error(int code, String message) MapString, Object result = new HashMap(); result.put(KEY_CODE, code); result.put(KEY_MESSAGE, message); return result; // 默认错误 public static MapString, Object error(String message) return error(400, message); 全局异常处理 (@ControllerAdvice @ExceptionHandler)： 通过创建一个使用 @ControllerAdvice 注解的类，并结合 @ExceptionHandler 注解的方法，可以集中处理所有 Controller（或指定包下的 Controller）抛出的异常。这样做的好处是： Controller 方法中不再需要 try-catch 块来捕获通用异常。 统一了错误响应的格式。 便于统一记录错误日志。 可以针对不同类型的异常返回不同的 HTTP 状态码和错误信息。 我用的全局异常处理代码： package com.example.demo.config;import com.example.demo.util.ResponseUtil;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;import java.util.Map;@ControllerAdvice@ResponseBody //确保返回的是JSONpublic class GlobalExceptionHandler private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class); @ExceptionHandler(Exception.class) public MapString, Object handleGlobalException(Exception e) logger.error(发生未捕获异常: , e); // 记录日志 return ResponseUtil.error(500, 服务器内部错误，请稍后再试或联系管理员); Service 层承担业务逻辑： 确保所有业务相关的操作（即使是简单的 CRUD）都封装在 Service 层。Controller 的职责是接收 HTTP 请求，验证和转换参数（如果需要），调用相应的 Service 方法，然后根据 Service 的返回结果（或通过全局异常处理器）构建响应。这使得 Controller 保持“瘦”，业务逻辑也更易于复用和测试。 现在，让我们看看 OrderController 在应用这些策略前后的代码对比。 优化前优化后在优化之前，OrderController 的每个方法都包含了手动创建响应 Map 以及 try-catch 块来处理异常和构建不同状态的响应。 /* 添加订单 */@PostMapping(/saveOrder)public MapString, Object saveOrder(@RequestBody Order order) MapString, Object result = new HashMap(); try orderService.save(order); result.put(code, 200); result.put(message, 添加成功); catch (Exception e) result.put(code, 400); result.put(message, 添加失败); return result;/* 删除订单 */@DeleteMapping(/deleteOrder/id)public MapString, Object deleteOrder(@PathVariable Integer id) MapString, Object result = new HashMap(); try orderService.removeById(id); result.put(code, 200); result.put(message, 删除成功); catch (Exception e) result.put(code, 400); result.put(message, 删除失败); return result;/* 修改订单 */@PutMapping(/updateOrder)public MapString, Object updateOrder(@RequestBody Order order) MapString, Object result = new HashMap(); try orderService.updateById(order); // MybatisPlus IService 方法返回 boolean result.put(code, 200); result.put(message, 修改成功); catch (Exception e) result.put(code, 400); result.put(message, 修改失败); return result; 应用了上述优化策略后，Controller 代码变得更加简洁和专注。 /* 添加订单 */@PostMapping(/saveOrder)public MapString, Object saveOrder(@RequestBody Order order) // Service 层 save 方法若失败会抛出异常，由全局异常处理器捕获 orderService.save(order); return ResponseUtil.success(添加成功);/* 删除订单 */@DeleteMapping(/deleteOrder/id)public MapString, Object deleteOrder(@PathVariable Integer id) boolean removed = orderService.removeById(id); if (removed) return ResponseUtil.success(删除成功); else return ResponseUtil.error(400, 删除失败，订单可能不存在);/* 修改订单 */@PutMapping(/updateOrder)public MapString, Object updateOrder(@RequestBody Order order) boolean updated = orderService.updateById(order); if (updated) return ResponseUtil.success(修改成功); else return ResponseUtil.error(400, 修改失败，订单可能不存在或数据无变更); Controller 方法体大大缩减，逻辑更清晰。更专注于接收请求、调用 Service 和基于 Service 的直接业务结果（如 boolean 返回值）来构建响应。 统一处理：异常由GlobalExceptionHandler 统一处理，响应由ResponseUtil 统一构建。 易于维护：修改响应格式或异常处理逻辑时，只需改动工具类或全局处理器。 健壮性提升：对于 Service 层返回 boolean 的方法，优化后的代码能更明确地根据业务结果来判断成功或失败，并给出相应的提示。 引入统一响应处理和全局异常捕获机制后，有效地精简 Controller 层的代码，使其职责更加单一，从而提高整个后端应用的开发效率和代码质量。对于那些 Service 方法本身就返回特定数据结构（如分页查询直接返回 Map）的接口，可以保持其原有返回，因为它们不一定适用标准的 code/message 包装。 前端优化 暂时省略","tags":[null],"categories":[null]},{"title":"LVGL 图像与字体使用笔记","path":"/data/ES/图形界面开发/LVGL 图像与字体使用笔记.html","content":"本笔记以我示例项目中的 obj/myexample.c 系列函数作为核心代码示例进行讲解 配置好跨平台规则的项目链接：跨平台 LVGL 项目模板 1. 图像 从 C 数组加载 (有限图像场景) 这种方法适合图标、背景图等固定不变的图像资源。它将图片数据直接编译进程序中，运行效率高，但不灵活。 核心步骤： 转换： 使用 LVGL 官方的 在线图像转换工具 将你的图片转换为一个 C 语言源文件。 这个 C 文件中会包含一个 lv_img_dsc_t 类型的数组，存储了图像的所有像素数据 按照下图选项来输出适合 v8 版本的图片 注意：如果图片里带有透明图层，颜色格式需要选择CF_TRUE_COLOR_ALPHA而不是CF_TRUE_COLOR，只有保存了ALPHA通道信息才能正常显示透明部分 编译： 将生成的 .c 文件添加到你的项目 CMake 中，并确保它能被编译链接 使用： 在代码中通过 LV_IMG_DECLARE 声明该图像资源，然后使用 lv_img_set_src 将其设置给一个图像对象 代码示例 以下代码演示了如何显示一个已经通过工具转换好的，名为 abc 的图像。 // obj/myexample.cvoid demo_sjpg_from_array( ) // 声明图片数据所在的数组名称 // 这个宏会引用在 abc.c 文件中定义的图像数组变量 LV_IMG_DECLARE(abc); lv_obj_t* img = lv_img_create(lv_scr_act()); // 创建一个图像对象 lv_img_set_src(img, abc); // 将图像资源设置给对象 lv_obj_center(img); // 图片居中显示 从文件系统加载 (不限图像场景) 当需要显示不固定的图片（如照片、网络下载的图片）时，就需要使用此方法。它要求 LVGL 能够访问设备的文件系统。 核心步骤： 配置 lv_conf.h： 开启文件系统支持：将 LV_USE_FS_STDIO 或其他文件系统接口设置为 1。 定义 “盘符”：设置 LV_FS_STDIO_LETTER 为一个大写字母，例如 'A'。此后，所有文件路径都必须以 A:/ 开头。 放置文件：将图片文件（如 small_image.sjpg）放置到你的设备文件系统的某个路径下（如 /mnt/nfs/）。 使用：在代码中，使用 lv_img_set_src 并传入 盘符 + 绝对路径 格式的字符串。 代码示例 以下代码演示了如何从设备的 /mnt/nfs/ 目录下加载并显示 small_image.sjpg 图片。 void demo_sjpg_from_file( ) lv_obj_t* img = lv_img_create(lv_scr_act()); // 创建一个图像对象 // 设置图像源为文件路径 // A: 是在 lv_conf.h 中定义的盘符 // /mnt/nfs/small_image.sjpg 是图片在设备上的实际路径 lv_img_set_src(img, A:/mnt/nfs/small_image.sjpg); lv_obj_center(img); // 将图片居中显示 安装 PNG 解码库 (依赖 zlib) PNG 库依赖 zlib 库，因此需要先编译安装 zlib，再编译安装 libpng。以下教程针对交叉编译环境，提供了避免常见陷阱的详细步骤。 1. 安装 zlib 压缩库 Ubuntu/Linux 用一句命令即可直接安装 sudo apt install zlib1g-dev 开发板 / 其他平台 需手动下载、交叉编译并链接： 官网 源码下载地址 进入 zlib 源码目录进行配置和编译。 关键提示： 为了避免后续在链接动态库时出现 recompile with -fPIC 的错误，我们必须在编译静态库时就生成“位置无关代码”(Position-Independent Code)。 推荐的编译命令 (生成静态库 .a): # 指定交叉编译器export CC=arm-linux-gcc# 使用 CMAKE_POSITION_INDEPENDENT_CODE=ON 来添加 -fPIC 标志cmake -B build -D CMAKE_BUILD_TYPE=Release -D CMAKE_POSITION_INDEPENDENT_CODE=ON# 编译cmake --build build -j12 编译完成后，会在 build 目录下生成 libz.a 文件。 2. 安装 libpng 库 Ubuntu/Linux 用一句命令即可直接安装 sudo apt install libpng-dev 开发板 / 其他平台 需手动下载、交叉编译并链接： 官网 源码下载地址 进入 libpng 源码目录进行配置和编译。 关键提示： 在交叉编译时，libpng 的构建系统无法自动找到我们刚刚编译好的 zlib。我们必须通过 CMake 参数明确地告诉它 zlib 的头文件和库文件在哪里。 推荐的编译命令 (生成静态库 .a): # 指定交叉编译器export CC=arm-linux-gcc# 运行 cmake，并用 -D 参数明确指定 zlib 的路径# 注意：请将 path/to 替换为你的实际路径，不要使用 ~cmake -B build \\ -D CMAKE_BUILD_TYPE=Release \\ -D BUILD_SHARED_LIBS=OFF \\ -D ZLIB_INCLUDE_DIR=path/to/zlib-1.3.1 \\ -D ZLIB_LIBRARY=path/to/zlib-1.3.1/build/libz.a \\ -D CMAKE_C_FLAGS=-Ipath/to/zlib-1.3.1/build# 编译cmake --build build -j12 参数详解: -D ZLIB_INCLUDE_DIR: 指向 zlib 的源码根目录，用于找到 zlib.h。 -D ZLIB_LIBRARY: 明确指向编译生成的 libz.a 静态库文件。 -D CMAKE_C_FLAGS=-I...: 额外添加一个头文件搜索路径，指向 zlib 的构建目录，用于找到编译时生成的 zconf.h。 编译完成后，会在 build 目录下生成 libpng16.a 文件。 CMake 工程链接 PNG 与 ZLIB 在链接时，必须同时链接 libpng 和 zlib。由于我们编译的是静态库，CMake 中也应配置为链接静态库。 if(CMAKE_CROSSCOMPILING) # ARM 平台 set(TARGET_PLATFORM arm) # --- 为 FreeType 添加 (静态库示例) --- add_library(freetype_local STATIC IMPORTED GLOBAL) set_target_properties(freetype_local PROPERTIES IMPORTED_LOCATION $CMAKE_CURRENT_SOURCE_DIR/libs/freetype/lib/arm/libfreetype.a ) # --- 为 PNG 添加 (静态库) --- add_library(png_local STATIC IMPORTED GLOBAL) set_target_properties(png_local PROPERTIES # 假设你已将编译好的 libpng16.a 复制到此路径 IMPORTED_LOCATION $CMAKE_CURRENT_SOURCE_DIR/libs/png/lib/arm/libpng16.a ) # --- 为 ZLIB 添加 (静态库) --- add_library(zlib_local STATIC IMPORTED GLOBAL) set_target_properties(zlib_local PROPERTIES # 假设你已将编译好的 libz.a 复制到此路径 IMPORTED_LOCATION $CMAKE_CURRENT_SOURCE_DIR/libs/zlib/lib/arm/libz.a ) # --- 将所有库加入列表 (注意链接顺序) --- set(PLATFORM_LIBS pthread freetype_local png_local zlib_local m)elseif(UNIX AND NOT APPLE) # Linux PC 平台 set(TARGET_PLATFORM pc) find_package(SDL2 REQUIRED) find_package(Threads REQUIRED) find_package(Freetype REQUIRED) # --- 查找 PNG 和 ZLIB --- find_package(PNG REQUIRED) find_package(ZLIB REQUIRED) # --- 将所有库加入列表 (使用现代CMake目标) --- set(PLATFORM_LIBS SDL2::SDL2 Threads::Threads Freetype::Freetype PNG::PNG ZLIB::ZLIB m)endif() 使用方法和之前一样，如果还是不行，用下面的函数调试： static void debug_load_image(const char* path_to_test) LV_LOG_USER(--- 开始终极调试: %s ---, path_to_test); // 步骤 1: 检查 LVGL 文件系统驱动是否就绪 if (!lv_fs_is_ready(A)) LV_LOG_ERROR(错误: LVGL 文件系统驱动 A 未就绪!); return; LV_LOG_USER(调试信息: LVGL 文件系统驱动 A 已就绪。); // 步骤 2: 尝试用 LVGL 的 API 打开文件 lv_fs_file_t f; lv_fs_res_t res = lv_fs_open(f, path_to_test, LV_FS_MODE_RD); if (res != LV_FS_RES_OK) LV_LOG_ERROR(错误: LVGL lv_fs_open 失败! 错误码: %d, res); else LV_LOG_USER(调试成功: LVGL lv_fs_open 成功!); lv_fs_close(f); // 步骤 3: 作为对比，尝试用标准 C 的 API 打开同一个文件 FILE* std_f = fopen(path_to_test, rb); if (std_f == NULL) LV_LOG_ERROR(错误: 标准 C fopen 失败!); else LV_LOG_USER(调试成功: 标准 C fopen 成功!); fclose(std_f); LV_LOG_USER(--- 终极调试结束 ---); 可以开启 lv_conf.h 里面的这个选项来缓存图片，使 cpu 占用降低： #define LV_IMG_CACHE_DEF_SIZE 2 2. 字体 LVGL 内置字体对中文支持不佳，推荐使用外部字体。最灵活、支持最全面的方式是集成 FreeType 字体库 使用 FreeType 加载外部字体（不限汉字场景） 此方法支持动态加载标准字体文件（如 .ttf），可直接显示任意汉字，无需预先转换 1. 配置与编译 开启 LVGL FreeType 支持 在 lv_conf.h 中设置： #define LV_USE_FREETYPE 1 安装 FreeType 库 Ubuntu/Linux 用一句命令即可直接安装 sudo apt install libfreetype6-dev 开发板 / 其他平台 需手动下载、交叉编译并链接： 官网 源码下载地址 将源码下载下来放到项目根目录 进入 freetype 源码目录命令行，进行以下配置和编译操作 编译为动态库： # 指定交叉编译器export CC=arm-linux-gcccmake -B build -D BUILD_SHARED_LIBS=true -D CMAKE_BUILD_TYPE=Release #编译cmake --build build -j12 或者编译为静态库： # 指定交叉编译器export CC=arm-linux-gcccmake -B build -D BUILD_SHARED_LIBS=OFF -D CMAKE_BUILD_TYPE=Release # 编译cmake --build build -j12 CMake 工程链接 FreeType if(CMAKE_CROSSCOMPILING) # ARM 平台 set(TARGET_PLATFORM arm) add_library(freetype_local SHARED IMPORTED GLOBAL) set_target_properties(freetype_local PROPERTIES # ARM 平台需要指定库程序路径 IMPORTED_LOCATION $CMAKE_CURRENT_SOURCE_DIR/libs/freetype/lib/arm/libfreetype.so ) set(PLATFORM_LIBS pthread freetype_local m)elseif(UNIX AND NOT APPLE) # Linux PC 平台 set(TARGET_PLATFORM pc) find_package(SDL2 REQUIRED) find_package(Threads REQUIRED) # 直接去系统库里面找 set(PLATFORM_LIBS SDL2::SDL2 Threads::Threads freetype m)endif() 2. 准备字体文件 将所需 .ttf 文件（如 MiSans.ttf）放到设备文件系统中，保证程序运行时可访问。 3. 使用方法 代码初始化 FreeType 字体 → 创建样式 → 应用到控件。 void demo_freetype_text(void) // 1. 初始化字体信息 static lv_ft_info_t info; // 确保字体文件在相对编译出的程序路径下 info.name = ./MiSans.ttf; info.weight = 24; info.style = FT_FONT_STYLE_NORMAL; info.mem = NULL; if (!lv_ft_font_init(info)) // 初始化字体 LV_LOG_ERROR(FreeType 初始化失败.); return; // 2. 创建一个样式来使用这个字体 static lv_style_t style; lv_style_init(style); // 将刚刚初始化好的字体设置到样式中 lv_style_set_text_font(style, info.font); lv_style_set_text_align(style, LV_TEXT_ALIGN_CENTER); // 3. 创建标签并应用样式 lv_obj_t* label = lv_label_create(lv_scr_act()); lv_obj_add_style(label, style, 0); // 应用前面设置的style样式 // 以后显示中文时像上面一样引用这个样式即可 lv_label_set_text(label, 你好, LVGL Im a font created with FreeType); lv_obj_center(label);","tags":[null],"categories":[null]},{"title":"LVGL 核心概念笔记","path":"/data/ES/图形界面开发/LVGL 核心概念笔记.html","content":"本笔记以项目中的 obj/myexample.c 系列函数作为核心代码示例进行讲解 配置好跨平台的项目链接：跨平台 LVGL 项目模板 1. LVGL 的对象与盒子模型 在 LVGL 中，所有图形元素（部件/Widgets）都是基于对象的。这种面向对象的思想，使得图形界面的构建模块化且易于管理。 核心理念 父子结构: 每个被创建的对象都有一个父对象。屏幕本身也是一个对象，通常作为最顶层的父对象。子对象的位置是相对于父对象的，并且其可见范围不会超出父对象的边界。 获取当前活动的屏幕: lv_scr_act() 创建一个新的对象: lv_obj_t *lv_obj_create(lv_obj_t *parent); 继承与派生: 所有不同类型的部件（如按钮、标签）都继承自一个基础的 lv_obj_t 结构体，并在此之上进行功能的扩展与具体化。 代码示例：创建对象 void demo_create_basic_objects(void) // 获取当前屏幕作为父对象 lv_obj_t* parent_screen = lv_scr_act(); // 在屏幕上创建一个面板 (panel) 对象 lv_obj_t* panel = lv_obj_create(parent_screen); // 为了能看见效果，我们给面板设置一个大小并居中 lv_obj_set_size(panel, 200, 150); lv_obj_center(panel); // 在面板 (panel) 上创建一个标签 (label) 对象 lv_obj_t* label = lv_label_create(panel); // 为了能看见效果，我们给标签设置一点文字 lv_label_set_text(label, A Label); 常用接口 (API) 以下是一些用于操作对象基本属性的常用函数： 尺寸设置与获取: lv_obj_set_width(obj, new_width); lv_obj_set_height(obj, new_height); lv_obj_set_size(obj, width, height); lv_obj_get_width(obj); lv_obj_get_height(obj); 位置设置与获取: lv_obj_set_x(obj, new_x); lv_obj_set_y(obj, new_y); lv_obj_set_pos(obj, x, y); lv_obj_get_x(obj); lv_obj_get_y(obj); 对齐: lv_obj_align(obj, LV_ALIGN_..., x_offset, y_offset); lv_obj_align_to(obj, base_obj, LV_ALIGN_..., x_offset, y_offset); 代码示例：设置位置和尺寸 void demo_set_position_and_size(void) lv_obj_t* parent_screen = lv_scr_act(); lv_obj_t* panel = lv_obj_create(parent_screen); lv_obj_set_size(panel, 200, 150); lv_obj_center(panel); lv_obj_t* label = lv_label_create(panel); lv_label_set_text(label, Hello, World!); // 将标签在面板顶部居中对齐，并向下偏移20像素 lv_obj_align(label, LV_ALIGN_TOP_MID, 0, 20); 对象的盒子模型 LVGL 遵循类似 CSS 的 border-box 模型，这对于理解对象的布局与样式至关重要。一个对象的“盒子”由内到外包含以下几个部分： 内容 (Content): 盒子实际容纳其子对象的区域。 填充 (Padding): 内容区域与边框之间的空间。 边框 (Border): 包围在填充区外围的线条，拥有厚度、颜色等属性。 轮廓 (Outline): 绘制在边框之外的线条，用于突出元素，但不占据实际的布局空间。LVGL 中没有外边距 (margin) 的概念，轮廓起到了类似的作用。 边界 (Bounding Box): 指的是由对象的宽度和高度定义的整个区域。 2. 样式 (Style) 样式用于定义对象的外观。LVGL 的样式系统类似网页三大件中的 CSS，具有灵活、高效的特点。 样式的组成：局部与状态 样式可以被应用于对象的特定部分 (Part) 和在特定的状态 (State) 下。 常见局部: LV_PART_MAIN (主体), LV_PART_SCROLLBAR (滚动条), LV_PART_INDICATOR (指示器), LV_PART_KNOB (旋钮) 等。 常见状态: LV_STATE_DEFAULT (默认), LV_STATE_PRESSED (按下), LV_STATE_FOCUSED (聚焦), LV_STATE_DISABLED (禁用) 等。 样式特点 复用与级联: 一个样式可以被多个对象使用。一个对象也可以添加多个样式，后添加的样式优先级更高。 继承: 如果对象没有指定某个属性（如文本颜色），它会从父对象继承。 本地样式: 对象可以拥有高优先级的“本地样式”，用于进行个别的、独特的样式设置。 过渡效果: 样式支持过渡动画，可以在状态改变时产生平滑的视觉效果。 使用样式三部曲 初始化，向系统申请一个空间用来存样式 设置样式 将样式添加到对象 void demo_create_and_apply_style(void) lv_obj_t* screen = lv_scr_act(); // 1. 初始化样式 // 样式变量必须是 static 或全局的，以防函数退出后被销毁 static lv_style_t style_btn_green; lv_style_init(style_btn_green); // 2. 设置样式属性 // 设置背景颜色为绿色 lv_style_set_bg_color(style_btn_green, lv_palette_main(LV_PALETTE_GREEN)); // 设置圆角半径为 10 lv_style_set_radius(style_btn_green, 10); // 创建一个按钮对象 lv_obj_t* btn = lv_btn_create(screen); lv_obj_center(btn); // 居中显示 // 3. 将样式添加到对象 lv_obj_add_style(btn, style_btn_green, LV_STATE_DEFAULT); // 给按钮添加一个文本，方便观察 lv_obj_t* label = lv_label_create(btn); lv_label_set_text(label, Styled Button); lv_obj_center(label); 样式应用举例：状态过渡动画 通过为不同状态设置不同的样式，并定义过渡描述，可以实现平滑的动画效果。 // 定义一个过渡描述，指定哪些属性（props）参与动画static const lv_style_prop_t props[] = LV_STYLE_BG_COLOR, 0;static lv_style_transition_dsc_t trans;lv_style_transition_dsc_init(trans, props, lv_anim_path_linear, 300, 0, NULL);// 默认状态的样式static lv_style_t style_def;lv_style_init(style_def);lv_style_set_bg_color(style_def, lv_palette_main(LV_PALETTE_BLUE));lv_style_set_transition(style_def, trans); // 添加过渡描述// 按下状态的样式static lv_style_t style_pr;lv_style_init(style_pr);lv_style_set_bg_color(style_pr, lv_palette_main(LV_PALETTE_RED));// 将样式应用到对象lv_obj_t * obj = lv_obj_create(lv_scr_act());lv_obj_add_style(obj, style_def, 0); // 应用默认样式lv_obj_add_style(obj, style_pr, LV_STATE_PRESSED); // 应用按下状态的样式 3. 事件 (Event) 处理机制 当对象的状态发生改变时（如被点击、数值变化等），LVGL 会触发相应的事件。我们可以通过为对象添加回调函数来响应这些事件。 事件特点 一个回调函数可以处理多种不同的事件。 一个对象可以根据不同的事件，绑定不同的回调函数。 对象的事件可以传递给其父对象，这一机制被称为事件冒泡。 事件种类 事件被分为几大类，每一类都包含具体的事件代码（宏定义在 lv_event.h 中）： 输入设备事件: 如 LV_EVENT_PRESSED (按下), LV_EVENT_CLICKED (单击), LV_EVENT_LONG_PRESSED (长按)。 绘图事件 其他特殊事件: 如 LV_EVENT_VALUE_CHANGED (数值改变)。 自定义事件 事件处理流程 编写事件回调函数: 定义一个符合 lv_event_cb_t 原型的函数。 // 事件回调函数static void button_event_handler(lv_event_t *e) // 获取事件代码 lv_event_code_t code = lv_event_get_code(e); // 获取通过 lv_obj_add_event_cb 传递的用户数据 lv_obj_t *label = (lv_obj_t *)lv_event_get_user_data(e); // 判断是否是点击事件 if (code == LV_EVENT_CLICKED) // 修改标签的文本 lv_label_set_text(label, Hello, World!); 为对象添加事件: 使用 lv_obj_add_event_cb 函数将回调函数与特定的事件绑定。 void demo_add_event_handler(void) lv_obj_t* panel = lv_obj_create(lv_scr_act()); lv_obj_set_size(panel, 200, 150); lv_obj_center(panel); // 创建一个标签用于显示结果 lv_obj_t* info_label = lv_label_create(panel); lv_label_set_text(info_label, Please click the button); lv_obj_align(info_label, LV_ALIGN_TOP_MID, 0, 10); // 创建一个按钮 lv_obj_t* btn = lv_btn_create(panel); lv_obj_align(btn, LV_ALIGN_CENTER, 0, 20); lv_obj_t* btn_label = lv_label_create(btn); lv_label_set_text(btn_label, Click Me); lv_obj_center(btn_label); // 关键步骤：为按钮添加事件回调 // 将 info_label 作为用户数据传递给回调函数 lv_obj_add_event_cb(btn, my_event_handler, LV_EVENT_CLICKED, info_label); 事件冒泡 当一个子对象的事件被触发后，如果开启了事件冒泡，该事件会像气泡一样“向上”传递给它的父对象，父对象也可以对这个事件进行响应。 如何开启: 使用 lv_obj_add_flag(obj, LV_OBJ_FLAG_EVENT_BUBBLE); 为子对象添加标志。 如何判断: 在回调函数中，可以通过 lv_event_get_target() 获取最初触发事件的对象，通过 lv_event_get_current_target() 获取当前正在处理事件的对象。如果两者不一致，则说明事件是冒泡上来的。 代码示例 下面的代码创建了一个按钮（子）和一个面板（父）。点击按钮后，上方的标签文本会先显示事件在按钮上触发，短暂延迟后会显示事件冒泡到了父面板上 // 事件冒泡的回调函数static void bubbling_event_cb(lv_event_t* e) lv_event_code_t code = lv_event_get_code(e); lv_obj_t* label_to_update = (lv_obj_t*)lv_event_get_user_data(e); // 获取当前正在处理事件的对象 lv_obj_t* current_target = lv_event_get_current_target(e); // 获取最初触发事件的对象 lv_obj_t* original_target = lv_event_get_target(e); if (code == LV_EVENT_CLICKED) if (lv_obj_check_type(current_target, lv_btn_class)) printf(事件由按钮触发 (Child). ); else if (lv_obj_check_type(current_target, lv_obj_class)) if (current_target != original_target) printf(事件冒泡到面板 (Parent). ); lv_label_set_text(label_to_update, Event bubbled to: Panel (Parent)); // 事件冒泡的演示函数void demo_event_bubbling(void) // 1. 创建父对象 (面板) lv_obj_t* parent_panel = lv_obj_create(lv_scr_act()); lv_obj_set_size(parent_panel, 250, 150); lv_obj_center(parent_panel); // 父对象必须是可点击的，才能接收到冒泡的点击事件 lv_obj_add_flag(parent_panel, LV_OBJ_FLAG_CLICKABLE); // 创建一个标签用于显示事件处理流程 lv_obj_t* info_label = lv_label_create(lv_scr_act()); lv_label_set_text(info_label, Click the button below); lv_obj_align(info_label, LV_ALIGN_TOP_MID, 0, 150); // 2. 创建子对象 (按钮) lv_obj_t* child_btn = lv_btn_create(parent_panel); lv_obj_set_size(child_btn, 120, 50); lv_obj_align(child_btn, LV_ALIGN_CENTER, 0, 20); lv_obj_t* btn_label = lv_label_create(child_btn); lv_label_set_text(btn_label, Click Me!); lv_obj_center(btn_label); // 3. (关键步骤) 为子对象开启事件冒泡标志 lv_obj_add_flag(child_btn, LV_OBJ_FLAG_EVENT_BUBBLE); // 4. 为父对象和子对象都绑定同一个事件回调 // 这样我们才能在同一个函数里观察到事件的传递过程 lv_obj_add_event_cb(child_btn, bubbling_event_cb, LV_EVENT_CLICKED, info_label); lv_obj_add_event_cb(parent_panel, bubbling_event_cb, LV_EVENT_CLICKED, info_label);","tags":[null],"categories":[null]},{"title":"MQTT 使用笔记","path":"/data/ES/进阶/MQTT使用笔记.html","content":"这篇文章大部分内容来自方工的教程，少部分来自官方文档 零、MQTT 的概念 mqtt 的作用实现多设备直接的互联与通信，mqtt 是基于 TCP 传输协议上的应用层协议 在 MQTT 协议中有三个角色(发布者/代理服务器/客户端)，关系图如下： 1. Broker (代理/服务器) Broker 是 MQTT 架构的核心，扮演着消息中转站的角色。所有客户端发布的消息都必须先发送到 Broker，再由 Broker 根据订阅关系，准确地将消息转发给一个或多个订阅者。Broker 的存在实现了发布者与订阅者之间的完全解耦，它们无需感知对方的存在，也无需在同一时间在线。 2. Client (客户端) 任何连接到 Broker 并通过 MQTT 协议进行通信的设备或应用程序都可称为客户端 (Client)。客户端的角色是动态的，它可以： 仅作为发布者 (Publisher)：如一个只负责上报数据的温湿度传感器。 仅作为订阅者 (Subscriber)：如一个只负责展示数据的监控大屏。 同时是发布者和订阅者：如一个智能家居中控 App，它既订阅设备状态，又发布控制指令。 当前笔记使用的是 mosquitto 代理服务器： 一、mosquitto MQTT 服务器安装、环境安装 (1) 搭建 MQTT 服务器 本教程主要参考 Mosquitto 官方文档，采用 APT 包管理器 安装方式。 如果你更熟悉 Docker，也可以通过一条命令快速部署，但 Docker 安装通常占用更多内存，因此这里选择资源占用较低的 APT 安装方式。 一、安装依赖与 MQTT 服务器 执行以下命令，更新软件源并一次性安装所有必要组件： sudo apt updatesudo apt install mosquitto mosquitto-clients libssl-dev libcjson-dev -y 组件名称 说明 mosquitto MQTT 服务器（Broker）核心程序 mosquitto-clients 提供 mosquitto_pub 与 mosquitto_sub 命令行客户端，用于测试 libssl-dev 支持 TLS/SSL 加密传输的依赖库 libcjson-dev 用于处理 JSON 格式消息的 C 语言库 二、启动与开机自启 sudo systemctl start mosquittosudo systemctl enable mosquitto 查看运行状态： systemctl status mosquitto 看到 active (running) 即表示服务启动成功。 三、配置允许外部访问（可选） 默认情况下 Mosquitto 仅允许本地访问，如需让其他设备连接： sudo vim /etc/mosquitto/mosquitto.conf 在文件末尾添加以下内容： listener 1883allow_anonymous true 保存后重启服务： sudo systemctl restart mosquitto 四、本地测试 MQTT 通信 在两个终端窗口中分别执行： 终端1：订阅消息 mosquitto_sub -t test 终端2：发布消息 mosquitto_pub -t test -m hello mqtt 若终端1收到 hello mqtt，说明 MQTT 服务器运行正常。 五、开启安全加密（可选） Mosquitto 支持 SSL/TLS 加密通信，可使用 libssl-dev 生成自签证书： sudo openssl req -new -x509 -days 365 -nodes -out /etc/mosquitto/certs/server.crt -keyout /etc/mosquitto/certs/server.key 然后在配置文件中启用： listener 8883cafile /etc/mosquitto/certs/server.crtkeyfile /etc/mosquitto/certs/server.keyrequire_certificate false 重启后客户端即可使用加密端口 8883 连接。 (2)、编译开发板运行环境 1, 下载 openssl、cjson、mosquitto 的相关库 为了进行交叉编译，你需要下载这些库的源码包。请从以下官方或可靠的链接下载： OpenSSL: 官方源码下载页: https://www.openssl.org/source/ 说明: OpenSSL 版本迭代较快，笔记中使用的 1.1.1q 是一个长期支持 (LTS) 版本，你可以在旧版本存档中找到它。对于新的项目，建议查看官网最新的稳定版 cJSON: GitHub Releases 页面: https://github.com/DaveGamble/cJSON/releases 说明: cJSON 是一个轻量级库，直接下载最新 release 的源码压缩包即可 Mosquitto: 官方下载页: https://mosquitto.org/download/ 说明: 在页面中找到 “Source” 部分，下载 .tar.gz 格式的源码包。笔记中使用的是 2.0.9 版本，你可以在 https://mosquitto.org/files/source/ 中找到所有历史版本 将下载好的源码包统一存放到一个工作目录下，以便后续解压和编译 2、配置安装 openssl 库 a、创建 arm_mqtt_lib 文件夹， 再在此文件夹下创建 openssl 文件夹 命令1：mkdir ~/arm_mqtt_lib命令2：mkdir ~/arm_mqtt_lib/openssl b、解压并进入 openssl-1.1.1q 目录 命令1：tar -xvf openssl-1.1.1q.tar.gz -C ~/arm_mqtt_lib/命令2：cd ~/arm_mqtt_lib/openssl-1.1.1q/ c、配置安装目录并生成 Makefile 文件 命令：./config no-asm -shared --prefix=/home/gec/arm_mqtt_lib/openssl注意：/home/gec/这个不同系统是不一样的，除非你用和我一致 d、进入 Makefile 文件，将编译工具修改为交叉编译链，修改的地方如下**(vi 或 gedit)** PLATFORM=arm CROSS_COMPILE= CC=arm-linux-gccCXX=arm-linux-g++ e、由于 ARM 基本的都是 32 位，所以需要 Makefile 文件中的‘-m64’删除，如下图所示 f、执行 make 编译，再执行 make install makemake install 执行上述的命令后，会在安装路径中生成相应的文件，如下图所示： 3、配置安装 cJSON 库 a、在安装路径下创建 cjson 文件夹 mkdir ~/arm_mqtt_lib/cjson b、解压并进入 cJSON-master 目录 cp cJSON-master.zip ~/arm_mqtt_lib/ #拷贝库到家目录的arm-lib目录unzip cJSON-master.zip #进入家目录的arm-lib目录 ，并解压json 库cd ~/arm_mqtt_lib/cJSON-master/ #进入源码目录 命令 1 现象： 命令 2 现象： 命令 3 现象： c、修改 Makefile 文件**(vi 或 gedit)** d、执行 make 编译，并执行 make install 安装 makemake install 会在安装路径中生成相应的文件，如下图所示： 4、配置安装mosquitto 库 a、在安装路径下创建 mosquitto 文件 mkdir ~/arm_mqtt_lib/mosquitto b、解压并进入/mosquitto-2.0.9/目录 tar -xvf mosquitto-2.0.9.tar.gz -C ~/arm_mqtt_lib/cd ~/arm_mqtt_lib/mosquitto-2.0.9/ 命令 1 现象： 命令 2 现象： c、修改 config.mk 配置文件**(vi 或 gedit 打开)** 修改配置项 添加安装路径和 openssl、cjson 库路径和头文件路径 WITH_UUID:=noCC=arm-linux-gccCXX=arm-linux-g++ prefix=/home/gec/arm_mqtt_lib/mosquittoCFLAGS:=-I/home/gec/arm_mqtt_lib/openssl/includeCFLAGS+=-I/home/gec/arm_mqtt_lib/cjson/include LDFLAGS=-L/home/gec/arm_mqtt_lib/openssl/lib -lssl -lcryptoLDFLAGS+=-L/home/gec/arm_mqtt_lib/cjson/lib -lcjson d、执行 make 编译、并执行 sudo make install makesudo make install 会在安装路径中生成相应的文件，如下图所示： 5、查看当前交叉编译工具的设置的默认库路径及头文件路径，并进行复制 注意：去到 openssl、cJson、mosquitto 文件夹下，将它们所有的头文件和库文件都复制到你的交叉编译工具的相关路径下 a、查看自己的交叉编译工具头文件和库文件的路径的命令 echo main() | arm-linux-gcc -E -v - 交叉编译的头文件路径： 注意：这个得看你当前环境编译器，不能固定用上面的路径 b、复制openssl、cJson、mosquitto 的头文件到交叉编译的头文件路径下 cp ~/arm_mqtt_lib/openssl/include/openssl/* /usr/arm/5.4.0/usr/bin/../lib/gcc/arm-none-linux-gnueabi/5.4.0/includecp ~/arm_mqtt_lib/cjson/include/cjson/* /usr/arm/5.4.0/usr/bin/../lib/gcc/arm-none-linux-gnueabi/5.4.0/includecp ~/arm_mqtt_lib/mosquitto/include/* /usr/arm/5.4.0/usr/bin/../lib/gcc/arm-none-linux-gnueabi/5.4.0/include 交叉编译的库文件路径 c、复制openssl、cJson、mosquitto 的库文件，到交叉编译的库文件路径下 cp ~/arm_mqtt_lib/openssl/lib/* /usr/arm/5.4.0/usr/bin/../lib/gcc/arm-none-linux-gnueabi/5.4.0/ -rfcp ~/arm_mqtt_lib/cjson/lib/* /usr/arm/5.4.0/usr/bin/../lib/gcc/arm-none-linux-gnueabi/5.4.0/ -rfcp ~/arm_mqtt_lib/mosquitto/lib/* /usr/arm/5.4.0/usr/bin/../lib/gcc/arm-none-linux-gnueabi/5.4.0/ -rf 6、arm 交叉编译程序的时候，后面的程序需要加 arm-linux-gcc test.c -o test -lmosquitto -lssl -lcrypto -lcjson 7、执行程序的时候 a、将 openssl、cJson、mosquitto 文件夹的库文件进行打包 前提：去到openssl、cJson、mosquitto文件夹下，将里面的库，全部放到一个文件夹里面 (方工的放在arm_mqtt_lib/文件夹下)命令：tar -cvf arm_mqtt_lib.tar.gz arm_mqtt_lib/ b、发送到开发板上的/lib/上面即可 前提：将arm_mqtt_lib.tar.gz发送到开发板上命令：tar -xvf arm_mqtt_lib.tar.gz -C /lib/ 二、mosquitto 库的使用 (1)、前提说明 1、备份文件 a、进入家目录，并将mosquitto.conf.example文件复制到家目录上 cd ~/cp /etc/mosquitto/mosquitto.conf.example ~/ b、启动 mqtt 服务器 mosquitto -c ~/mosquitto.conf.example 2、配置文件mosquitto.conf.example文件 a、打开mosquitto.conf.example文件 gedit ~/mosquitto.conf.example b、修改文件(可远程、允许任何人访问) listener 1883或port 1883 allow_anonymous true 注意事项：如果端口出现了端口被占用的情况： 1、先进入到 root 模式 sudo su 2、查找 1883 被占用进程 sudo lsof -i:1883 3、使用 kill+PID 杀死占用进程即可 4、返回自己的用户 exit (2)、MQTT 发布与订阅的命令 1、前提需要将 MQTT 服务器开启 mosquitto -c ~/mosquitto.conf.example 2、mqtt 订阅命令 mosquitto_sub -t temp #订阅命令 -t 订阅的主题 出现错误 1： 解决方法： sudo cp /usr/local/lib/libmosquitto* /lib/ 出现错误 2： 解决方法： sudo cp /usr/local/lib/libcjson* /lib/ 现象：相当于你订阅了 B 站上的一个 UP 主(涉猎游戏、美食、钓鱼)，你在等他发布美食主题消息 3、mqtt 发布命令 发布的命令：mosquitto_pub -t temp -m hello_world #主题发布 -t 发布的主题 -m 发布的消息 (3)、发布函数接口 1. 初始话库函数 int mosquitto_lib_init(void); 功能: 初始化 Mosquitto 库。这是调用任何其他 Mosquitto 函数之前必须执行的第一步。 返回值: 始终返回 MOSQ_ERR_SUCCESS。 2. 创建客户端实例 struct mosquitto *mosquitto_new(const char *id, bool clean_session, void *obj); 参数: id (const char *): 客户端 ID。如果设为 NULL 且 clean_session 为 true，Broker 会自动为其分配一个唯一的 ID。 clean_session (bool): 会话清除标志。true 表示建立干净会话，false 表示建立持久会话。 obj (void *): 用户自定义数据指针，该指针会传递给所有回调函数，常用于在回调中访问外部数据。 返回值: 成功: 返回指向 mosquitto 结构体的指针。 失败: 返回 NULL。 3. 连接到 MQTT Broker int mosquitto_connect(struct mosquitto *mosq, const char *host, int port, int keepalive); 参数: mosq (struct mosquitto *): mosquitto_new 创建的客户端实例。 host (const char *): Broker 的 IP 地址或域名。 port (int): Broker 的端口号（默认为 1883）。 keepalive (int): 心跳间隔时间（秒）。客户端会在此时间内至少发送一个 PING 包以保持连接。建议值大于 5。 返回值: 成功: MOSQ_ERR_SUCCESS。 失败: 返回其他错误码。 4. 发布一条消息到指定的主题 int mosquitto_publish(struct mosquitto *mosq, int *mid, const char *topic, int payloadlen, const void *payload, int qos, bool retain); 参数: mosq (struct mosquitto *): 客户端实例。 mid (int *): 指向消息 ID 的指针，通常设为 NULL 让库自动处理。 topic (const char *): 消息要发布到的主题。 payloadlen (int): 消息内容的长度。 payload (const void *): 指向消息内容的指针。 qos (int): 服务质量等级 (0, 1, 或 2)。 retain (bool): 保留消息标志。true 表示将此消息设为该主题的保留消息。 返回值: 成功: MOSQ_ERR_SUCCESS。 失败: 返回其他错误码。 5. 断开与 Broker 的连接 int mosquitto_disconnect(struct mosquitto *mosq); 参数: mosq (struct mosquitto *): 客户端实例。 返回值: 成功: MOSQ_ERR_SUCCESS。 失败: 返回其他错误码。 6. 释放连接资源 int mosquitto_lib_cleanup(void); 示例代码： /** ****************************************************************************** * @file test.c * @author FZetc飞贼 * @version V0.0.1 * @date 2025.06.17 * @brief 给学生的演示例程：mqtt信息发布 * 前提：需要先运行起mqtt服务器 * 编译： * gcc 001__MQTT信息发布.c -o sub -lmosquitto(需要mqtt的库) * ****************************************************************************** */#include stdio.h// 添加MQTT头文件#include mosquitto.h#include string.h// MQTT服务器的地址#define MQTT_ADDR 192.168.13.3// MQTT服务器的端口号#define MQTT_PORT 1883// 主函数int main(int argc, char const* argv[]) // 1、初始化MQTT资源(a、买了一步电脑、手机) mosquitto_lib_init(); // 2、创建一个MQTT客户端对象(b、下载了B站、小红书软件，并且开了个号，准备发布素材) struct mosquitto* client_up = mosquitto_new(jack, true, NULL); if (client_up == NULL) perror(mosquitto_new error! ); return -1; // 3、链接到MQTT服务器(c、连接到B站、小红书的服务器了(打开APP)) int ret = mosquitto_connect(client_up, MQTT_ADDR, MQTT_PORT, 60); if (ret != MOSQ_ERR_SUCCESS) perror(mosquitto_connect error! ); return -2; // 4、发布消息(d、上传作品、更新动态等) char msg_buf[1024] = 人居然要吃饭！; ret = mosquitto_publish(client_up, NULL, 震惊, strlen(msg_buf), msg_buf, 0, 0); if (ret != 0) perror(mosquitto_publish error! ); return -3; else printf(mosquitto_publish 成功! ); // 5、断开服务器(e、退出app) mosquitto_disconnect(client_up); // 6、释放mqtt库资源(f、把电脑、手机给砸了) mosquitto_lib_cleanup(); (4)、订阅函数接口 1.订阅一个或多个主题 int mosquitto_subscribe(struct mosquitto *mosq, int *mid, const char *sub, int qos); 参数: mosq (struct mosquitto *): 客户端实例。 mid (int *): 消息 ID 指针，通常设为 NULL。 sub (const char *): 要订阅的主题或主题过滤器（可使用通配符 + 和 #）。 qos (int): 期望接收此主题消息的最高 QoS 等级 (0, 1, 或 2)。 返回值: 成功: MOSQ_ERR_SUCCESS。 失败: 返回其他错误码。 2. 处理接收到的消息 void mosquitto_message_callback_set(struct mosquitto *mosq, void (*on_message)(struct mosquitto *, void *, const struct mosquitto_message *)); 功能: 注册一个回调函数，用于处理接收到的消息。 参数: mosq (struct mosquitto *): 客户端实例。 on_message: 指向回调函数的指针。当客户端收到任何已订阅主题的消息时，此函数将被调用。 回调函数原型: void on_message(struct mosquitto *mosq, void *obj, const struct mosquitto_message *message) mosq: 触发回调的客户端实例。 obj: mosquitto_new 中设置的用户自定义数据指针。 message: 指向 mosquitto_message 结构体的指针，包含了接收到的消息详情。 struct mosquitto_message int mid; // 消息 ID char *topic; // 消息所属的主题 void *payload; // 消息内容 int payloadlen; // 内容长度 int qos; // 消息的 QoS 等级 bool retain; // 是否为保留消息; 3. 循环接收消息 int mosquitto_loop_forever(struct mosquitto *mosq, int timeout, int max_packets); 功能: 启动一个阻塞的网络循环来处理 MQTT 消息（接收、发送 PING 包等）。此函数会一直运行，直到客户端断开连接。 参数: mosq (struct mosquitto *): 客户端实例。 timeout (int): 超时时间（毫秒），通常设为 -1 表示永不超时。 max_packets (int): 未使用的参数，保持为 1 即可。 返回值: 正常断开: MOSQ_ERR_SUCCESS。 发生错误: 返回相应的错误码。 示例代码： /********************************************************************************* @file test.c* @author FZetc飞贼* @version V0.0.1* @date 2025.06.17* @brief 给学生的演示例程：mqtt信息订阅* 前提：需要先运行起mqtt服务器* 编译：* gcc 002__MQTT信息订阅.c -o sub -lmosquitto(需要mqtt的库)********************************************************************************/#include stdio.h// 添加MQTT头文件#include mosquitto.h#include string.h// MQTT服务器的地址#define MQTT_ADDR 192.168.13.x// MQTT服务器的端口号#define MQTT_PORT 1883/** * @brief 回调函数 * @note None * @param id：发布者对象 * arg：mosquitto_new发过来的参数 * msg：消息的结构体(保存发布的信息) * @retval None */void MSG_CallBack(struct mosquitto* id, void* arg, const struct mosquitto_message* msg) printf(arg == %d , *(int*)arg); printf(发布消息时id:%d , msg-mid); printf(消息的主题:%s , msg-topic); printf(消息的内容:%s , (char*)msg-payload); printf(消息的长度:%d , msg-payloadlen); printf(消息的质量:%d , msg-qos); printf(保留标志:%d , msg-retain);// 主函数int main(int argc, char const* argv[]) // 1、初始化MQTT库(a、买了一部电脑、手机) mosquitto_lib_init(); // 2、创建一个MQTT对象(b、下载B站、小红书) int num = 110; struct mosquitto* client_fans = mosquitto_new(rose, true, (void*)num); if (client_fans == NULL) perror(mosquitto_new error! ); return -1; // 3、链接到MQTT服务器(c、连接到B站、小红书的服务器了(打开APP)) int ret = mosquitto_connect(client_fans, MQTT_ADDR, MQTT_PORT, 60); if (ret != MOSQ_ERR_SUCCESS) perror(mosquitto_connect error! ); return -2; // 4、订阅主题(d、关注你的up主的某个话题(震惊)) ret = mosquitto_subscribe(client_fans, NULL, 震惊, 0); if (ret != MOSQ_ERR_SUCCESS) perror(mosquitto_subscribe error! ); return -3; else printf(mosquitto_subscribe 成功! ); // 5、设置消息回调函数(e、浏览这个话题的相关信息) mosquitto_message_callback_set(client_fans, MSG_CallBack); // 6、循环处理消息时间，检测是否有消息触发 mosquitto_loop_forever(client_fans, -1, 1); 其它参数设置 服务质量 (QoS - Quality of Service) QoS 是 MQTT 中确保消息可靠传输的关键机制，共分为三个等级： QoS 0 (最多一次): “发后即忘”，以最高的性能发送消息，但不保证消息一定能送达。适用于数据更新频率高且允许少量丢失的场景（如传感器实时读数）。 QoS 1 (至少一次): 确保消息至少到达接收方一次，但由于重传机制，可能会导致消息重复。适用于要求消息必须送达，且接收端有能力处理重复数据的场景（如远程开关指令）。 QoS 2 (只有一次): 最可靠的等级，通过复杂的握手流程确保消息有且仅有一次被送达，但性能开销最大。适用于绝对不允许消息丢失或重复的金融、计费等关键业务场景。 主题 (Topic) 与通配符 主题 (Topic) 是 MQTT 的消息路由核心，它是一个使用 / 分隔层级的 UTF-8 字符串，类似于文件系统路径。 主题层级 (Topic Levels): 例如 home/livingroom/temperature，这种层级结构使得主题管理和订阅变得非常灵活。 通配符 (Wildcards): + (单层通配符): 匹配一个层级。例如，订阅 home/+/light 可以接收到 home/livingroom/light 和 home/bedroom/light 的消息。 # (多层通配符): 匹配零个或多个层级，并且必须是主题的最后一级。例如，订阅 home/# 可以接收到所有以 home/ 开头的消息，如 home/livingroom/temperature 和 home/security/door/status。 高级特性 保留消息 (Retained Message): 当 Broker 接收到一个设置了“保留”标志的发布消息时，它会存储该主题的最后一条消息。当有新的订阅者订阅该主题时，Broker 会立即将这条被保留的消息发送给它。这对于让新上线的设备立即获取最新状态非常有用。 遗嘱消息 (Last Will and Testament - LWT): 客户端在连接 Broker 时可以预设一条“遗嘱消息”。如果客户端因意外（如断电、网络故障）而异常断开连接，Broker 会自动将这条遗嘱消息发布到指定的遗嘱主题上。这常用于监控设备的在线状态。 清除会话 (Clean Session): true：当客户端断开连接时，Broker 会清除其所有订阅关系和离线消息。每次连接都是一个全新的开始。 false：客户端断开后，Broker 会保留其订阅关系和 QoS 0 的离线消息，直到客户端重新连接后发送给它。这对于网络不稳定的移动设备至关重要。 心跳机制 (Keep Alive): 客户端在连接时与 Broker 协商一个时间间隔（秒）。在此期间若无任何消息交互，客户端会发送一个极小的 PINGREQ 包，Broker 则响应 PINGRESP 包，以此确认双方连接仍然有效。如果 Broker 在 1.5 倍的 Keep Alive 时间内未收到客户端的任何消息，则会判定连接断开，并触发 LWT 机制。","tags":[null],"categories":[null,null]},{"title":"Linux 多线程编程：Pthreads 核心函数与资源管理详解","path":"/data/ES/进阶/线程.html","content":"线程的概念及基础 1. 线程是什么？ 定义：线程（Thread）是操作系统能调度的最小执行单位。 进程和线程的区别： 进程：是系统分配资源的最小单位，系统会为每一个进程分配一块独立的虚拟的内存空间 线程：是系统调度的最小单位，系统不会为线程分配新的内存空间，但是线程也参与系统调度 进程好比一栋大房子（提供厨房、客厅、水电等资源） 主线程（main 函数）是第一个住进去的人（负责把房子用起来） 子线程是后来搬进来的家人（大家共享厨房和水电，但各自有独立卧室 = 各自的栈） 2. 线程库 (Pthreads) 与相关函数 在 Linux 系统中进行多线程编程，我们主要依赖 POSIX Threads (Pthreads) 库。它是一套标准的 API，提供了创建、管理和同步线程所需的所有工具。 编译核心注意： Pthreads 并非 C 语言标准库的一部分，因此在编译链接时，必须显式地告知编译器链接该库。这通过添加 -pthread 标志来完成。 gcc your_program.c -o your_program -pthread 核心生命周期：创建、等待与退出 这是一个线程从诞生到正常消亡的“标准流程”，涉及三个核心函数。 创建线程: pthread_create 此函数是所有多线程程序的起点，用于在一个进程内创建一个新的、独立的执行流（线程）。 man 3 pthread_create #include pthread.hint pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg); thread (输出): 指向 pthread_t 变量的指针，成功时用于接收新线程的唯一 ID。 attr (输入): 指向线程属性对象的指针，用于对线程进行高级定制。传入 NULL 表示使用默认属性。（详细内容见“线程资源管理”一节） start_routine (输入): 函数指针，指向新线程要执行的任务函数，其原型必须是 void* func(void*)。 arg (输入): 传递给 start_routine 函数的参数，类型为 void*。 等待与回收线程: pthread_join 该函数用于阻塞地等待一个指定的线程结束，并负责回收其占用的系统资源。 man 3 pthread_join int pthread_join(pthread_t thread, void **retval); 作用: 阻塞等待、回收资源、获取返回值。 重要性: 线程结束后，其资源不会自动释放。必须通过 pthread_join 或将其设置为分离状态来回收。否则，已终止的线程会变成“僵尸线程”，持续占用内存，导致资源泄漏。 线程的自我终止: pthread_exit 用于显式、安全地终止当前线程，并可以返回一个退出状态值。 man 3 pthread_exit void pthread_exit(void *retval); 关键区别：pthread_exit vs return vs exit() pthread_exit(value): 仅终止当前线程，进程中其他线程继续运行。 return value; (在线程函数中): 效果完全等同于 pthread_exit((void*)value);。 exit(0): 立即终止整个进程，导致进程内所有线程全部被强制销毁。在线程编程中应极力避免使用。 综合示例：完整的核心生命周期 #include stdio.h#include pthread.h#include stdlib.h#include unistd.h// 线程任务：接收一个整数，计算其平方，并将结果通过堆内存返回void* square_calculator(void* arg) int input_value = *(int*)arg; printf(子线程: 接收到值 %d，开始计算... , input_value); sleep(1); // 正确做法：在堆上分配内存来存储返回值 int* result_ptr = malloc(sizeof(int)); *result_ptr = input_value * input_value; printf(子线程: 计算完成，结果为 %d。线程即将退出。 , *result_ptr); pthread_exit((void*)result_ptr);int main(void) pthread_t tid; void* thread_return_value; int number = 12; // 1. 创建线程 pthread_create(tid, NULL, square_calculator, number); printf(主线程: 已创建计算线程，正在等待其完成... ); // 2. 等待并回收线程，同时接收返回值 pthread_join(tid, thread_return_value); int final_result = *(int*)thread_return_value; printf(主线程: 已回收子线程，获取到其返回值为: %d , final_result); // 3. 释放子线程分配的堆内存（运行不到，因为线程已经自行退出） free(thread_return_value); return 0; 线程资源管理 本节集中讨论如何管理线程的系统资源，主要包括分配（它能用多少）和回收（它用完后怎么办）两个方面。这通常通过 pthread_attr_t 属性对象来完成。 使用线程属性的通用步骤 (五步法) 无论设置何种属性，都遵循以下流程，这是一个可复用的模式： 定义属性变量: pthread_attr_t attr; 初始化属性对象: pthread_attr_init(attr); 设置特定属性: 调用 pthread_attr_set* 系列函数，如 pthread_attr_setstacksize()。 使用属性创建线程: 将配置好的 attr 作为 pthread_create 的第二个参数传入。 销毁属性对象: pthread_attr_destroy(attr); (线程创建后即可销毁)。 使用man -k pthread_attr命令可以查找线程属性相关 api 函数 资源分配策略 目的：在内存敏感的场景（如嵌入式设备）或需要大量线程的应用中，精确控制每个线程的内存消耗。 实现方式：通过线程属性 pthread_attr_t，遵循上述五步法。 核心函数: int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize); 注意事项: stacksize 必须不小于系统定义的最小值 PTHREAD_STACK_MIN (通常为 16KB)。 若线程中局部变量占用空间超过了设定的栈大小，将引发栈溢出，导致程序崩溃 (段错误)。 示例：设置自定义栈大小 #include stdio.h#include pthread.h#include limits.h // for PTHREAD_STACK_MINint main(void) pthread_t tid; pthread_attr_t attr; // 1. 定义 size_t desired_stack_size = 32 * 1024; // 期望设置 32KB size_t actual_stack_size; pthread_attr_init(attr); // 2. 初始化 // 3. 设置自定义的栈大小 pthread_attr_setstacksize(attr, desired_stack_size); // (可选) 验证设置是否成功 pthread_attr_getstacksize(attr, actual_stack_size); printf(设置的线程栈大小为: %zu 字节 , actual_stack_size); // 4. 使用自定义属性创建线程 pthread_create(tid, attr, some_task_function, NULL); // some_task_function 未定义，仅为演示 pthread_attr_destroy(attr); // 5. 销毁 pthread_join(tid, NULL); return 0; 资源回收策略 目的：决定线程结束后其资源是由主程序手动回收（Joinable），还是由系统自动回收（Detached）。 方法 A : 创建时配置为分离 实现方式：通过线程属性 pthread_attr_t。 核心函数: int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate); detachstate 可为 PTHREAD_CREATE_JOINABLE (默认) 或 PTHREAD_CREATE_DETACHED。 示例：创建时即设为分离 #include stdio.h#include pthread.h#include unistd.h#include errno.hvoid* background_task(void* arg) printf(分离线程: 开始执行，2秒后自动退出并由系统回收资源。 ); sleep(2); printf(分离线程: 执行完毕。 ); return NULL;int main(void) pthread_t tid; pthread_attr_t attr; // 1. 定义 pthread_attr_init(attr); // 2. 初始化 pthread_attr_setdetachstate(attr, PTHREAD_CREATE_DETACHED); // 3. 设置为分离状态 // 4. 使用该属性创建线程 pthread_create(tid, attr, background_task, NULL); pthread_attr_destroy(attr); // 5. 销毁 printf(主线程: 分离线程已创建，无需join。 ); // 必须保证主线程存活足够长时间，否则整个进程退出，分离线程也会被终止 sleep(3); printf(主线程退出。 ); return 0; 方法 B (推荐): 创建后修改为分离 实现方式：调用 API 直接修改已存在线程的状态。 核心函数: int pthread_detach(pthread_t thread); 补充: 可在线程内部通过 pthread_detach(pthread_self()); 实现自我分离。 示例：创建后手动分离 #include stdio.h#include pthread.h#include unistd.hvoid* another_background_task(void* arg) printf(子线程: 我被创建了，将自我分离。 ); pthread_detach(pthread_self()); // 自我分离 sleep(2); printf(子线程: 任务完成，自动退出。 ); return NULL;int main(void) pthread_t tid; // 正常创建一个可连接的线程 pthread_create(tid, NULL, another_background_task, NULL); // 主线程无需再对其进行任何操作 printf(主线程: 子线程已创建，它会自我分离。主线程等待3秒。 ); sleep(3); printf(主线程退出。 ); return 0; 线程的外部干预：取消 这是一种由一个线程请求另一个线程异常终止的机制，与正常的 pthread_exit 不同。 发起取消请求: pthread_cancel 此函数仅向目标线程发送一个取消请求，目标线程并不会立即终止。 安全响应机制 取消点 (Cancellation Points): 目标线程只有在执行到“取消点”时，才会检查并响应该请求。许多阻塞的系统调用（如 sleep, read, write）都是默认的取消点。 控制响应时机 (pthread_setcancelstate): 用于临时屏蔽取消请求，以保护不可中断的关键代码段。 确保资源释放 (pthread_cleanup_push / pop): 注册清理处理函数。当线程被取消时，这些函数会被自动调用，以释放该线程持有的资源（如文件、内存、锁），防止资源泄漏。 示例：安全地取消一个正在工作的线程 #include stdio.h#include pthread.h#include stdlib.h#include unistd.h// 清理函数：在线程被取消时调用，负责释放资源void cleanup_handler(void *arg) char *buffer = (char *)arg; printf( [清理函数]: 线程被取消，释放内存: %s , buffer); free(buffer);void* worker_thread(void* arg) char* dynamic_buffer = malloc(100); sprintf(dynamic_buffer, 这是一块需要被释放的动态内存); // 注册清理函数，当线程被取消时，`cleanup_handler` 会被调用 pthread_cleanup_push(cleanup_handler, dynamic_buffer); printf(子线程: 已获取资源，进入无限循环... ); int i = 0; while (1) printf(%d , i++); fflush(stdout); sleep(1); // sleep() 是一个取消点 // `push` 和 `pop` 必须成对出现。参数0表示正常结束时不执行清理函数。 pthread_cleanup_pop(0); return NULL;int main(void) pthread_t tid; pthread_create(tid, NULL, worker_thread, NULL); sleep(4); // 让子线程运行一会儿 printf( 主线程: 发送取消请求给子线程！ ); pthread_cancel(tid); // 等待被取消的线程完成清理并完全终止 pthread_join(tid, NULL); printf(主线程: 已确认子线程被取消并回收。 ); return 0; 线程安全与同步 当多个线程同时访问和操作同一个共享资源（如全局变量、堆内存、文件等）时，如果没有适当的保护机制，就可能导致数据错乱、程序崩溃等问题。本节将探讨保证多线程程序正确运行的核心机制。 核心概念 线程安全: 指一个函数或一段代码在被多个线程同时调用时，仍然能够保证其行为的正确性和数据的完整性。 竞态条件: 当多个线程并发地访问和修改同一个共享数据，并且最终结果依赖于线程执行的特定时序时，就会发生竞态条件。这是导致线程不安全的根源。 临界区: 指一段访问共享资源的代码，为了保证线程安全，必须确保在任何时刻只有一个线程能进入该区域执行。 为了解决这些问题，Pthreads 提供了多种同步与互斥的工具。 互斥 : 保护共享数据 互斥的核心思想是“独占访问”，确保在任何时刻，只有一个线程能够访问临界区。 互斥锁 (Mutex) 互斥锁是最基本、最常用的互斥工具。它就像一把锁，保护着临界区。线程在进入临界区前必须先获取锁，离开时则释放锁。 工作流程: pthread_mutex_init(): 初始化一个互斥锁变量。 pthread_mutex_lock(): 加锁。如果锁已被其他线程持有，则当前线程会阻塞等待，直到锁被释放。 — 临界区代码 (访问共享资源) — pthread_mutex_unlock(): 解锁。 pthread_mutex_destroy(): 销毁互斥锁，释放资源。 核心 API int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr); int pthread_mutex_lock(pthread_mutex_t *mutex); int pthread_mutex_unlock(pthread_mutex_t *mutex); int pthread_mutex_destroy(pthread_mutex_t *mutex); 示例：使用互斥锁保护银行账户 在多线程存取款的场景下，账户余额是共享资源。“读取余额-计算新余额-写回余额”这个操作必须是原子的，否则就会出错。 #include stdio.h#include pthread.h#include unistd.h#include stdlib.h// 共享的银行账户结构体typedef struct int balance; // 账户余额 pthread_mutex_t lock; // 保护余额的互斥锁 BankAccount;// 存款操作 (临界区)void deposit(BankAccount *acc, int amount) pthread_mutex_lock(acc-lock); // 加锁 // --- 临界区开始 --- printf(尝试存款 %d, 当前余额: %d , amount, acc-balance); int old_balance = acc-balance; usleep(10000); // 模拟处理耗时，增加竞态条件发生概率 acc-balance = old_balance + amount; printf(存款成功, 最新余额: %d , acc-balance); // --- 临界区结束 --- pthread_mutex_unlock(acc-lock); // 解锁// 取款操作 (临界区)void withdraw(BankAccount *acc, int amount) pthread_mutex_lock(acc-lock); // 加锁 // --- 临界区开始 --- printf(尝试取款 %d, 当前余额: %d , amount, acc-balance); if (acc-balance = amount) int old_balance = acc-balance; usleep(10000); // 模拟处理耗时 acc-balance = old_balance - amount; printf(取款成功, 最新余额: %d , acc-balance); else printf(余额不足, 取款失败! ); // --- 临界区结束 --- pthread_mutex_unlock(acc-lock); // 解锁// 模拟客户操作的线程函数void* customer_action(void* arg) BankAccount *acc = (BankAccount*)arg; for (int i = 0; i 5; ++i) if (rand() % 2) deposit(acc, 100); else withdraw(acc, 100); usleep(100000); // 随机延时 return NULL;int main() BankAccount my_account; my_account.balance = 1000; pthread_mutex_init(my_account.lock, NULL); // 初始化互斥锁 pthread_t tids[5]; for (int i = 0; i 5; ++i) pthread_create(tids[i], NULL, customer_action, my_account); for (int i = 0; i 5; ++i) pthread_join(tids[i], NULL); pthread_mutex_destroy(my_account.lock); // 销毁互斥锁 printf( 所有操作完成, 最终账户余额: %d , my_account.balance); return 0; 读写锁 (Read-Write Lock) 读写锁是互斥锁的一种优化，适用于“读多写少”的场景，能显著提高并发性能。 规则: 读锁 (共享锁): 多个线程可以同时持有读锁，进行并发读取。 写锁 (独占锁): 只能有一个线程持有写锁。当任何线程持有写锁时，其他线程（无论是想读还是想写）都必须阻塞等待。 写锁的优先级通常高于读锁，以防止“写饥饿”。 工作流程: 写者: pthread_rwlock_wrlock() - 写操作 - pthread_rwlock_unlock() 读者: pthread_rwlock_rdlock() - 读操作 - pthread_rwlock_unlock() 核心 API int pthread_rwlock_init(pthread_rwlock_t *rwlock, ...); int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock); (加读锁) int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock); (加写锁) int pthread_rwlock_unlock(pthread_rwlock_t *rwlock); int pthread_rwlock_destroy(pthread_rwlock_t *rwlock); 示例：多读者、少写者访问共享数据 #include stdio.h#include pthread.h#include unistd.h#define NUM_READERS 5#define NUM_WRITERS 2int shared_data = 0;pthread_rwlock_t rw_lock;// 读者线程void* reader_thread(void* arg) int reader_id = *(int*)arg; while (1) pthread_rwlock_rdlock(rw_lock); // 加读锁 printf(读者 %d: 读取数据 = %d , reader_id, shared_data); pthread_rwlock_unlock(rw_lock); // 解锁 usleep(500000); // 模拟读完后的处理 return NULL;// 写者线程void* writer_thread(void* arg) int writer_id = *(int*)arg; while (1) pthread_rwlock_wrlock(rw_lock); // 加写锁 shared_data++; printf(写者 %d: 更新数据为 - %d , writer_id, shared_data); pthread_rwlock_unlock(rw_lock); // 解锁 sleep(1); // 写者操作频率较低 return NULL;int main() pthread_rwlock_init(rw_lock, NULL); pthread_t reader_tids[NUM_READERS], writer_tids[NUM_WRITERS]; int reader_ids[NUM_READERS], writer_ids[NUM_WRITERS]; // 创建读者线程 for (int i = 0; i NUM_READERS; ++i) reader_ids[i] = i + 1; pthread_create(reader_tids[i], NULL, reader_thread, reader_ids[i]); // 创建写者线程 for (int i = 0; i NUM_WRITERS; ++i) writer_ids[i] = i + 1; pthread_create(writer_tids[i], NULL, writer_thread, writer_ids[i]); // 主线程阻塞，防止程序退出 pthread_join(reader_tids[0], NULL); pthread_rwlock_destroy(rw_lock); return 0; 同步 (Synchronization): 协调线程执行 同步的目的是控制线程之间的执行顺序，一个线程的行为需要依赖另一个线程的结果。 POSIX 无名信号量 (Unnamed Semaphore) 信号量本质上是一个非负整数计数器，常用于管理对有限资源的访问或协调线程执行顺序。 P 操作 (sem_wait): 信号量值减 1。如果值为 0，则线程阻塞，直到有其他线程对信号量执行 V 操作。 V 操作 (sem_post): 信号量值加 1。如果此时有线程因该信号量而阻塞，则唤醒其中一个。 工作流程: sem_init(): 初始化一个无名信号量，设定初始值。 sem_wait() / sem_post(): 执行 P/V 操作来协调。 sem_destroy(): 销毁信号量。 核心 API int sem_init(sem_t *sem, int pshared, unsigned int value); pshared: 0 表示用于线程间同步。 int sem_wait(sem_t *sem); int sem_post(sem_t *sem); int sem_destroy(sem_t *sem); 示例：使用信号量实现流水线同步 模拟一个三步流水线：焊接 - 检查 - 打包。必须严格按照此顺序执行。 #include stdio.h#include pthread.h#include semaphore.h#include unistd.hsem_t sem_weld; // 允许焊接的信号量sem_t sem_check; // 允许检查的信号量sem_t sem_pack; // 允许打包的信号量// 步骤1：焊接void* weld_thread(void* arg) while(1) sem_wait(sem_weld); // 等待焊接许可 (P操作) printf(====================== (1) 焊接元器件... ); sleep(1); sem_post(sem_check); // 发出检查许可 (V操作) // 步骤2：检查void* check_thread(void* arg) while(1) sem_wait(sem_check); // 等待检查许可 (P操作) printf((2) 检查元器件... ); sleep(1); sem_post(sem_pack); // 发出打包许可 (V操作) // 步骤3：打包void* pack_thread(void* arg) while(1) sem_wait(sem_pack); // 等待打包许可 (P操作) printf((3) 打包并发货... ); sleep(1); sem_post(sem_weld); // 允许开始下一轮焊接 (V操作) int main() // 初始时，只允许焊接(值为1)，检查和打包都不允许(值为0) sem_init(sem_weld, 0, 1); sem_init(sem_check, 0, 0); sem_init(sem_pack, 0, 0); pthread_t tid_weld, tid_check, tid_pack; pthread_create(tid_weld, NULL, weld_thread, NULL); pthread_create(tid_check, NULL, check_thread, NULL); pthread_create(tid_pack, NULL, pack_thread, NULL); pthread_join(tid_weld, NULL); // 主线程阻塞 sem_destroy(sem_weld); sem_destroy(sem_check); sem_destroy(sem_pack); return 0; 条件变量 (Condition Variable) 条件变量提供了一种更高效的等待/通知机制。它允许一个线程在某个条件不满足时挂起等待，直到另一个线程满足了该条件并发出通知，从而避免了低效的“忙等”（在循环中不断检查条件）。 重要：条件变量必须与互斥锁配合使用！ 因为“条件”本身就是共享数据，对它的检查和修改必须在互斥锁的保护下进行。 工作流程: 等待方: a. 加锁 pthread_mutex_lock()。 b. while 循环检查条件是否满足。 c. 如果不满足，调用 pthread_cond_wait()。此函数会原子地：1.解锁互斥锁 2.让线程阻塞 d. 当被唤醒时，pthread_cond_wait() 会自动重新加锁**，然后 while 循环会再次检查条件 e. 条件满足，执行任务。 f. 解锁 pthread_mutex_unlock() 通知方: a. 加锁 pthread_mutex_lock() b. 修改条件。 c. 调用 pthread_cond_signal() (唤醒至少一个等待的线程) 或 pthread_cond_broadcast() (唤醒所有等待的线程) d. 解锁 pthread_mutex_unlock() 核心 API int pthread_cond_init(pthread_cond_t *cond, ...); int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex); int pthread_cond_signal(pthread_cond_t *cond); int pthread_cond_broadcast(pthread_cond_t *cond); int pthread_cond_destroy(pthread_cond_t *cond); 示例：使用条件变量实现生产者-消费者模型 #include stdio.h#include pthread.h#include unistd.h// 共享的仓库int stock = 0;pthread_mutex_t lock;pthread_cond_t cond_producer; // 条件：仓库未满，可生产pthread_cond_t cond_consumer; // 条件：仓库不空，可消费// 生产者线程void* producer_thread(void* arg) while (1) pthread_mutex_lock(lock); while (stock = 5) // 条件：仓库满了 printf(生产者: 仓库已满，等待消费... ); // 等待“仓库未满”的条件，等待时自动释放锁 pthread_cond_wait(cond_producer, lock); stock++; printf(生产者: 生产一件产品，当前库存: %d , stock); // 通知消费者“仓库不空”了 pthread_cond_signal(cond_consumer); pthread_mutex_unlock(lock); sleep(1); // 消费者线程void* consumer_thread(void* arg) while (1) pthread_mutex_lock(lock); while (stock = 0) // 条件：仓库空了 printf(消费者: 仓库已空，等待生产... ); // 等待“仓库不空”的条件，等待时自动释放锁 pthread_cond_wait(cond_consumer, lock); stock--; printf(消费者: 消费一件产品，当前库存: %d , stock); // 通知生产者“仓库未满”了 pthread_cond_signal(cond_producer); pthread_mutex_unlock(lock); usleep(500000); int main() pthread_mutex_init(lock, NULL); pthread_cond_init(cond_producer, NULL); pthread_cond_init(cond_consumer, NULL); pthread_t pid, cid; pthread_create(pid, NULL, producer_thread, NULL); pthread_create(cid, NULL, consumer_thread, NULL); pthread_join(pid, NULL); pthread_mutex_destroy(lock); pthread_cond_destroy(cond_producer); pthread_cond_destroy(cond_consumer); return 0; 好的，没问题。我会根据老师的教案，为你整理出一份结构清晰、代码完整且功能正确的线程池笔记。 笔记将从概念入手，逐步深入，从一个最简单的模型演进到一个功能更完善的中等模型，最后提供一个结构化、可复用的高等线程池设计框架。所有代码我都进行了整理和测试，确保其可运行并实现预期功能。 线程池（拓展） 一、线程池的概念 说明：线程池是一种线程使用模式。它预先创建并维护一个由多个工作线程组成的“池子”。当任务到来时，不再临时创建新线程，而是从池中唤醒一个处于休眠状态的线程来执行任务。任务完成后，该线程不会被销毁，而是返回池中继续休眠，等待下一个任务。 优点： 降低资源消耗：通过复用已存在的线程，避免了频繁创建和销毁线程所带来的系统开销。 提高响应速度：任务可以立即被空闲线程执行，省去了创建线程的等待时间。 提高线程可管理性：可以对池中的线程进行统一分配、调优和监控。 图示： 二、简单的线程池设计 (1) 设计方案 这个最简单的模型旨在演示线程池的核心思想：预创建、休眠等待、唤醒执行。 创建多个线程 (招聘员工)：程序启动时，一次性创建多个工作线程。 让线程休眠 (员工待命)：使用条件变量让所有工作线程都进入阻塞等待状态。 唤醒线程执行任务 (派发任务)：当需要执行任务时，主线程发送一个信号，唤醒池中的一个线程来执行固定的任务。 (2) 示例代码 这个模型中，所有线程执行的任务是固定的，主线程通过 getchar() 模拟任务的到来，并使用 pthread_cond_signal() 随机唤醒一个线程。 #include stdio.h#include pthread.h#include unistd.h// 全局的条件变量和互斥锁pthread_cond_t cond;pthread_mutex_t mutex;// 工作线程函数void* worker(void* arg) int worker_id = *(int*)arg; while (1) // 加锁以保护对条件变量的访问 pthread_mutex_lock(mutex); printf(员工 %d (TID: %lu): 正在休息，等待任务... , worker_id, pthread_self()); // 等待条件变量信号，等待时会自动解锁，被唤醒后会自动加锁 pthread_cond_wait(cond, mutex); printf(员工 %d (TID: %lu): 被唤醒，开始工作！ , worker_id, pthread_self()); // 模拟执行任务 sleep(2); printf(员工 %d (TID: %lu): 任务完成，准备继续休息。 , worker_id, pthread_self()); // 解锁 pthread_mutex_unlock(mutex); return NULL;int main(void) // 1. 初始化互斥锁和条件变量 pthread_mutex_init(mutex, NULL); pthread_cond_init(cond, NULL); // 2. 创建线程池（招聘5名员工） const int NUM_WORKERS = 5; pthread_t workers[NUM_WORKERS]; int worker_ids[NUM_WORKERS]; for (int i = 0; i NUM_WORKERS; i++) worker_ids[i] = i + 1; pthread_create(workers[i], NULL, worker, worker_ids[i]); // 3. 主线程（老板）派发任务 printf(线程池已启动。按 Enter 键派发一个任务。 ); while (1) getchar(); printf(老板：来活了！叫醒一个员工干活！ ); // 发送信号，唤醒一个正在等待的线程 pthread_cond_signal(cond); // (实际项目中需要有关闭线程池的逻辑) pthread_mutex_destroy(mutex); pthread_cond_destroy(cond); return 0; 三、中等的线程池设计 这个设计引入了任务队列的概念，使得线程池可以处理不同类型的、动态添加的任务。 (1) 设计方案 任务队列 (客户源)： 使用一个数据结构（如链表）来存储待执行的任务。 每个任务节点包含一个函数指针和传递给该函数的参数。 工作线程 (员工)： 线程不再执行固定任务，而是从任务队列中取出一个任务来执行。 如果任务队列为空，线程就休眠等待。 任务派发 (老板接活)： 主线程或任何其他线程可以将新任务添加到任务队列的末尾。 添加任务后，发送信号唤醒一个休眠的线程去处理。 (2) 示例代码 这个实现包含了一个单向链表作为任务队列，主线程负责接收用户输入并将不同的任务添加到队列中，工作线程则从队列中取任务执行。 #include stdio.h#include stdlib.h#include string.h#include pthread.h#include unistd.h#include stdbool.h// --- 1. 任务及任务队列定义 ---typedef struct Task void (*function)(void* arg); // 任务函数指针 void* arg; // 任务函数参数 struct Task* next; // 指向下一个任务 Task;// 线程池结构体typedef struct ThreadPool Task* task_queue; // 任务队列头指针 pthread_mutex_t mutex; // 互斥锁，保护任务队列 pthread_cond_t cond; // 条件变量，用于线程等待/通知 pthread_t* threads; // 工作线程ID数组 int num_threads; // 线程数量 ThreadPool;// --- 2. 任务函数 ---void task_a(void* arg) int duration = *(int*)arg; printf(TID %lu: 正在执行任务A，预计耗时 %d 秒... , pthread_self(), duration); sleep(duration); printf(TID %lu: 任务A完成。 , pthread_self());void task_b(void* arg) printf(TID %lu: 正在执行任务B，打印消息: %s , pthread_self(), (char*)arg);// --- 3. 线程池核心逻辑 ---void* worker(void* arg) ThreadPool* pool = (ThreadPool*)arg; while (1) pthread_mutex_lock(pool-mutex); // 如果任务队列为空，则等待 while (pool-task_queue == NULL) pthread_cond_wait(pool-cond, pool-mutex); // 从队列头部取出一个任务 Task* task = pool-task_queue; pool-task_queue = task-next; pthread_mutex_unlock(pool-mutex); // 执行任务 task-function(task-arg); free(task); // 释放任务节点 return NULL;// --- 4. 主函数：创建线程池并添加任务 ---int main(void) // 初始化线程池 ThreadPool pool; pool.num_threads = 5; pool.task_queue = NULL; pthread_mutex_init(pool.mutex, NULL); pthread_cond_init(pool.cond, NULL); pool.threads = malloc(sizeof(pthread_t) * pool.num_threads); // 创建工作线程 for (int i = 0; i pool.num_threads; i++) pthread_create(pool.threads[i], NULL, worker, pool); printf(线程池已创建，包含 %d 个工作线程。 , pool.num_threads); // 动态添加任务 int duration_a = 3; char* msg_b = Hello, ThreadPool!; for (int i=0; i10; ++i) // 创建任务节点 Task* new_task = malloc(sizeof(Task)); if (i % 2 == 0) new_task-function = task_a; new_task-arg = duration_a; else new_task-function = task_b; new_task-arg = msg_b; new_task-next = NULL; // 将任务添加到队列 pthread_mutex_lock(pool.mutex); Task* current = pool.task_queue; if (current == NULL) pool.task_queue = new_task; else while(current-next != NULL) current = current-next; current-next = new_task; printf(主线程：添加了一个新任务。 ); pthread_mutex_unlock(pool.mutex); // 唤醒一个等待的线程 pthread_cond_signal(pool.cond); sleep(1); // (实际项目中需要有关闭和销毁线程池的逻辑) sleep(10); // 等待任务执行 return 0; 四、高等线程池设计 (标准设计方案) 一个生产级别的线程池应该是一个封装良好的模块，提供清晰的 API，并能处理动态线程数量调整、优雅关闭等复杂情况。 (1) 线程池管理结构体 一个健壮的线程池需要一个管理结构体来维护其所有状态。 // 任务节点typedef struct Task void* (*function)(void* arg); // 任务函数指针 void* arg; // 任务函数参数 struct Task* next; // 指向下一个任务 Task;// 线程池管理结构体typedef struct ThreadPool pthread_mutex_t lock; // 互斥锁 pthread_cond_t cond; // 条件变量 Task* task_list_head; // 任务队列头 pthread_t* tids; // 线程ID数组 int min_threads; // 最小线程数 int max_threads; // 最大线程数 int active_threads; // 当前存活线程数 int busy_threads; // 当前正忙线程数 bool shutdown; // 线程池关闭标志 ThreadPool; (2) 核心功能函数 一个标准的线程池应提供以下 API： thread_pool_create(min, max): 创建并初始化线程池。 thread_pool_add_task(pool, function, arg): 向线程池中添加一个任务。 thread_pool_destroy(pool): 优雅地销毁线程池（等待所有任务完成）。 (3) 工作线程的例程 (worker_routine) 工作线程的核心逻辑是一个循环： 加锁。 检查任务队列是否为空并且线程池是否未关闭。如果条件成立，则调用 pthread_cond_wait() 阻塞等待。 检查是否需要关闭线程池或线程是否过多需要退出。 如果队列中有任务，则从队列中取出一个任务。 解锁。 执行任务。 循环返回第 1 步。 注：高等线程池的实现较为复杂，涉及动态线程管理（扩容/缩容）、任务拒绝策略、优雅关闭等高级特性，老师提供的代码框架展示了其核心思想。实际应用中，可以直接使用以下成熟的开源库 C 语言线程池库 对于纯 C 项目，以下库非常流行，它们通常轻量级且易于集成。 1. thpool (by Johan Astborg) 这是一个非常受欢迎且易于使用的 C 语言线程池库。它的代码简洁，文档清晰，非常适合初学者和中小型项目。 主要特点: 纯 C 实现：无任何外部依赖，只需引入 thpool.c 和 thpool.h 即可使用。 API 简单直观：创建、添加任务、销毁等操作都非常简单。 任务队列：内置了任务队列和同步机制（互斥锁、信号量）。 动态调整：支持在运行时增加或减少线程数量。 任务优先级：支持为任务设置优先级。 适用场景： 任何需要并发处理的 C 语言项目。 希望快速集成一个稳定线程池而不愿深入复杂细节的开发者。 嵌入式 Linux 项目。 基本用法示例: #include thpool.hvoid my_task(void* arg) printf(Thread #%u is executing task %d , (int)pthread_self(), *(int*)arg);int main() threadpool thpool = thpool_init(4); // 创建一个有4个线程的线程池 int i; for (i=0; i20; i++) int *a = malloc(sizeof(int)); *a = i; thpool_add_work(thpool, my_task, a); // 添加任务 ; thpool_wait(thpool); // 等待所有任务完成 thpool_destroy(thpool); // 销毁线程池 return 0; C++ 语言线程池库 得益于 C11 及之后版本的语言特性（如 std::function, std::future, lambda 表达式），C 的线程池库通常功能更强大、使用更灵活。 1. BS::thread_pool (by Barak Shoshany) 这是一个现代化、轻量级且功能极其丰富的 C++17 线程池库，在 GitHub 上非常受欢迎。 主要特点: 仅头文件：只需包含 thread_pool.hpp 即可，集成极其方便。 现代 C++ 设计：完美支持 lambda 表达式、std::function 等。 支持 future：可以轻松获取任务的返回值，实现异步编程。 高性能：代码经过优化，性能表现优异。 任务同步：提供了等待任务完成的多种方式。 动态调整：可以在运行时修改线程数量。 适用场景: 所有使用现代 C++ (C++17/20) 的项目。 需要从并发任务中获取返回值的场景。 追求高性能和易用性的项目。 基本用法示例: #include thread_pool.hpp#include iostreamint main() BS::thread_pool pool(4); // 创建一个有4个线程的线程池 // 提交任务并获取 future auto future1 = pool.submit([] return 10 + 20; ); pool.submit([] std::cout This is a task without return value. std::endl; ); // 等待并获取任务返回值 std::cout Result of task 1: future1.get() std::endl; return 0; 2. ThreadPool (by progschj) 这是一个非常经典和简洁的 C++11 线程池实现，同样是仅头文件。它的代码量很小，非常适合学习线程池的内部实现原理。 主要特点: 仅头文件：只需一个 ThreadPool.h 文件。 C++11 实现：兼容性好，依赖标准库。 支持 future：同样支持提交任务并获取返回值。 简洁明了：代码实现非常清晰，是学习的绝佳范本。 适用场景: 中小型 C++11/14 项目。 希望理解线程池底层实现的开发者。 基本用法示例: #include ThreadPool.h#include iostreamint main() ThreadPool pool(4); // 创建一个有4个线程的线程池 // 提交任务并获取 future auto result = pool.enqueue([](int answer) return answer; , 42); // 等待并获取返回值 std::cout Task returned: result.get() std::endl; return 0; 如何选择？ 库名称 语言 主要优点 适合场景 thpool C 纯 C、API 简单、支持动态调整 C 项目、嵌入式 Linux、快速集成 BS::thread_pool C++ 功能最丰富、性能高、现代 C++ 特性支持好 C++17/20 项目、需要异步获取结果、追求高性能 ThreadPool (progschj) C++ 简洁、经典、易于学习其实现原理 C++11/14 项目、学习目的、中小型项目 总结建议： 如果你的项目是纯 C，或者你在嵌入式 Linux 环境下开发，thpool 是一个非常优秀和稳妥的选择。 如果你的项目使用现代 C++ (C++17 或更高版本)，强烈推荐 BS::thread_pool，它的功能、性能和易用性都是顶级的。 如果你在使用 C++11/14，并且想要一个简单可靠的方案，或者想通过阅读源码来学习，ThreadPool (by progschj) 是一个绝佳的起点。 考试考点总结：Linux 并发编程 I. Linux 多线程编程 (Pthreads) 1. 线程概念与基础 定义区分： 进程 (Process)：是系统分配资源的最小单位，拥有独立的虚拟内存空间。 线程 (Thread)：是系统调度的最小单位，不分配新的内存空间，但在进程内参与调度。 线程库：Linux 多线程编程主要依赖 POSIX Threads (Pthreads) 库。 编译注意：由于 Pthreads 并非 C 标准库的一部分，编译链接时必须显式添加 -pthread 标志。 2. 核心生命周期函数（创建、等待与退出） 函数 作用 关键点 pthread_create 创建新的线程执行流。 传入 start_routine (新线程要执行的任务函数) 和 attr (线程属性)。 pthread_join 阻塞地等待指定线程结束，并回收其占用的系统资源。 重要性：线程结束后资源不会自动释放，如不回收会形成僵尸线程，导致资源泄漏。 pthread_exit 显式安全地终止当前线程。 效果等同于在线程函数中 return value。 exit(0) 切勿使用。它会立即终止整个进程，导致进程内所有线程全部被强制销毁。 3. 线程资源管理（属性对象 pthread_attr_t） 线程属性主要用于管理资源分配（栈大小）和资源回收（分离状态）。 通用五步法：定义 - pthread_attr_init() - pthread_attr_set*() - pthread_create() - pthread_attr_destroy()。 栈大小：通过 pthread_attr_setstacksize() 控制线程内存消耗。若栈溢出将导致程序崩溃（段错误）。 回收策略 (分离状态)： PTHREAD_CREATE_JOINABLE (默认)：需要主程序调用 pthread_join 手动回收。 PTHREAD_CREATE_DETACHED (分离)：系统自动回收资源，主程序无需 join。 可以通过 pthread_attr_setdetachstate() 在创建时设置，或在创建后调用 pthread_detach() 设置。 4. 线程同步与互斥（线程安全） 核心概念： 线程安全：代码在多线程调用下仍能保证正确性。 竞态条件：多线程并发访问共享数据时，结果依赖于执行时序，是线程不安全的根源。 临界区：访问共享资源的代码段，必须确保独占访问。 同步机制 目的 关键 API 与规则 互斥锁 (Mutex) 独占访问临界区。 pthread_mutex_lock() (阻塞等待加锁)，pthread_mutex_unlock() (释放锁)。 读写锁 (RW Lock) 提高“读多写少”场景的并发性。 读锁可共享 (rdlock)，写锁独占 (wrlock)。 信号量 (Semaphore) 计数器，用于管理有限资源的访问或协调执行顺序。 P 操作 (sem_wait)：计数器减 1，值为 0 时阻塞。V 操作 (sem_post)：计数器加 1，唤醒等待线程。 条件变量 (Cond Var) 高效的等待/通知机制，避免忙等。 必须与互斥锁配合使用。pthread_cond_wait() 原子地解锁互斥锁并阻塞，被唤醒时自动重新加锁。 II. Linux 进程基础与管理 1. 进程状态与生命周期 进程：已经被加载到内存中的程序文件，是动态的。 重点状态： 就绪态：等待 CPU 时间片。 僵尸态 (Zombie)：子进程死亡后，等待父进程调用 wait/waitpid 收尸。必须避免，否则会耗尽系统 PID。 死亡态：父进程回收资源后，彻底清理。 2. 进程创建与回收 创建 (fork)： 创建后父子进程执行同一段代码。 不同点：PID 和 fork() 返回值不同（父进程返回子 PID，子进程返回 0）。 资源：父子进程的全局变量、局部变量等各自独立修改，互不影响（资源独立）。 回收 (wait/waitpid)： wait()：阻塞等待任意子进程结束。 waitpid()：更灵活，可等待特定子进程（pid 0），可设置为非阻塞 (WNOHANG)。 退出状态宏：使用 WIFEXITED() 判断是否正常退出，使用 WEXITSTATUS() 获取退出码。 退出方式： exit(status)：终止整个进程，执行清理操作（如刷新 I/O 缓冲区，调用 atexit 注册函数）。 _exit(status)：立即终止进程，不执行任何清理操作。推荐在 fork() 后的子进程中使用，以避免影响父进程的 I/O 流。 3. 特殊进程关系 僵尸进程：子进程先结束，父进程未回收。危害是占用 PID，导致系统瘫痪。 孤儿进程：父进程先于子进程结束。孤儿进程会被系统的 1 号进程（systemd）收养，由其负责回收。 守护进程 (Daemon)：脱离控制终端的后台进程。创建核心步骤包括 fork 两次（通常简化为一次，父进程退出），以及调用 setsid() 创建新会话并脱离控制终端。 4. 程序加载 system()：执行 shell 命令字符串，会创建子进程，并阻塞等待命令执行完毕。 exec 系列函数：最核心的加载机制。不会创建新进程，而是用新程序替换当前进程的内存空间。调用成功后，程序不会返回。常见模式是 fork() + exec()。 III. 进程间通信 (IPC) 核心挑战：进程隔离（每个进程有独立的虚拟内存空间）。IPC 机制依赖于内核空间开辟共享区域。 1. 管道 (Pipe) 匿名管道：仅用于具有亲缘关系的进程（如父子进程）。 命名管道 (FIFO)：在文件系统中存在路径名，可用于任意不相关进程通信。 2. 信号 (Signal) 特点：异步通信机制，用于通知事件发生，不传输数据。类似于软件中断。 重要信号：SIGKILL (9) 和 SIGSTOP (19) 不可被捕捉或忽略。SIGCHLD (17) 用于父进程异步处理子进程退出。 编程：使用 signal() 设置信号处理方式。 3. System V IPC (共享内存、消息队列、信号量) System V IPC 机制遵循相似的工作流程：ftok() 创建密钥 - *get() 获取 ID - *snd/*rcv/shmat/semop 操作 - *ctl() 销毁。 机制 特点 速度与用途 共享内存 (Shared Memory) 最快的 IPC 方式。 将同一块物理内存映射到多进程虚拟地址空间，进程直接读写，无需内核数据拷贝。 消息队列 (Message Queue) 内核中的消息链表。 克服管道只能传输字节流的限制，适用于传输结构化消息。 信号量 (Semaphore) 计数器。 主要用于进程间的同步与互斥，保护共享内存等资源。 总结 Linux 并发编程的核心是围绕进程（Process）和线程（Thread）的生命周期管理、同步互斥以及通信机制这三大支柱展开的 首先，你必须清晰地区分进程和线程：进程是系统分配资源的独立单位，通过 fork() 创建，拥有独立的内存空间，父进程必须调用 wait() 或 waitpid() 回收子进程资源以防僵尸进程，并通过 WIFEXITED() 等宏解析其退出状态；线程是系统调度的最小单位，通过 pthread_create() 创建，它们共享进程的大部分资源（如内存），因此执行开销远小于进程，需要通过 pthread_join() 回收资源，或通过 pthread_detach() 设置为分离状态让系统自动回收 其次，由于线程共享内存，线程安全是重中之重，其核心是互斥与同步： 互斥是为了保护临界区，防止竞态条件。最核心的工具是互斥锁（Mutex），其操作流程为 pthread_mutex_init() - pthread_mutex_lock() - 访问共享资源 - pthread_mutex_unlock()。对于“读多写少”的场景，应使用读写锁（Read-Write Lock）（pthread_rwlock_rdlock() / pthread_rwlock_wrlock()）来提高并发性能 同步是为了协调线程间的执行顺序。关键工具有两种：信号量（Semaphore），通过 sem_init() 初始化，使用 sem_wait()（P 操作，申请资源）和 sem_post()（V 操作，释放资源）来控制对有限资源的访问；条件变量（Condition Variable），它必须与互斥锁配合使用，通过 pthread_cond_wait() 让线程在某个条件不满足时原子性地解锁并挂起等待，再由另一线程在改变条件后通过 pthread_cond_signal() 或 pthread_cond_broadcast() 发出通知将其唤醒 最后，由于进程内存相互隔离，它们必须依赖内核提供的进程间通信（IPC） 机制： 简单的通信方式包括匿名管道（pipe()，用于父子进程）和命名管道（mkfifo()，用于任意进程） 信号（Signal） 是一种异步通知机制，通过 kill() 发送，并使用 signal() 注册处理函数，常用于事件通知（如 SIGCHLD 信号可用于异步回收子进程）。 功能最强大的 System V IPC 体系，它们都依赖 ftok() 生成的密钥来标识：共享内存（Shared Memory） 是最快的 IPC 方式（shmget() / shmat()），因为它避免了内核数据拷贝，但必须配合信号量等工具进行同步；消息队列（Message Queue）（msgget() / msgsnd() / msgrcv()）则适用于结构化的小数据块交换。所有 System V IPC 对象都需要通过 ipcs 命令查看并通过 ipcrm 命令或 msgctl/shmctl 函数手动销毁","tags":[null],"categories":[null,null]},{"title":"Linux 网络编程","path":"/data/ES/进阶/网络编程.html","content":"计算机网络概念入门资料，从入门到进阶，依次如下： 一个视频讲清楚家庭网络通信流程，折腾软路由前必看的计算机网络通识教程 | Youtube 你管这破玩意叫网络 | 闪客 图解计算机网络| 小林 coding 图解计算机网络| 小林 coding | Github 开源版本 Linux 网络编程 网络编程的核心——Socket 无论是 UDP 还是 TCP，在 Linux 中都是通过“Socket（套接字）”这一统一的接口来实现的。可以把 Socket 理解为一个“通信端点”，我们的程序通过读写这个“文件”来收发网络数据。 本笔记将围绕 Socket 展开，分为两大核心部分： UDP 编程：学习如何使用数据报套接字（SOCK_DGRAM），实现简单、高效但不可靠的通信 TCP 编程：学习如何使用流式套接字（SOCK_STREAM），实现复杂、可靠、面向连接的通信 我会先从各自的协议特性讲起，然后深入学习核心 API 的使用，最后探讨各自的高级应用场景和服务器模型 UDP 协议 一、传输层协议与 UDP 基础 1. UDP 协议的核心特点 UDP (User Datagram Protocol) 是传输层的一个核心协议，其设计哲学是简单、高效。根据其标准文档 RFC 768，UDP 的主要特点可以总结如下： 无连接 (Connectionless)：发送数据前，双方不需要像打电话一样先“建立连接”。发送端直接将数据打包发出，接收端直接接收。 不可靠 (Unreliable)：UDP 不保证数据包一定能送达，也不保证数据包的顺序，更不会在数据包丢失后进行重传。所有可靠性保障都需要应用层自己实现。 面向数据报 (Datagram-Oriented)：应用层交下来多大的数据块，UDP 就直接打包成一个数据报发送，它不会对数据进行拆分或合并。 高效率、低延迟：由于没有建立连接、确认、重传等复杂的机制，UDP 的头部开销小，处理速度快，延迟低。 一句话总结：UDP 提供的是一种“尽力而为”的、高效的、简单的信息传送服务。 2. UDP 协议的报头结构 UDP 的报头非常简单，仅有 8 个字节，这也是其高效的原因之一 源端口号 (16 位)：发送方进程的端口号。可选，若不使用则为 0。 目标端口号 (16 位)：接收方进程的端口号。必需。 包总长度 (16 位)：UDP 报头 + UDP 数据的总长度（字节）。最大值为 65535 字节。 实际数据最大值：65535 - 8 (UDP 头) - 20 (IP 头) = 65507 字节。 实践建议：为避免在网络层被分片（分片会增加丢包风险），UDP 数据包的大小最好控制在 MTU (通常为 1500 字节) 以内，即数据大小不超过 1472 字节。 校验和 (16 位)：用于检查数据在传输过程中是否出错。可选，若不使用则为 0。 二、UDP 核心 Socket API 在 Linux 中，网络通信是通过 Socket (套接字) 文件来实现的。“一切皆文件”的思想在这里也适用。 UDP 通信基本流程： 服务器 (接收端)：socket() - bind() - recvfrom() - close() 客户端 (发送端)：socket() - sendto() - close() 1. socket() - 创建套接字 man 2 socket 查看接口函数。 #include sys/socket.hint socket(int domain, int type, int protocol);参数分别为： 协议族 ， 套接字类型 ， 具体协议 domain: 协议族。对于 IPv4 网络，使用 AF_INET。 type: 套接字类型。 SOCK_DGRAM: 用于 UDP 协议 (数据报套接字)。 SOCK_STREAM: 用于 TCP 协议 (流式套接字)。 protocol: 具体协议。通常设为 0，让系统自动选择。 返回值：成功返回一个文件描述符 (sockfd)，失败返回 -1。 创建 UDP 套接字示例： int sockfd = socket(AF_INET, SOCK_DGRAM, 0); 2. bind() - 绑定地址和端口 man 2 bind 查看接口函数。 int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);参数分别为： 套接字文件描述符 ， 地址信息结构体 ， 结构体长度 作用：将一个套接字与一个具体的 IP 地址和端口号绑定起来。这通常是服务器端在接收数据前必须做的 sockfd: socket() 返回的文件描述符 addr: 指向一个 struct sockaddr 结构体的指针，但实际使用时我们通常填充一个 struct sockaddr_in 结构体，然后进行强制类型转换，这样方便管理 ipv4 数据 addrlen: addr 结构体的长度。 struct sockaddr_in 结构体 #include netinet/in.hstruct sockaddr_in sa_family_t sin_family; // 协议族，必须为 AF_INET in_port_t sin_port; // 16位端口号 struct in_addr sin_addr; // 32位IPv4地址;struct in_addr uint32_t s_addr; // IPv4地址; 核心概念：网络字节序 (Big Endian) 不同的计算机体系结构存储多字节数据的方式可能不同（大端 vs. 小端）。为了在网络中统一标准，所有网络协议都规定使用大端序。因此，在填充 sockaddr_in 结构体时，必须将主机字节序的端口和地址转换为网络字节序。 htons(): Host to Network Short (16 位，用于端口号)。 htonl(): Host to Network Long (32 位，用于 IP 地址)。 ntohs(), ntohl(): Network to Host，反向转换。 inet_addr(): 将点分十进制的 IP 地址字符串转换为网络字节序的 32 位整数。 setsockopt()设置端口复用 在网络程序开发，尤其是在频繁重启调试时，你几乎一定会遇到 bind failed: Address already in use 这个错误。 问题根源：当你关闭一个网络程序时，操作系统为了确保网络中残余的数据包能被正确处理，会使该程序占用的端口进入一个名为 TIME_WAIT 的状态，并持续一小段时间。在这段时间内，该端口被视为“仍在使用中”，任何新程序都无法立即绑定它。 解决方案：使用 setsockopt() 函数为套接字设置 SO_REUSEADDR (地址复用) 选项。这个选项向操作系统声明：“我允许将此套接字绑定到一个正在 TIME_WAIT 状态的地址上”。 setsockopt() 函数 #include sys/socket.hint setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);参数分别为： 文件描述符 ， 协议层等级 ， 选项名 ， 选项值 ， 选项值长度 作用：设置套接字的各种选项，以改变其默认行为。 level: 选项所属的协议层。SOL_SOCKET 表示套接字本身。 optname: 选项名称，例如 SO_REUSEADDR。 optval: 指向一个变量的指针，该变量的值就是选项要设置的值。 代码实现 在 socket() 创建套接字之后、bind() 绑定地址之前，加入以下代码： // 在 socket() 之后，bind() 之前int sockfd = socket(AF_INET, SOCK_DGRAM, 0);// 设置地址复用选项，解决 TIME_WAIT 问题int optval = 1; // 1 表示开启该选项if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, optval, sizeof(optval)) 0) perror(setsockopt failed); close(sockfd); return -1;// 继续执行 bind()bind(sockfd, ...); 重要提示：SO_REUSEADDR 选项主要用于解决 TIME_WAIT 状态导致无法立即重启程序的问题。它不能让两个程序在同一时刻都成功 bind 并监听同一个端口（除非在特定的组播场景下）。如果错误持续存在，请检查是否已有另一个程序实例正在后台运行。 3. sendto() recvfrom() - 收发数据 man 2 sendto 和 man 2 recvfrom 查看接口函数 // 发送数据ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);参数分别为： 文件描述符 ，要发送数据 ， 发送数据长度 ， 控制标准（一般为0） 目标地址结构体指针 ， 目标地址结构体长度// 接收数据ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);参数分别为： 文件描述符 ，要发送数据 ， 发送数据长度 ， 控制标准（一般为0） 自身地址结构体指针 ， 自身地址结构体长度 sendto() 需要指定目标地址 dest_addr。 recvfrom() 会阻塞程序，直到收到数据，并能获取到源地址 src_addr。 示例：简单的客户端/服务器 服务器 (接收端) udp_server.c #include stdio.h#include sys/socket.h#include netinet/in.h#include arpa/inet.h#include unistd.h#include string.hint main(void) // 1. 创建套接字 int sockfd = socket(AF_INET, SOCK_DGRAM, 0); // 2. 绑定地址和端口 struct sockaddr_in my_addr; my_addr.sin_family = AF_INET; my_addr.sin_port = htons(8888); // 绑定8888端口 my_addr.sin_addr.s_addr = inet_addr(192.168.59.198); // 绑定本机IP bind(sockfd, (struct sockaddr *)my_addr, sizeof(my_addr)); // 3. 接收数据 char buf[128] = 0; struct sockaddr_in client_addr; socklen_t len = sizeof(client_addr); recvfrom(sockfd, buf, sizeof(buf), 0, (struct sockaddr *)client_addr, len); printf(收到来自 %s 的消息: %s , inet_ntoa(client_addr.sin_addr), buf); // 4. 关闭套接字 close(sockfd); return 0; 客户端 (发送端) udp_client.c #include stdio.h#include sys/socket.h#include netinet/in.h#include arpa/inet.h#include unistd.h#include string.hint main(void) // 1. 创建套接字 int sockfd = socket(AF_INET, SOCK_DGRAM, 0); // 2. 准备目标地址并发送数据 struct sockaddr_in dest_addr; dest_addr.sin_family = AF_INET; dest_addr.sin_port = htons(8888); dest_addr.sin_addr.s_addr = inet_addr(192.168.59.198); char *msg = Hello, UDP Server!; sendto(sockfd, msg, strlen(msg), 0, (struct sockaddr *)dest_addr, sizeof(dest_addr)); // 3. 关闭套接字 close(sockfd); return 0; 示例：使用线程实现收发一体 #include arpa/inet.h#include netinet/in.h#include pthread.h#include stdio.h#include stdlib.h#include string.h#include sys/socket.h#include unistd.h#define SEND_PORT 50001#define SEND_IP 192.168.59.198#define RECV_PORT 50003// 线程任务：接收消息void* receive_thread(void* arg) // 1. 创建 socket int sockfd = socket(AF_INET, SOCK_DGRAM, 0); if (sockfd == -1) perror(socket creation failed); return NULL; // 线程异常退出 // 2. 绑定本地地址和端口用于接收 struct sockaddr_in my_addr; memset(my_addr, 0, sizeof(my_addr)); my_addr.sin_family = AF_INET; my_addr.sin_port = htons(RECV_PORT); // 用INADDR_ANY，接收发送到本机任何IP地址上指定端口的数据 my_addr.sin_addr.s_addr = htonl(INADDR_ANY); if (bind(sockfd, (struct sockaddr*)my_addr, sizeof(my_addr)) == -1) perror(bind failed); close(sockfd); return NULL; // 线程异常退出 printf(接收线程启动，正在监听端口 %d , RECV_PORT); char buffer[512]; struct sockaddr_in src_addr; socklen_t src_addr_len = sizeof(src_addr); // 3. 循环接收消息 while (1) memset(buffer, 0, sizeof(buffer)); ssize_t recv_len = recvfrom(sockfd, buffer, sizeof(buffer) - 1, 0, (struct sockaddr*)src_addr, src_addr_len); if (recv_len 0) printf( [收到消息]: %s , buffer); fflush(stdout); // 刷新输出缓冲区，确保提示符 能正确显示 if (strncmp(buffer, quit, 4) == 0) printf(对方已退出，接收线程关闭。 ); break; else perror(recvfrom error); break; // 出现错误时退出循环 // 4. 关闭 socket close(sockfd); return NULL;// 线程任务：发送消息void* send_thread(void* arg) // 1. 创建 socket int sockfd = socket(AF_INET, SOCK_DGRAM, 0); if (sockfd == -1) perror(socket creation failed); return NULL; // 2. 设置目标地址和端口 struct sockaddr_in dest_addr; memset(dest_addr, 0, sizeof(dest_addr)); dest_addr.sin_family = AF_INET; dest_addr.sin_port = htons(SEND_PORT); // 注意：这里是发送目标端口 dest_addr.sin_addr.s_addr = inet_addr(SEND_IP); printf(发送线程启动，准备向 %s:%d 发送消息 , SEND_IP, SEND_PORT); char message[100]; printf( ); fflush(stdout); // 3. 循环发送消息 while (fgets(message, sizeof(message), stdin) != NULL) // 移除 fgets 读取到的换行符 message[strcspn(message, )] = 0; if (strlen(message) == 0) // 如果用户只输入回车 printf( ); fflush(stdout); continue; sendto(sockfd, message, strlen(message), 0, (struct sockaddr*)dest_addr, sizeof(dest_addr)); if (strncmp(message, quit, 4) == 0) printf(你已退出，发送线程关闭。 ); break; printf( ); fflush(stdout); // 4. 关闭 socket close(sockfd); return NULL;int main(void) pthread_t tid_receive, tid_send; pthread_create(tid_receive, NULL, receive_thread, NULL); pthread_create(tid_send, NULL, send_thread, NULL); pthread_join(tid_receive, NULL); pthread_join(tid_send, NULL); printf(所有线程已结束，主程序退出。 ); return 0; 三、UDP 的广播与组播 1. UDP 广播 (Broadcast) 概念：向局域网内的所有主机发送数据包。 广播地址：一个特殊的 IP 地址，通常是网络号不变，主机号全为 1。例如，对于 192.168.5.0/24 网段，广播地址是 192.168.5.255。 实现： 发送方：必须使用 setsockopt() 函数为套接字开启广播权限。 接收方：bind() 时绑定的 IP 地址应为 INADDR_ANY，表示接收发送到本机任意网卡的数据包。 setsockopt() - 设置套接字 man 2 setsockopt 查看接口函数。 int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);参数分别为： 文件描述符 ， 协议层级 ， 选项名 ， 选项值指针 ， 选项值长度 例如设置开启广播权限： int on = 1;setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, on, sizeof(on)); 2. UDP 组播/多播 (Multicast) 概念：向一个特定“小组”内的所有成员发送数据包，只有加入了该组的主机才能收到。这比广播更高效，因为它只影响感兴趣的主机。 组播地址：D 类 IP 地址，范围从 224.0.0.0 到 239.255.255.255。 实现： 发送方：与广播类似，需要开启广播权限，并向一个组播地址发送数据。 接收方：必须使用 setsockopt() 加入一个或多个组播组。 加入组播组： struct ip_mreq mreq;mreq.imr_multiaddr.s_addr = inet_addr(224.0.0.10); // 组播组地址mreq.imr_interface.s_addr = htonl(INADDR_ANY); // 使用哪个网卡加入，INADDR_ANY表示由系统选择setsockopt(sockfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, mreq, sizeof(mreq)); 四、UDP 的应用 1. 适用场景 UDP 的高效和低延迟特性使其非常适合以下场景： 音视频流传输：如直播、视频会议。偶尔丢失一两帧数据不影响整体体验。 实时游戏：对实时性要求极高。 DNS (域名解析)：一次简短的请求和响应，追求速度。 网络发现协议：如 DHCP。 2. 示例：DNS 域名解析 Linux 提供了 gethostbyname() 函数来查询域名对应的 IP 地址。 man 3 gethostbyname 查看接口函数。 #include stdio.h#include netdb.h#include arpa/inet.hint main() struct hostent *host_info; char *hostname = www.baidu.com; host_info = gethostbyname(hostname); if (host_info == NULL) herror(gethostbyname); return -1; printf(%s 的 IP 地址列表: , hostname); for (int i = 0; host_info-h_addr_list[i] != NULL; i++) // inet_ntoa 将网络字节序的地址转换为点分十进制字符串 printf( %s , inet_ntoa(*(struct in_addr*)host_info-h_addr_list[i])); return 0; TCP 协议 一、TCP 协议基础 1. TCP 协议的核心特点 TCP (Transmission Control Protocol) 是传输层与 UDP 并列的核心协议，但它的设计目标是可靠性。 面向连接 (Connection-Oriented)：在数据传输前，通信双方必须先通过“三次握手”建立一个逻辑连接。通信结束后，通过“四次挥手”断开连接。 可靠传输 (Reliable)：TCP 通过多种机制确保数据不丢失、不重复、无差错、按顺序到达。 全双工通信 (Full-Duplex)：连接建立后，双方可以同时进行数据的发送和接收。 面向字节流 (Byte Stream-Oriented)：应用程序发送的数据会被 TCP 视为一连串无边界的字节流。TCP 可能会根据网络状况对数据进行分段或合并，接收方需要自己处理“粘包”和“半包”问题。 一句话总结：TCP 就像打电话，必须先拨号接通，通话过程稳定可靠，说完后挂断，只支持一对一通话。 2. TCP 如何保证可靠性？ TCP 的可靠性并非凭空而来，而是依赖于其精巧的报头设计和一系列机制： 序列号 (Sequence Number)：TCP 为每个发送的字节都编上号。接收方可以根据序列号来检测数据包的丢失、重组乱序的数据包。 确认应答 (ACK)：接收方每收到一个数据包，都会发送一个 ACK 确认包，告知发送方“我收到了序列号 xxx 之前的所有数据”。 超时重传 (Timeout Retransmission)：发送方在发出数据后会启动一个计时器。如果在规定时间内没有收到对方的 ACK，就会认为数据包丢失，并重新发送该数据包。 校验和 (Checksum)：发送方和接收方都会对报头和数据进行校验和计算，以检测数据在传输过程中是否损坏。 流量控制 (Flow Control)：通过报头中的“窗口大小”字段，接收方可以告知发送方自己还能接收多少数据，防止发送方发送过快导致接收方缓冲区溢出。 3. TCP 报头格式 TCP 的报头比 UDP 复杂得多，标准长度为 20 字节，包含了实现其可靠性所需的各种字段。 关键字段说明： 源/目标端口号：各 16 位，标识通信的两个进程。 序列号 (Sequence Number)：32 位，标记本报文段数据第一个字节的序号。 确认应答号 (Acknowledgement Number)：32 位，期望收到的下一个字节的序列号。 头部长度：4 位，表示 TCP 头部的长度，单位是 4 字节（32 位）。 控制位 (Flags)：6 位，至关重要。 ACK: 确认位。 SYN: 同步位，在建立连接时使用。 FIN: 终止位，在断开连接时使用。 窗口大小 (Window Size)：16 位，用于流量控制。 二、TCP 连接生命周期 1. 三次握手 (建立连接) TCP 连接的建立过程由客户端发起，在 connect() 和 accept() 函数内部自动完成。 客户端 - 服务器：客户端发送一个 SYN 包（SYN=1），并携带一个随机生成的初始序列号 seq=x。客户端进入 SYN_SENT 状态。 服务器 - 客户端：服务器收到 SYN 包后，回复一个 SYN+ACK 包（SYN=1, ACK=1），并携带自己的初始序列号 seq=y 和确认号 ack=x+1。服务器进入 SYN_RCVD 状态。 客户端 - 服务器：客户端收到服务器的确认后，再发送一个 ACK 包（ACK=1），并携带确认号 ack=y+1。连接建立成功，双方进入 ESTABLISHED 状态。 2. 四次挥手 (断开连接) 连接的断开可以由任意一方发起，在 close() 函数调用时触发。 主动方 - 被动方：主动方发送一个 FIN 包（FIN=1），表示我这边的数据已经发完了。 被动方 - 主动方：被动方回复一个 ACK 包，表示收到了你的断开请求。 被动方 - 主动方：被动方处理完自己要发送的数据后，也发送一个 FIN 包。 主动方 - 被动方：主动方回复最后一个 ACK 包。 TIME_WAIT 状态 主动断开方在发送完最后一个 ACK 后，会进入 TIME_WAIT 状态，并持续 2*MSL (报文最大生存时间，通常是 60 秒) 的时间。 目的： 确保最后一个 ACK 包能成功到达对方（如果丢失，对方会重传FIN，我方可以再次回复ACK）。 防止网络中延迟的旧连接数据包干扰新建立的连接。 三、TCP 核心 Socket API TCP 通信基本流程： 服务器：socket() - bind() - listen() - accept() - recv() / send() - close() 客户端：socket() - connect() - send() / recv() - close() 1. 通用函数 socket() man 2 socket 查看接口函数。 int socket(int domain, int type, int protocol);参数分别为： 协议族 ， 套接字类型 ， 具体协议 作用：创建一个套接字（网络通信端点）。对于 TCP，type 必须是 SOCK_STREAM。 2. 客户端专用函数 connect() man 2 connect 查看接口函数。 int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);参数分别为： 套接字文件描述符 ， 服务器地址信息 ， 地址结构体长度 作用：客户端使用此函数向服务器发起连接请求。函数内部会自动完成三次握手。成功返回 0，失败返回-1。 3. 服务器专用函数 a. bind() - 绑定地址和端口 man 2 bind 查看接口函数。 int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);参数分别为： 套接字文件描述符 ， 本机地址信息 ， 地址结构体长度 作用：将套接字与服务器的 IP 地址和端口号关联起来，告诉内核监听哪个端口。 b. listen() - 设置监听状态 man 2 listen 查看接口函数。 int listen(int sockfd, int backlog);参数分别为： 监听的套接字 ， 等待连接队列的最大长度 作用：将一个主动套接字转换为被动监听套接字，准备接受客户端的连接。backlog 定义了内核为这个套接字维护的、已完成三次握手但尚未被 accept() 的连接队列大小。 c. accept() - 接受连接 man 2 accept 查看接口函数。 int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);参数分别为： 监听的套接字 ， 客户端地址信息(输出) ， 地址长度(输入输出) 作用：从已完成连接队列中取出一个连接。如果队列为空，accept() 会阻塞。 返回值：成功时返回一个全新的、已连接的套接字描述符，用于与该客户端进行通信。原来的监听套接字 sockfd 保持不变，继续监听其他连接。 4. 数据收发函数 a. send() write() man 2 send 查看接口函数。 ssize_t send(int sockfd, const void *buf, size_t len, int flags);参数分别为： 已连接的套接字 ， 数据缓冲区 ， 数据长度 ， 标志位 作用：在已连接的套接字上发送数据。flags 通常为 0，此时功能与 write() 几乎相同。 b. recv() read() man 2 recv 查看接口函数。 ssize_t recv(int sockfd, void *buf, size_t len, int flags);参数分别为： 已连接的套接字 ， 接收缓冲区 ， 缓冲区长度 ， 标志位 作用：从已连接的套接字接收数据。如果缓冲区无数据，recv() 会阻塞。 返回值： 0: 成功接收的字节数。 = 0: 对方已正常关闭连接（发送了 FIN）。 0: 发生错误。 四、TCP 编程示例 服务器 tcp_server.c #include stdio.h#include sys/socket.h#include arpa/inet.h#include unistd.h#include string.hint main(void) // 1. 创建监听套接字 int listen_fd = socket(AF_INET, SOCK_STREAM, 0); // 2. 绑定地址和端口 struct sockaddr_in server_addr; server_addr.sin_family = AF_INET; server_addr.sin_port = htons(8888); server_addr.sin_addr.s_addr = INADDR_ANY; // 监听所有网卡 bind(listen_fd, (struct sockaddr *)server_addr, sizeof(server_addr)); // 3. 设置为监听状态 listen(listen_fd, 5); printf(服务器正在监听 8888 端口... ); // 4. 接受客户端连接 struct sockaddr_in client_addr; socklen_t len = sizeof(client_addr); int conn_fd = accept(listen_fd, (struct sockaddr *)client_addr, len); printf(接受来自 %s:%d 的连接 , inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port)); // 5. 接收数据 char buf[128]; int n = recv(conn_fd, buf, sizeof(buf), 0); buf[n] = \\0; printf(收到消息: %s , buf); // 6. 关闭套接字 close(conn_fd); close(listen_fd); return 0; 客户端 tcp_client.c #include stdio.h#include sys/socket.h#include arpa/inet.h#include unistd.h#include string.hint main(void) // 1. 创建套接字 int sockfd = socket(AF_INET, SOCK_STREAM, 0); // 2. 连接服务器 struct sockaddr_in server_addr; server_addr.sin_family = AF_INET; server_addr.sin_port = htons(8888); server_addr.sin_addr.s_addr = inet_addr(127.0.0.1); // 连接本机 if (connect(sockfd, (struct sockaddr *)server_addr, sizeof(server_addr)) 0) perror(connect failed); return -1; // 3. 发送数据 char *msg = Hello, TCP Server!; send(sockfd, msg, strlen(msg), 0); printf(消息已发送。 ); // 4. 关闭套接字 close(sockfd); return 0; 五、高级 TCP 特性 1. 缓冲区管理 TCP 套接字在内核中拥有独立的发送缓冲区 (Send Buffer) 和接收缓冲区 (Receive Buffer)。send() 实际上是将数据写入发送缓冲区，而 recv() 是从接收缓冲区读取数据。我们可以通过 setsockopt 来调整这些缓冲区的行为。 a. 缓冲区大小 (SO_SNDBUF / SO_RCVBUF) 作用：获取或设置 TCP 发送/接收缓冲区的大小。调整此值可以影响 TCP 的吞吐量和性能，尤其是在高延迟或高带宽网络中。 注意：设置的值只是给内核的一个“建议”，内核会自动将其调整（通常是加倍）以预留管理开销。设置应在 listen() 或 connect() 之前进行。 b. 接收低水位标记 (SO_RCVLOWAT) 作用：设置接收缓冲区的“水位线”。只有当缓冲区中待读取的数据量达到或超过这个阈值时，select/poll/epoll 等 I/O 复用函数才会认为该套接字是“可读”的。默认值为 1。 场景：可以避免频繁地被少量数据唤醒，实现“攒够一定量的数据再处理”，提高处理效率。 getsockopt() / setsockopt() - 获取/设置套接字选项 man 2 getsockopt 查看接口函数。 int getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen);int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);参数分别为： 套接字，协议层(SOL_SOCKET)，选项名，选项值指针，选项长度 作用：用于获取或配置套接字的各种底层参数。 示例代码：查询与设置缓冲区参数 该程序演示了如何查询套接字的默认缓冲区大小和低水位标记，然后根据用户输入进行设置，并验证设置后的结果。 // buffer_options.c#include stdio.h#include stdlib.h#include sys/socket.h#include netinet/in.hint main(void) int sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd 0) perror(socket); return -1; int rcv_buf_size, rcv_lowat_size; socklen_t len = sizeof(int); // 1. 获取默认值 getsockopt(sockfd, SOL_SOCKET, SO_RCVBUF, rcv_buf_size, len); getsockopt(sockfd, SOL_SOCKET, SO_RCVLOWAT, rcv_lowat_size, len); printf(默认接收缓冲区大小: %d 字节 , rcv_buf_size); printf(默认接收低水位标记: %d 字节 , rcv_lowat_size); // 2. 设置新值 printf(请输入新的接收缓冲区大小: ); scanf(%d, rcv_buf_size); setsockopt(sockfd, SOL_SOCKET, SO_RCVBUF, rcv_buf_size, sizeof(rcv_buf_size)); printf(请输入新的接收低水位标记: ); scanf(%d, rcv_lowat_size); setsockopt(sockfd, SOL_SOCKET, SO_RCVLOWAT, rcv_lowat_size, sizeof(rcv_lowat_size)); // 3. 验证设置后的值 getsockopt(sockfd, SOL_SOCKET, SO_RCVBUF, rcv_buf_size, len); getsockopt(sockfd, SOL_SOCKET, SO_RCVLOWAT, rcv_lowat_size, len); printf( 设置后，内核实际接收缓冲区大小: %d 字节 (通常为设置值的两倍) , rcv_buf_size); printf(设置后，接收低水位标记: %d 字节 , rcv_lowat_size); close(sockfd); return 0; 2. 带外数据 (Out-of-Band, OOB) 作用：提供一种发送“紧急”数据的方式。它允许发送一个字节的数据，这个数据在逻辑上独立于正常的 TCP 字节流，可以被接收方优先处理，而无需等待缓冲区中的普通数据被读完。 实现机制： 发送方: 调用 send() 时，将 flags 参数设置为 MSG_OOB。 接收方: 当 OOB 数据到达时，内核会向接收进程发送 SIGURG 信号。进程需要： a. 使用 signal() 或 sigaction() 捕捉 SIGURG 信号。 b. 使用 fcntl() 的 F_SETOWN 命令，将套接字的所有权指定给当前进程，这样内核才知道该把信号发给谁。 c. 在信号处理函数中，调用 recv() 并将 flags 参数设置为 MSG_OOB 来读取这个紧急字节。 示例代码：发送和接收带外数据 服务器 (接收端) server_oob.c // server_oob.c#include stdio.h#include signal.h#include fcntl.h#include unistd.h#include sys/socket.h#include arpa/inet.h#include string.hint conn_fd;void oob_handler(int sig) char oob_data; // 使用 MSG_OOB 标志接收紧急数据 recv(conn_fd, oob_data, 1, MSG_OOB); printf( 收到紧急数据: %c , oob_data);int main(void) int listen_fd = socket(AF_INET, SOCK_STREAM, 0); struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(8888); addr.sin_addr.s_addr = INADDR_ANY; bind(listen_fd, (struct sockaddr *)addr, sizeof(addr)); listen(listen_fd, 5); printf(等待连接... ); conn_fd = accept(listen_fd, NULL, NULL); printf(客户端已连接。 ); // 1. 设置信号处理函数 signal(SIGURG, oob_handler); // 2. 指定当前进程为信号的接收者 fcntl(conn_fd, F_SETOWN, getpid()); char buf[128]; while (1) int n = recv(conn_fd, buf, sizeof(buf) - 1, 0); if (n = 0) break; buf[n] = \\0; printf(收到普通数据: %s , buf); close(conn_fd); close(listen_fd); return 0; 客户端 (发送端) client_oob.c // client_oob.c#include stdio.h#include unistd.h#include sys/socket.h#include arpa/inet.h#include string.hint main(void) int sockfd = socket(AF_INET, SOCK_STREAM, 0); struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(8888); addr.sin_addr.s_addr = inet_addr(127.0.0.1); connect(sockfd, (struct sockaddr *)addr, sizeof(addr)); send(sockfd, normal_data_1, 13, 0); printf(发送普通数据 normal_data_1 ); sleep(1); send(sockfd, A, 1, MSG_OOB); // 发送紧急数据 printf(发送紧急数据 A ); sleep(1); send(sockfd, normal_data_2, 13, 0); printf(发送普通数据 normal_data_2 ); close(sockfd); return 0; 3. 超时控制 作用：为阻塞的套接字操作（如 accept, connect, recv）设置一个最长等待时间。如果在超时时间内操作未能完成（如没等到连接、没收到数据），函数将不再阻塞，而是立即返回一个错误，通常 errno 会被设为 EAGAIN 或 EWOULDBLOCK。这可以防止程序因网络问题而无限期挂起。 实现：通过 setsockopt 设置 SO_RCVTIMEO (接收超时) 或 SO_SNDTIMEO (发送超时) 选项。超时时间通过 struct timeval 结构体指定。 struct timeval 结构体 man 3 timeval 查看接口函数。 #include sys/time.hstruct timeval time_t tv_sec; /* seconds */ long tv_usec; /* microseconds */; 示例代码：带超时的服务器 这个服务器演示了两种超时： accept 超时：如果在 5 秒内没有客户端连接，accept 将超时返回。 recv 超时：连接成功后，如果在 5 秒内没有收到客户端的任何数据，recv 将超时返回。 // timeout_server.c#include stdio.h#include sys/socket.h#include arpa/inet.h#include unistd.h#include errno.hint main(void) int listen_fd = socket(AF_INET, SOCK_STREAM, 0); struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(8888); addr.sin_addr.s_addr = INADDR_ANY; bind(listen_fd, (struct sockaddr *)addr, sizeof(addr)); listen(listen_fd, 5); // 1. 设置 accept 的超时时间 struct timeval timeout = 5, 0; // 5秒 setsockopt(listen_fd, SOL_SOCKET, SO_RCVTIMEO, timeout, sizeof(timeout)); printf(等待客户端连接 (5秒超时)... ); int conn_fd = accept(listen_fd, NULL, NULL); if (conn_fd 0) perror(accept 超时或出错); close(listen_fd); return -1; printf(客户端已连接。 ); // 2. 设置 recv 的超时时间 setsockopt(conn_fd, SOL_SOCKET, SO_RCVTIMEO, timeout, sizeof(timeout)); char buf[128]; while(1) printf(等待接收数据 (5秒超时)... ); int n = recv(conn_fd, buf, sizeof(buf), 0); if (n 0) if (errno == EAGAIN || errno == EWOULDBLOCK) printf(recv 超时！ ); break; // 超时后退出循环 perror(recv error); break; else if (n == 0) printf(客户端断开连接。 ); break; else buf[n] = \\0; printf(收到数据: %s , buf); close(conn_fd); close(listen_fd); return 0; 六、服务器 I/O 模型 当服务器需要同时处理多个客户端时，如何高效地管理这些连接就成了关键问题。 非阻塞轮询：将所有套接字设为非阻塞，然后在一个死循环中不断轮询每个套接字是否有数据。缺点：CPU 空转，效率低下。 多任务并发 (多进程/多线程)：每当 accept() 一个新连接，就创建一个新的进程或线程专门为这个客户端服务。缺点：资源开销大，能支持的并发连接数有限。 I/O 多路复用 (Multiplexing)：推荐方案。使用 select(), poll(), epoll() 等函数，让一个线程可以同时监视多个文件描述符（套接字）的状态。当某个或某些描述符就绪（可读/可写）时，函数返回，程序再去处理这些就绪的描述符。 优点：资源开销小，能够高效地处理大量并发连接。 select() 模型详解 man 2 select 查看接口函数。 int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);参数分别为： 最大描述符+1，读集合，写集合，异常集合，超时时间 作用：阻塞地等待一组文件描述符中的一个或多个变为就绪状态。 fd_set: 一个位图，用于表示文件描述符的集合。需要使用以下宏来操作： FD_ZERO(fd_set *set): 清空集合。 FD_SET(int fd, fd_set *set): 将一个 fd 加入集合。 FD_CLR(int fd, fd_set *set): 将一个 fd 从集合中移除。 FD_ISSET(int fd, fd_set *set): 判断一个 fd 是否仍在集合中（即是否就绪）。 select 工作流程 创建一个 fd_set (例如 readfds)。 使用 FD_ZERO 清空它。 将所有需要监视的 fd (监听套接字、所有已连接的客户端套接字) 通过 FD_SET 加入集合。 调用 select()。函数会阻塞。 当有 fd 状态就绪时，select 返回，并修改传入的 fd_set，只保留那些就绪的 fd。 遍历所有原始的 fd，使用 FD_ISSET 检查哪个 fd 仍然在集合中，然后对其进行相应的读写操作。 重复以上步骤（select会修改集合，所以每次循环前都必须重新设置）。 核心考点总结 第一部分：UDP (用户数据报协议) 1. UDP 核心特性 (必考) 无连接：发送前不需要建立连接（不“握手”）。 不可靠：不保证数据送达，不保证顺序，不重传。可靠性需应用层自己实现。 面向数据报：保持应用层消息的边界，不会拆分或合并数据包。 效率高、延迟低：开销小，适用于实时性要求高的场景。 报头简单：仅 8 字节。 2. UDP 编程流程与核心 API 服务器流程: socket() - bind() - recvfrom() - close() 客户端流程: socket() - sendto() - close() 函数 作用 考点 socket() 创建套接字 socket(AF_INET, SOCK_DGRAM, 0); bind() (服务器) 绑定 IP 和端口 必须将主机字节序的端口和地址转为网络字节序（大端序） sendto() (客户端) 发送数据 需要指定目标地址 dest_addr recvfrom() (服务器) 接收数据 阻塞函数，会返回源地址 src_addr 3. 关键概念与函数 网络字节序：网络协议规定使用大端序。必须使用 htons() (端口) 和 htonl() (IP) 函数进行转换。 TIME_WAIT 问题：程序关闭后端口会短时间被占用，导致重启失败，报 “Address already in use”。 setsockopt() 与 SO_REUSEADDR：解决 TIME_WAIT 问题的关键。在 bind() 之前调用 setsockopt() 设置地址复用选项，可以立即重启程序。 广播 (Broadcast)：向局域网所有主机发送。 发送方需要用 setsockopt() 开启 SO_BROADCAST 权限。 目标地址是广播地址（如 192.168.1.255）。 组播 (Multicast)：向特定“小组”内的主机发送。 使用 D 类 IP 地址 (224.0.0.0 - 239.255.255.255)。 接收方需要用 setsockopt() 的 IP_ADD_MEMBERSHIP 选项加入组播组。 第二部分：TCP (传输控制协议) 1. TCP 核心特性 (必考) 面向连接：传输数据前必须通过“三次握手”建立连接，结束后“四次挥手”断开。 可靠传输：通过序列号、确认应答(ACK)、超时重传、流量控制等机制保证数据不丢、不乱、无误。 面向字节流：数据没有边界，可能会发生“粘包”或“半包”问题，需要应用层处理。 全双工：连接建立后，双方可同时收发数据。 2. TCP 连接生命周期 (高频考点) 三次握手 (建立连接)： 客户端 SYN - 服务器 服务器 SYN+ACK - 客户端 客户端 ACK - 服务器 四次挥手 (断开连接)： 主动方 FIN - 被动方 被动方 ACK - 主动方 被动方 FIN - 主动方 主动方 ACK - 被动方 TIME_WAIT 状态： 谁产生：主动断开连接的一方。 目的：1. 确保最后一个 ACK 能成功送达；2. 防止延迟的旧数据包干扰新连接。 3. TCP 编程流程与核心 API 服务器流程: socket() - bind() - listen() - accept() - recv()/send() - close() 客户端流程: socket() - connect() - send()/recv() - close() 函数 作用 考点 socket() 创建套接字 socket(AF_INET, SOCK_STREAM, 0); connect() (客户端) 发起连接请求 内部自动完成三次握手，是阻塞函数。 listen() (服务器) 将套接字设为监听状态 第二个参数 backlog 定义了等待连接队列的大小。 accept() (服务器) 从队列中接受连接 阻塞函数。成功时会返回一个全新的已连接套接字用于通信。 recv() 接收数据 阻塞函数。返回 0 (字节数)，=0 (对方正常关闭)，0 (出错)。 send() 发送数据 - 第三部分：高级特性与 I/O 模型 1. 高级 TCP 特性 缓冲区管理： SO_RCVBUF / SO_SNDBUF：设置接收/发送缓冲区大小，影响吞吐量。 超时控制 (必考)： 作用：防止 accept、connect、recv 等阻塞函数因网络问题无限期挂起。 实现：使用 setsockopt() 设置 SO_RCVTIMEO (接收超时) 或 SO_SNDTIMEO (发送超时)。超时后函数返回 -1，errno 为 EAGAIN 或 EWOULDBLOCK。 带外数据 (OOB)： 发送一个字节的“紧急”数据，接收方会收到 SIGURG 信号。 通过 send() 的 MSG_OOB 标志发送，recv() 的 MSG_OOB 标志接收。 2. 服务器 I/O 模型 (必考) 问题：如何高效处理大量并发连接？ 解决方案：I/O 多路复用（重点是 select）。 select() 模型： 作用：让一个线程同时监视多个套接字（文件描述符）的状态。 核心：使用 fd_set 位图结构来管理文件描述符集合。 关键宏：FD_ZERO (清空), FD_SET (添加), FD_CLR (移除), FD_ISSET (检查)。 工作流程： FD_ZERO 清空 fd_set。 FD_SET 将所有要监视的套接字加入集合。 调用 select() 进行阻塞等待。 select() 返回后，fd_set 中只剩下就绪的套接字。 使用 FD_ISSET 遍历，找出哪些套接字就绪并进行处理。 易错点：每次循环调用 select 之前，必须重新设置 fd_set，因为它会被内核修改。","tags":[null]},{"title":"C语言-库的制作和使用","path":"/data/ES/基础/C语言-库的制作和使用.html","content":"1. 基础概念：什么是库？ 在嵌入式开发中，库（Library） 本质上是已编译好的二进制目标文件（*.o）的集合。 它将可复用的代码模块打包，方便其他程序链接和使用。 库分为两种：静态库和动态库。 编译过程回顾：一个 .c 文件经过 预处理 - 编译 - 汇编 最终生成 .o 文件。 链接 步骤就是将一个或多个 .o 文件（以及它们所依赖的库）捆绑成一个最终的可执行文件。 静态库 (.a) 原理：在链接阶段，将库中被调用到的代码完整地复制到最终的可执行文件中。 优点：程序不依赖外部库文件即可运行，执行效率只高一点点。 缺点：生成的可执行文件体积较大，库升级时需要重新编译整个程序。 动态库 (.so) 原理：在链接阶段，只记录所需函数的位置信息。程序运行时，才动态地加载库代码到内存中。 优点：节省磁盘和内存空间，多个程序可共享同一份库。库升级时，只需替换库文件，程序无需重新编译即可获益。 缺点：程序运行依赖外部库文件，存在潜在的运行时链接问题。 命名规范：库文件名通常遵循 lib库名.后缀 的格式。例如 libmath.a 或 libcustom.so。链接时使用 -l库名，如 -lmath、-lcustom。 2. 静态库的制作与使用 2.1 制作静态库 假设有功能模块 a.c 和 b.c。 生成目标文件 (.o)： # -c 选项表示只编译不链接gcc a.c -o a.o -cgcc b.c -o b.o -c 打包成静态库 (.a)archive： 使用 ar (archiver) 命令。 # c: 创建库 r: 替换(或添加)文件 s: 创建索引ar crs libx.a a.o b.o 2.2 使用静态库 假设主程序 main.c 调用了 libx.a 中的函数。 编译链接：# -L路径: 指定库文件所在的目录# -l库名: 指定要链接的库gcc main.c -o main -L. -lx -L. 表示在当前目录查找库文件。 -lx 表示链接 libx.a，链接时去掉lib和.a这种通用记号。 重点：库的依赖顺序 如果库 libb.a 依赖于 liba.a，那么在链接时，被依赖的库最好放在后面，不然链接器找不到定义 # 正确: -la 在 -lb 之后gcc main.c -o main -L. -lb -la# 错误: 链接器找不到 fa 的定义gcc main.c -o main -L. -la -lb 3. 动态库的制作与应用 3.1 制作动态库 生成位置无关的目标文件 (.o)： 动态库的代码必须是位置无关代码 (PIC)，因为它在内存中的加载地址是不固定的 且不能包含主函数main，不可能对一个主函数引用另外一个有主函数的库 # -fPIC: 生成位置无关代码gcc a.c -o a.o -c -fPICgcc b.c -o b.o -c -fPIC 打包成动态库 (.so) share object： # -shared: 生成共享库(动态库)gcc -shared -fPIC -o libx.so a.o b.o 3.2 使用动态库与运行时链接 编译链接： 命令与静态库完全相同。 gcc main.c -o main -L. -lx 解决运行时找不到库的问题： 直接运行 ./main 会报错，因为操作系统不知道去哪里找 libx.so。有多种种解决方法： 方法一：编译时指定（推荐） 使用 -rpath 选项将库路径硬编码到可执行文件中。 # -Wl, 表示将后续参数传递给链接器(ld)# 这里指定rpath为程序所在的相对路径gcc main.c -o main -L. -lx -Wl,-rpath=. 方法二：设置环境变量 临时将库路径添加到 LD_LIBRARY_PATH 环境变量中。 export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:../main ​ 其他方法不推荐 4. 动态库的升级与版本管理 动态库的核心优势在于升级维护。一个标准的动态库版本管理流程如下： 版本号命名：lib库名.so.主版本号.次版本号.修订号，例如 liba.so.1.0.0。 主版本号：发生不向前兼容的重大变更时修改。 次版本号：增加新功能，但保持向前兼容。 修订版本号：修复 Bug。 SONAME: 这是库的一个别名，格式为 lib库名.so.主版本号。程序在运行时是根据 SONAME 来查找库的。 标准制作流程： (1) 编译库并指定 SONAME： # -Wl,-soname,你的SONAMEgcc -shared -fPIC a.c -o liba.so.1.0.0 -Wl,-soname,liba.so.1 (2) 创建 SONAME 软链接： ldconfig 命令可以自动扫描当前目录的库文件，并根据其 SONAME 创建软链接。 # -n .: 在当前目录操作ldconfig -n .# 执行后会生成： liba.so.1 - liba.so.1.0.0 (3) 创建编译器链接名： 编译器在链接时查找的是不带版本号的名字，如 liba.so。 ln -s liba.so.1 liba.so# 执行后会生成： liba.so - liba.so.1 (4) 编译主程序： gcc main.c -o main -L. -la 无缝升级： 当库升级到 liba.so.1.0.1 时，只需替换旧文件，然后重新执行 ldconfig -n . 更新 liba.so.1 的指向即可。main 程序无需重新编译，下次运行时就会自动加载新版库。 5. 动态库的动态加载 (实现插件化与条件加载) 除了在编译时链接，我们还可以在程序运行时，根据需要手动加载和卸载动态库。这种技术是实现高级软件架构的基石，它允许程序在不重新启动的情况下扩展功能，或根据特定条件选择不同的代码路径。 这主要应用于两大场景： 插件化架构：主程序提供一个框架，具体功能由第三方或后续开发的“插件”（即动态库）提供。 条件加载：主程序根据运行时的数据、用户输入或环境来决定加载哪个功能模块。 5.1 核心 API 要使用动态加载功能，必须包含头文件 dlfcn.h，并掌握以下几个核心函数： void *dlopen(const char *filename, int flag); 功能：打开并加载一个动态库。 filename：库文件的路径，如 ./libcolor.so。若设为NULL，则在当前进程的全局符号表中搜索。 flag：加载标志。常用RTLD_LAZY（延迟解析，用到函数时才解析地址）或RTLD_NOW（立即解析所有符号）。 返回值：成功返回一个库句柄（handle），失败返回NULL。 void *dlsym(void *handle, const char *symbol); 功能：在已加载的库中查找符号（通常是函数名）的地址。 handle：由dlopen返回的库句柄。 symbol：要查找的符号名称字符串，如 detection。 返回值：成功返回符号的地址，失败返回NULL。 char *dlerror(void); 功能：返回一个描述最后一次 dlopen, dlsym, dlclose 调用错误的字符串。每次调用后，错误状态会被清除。这是调试动态加载问题的首选工具。 int dlclose(void *handle); 功能：卸载一个动态库，减少其引用计数。当引用计数降为 0 时，库被从内存中移除。 5.2 重要提醒：处理插件的间接依赖 这是一个在使用 dlopen 时极易遇到的陷阱。 场景：假设你的主程序 main 动态加载一个插件 libplugin.so，而这个插件本身又依赖于另一个基础库 libbase.so main — (dlopen) — libplugin.so — (依赖) — libbase.so 问题：在编译主程序 main 时，编译器只知道 main 的直接依赖，它对 libplugin.so 的内部依赖一无所知。因此，即使不链接 -lbase，编译也能通过。然而，当程序运行并成功 dlopen(libplugin.so) 后，一旦调用到 libplugin.so 中使用了 libbase.so 功能的函数时，动态链接器会因为找不到 libbase.so 中的符号而报错，导致程序崩溃。 解决方案： 将插件的间接依赖库与主程序一起链接。这样，在 dlopen 加载插件之前，所需的符号已经存在于主程序的全局符号表中。编译主程序时，不要忘记链接-ldl # 将libbase.so与主程序一起编译，并链接-ldlgcc main.c -o main -L . -lbase -ldl 设计原则：尽量让插件（被动态加载的库）自包含，不依赖或少依赖其他非系统标准库。这能从根本上避免此类问题，让插件更加独立和健壮 5.3 应用场景一：基于配置的插件系统 (系统扩展) 需求：开发一个检测系统，它能根据配置文件加载不同的检测模块，而无需重新编译主程序。 约定接口：所有检测插件都必须实现一个同名函数，如 void detection(void); 制作插件库： // color.c#include stdio.hvoid detection() printf(正在检测颜色是否均匀... ); // shape.c#include stdio.hvoid detection() printf(正在检测外观是否破损... ); gcc color.c -fPIC -shared -o libcolor.sogcc shape.c -fPIC -shared -o libshape.so 编写配置文件 config，指定要加载的插件： libcolor.so 主程序实现动态加载： #include stdio.h#include stdlib.h#include string.h#include dlfcn.hint main(void) // 1. 从配置文件读取要加载的库名 FILE *fp = fopen(config, r); if (fp == NULL) perror(打开配置文件失败); exit(1); char lib_name[50]; fgets(lib_name, sizeof(lib_name), fp); fclose(fp); strtok(lib_name, ); // 移除 fgets 读取到的末尾换行符 char path[60]; snprintf(path, sizeof(path), ./%s, lib_name); // 2. 使用 dlopen 加载指定的库 void *handle = dlopen(path, RTLD_NOW); if (handle == NULL) fprintf(stderr, 加载动态库 [%s] 失败: %s , path, dlerror()); exit(1); // 3. 使用 dlsym 查找约定的函数接口 void (*detect_func)(void); detect_func = dlsym(handle, detection); if (detect_func == NULL) fprintf(stderr, 查找符号 [detection] 失败: %s , dlerror()); dlclose(handle); exit(1); // 4. 调用函数 printf(开始执行检测... ); detect_func(); printf(检测完成。 ); // 5. 关闭句柄，释放资源 dlclose(handle); return 0; 通过修改 config 文件的内容（例如改成 libshape.so），主程序就能在不重新编译的情况下调用不同的检测功能，实现了真正的插件化 5.4 应用场景二：基于输入的条件加载 (行为选择) 需求：开发一个图片查看器，能根据用户输入的图片文件后缀（如 .jpg 或 .bmp），自动加载对应的解码库来显示图片 约定接口：所有图片解码库都必须提供一个统一的显示函数 // 在一个公共头文件(如 display.h)中定义#include stdint.h#include ./src/lcd.h // 假设lcd.h定义了LCD_info和显示模式void display(const char *pathname, const struct LCD_info *plcd, uint8_t mode); 制作不同格式的解码库： // libjpg.c: 负责解码和显示JPG图片#include stdio.h#include display.hvoid display(const char *pathname, const struct LCD_info *plcd, uint8_t mode) printf(使用JPG解码库显示图片: %s , pathname); // ... 此处是真实的JPG解码和LCD显示代码 ...// libbmp.c: 负责解码和显示BMP图片#include stdio.h#include display.hvoid display(const char *pathname, const struct LCD_info *plcd, uint8_t mode) printf(使用BMP解码库显示图片: %s , pathname); // ... 此处是真实的BMP解码和LCD显示代码 ... gcc libjpg.c -fPIC -shared -o libjpg.sogcc libbmp.c -fPIC -shared -o libbmp.so 主程序根据输入条件动态加载： #include stdio.h#include stdlib.h#include string.h#include dlfcn.h#include display.h // 包含统一接口和所需结构体定义int main(int argc, char const *argv[]) if (argc 2) printf(用法: %s 图片文件名 , argv[0]); return -1; void *handle = NULL; const char *lib_path = NULL; // 1. 根据输入的文件名后缀，决定加载哪个库 if (strstr(argv[1], .jpg) != NULL) lib_path = ./libjpg.so; else if (strstr(argv[1], .bmp) != NULL) lib_path = ./libbmp.so; else printf(错误: 不支持的文件格式，目前仅支持 .jpg 和 .bmp ); return -1; // 2. 加载选定的动态库 handle = dlopen(lib_path, RTLD_NOW); if (handle == NULL) fprintf(stderr, 打开动态库 [%s] 失败: %s , lib_path, dlerror()); return -1; printf(成功加载库: %s , lib_path); // 3. 查找统一的显示函数 `display` void (*display_func)(const char *, const struct LCD_info *, uint8_t); display_func = dlsym(handle, display); if (display_func == NULL) fprintf(stderr, 从动态库获取函数 [display] 失败: %s , dlerror()); dlclose(handle); return -1; // 4. 准备环境并调用函数 struct LCD_info lcdinfo; init_LCD(lcdinfo); // 假设这是初始化LCD屏幕的函数 printf(调用显示函数... ); // 调用从动态库中获取的函数 display_func(argv[1], lcdinfo, CENTER | ZOOM); // 假设CENTER和ZOOM是定义好的模式 relese_LCD(lcdinfo); // 假设这是释放LCD资源的函数 dlclose(handle); // 关闭库句柄 return 0; 这样，程序就能根据用户输入的文件名，在运行时才决定加载哪个解码库 未来如果需要支持 .png 格式，只需新增一个 libpng.so 并更新主程序的判断逻辑即可，无需改动现有代码，极大地增强了程序的灵活性和可扩展性","tags":[null],"categories":[null]},{"title":"Linux 进程管理与调度","path":"/data/ES/进阶/进程.html","content":"进程的概念及基础 程序和进程的关系 程序：是静态的，一堆没有被加载(运行)的二进制代码，存储在硬盘中 进程：是动态的，已经被加载(运行)到内存中的程序文件，存储到内存中 进程的相关命令 查看：Linux 基础与实战笔记-进程与服务管理 进程的生命周期状态（重点） 1、就绪态：当一个程序被加载后就处于就绪态中，所有的进程要变成执行态，都要从就绪态开始 2、执行态：当一个进程得到 CPU 的使用权(时间片)后，就会处于执行态中 3、睡眠/挂起态：当一个进程调用 sleep 或者一些等待阻塞函数 scanf 时，都会进入到睡眠/挂起态 4、暂停态：收到 STOP 暂停信号后就会进入到暂停态中，等待 CONT 继续信号 5、僵尸态：进程死亡后都会进入到僵尸态，等待别人帮他收尸 6、死亡态：父母进程回收(wait)子进程的资源就会进入死亡态 进程的相关 API 和说明 进程的创建（fork 函数） 父子进程在 fork() 之后的区别，核心就一条： 👉 父进程和子进程的虚拟内存内容相同，但属于不同的进程，PID 不同，资源不共享（文件描述符除外） 具体来说： 不同点 PID 不同：getpid() 获取到的进程号不同。 fork() 的返回值不同： 父进程中 fork() 返回子进程 PID。 子进程中 fork() 返回 0。 资源独立：全局变量、局部变量等虽然初始值相同，但各自独立修改，互不影响 相同点 代码段相同：执行同一段程序。 数据段、堆、栈初始内容相同（fork 后复制） 打开的文件描述符相同（共享文件偏移量） 父子进程共享同一份程序代码，调度由操作系统时间片复用完成，所以运行起来像同一个程序 它们的区别只能通过 fork() 的返回值 和 进程号（PID） 来区分 #include stdio.h#include sys/types.h#include unistd.hint main(int argc, char const *argv[]) int value = 100; // 获取本进程的id printf(fork之前：pid==%d , getpid()); // fork后有两个进程 pid_t pid = fork(); if (pid 0) perror(fork error! ); return -1; else if (pid == 0) // 字进程 value = 110; printf(fork之后，pid==%d，value：%p,value:%d , getpid(), value, value); return 0; else // 父进程 value = 120; printf(fork之后，pid==%d，value：%p,value:%d , getpid(), value, value); return 0; return 0; 运行结果如下： ➜ ./1.fork函数创建进程fork之前：pid==977163fork之后，pid==977163，value：0x7fffde4f16c0,value:120fork之后，pid==977164，value：0x7fffde4f16c0,value:110 可以看到，父进程和字进程变量的虚拟内存地址相同，但值不同 进程的回收（wait, waitpid, 状态值） 当一个子进程退出时，它会进入僵尸态。此时，子进程的资源（如内存）大部分已被释放，但在内核的进程表中仍然保留其退出状态等信息。父进程需要调用 wait() 或 waitpid() 来获取这些信息，并彻底清理子进程的记录，这个过程称为“为子进程收尸”。 1. wait() 函数 wait() 函数会阻塞父进程，直到它的任意一个子进程结束。 函数原型： pid_t wait(int *wstatus); 参数：wstatus 是一个整型指针，用于接收子进程的退出状态。如果不需要，可以传入 NULL。 返回值：成功时返回结束的子进程的 PID；失败时返回 -1。 下面的代码演示了父进程如何使用 wait() 等待子进程结束。子进程运行 5 秒后退出，父进程则一直阻塞等待 #include stdio.h#include sys/types.h#include unistd.h#include sys/wait.hint main(int argc, char const *argv[]) pid_t pid = fork(); if (pid 0) perror(fork error! ); return -1; else if (pid == 0) // 子进程 int i = 0; while (1) printf(pid(%d): play game(%d)...... , getpid(), i); sleep(1); i++; if (i == 5) printf(子进程结束! ); return 0; // 结束子进程 else // 父进程 printf(父进程正在等待子进程结束! ); int wait_status = 0; // 堵塞于此，等待任意一个子进程结束(并给子进程收尸) pid_t child_pid = wait(wait_status); printf(回收成功，被终止的子进程ID == %d , child_pid); return 0; 2. waitpid() 函数 waitpid() 是 wait() 的一个更强大、更灵活的版本。它可以等待一个特定的子进程，也可以设置为非阻塞模式。 函数原型： pid_t waitpid(pid_t pid, int *wstatus, int options); 参数： pid： 0: 等待进程 ID 为 pid 的子进程。 -1: 等待任意子进程（等同于 wait()）。 wstatus：同 wait()，用于存储退出状态。 options： 0: 阻塞等待。 WNOHANG: 非阻塞，如果子进程还未结束，立即返回 0。 WUNTRACED: 如果子进程进入暂停状态，也返回。 3. 获取子进程退出状态 当 wait() 或 waitpid() 返回后，wstatus 中包含了子进程的退出信息，不能直接当作退出码使用。 需要用一组宏来解析： WIFEXITED(wstatus): 判断子进程是否正常退出（通过 return, exit, _exit）。 WEXITSTATUS(wstatus): 如果正常退出，用此宏获取退出状态码。 WIFSIGNALED(wstatus): 判断子进程是否被信号终止。 WTERMSIG(wstatus): 如果是，用此宏获取终止它的信号编号。 WIFSTOPPED(wstatus): 判断子进程是否处于暂停状态。 WSTOPSIG(wstatus): 如果是，用此宏获取使它暂停的信号编号。 以下代码演示了如何使用 waitpid() 和状态宏来详细判断子进程的退出原因 #include stdio.h#include sys/types.h#include unistd.h#include sys/wait.hint main(int argc, char const *argv[]) pid_t pid = fork(); if (pid 0) perror(fork error! ); return -1; else if (pid == 0) // 子进程 sleep(3); printf(子进程结束! ); return 66; // 结束子进程，退出码为66 else // 父进程 printf(父进程正在等待子进程(pid=%d)结束! , pid); int wait_status = 0; // 等待指定的子进程pid结束 waitpid(pid, wait_status, 0); // 判断子进程是否正常退出 if (WIFEXITED(wait_status)) printf(子进程正常退出！ ); printf(退出状态码：%d , WEXITSTATUS(wait_status)); // 获取子进程的退出码 // 判断子进程是否被信号杀死 if (WIFSIGNALED(wait_status)) printf(子进程被信号杀死！ ); printf(杀死子进程的信号为：%d , WTERMSIG(wait_status)); // 判断子进程是否被信号暂停 if (WIFSTOPPED(wait_status)) printf(子进程被信号暂停！ ); printf(暂停子进程的信号为：%d , WSTOPSIG(wait_status)); // 获取暂停子进程的信号 // 判断子进程是否被信号继续 if (WIFCONTINUED(wait_status)) printf(子进程从暂停态中被恢复了 ); return 0; 进程的退出（return, exit, _Exit） 进程的退出分为正常退出和异常退出。这里主要讨论三种正常退出的方式。 return 在 main 函数中使用 return，等同于调用 exit(return_value)。进程会正常终止，并执行清理操作。 在普通函数中使用 return，仅仅是将控制权返回给调用者，并不会导致进程退出。 exit() 函数 函数原型：void exit(int status); 这是标准的退出函数。无论在哪个函数中调用，都会立即终止整个进程。 特点：在进程退出前，会执行一系列“清理操作”，包括： 刷新标准 I/O 缓冲区（如 printf 的内容）。 调用 atexit() 注册的函数。 _exit() 和 _Exit() 函数 函数原型：void _exit(int status); 这两个函数功能相同，会立即终止进程，但不会执行任何清理操作。缓冲区的数据会丢失，atexit 注册的函数也不会被调用。 推荐场景：在 fork() 后的子进程中，推荐使用 _exit()。因为 exit() 的缓冲区刷新可能会影响父进程的 I/O 流，导致数据重复输出或混乱。使用 _exit() 可以避免这种副作用。 下面的代码演示了在普通函数 PTask1_PlayGame 中，三种退出方式的示例代码 #include stdio.h#include sys/types.h#include unistd.h#include sys/wait.h#include stdlib.hint PTask1_PlayGame(void);int main(int argc, char const *argv[]) pid_t pid = fork(); if (pid 0) perror(fork error! ); return -1; else if (pid == 0) // 子进程 PTask1_PlayGame(); // 如果PTask1_PlayGame是return返回的，这里会继续执行 printf(PTask1_PlayGame函数返回了，但子进程还在运行! ); sleep(3); printf(子进程现在才真正退出! ); return 0; else // 父进程 int wait_status = 0; wait(wait_status); if (WIFEXITED(wait_status)) printf(父进程：子进程已正常退出，退出码：%d , WEXITSTATUS(wait_status)); int PTask1_PlayGame(void) int i = 0; for (i = 1; i = 3; i++) printf(PTask1_PlayGame(PID: %d)...玩了%d秒... , getpid(), i); sleep(1); printf(PTask1_PlayGame函数结束了(Game Over)! ); // 演示1: return 只是返回main函数，进程继续 // return 11; // 演示2: exit 会终止整个进程，父进程会收到退出码66 exit(66); // 演示3: _exit 也会终止整个进程，父进程收到退出码88 // _exit(88); 多进程的使用 在实际应用中，可以通过创建多个子进程来并行处理不同的任务，以提高程序的效率和模块化程度。例如，一个车载系统可以为每个功能（如胎压监测、车速显示、油耗计算等）创建一个独立的进程。 实现思路: 父进程在一个循环中多次调用 fork() 来创建所需数量的子进程。 在子进程的代码块中，通过循环变量或其他标识来区分不同的子进程，并让它们执行各自的任务函数。 每个子进程任务完成后，应调用 _exit() 退出，避免不必要的资源清理副作用。 父进程在创建完所有子进程后，进入另一个循环，调用 wait() 来回收所有子进程的资源，防止它们变成僵尸进程。 #include stdio.h#include unistd.h#include sys/wait.h#include stdlib.h// 模拟各个任务void tire_pressure_task() printf(PID %d: 胎压监测任务启动... , getpid()); sleep(2); _exit(1); void speed_task() printf(PID %d: 车速监测任务启动... , getpid()); sleep(3); _exit(2); void fuel_task() printf(PID %d: 油耗监测任务启动... , getpid()); sleep(4); _exit(3); int main() const int NUM_TASKS = 3; for (int i = 0; i NUM_TASKS; i++) pid_t pid = fork(); if (pid == 0) // 子进程 if (i == 0) tire_pressure_task(); else if (i == 1) speed_task(); else if (i == 2) fuel_task(); // 父进程回收所有子进程 for (int i = 0; i NUM_TASKS; i++) int status; pid_t child_pid = wait(status); if (WIFEXITED(status)) printf(父进程：回收了子进程 %d，退出码 %d , child_pid, WEXITSTATUS(status)); printf(所有车载任务已结束。 ); return 0; 程序的加载（system, popen, exec 系列函数） 有时候，一个进程需要执行一个全新的程序。这可以通过加载外部程序来实现 1. system() 函数 system() 函数非常方便，它可以直接执行一个 shell 命令字符串。 函数原型： int system(const char *command); 工作原理：system() 会创建一个子进程来执行 sh -c command，并阻塞等待该命令执行完毕。 优点：使用简单，可以执行复杂的 shell 命令，如管道、重定向。 缺点：开销较大（创建了 shell 进程），且存在安全风险（命令注入）。 #include stdio.h#include stdlib.hint main(int argc, char const *argv[]) printf(--- 开始执行system命令 --- ); // 1. 加载并执行外部程序，并传递参数 system(./test_app arg1 arg2); // 2. 执行系统命令，如ls system(ls -l /); // 3. 让程序在后台运行 () system(gedit ); // gedit会打开，但system不会立即返回，通常等待shell退出 printf(--- system命令执行完毕 --- ); return 0; 2. popen() 和 pclose() 函数 popen() 函数用于执行一个命令，但与 system() 不同的是，它会创建一个管道(pipe)，使得当前进程可以读取该命令的输出，或者写入数据给该命令的输入。 函数原型： FILE *popen(const char *command, const char *type); int pclose(FILE *stream); 参数 type: r: 读取模式。可以像读文件一样，读取 command 的标准输出。 w: 写入模式。可以像写文件一样，将数据写入到 command 的标准输入。 pclose()：必须调用 pclose() 来关闭 popen 创建的流，它会等待命令执行结束。 #include stdio.h#include stdlib.hint main(int argc, char const *argv[]) FILE *fp; char buffer[1024]; // --- 演示 r 模式：读取命令的输出 --- printf(--- 读取 ls -l 的输出 --- ); fp = popen(ls -l, r); if (fp == NULL) perror(popen r error); return -1; // 逐行读取并打印 while (fgets(buffer, sizeof(buffer), fp) != NULL) printf(%s, buffer); pclose(fp); // 关闭管道并等待命令结束 // --- 演示 w 模式：向命令写入数据 --- printf( --- 向 grep hello 写入数据 --- ); fp = popen(grep hello, w); if (fp == NULL) perror(popen w error); return -1; // 写入数据，grep会筛选包含hello的行并输出到终端 fprintf(fp, hello world ); fprintf(fp, goodbye ); fprintf(fp, another hello line ); pclose(fp); // 关闭管道，刷新缓冲区，等待命令结束 return 0; 3. exec 系列函数 exec 系列函数是最核心的程序加载机制。它不会创建新进程，而是用一个全新的程序替换当前进程的内存空间（包括代码、数据、堆栈）。 核心特点：一旦 exec 调用成功，原来的程序就不存在了，PID 保持不变，但执行的已经是新程序了。exec 成功后不会返回。 常见模式：fork() + exec()。父进程 fork 一个子进程，然后子进程调用 exec 去执行新程序，父进程可以继续做自己的事或 wait 子进程。system 和 popen 内部都封装了这个模式。 函数家族： execl, execlp, execle: 参数以列表形式给出 (l)。(list) execv, execvp, execve: 参数以字符串数组形式给出 (v)。(vector) 带 p 的 (execlp, execvp) 会在 PATH 环境变量中搜索可执行文件。(path) 带 e 的 (execle, execve) 允许你自定义新程序的环境变量。(environment) // 简单的 fork + exec 示例#include stdio.h#include unistd.h#include sys/wait.hint main() pid_t pid = fork(); if (pid == 0) // 子进程 printf(子进程(PID:%d)开始执行 ls -l , getpid()); // 使用新程序 ls 替换当前子进程 execlp(ls, ls, -l, NULL); // 如果execlp成功，下面这行代码永远不会被执行 perror(execlp failed); return 1; else if (pid 0) // 父进程 printf(父进程(PID:%d)等待子进程结束... , getpid()); wait(NULL); printf(父进程：子进程执行完毕。 ); return 0; 进程的关系（重点） (1) 父子进程 通过 fork() 创建的进程具有父子关系。父进程是创建者，子进程是被创建者。父进程有责任管理其子进程的生命周期，最重要的是在子进程结束后，通过调用 wait() 或 waitpid() 来回收其资源，防止子进程变成僵尸进程。 可以使用 pstree 命令查看系统中所有进程形成的“家族树”，直观地看到父子关系。top 或 ps 命令也可以查看每个进程的 PID (进程 ID) 和 PPID (父进程 ID)。 #include stdio.h#include sys/types.h#include unistd.h#include sys/wait.hint main(void) pid_t pid = fork(); if (pid 0) perror(fork error); return -1; else if (pid == 0) // 子进程 printf(我是子进程(PID:%d)，我的父进程是(PPID:%d) , getpid(), getppid()); sleep(5); printf(子进程结束。 ); return 0; else // 父进程 printf(我是父进程(PID:%d)，我创建了子进程(PID:%d) , getpid(), pid); wait(NULL); // 阻塞等待，直到子进程结束并回收其资源 printf(父进程：已回收子进程资源，现在退出。 ); return 0; (2) 孤儿进程 说明：当一个父进程比它的子进程先结束时，这个子进程就成为了“孤儿进程”。 系统处理：孤儿进程不会无人管理，它会被系统的 1 号进程（在现代 Linux 系统中通常是 systemd）所“收养”，systemd 会成为它的新父进程，并负责在其结束后回收资源。 注意：虽然系统会自动处理孤儿进程，但这通常意味着程序设计上存在逻辑问题。正常情况下，父进程应该等待所有子进程结束后再退出。 #include stdio.h#include sys/types.h#include unistd.hint main(void) pid_t pid = fork(); if (pid 0) perror(fork error); return -1; else if (pid == 0) // 子进程 // 循环打印自己的PID和父进程的PPID while (1) printf(我是子进程(PID:%d)，我的父进程是(PPID:%d) , getpid(), getppid()); sleep(1); else // 父进程 printf(我是父进程(PID:%d)，我将在5秒后退出。 , getpid()); sleep(5); printf(父进程结束！ ); return 0; 运行现象：程序运行后，子进程会持续打印其父进程的 ID。5 秒后，父进程退出，你会观察到子进程打印的父进程 ID（PPID）从原来的父进程 PID 变成了 1 (3) 僵尸进程 说明：当一个子进程比父进程先结束，但父进程没有调用 wait() 或 waitpid() 来获取子进程的退出状态时，子进程就会变成“僵尸进程”。 状态：此时，子进程的绝大部分资源（如内存）已被释放，但在内核的进程表中仍然保留着它的条目（包含 PID、退出状态、资源使用信息等），等待父进程来读取。在 ps 命令中，僵尸进程的状态显示为 Z (Zombie) 或 defunct。 危害：僵尸进程本身不占用太多资源，但它会一直占用一个 PID。如果一个程序持续产生僵尸进程而不进行回收，最终会耗尽系统可用的 PID，导致无法创建任何新进程，从而使系统瘫痪。必须避免僵尸进程的产生 #include stdio.h#include sys/types.h#include unistd.h#include stdlib.hint main(void) // 1. 创建10个子进程 for (int i = 0; i 10; i++) pid_t pid = fork(); if (pid == 0) // 子进程 printf(子进程(PID:%d)创建并立即退出。 , getpid()); _exit(0); // 子进程立刻退出 // 2. 父进程不回收子进程，而是长时间运行 printf(父进程(PID:%d)正在运行，但未回收子进程。请在另一个终端使用 ps aux | grep a.out 查看。 , getpid()); getchar(); // 阻塞在这里，等待用户输入 printf(父进程结束。 ); return 0; 运行现象：运行该程序后，立即在另一个终端执行 ps aux | grep a.out，你会看到多个状态为 Z+ 的僵尸进程 (4) 守护进程 (精灵进程) 说明：守护进程是一种特殊的后台进程，它完全脱离于控制终端，独立于任何登录会话，通常用于执行周期性任务或提供系统服务（如 sshd, httpd 等）。 特点： 长期运行：通常在系统启动时开始运行，直到系统关闭。 无控制终端：不与任何终端关联，不会接收终端输入或向终端输出。 会话独立：自己是一个独立的会话首进程。 后台运行：在系统后台默默执行任务。 特定工作目录：通常将工作目录切换到根目录 (/)，以防其所在的文件系统被卸载。 特定文件权限掩码：通常将 umask 设置为 0，以便对创建的文件拥有完全控制权。 创建步骤： fork() 创建子进程，父进程退出。 子进程调用 setsid() 创建新会话，使自己成为会话首进程、进程组组长，并脱离控制终端。 调用 chdir(/) 改变工作目录到根目录。 调用 umask(0) 重设文件权限掩码。 关闭不再需要的文件描述符（特别是标准输入、输出、错误）。 简化函数：unistd.h 提供了 daemon() 函数来简化上述步骤。 int daemon(int nochdir, int noclose); nochdir: 若为 0，则改变目录到 /。 noclose: 若为 0，则将标准输入、输出、错误重定向到 /dev/null。 成功返回 0，失败返回-1。 #include stdio.h#include unistd.h#include stdlib.h#include time.hint main(void) // 1. 调用daemon函数，成为守护进程 // chdir到根目录，关闭标准IO if (daemon(0, 0) == -1) perror(daemon create failed); exit(1); // 2. 守护进程的核心逻辑 FILE *fp; time_t t; while(1) fp = fopen(/tmp/daemon_time.log, a); // 追加模式打开日志文件 if (fp) t = time(NULL); fprintf(fp, Current Time: %s, asctime(localtime(t))); fclose(fp); sleep(1); return 0; 运行现象：编译运行后，程序会立即返回，你看不到任何输出。但你可以通过 ps aux | grep a.out 找到这个进程在后台运行，并且 /tmp/daemon_time.log 文件会每秒被写入一次当前时间 其他的进程相关函数说明 进程创建(vfork 函数) vfork() 是一个历史遗留的函数，其设计初衷是在 fork() 之后立即调用 exec() 的场景下提供更高的效率。由于现代 Linux 内核对 fork() 实现了“写时复制(Copy-On-Write)”优化，vfork() 的性能优势已不再明显，且其独特的行为容易导致错误，因此不推荐使用。 vfork() 与 fork() 的核心区别： 内存复制方式： fork()：子进程会获得父进程数据段、堆、栈的独立副本（通过写时复制技术实现）。 vfork()：子进程与父进程共享数据段。子进程对共享内存（如全局变量）的修改会直接影响到父进程。 执行顺序： fork()：父子进程的执行顺序由操作系统调度决定，是不确定的。 vfork()：保证子进程先运行，父进程会被阻塞，直到子进程调用了 exec() 系列函数或 _exit() 退出。 使用注意： 因为共享地址空间，在 vfork() 创建的子进程中，不能从函数 return 或调用 exit()，这会破坏父进程的栈帧。必须使用 _exit() 或 exec() 族函数来结束子进程 #include stdio.h#include sys/types.h#include unistd.h#include stdlib.hint g_num = 100; // 全局变量int main(void) pid_t pid = vfork(); if (pid 0) perror(vfork error); return -1; else if (pid == 0) // 子进程 printf(--- 子进程开始执行 --- ); printf(子进程中：修改前 g_num = %d , g_num); g_num = 200; // 修改全局变量 printf(子进程中：修改后 g_num = %d , g_num); printf(--- 子进程退出 --- ); _exit(0); // 必须用 _exit() else // 父进程 // 父进程会等待子进程结束后才执行 printf(--- 父进程开始执行 --- ); printf(父进程中：g_num = %d , g_num); return 0; 运行结果： --- 子进程开始执行 ---子进程中：修改前 g_num = 100子进程中：修改后 g_num = 200--- 子进程退出 ------ 父进程开始执行 ---父进程中：g_num = 200 结果清晰地表明：子进程先执行，并且它对 g_num 的修改反映到了父进程中 进程间的通信 在现代操作系统中，为了安全和稳定，每个进程都拥有自己独立的虚拟内存空间。这意味着一个进程无法直接访问另一个进程的内存，这种机制被称为进程隔离。 它保证了一个进程的崩溃不会影响到其他进程，但同时也带来了挑战：进程之间如何协作和交换数据？ 很多复杂应用，如 Web 服务器处理用户请求、数据库系统管理并发访问，都需要多个进程协同工作。为了解决进程隔离下的协作问题，操作系统内核提供了一系列官方的、安全可控的“沟通渠道”，即进程间通信（Inter-Process Communication, IPC） 机制。 这些机制本质上都是在内核空间开辟一块共享区域，允许不同进程通过这块区域进行数据交换或同步，如下图所示： 有哪些通信方式（重点）： Linux 系统提供了多种 IPC 方式，各有其特点和适用场景： (1) 文件和文件锁 (File Locking): 通过读写共享文件进行通信，使用文件锁同步，速度慢。 (2) 管道 (Pipe): 包括只能用于亲缘进程的匿名管道和可用于任意进程的命名管道 (FIFO)。 (3) 信号 (Signal): 用于异步通知，不传输数据，类似于系统中断。 (4) 消息队列 (Message Queue): 内核维护的消息链表，适用于结构化、小规模数据通信。 (System V IPC) (5) 共享内存 (Shared Memory): 最快的 IPC 方式，将同一块物理内存映射到多个进程，适用于大规模数据交换。 (System V IPC) (6) 信号量 (Semaphore): 主要用于进程/线程间的同步与互斥，保护共享资源（如共享内存）。 (System V IPC) (7) 套接字 (Socket): 最通用的 IPC 机制，既可用于本机进程间通信，也可用于网络间通信 (1) 文件与文件锁 这是最直观的 IPC 方式。一个进程将数据写入文件，另一个进程从文件中读取。为防止并发读写造成数据损坏，必须使用文件锁。 原理：利用文件系统作为公共存储区。 同步：flock()函数提供建议性锁。LOCK_EX（独占锁/写锁）保证只有一个进程可以写入，LOCK_SH（共享锁/读锁）允许多个进程同时读取。 1. flock 函数 头文件: #include sys/file.h 原型: int flock(int fd, int operation); operation: LOCK_SH: 施加共享锁 LOCK_EX: 施加独占锁 LOCK_UN: 释放锁 LOCK_NB: 与以上选项组合，使调用非阻塞 2. 示例代码：写进程 // writer.c#include stdio.h#include unistd.h#include fcntl.h#include sys/file.h#include time.h#include string.h#define FILE_PATH /tmp/msg_file.txtint main(void) int fd = open(FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0666); if (fd == -1) perror(open); return -1; char buf[512]; printf(--- 写进程 (PID: %d) --- , getpid()); while (1) printf(输入消息 (输入 quit 退出): ); fgets(buf, sizeof(buf), stdin); flock(fd, LOCK_EX); // 获取写锁 lseek(fd, 0, SEEK_SET); ftruncate(fd, 0); // 清空文件 write(fd, buf, strlen(buf)); flock(fd, LOCK_UN); // 释放锁 if (strncmp(buf, quit, 4) == 0) break; close(fd); return 0; 3. 示例代码：读进程 // reader.c#include stdio.h#include unistd.h#include fcntl.h#include sys/file.h#define FILE_PATH /tmp/msg_file.txtint main(void) int fd = open(FILE_PATH, O_RDONLY | O_CREAT, 0666); if (fd == -1) perror(open); return -1; char buf[512] = 0; printf(--- 读进程 (PID: %d) --- , getpid()); while (1) flock(fd, LOCK_SH); // 获取读锁 lseek(fd, 0, SEEK_SET); int bytes_read = read(fd, buf, sizeof(buf) - 1); if (bytes_read 0) buf[bytes_read] = \\0; printf(读取到: %s, buf); flock(fd, LOCK_UN); // 释放锁 if (strncmp(buf, quit, 4) == 0) break; sleep(1); close(fd); return 0; (2)、通过管道 (Pipe) 来通信 管道是 Linux 中一种基于文件的 IPC 机制，它在内核中创建一块缓冲区，用于进程间的单向数据传输，遵循“先进先出”（FIFO）原则。 A、匿名管道 (Anonymous Pipe) 1、说明 用途：只能用于具有亲缘关系的进程之间（通常是父子进程）。 特点：它没有文件系统中的路径名，存在于内存中，随进程的结束而消失。 核心：必须在 fork() 之前调用 pipe() 创建管道，子进程会继承父进程的文件描述符，从而实现共享。通信时，父子进程通常会各自关闭管道的一个端口（一个关读，一个关写）。 2、图解 3、pipe() 函数的使用 使用命令：man 2 pipe 查看接口函数。 // 函数头文件：#include unistd.h// 函数原型：int pipe(int pipefd[2]);/* 参数一：一个含两个整数的数组。 pipefd[0]：管道的读取端文件描述符。 pipefd[1]：管道的写入端文件描述符。*/// 返回值：// 成功返回 0，失败返回 -1。 4、示例代码：父子进程通信 /** * @brief 使用匿名管道实现父进程向子进程发送消息。 */#include stdio.h#include unistd.h#include string.h#include sys/wait.hint main(void) int pipe_fd[2]; if (pipe(pipe_fd) == -1) perror(pipe create failed); return -1; pid_t pid = fork(); if (pid 0) perror(fork failed); return -1; if (pid == 0) // 子进程：读取数据 close(pipe_fd[1]); // 关闭写端 char buf[64]; int len = read(pipe_fd[0], buf, sizeof(buf) - 1); buf[len] = \\0; printf(子进程收到消息: %s , buf); close(pipe_fd[0]); else // 父进程：写入数据 close(pipe_fd[0]); // 关闭读端 char *msg = Message from parent!; write(pipe_fd[1], msg, strlen(msg)); printf(父进程已发送消息。 ); close(pipe_fd[1]); wait(NULL); // 等待子进程结束 return 0; B、命名管道 (Named Pipe / FIFO) 1、说明 用途：可以在任意两个不相关的进程之间进行通信。 特点：它在文件系统中以一个特殊文件的形式存在（文件类型为p），有具体的路径名。只要进程有权限访问这个文件，就可以进行通信。 阻塞特性：打开命名管道时，读端会阻塞直到写端被打开，反之亦然。 2、创建命令与函数 终端命令：mkfifo 管道文件名，例如 mkfifo /tmp/myfifo。 mkfifo() 函数：man 3 mkfifo 查看接口函数。 // 函数头文件：#include sys/types.h#include sys/stat.h// 函数原型：int mkfifo(const char *pathname, mode_t mode);/* 参数一：pathname, 管道文件的路径名。 参数二：mode, 文件权限，如 0666。*/// 返回值：// 成功返回 0，失败返回 -1。 3、示例代码：不相关进程通信 a、写入命名管道 (writer.c) /** * @brief 向命名管道写入数据。 */#include stdio.h#include unistd.h#include sys/stat.h#include fcntl.h#include string.h#define FIFO_PATH /tmp/myfifoint main(void) // 如果管道不存在则创建 if (access(FIFO_PATH, F_OK) == -1) mkfifo(FIFO_PATH, 0666); printf(写进程：等待读进程连接... ); int fd = open(FIFO_PATH, O_WRONLY); printf(写进程：已连接，发送消息。 ); char *msg = Hello from FIFO!; write(fd, msg, strlen(msg)); close(fd); return 0; b、读取命名管道 (reader.c) /** * @brief 从命名管道读取数据。 */#include stdio.h#include unistd.h#include sys/stat.h#include fcntl.h#define FIFO_PATH /tmp/myfifoint main(void) printf(读进程：等待写进程连接... ); int fd = open(FIFO_PATH, O_RDONLY); printf(读进程：已连接，等待消息。 ); char buf[64]; int len = read(fd, buf, sizeof(buf) - 1); buf[len] = \\0; printf(读进程收到消息: %s , buf); close(fd); // 可选：删除管道文件 // unlink(FIFO_PATH); return 0; 如何运行： 编译两个程序：gcc writer.c -o writer 和 gcc reader.c -o reader。 在一个终端先运行 ./reader，它会阻塞。 在另一个终端再运行 ./writer，它会写入数据并退出 此时，reader 终端会打印出收到的消息并退出 (3)、通过信号 (Signal) 来通信 信号是一种异步通信机制，用于通知进程某个事件已经发生。它不传输数据，功能类似于一个软件中断，用于进程控制和状态通知。 1、信号命令与种类 A、信号的种类 查看命令: man 7 signal 或 kill -l 常用信号: SIGINT (2): 中断信号 (Ctrl+C)。 SIGKILL (9): 强制杀死信号，不可被捕捉或忽略。 SIGTERM (15): 终止信号 (kill 默认发送)。 SIGCHLD (17): 子进程状态改变。 SIGSTOP (19): 暂停信号，不可被捕捉或忽略。 SIGALRM (14): 定时器信号。 SIGUSR1, SIGUSR2: 用户自定义信号。 B、终端发送信号 kill -信号值 PID: 向指定进程发送信号。 killall -信号值 进程名: 向所有同名进程发送信号。 2、信号编程核心函数 kill(): 发送信号 (man 2 kill) #include signal.hint kill(pid_t pid, int sig); alarm(): 设置定时器信号 (man 2 alarm) #include unistd.hunsigned int alarm(unsigned int seconds); // seconds秒后发送 SIGALRM signal(): 设置信号处理方式 (man 2 signal) #include signal.htypedef void (*sighandler_t)(int);sighandler_t signal(int signum, sighandler_t handler);// handler 可以是 SIG_DFL (默认), SIG_IGN (忽略), 或自定义函数地址。 3、示例代码 a、处理终止信号 (捕捉信号) 用途：允许程序在收到 Ctrl+C 等终止信号时，执行清理工作（如保存数据）后再优雅地退出。 说明：捕捉 SIGINT 和 SIGQUIT 信号。 #include stdio.h#include signal.h#include unistd.hvolatile sig_atomic_t running = 1;void term_handler(int sig) printf( 收到信号 %d，准备退出... , sig); running = 0;int main(void) signal(SIGINT, term_handler); // 捕捉 Ctrl+C signal(SIGQUIT, term_handler); // 捕捉 Ctrl+\\ printf(程序运行中，按 Ctrl+C 或 Ctrl+\\\\ 退出。 ); while(running) printf(工作中... ); sleep(1); printf(执行清理任务... ); // ... 清理代码 ... printf(程序已退出。 ); return 0; b、处理闹钟信号 (捕捉信号) 用途：实现超时机制或周期性任务。 说明：使用 alarm() 配合 SIGALRM 信号。 #include stdio.h#include signal.h#include unistd.hvoid alarm_handler(int sig) printf(闹钟触发！执行定时任务。 ); alarm(3); // 重新设置下一次闹钟，实现周期性int main(void) signal(SIGALRM, alarm_handler); alarm(3); // 3秒后第一次触发 printf(已设置3秒周期闹钟，等待触发... ); while(1) pause(); // 等待信号，降低CPU消耗 return 0; c、忽略信号 用途：保护关键进程不被某些信号（如 Ctrl+C）意外中断。 #include stdio.h#include signal.h#include unistd.hint main(void) // 忽略 SIGINT 信号(ctrl+c、ctrl+\\) signal(SIGINT, SIG_IGN);\tsignal(SIGQUIT, SIG_IGN); printf(已忽略 Ctrl+C 信号，请尝试按 Ctrl+C。 ); printf(请使用 kill -9 %d 强制终止。 , getpid()); while(1) sleep(1); return 0; d、处理通信信号 用途：实现父子进程或任意两个进程间的简单通知。 #include stdio.h#include signal.h#include unistd.h#include sys/wait.hvoid child_sig_handler(int sig) printf(子进程：收到父进程发来的 SIGUSR1 信号！ );int main(void) pid_t pid = fork(); if (pid == 0) // 子进程 signal(SIGUSR1, child_sig_handler); printf(子进程 (PID: %d) 等待信号... , getpid()); while(1) pause(); else // 父进程 sleep(1); // 确保子进程已设置好信号处理 printf(父进程：向子进程 %d 发送 SIGUSR1 信号。 , pid); kill(pid, SIGUSR1); wait(NULL); return 0; e、处理子进程的退出 用途：父进程通过 SIGCHLD 信号异步回收子进程资源，避免产生僵尸进程，且父进程无需阻塞。 #include stdio.h#include signal.h#include unistd.h#include sys/wait.hvoid child_handler(int sig) // 信号处理不要太复杂(运算、时间等) int wait_status = 0; // 返回的状态 pid_t child_pid; while ((child_pid = waitpid(-1, wait_status, WNOHANG | WUNTRACED)) 0) // 等待任意任意子进程，如果还有子进程需要回收，就一直循环 if (WIFEXITED(wait_status)) printf(子进程(PID:%d)正常退出，状态:%d , child_pid, WEXITSTATUS(wait_status)); else if (WIFSIGNALED(wait_status)) printf(子进程(PID:%d)被信号%d杀死 , child_pid, WTERMSIG(wait_status)); else if (WIFSTOPPED(wait_status)) printf(子进程(PID:%d)被信号%d暂停 , child_pid, WSTOPSIG(wait_status)); // 主函数int main(int argc, char const* argv[]) pid_t pid = fork(); if (pid 0) // 创建进程失败 perror(fork error! ); return -1; else if (pid == 0) // 子进程 int i = 0; while (1) printf(子进程(PID: %d)正在运行中....... , getpid()); sleep(1); i++; if (i == 100) printf(子进程结束! ); _exit(0); else // 父进程 // 使用signal，设置信号处理函数 signal(SIGCHLD, child_handler); while (1) printf(父进程(PID: %d)正在运行中....... , getpid()); sleep(1); return 0; return 0; f、处理自定义工作进程控制 用途：使用用户自定义信号 SIGUSR1 和 SIGUSR2 来灵活控制一个工作进程的状态（如暂停/继续/终止）。 #include stdio.h#include signal.h#include unistd.h#include stdlib.hvolatile sig_atomic_t is_paused = 0;void control_handler(int sig) if (sig == SIGUSR1) is_paused = !is_paused; // 切换暂停/继续状态 printf(收到 SIGUSR1, 状态切换为: %s , is_paused ? 暂停 : 继续); else if (sig == SIGUSR2) printf(收到 SIGUSR2, 进程终止。 ); _exit(0); int main(void) signal(SIGUSR1, control_handler); signal(SIGUSR2, control_handler); printf(工作进程 (PID: %d) 已启动。 , getpid()); printf(使用 kill -SIGUSR1 %d 切换暂停/继续。 , getpid()); printf(使用 kill -SIGUSR2 %d 终止进程。 , getpid()); while(1) if (!is_paused) printf(工作中... ); sleep(1); return 0; g、信号控制多线程 (暂无) (此部分内容待后续线程章节学习后补充) (4)、System V IPC（重点） System V IPC 是一组经典且功能强大的进程间通信机制，包括消息队列、共享内存和信号量。它们共享一套相似的设计哲学和管理方式。 核心概念与管理 1. 工作流程 所有 System V IPC 机制都遵循相似的步骤： 创建密钥 (Key)：使用 ftok() 函数，通过一个已存在的文件路径和项目 ID，生成一个唯一的 key_t 类型的键值。这个键值是不同进程用来访问同一个 IPC 对象的“门牌号”。 创建/获取 IPC 对象：使用 msgget()、shmget() 或 semget() 函数，传入密钥来创建新的 IPC 对象，或获取一个已存在的对象的 ID。 操作 IPC 对象：使用各自的 API（如 msgsnd/msgrcv, shmat, semop）进行数据交换或同步。 销毁 IPC 对象：通信结束后，使用 msgctl()、shmctl() 或 semctl() 来删除 IPC 对象，释放内核资源。 2. IPC 管理命令 ipcs -a: 查看系统中所有的 IPC 对象（消息队列、共享内存、信号量）。 ipcs -q: 单独查看消息队列。 ipcs -m: 单独查看共享内存。 ipcs -s: 单独查看信号量。 ipcrm -q id: 删除指定 ID 的消息队列。 ipcrm -m id: 删除指定 ID 的共享内存。 ipcrm -s id: 删除指定 ID 的信号量。 3. ftok() 函数：创建密钥 man 3 ftok 查看接口函数。 #include sys/ipc.hkey_t ftok(const char *pathname, int proj_id);/* 参数一：一个已存在的文件路径。 参数二：项目ID，一个非零整数。 返回值：成功返回一个 key_t 键值，失败返回 -1。*/ A、消息队列 (Message Queue) 1. 说明与图解 消息队列是存放在内核中的一个消息链表，允许一个或多个进程向其发送或接收结构化的消息。它克服了管道只能传输无格式字节流的限制。 2. 核心函数 msgget(): 创建或获取消息队列 ID (man 2 msgget) #include sys/msg.hint msgget(key_t key, int msgflg);// msgflg: 表示创建或打开队列的权限和方式，通常是 IPC_CREAT | 0666 msgsnd(): 发送消息 (man 2 msgsnd) int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);// 参数分别为： 消息id 消息本体 消息大小 发送方式，一般为0 msgrcv(): 接收消息 (man 2 msgrcv) ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);// 参数分别为： 消息id 消息本体 消息大小 消息类型 发送方式，一般为0 msgctl(): 控制消息队列 (man 2 msgctl) int msgctl(int msqid, int cmd, struct msqid_ds *buf);// cmd: IPC_RMID 用于删除消息队列 3. 示例代码 公共结构体定义 (common.h) // common.h#define MSG_KEY_PATH .#define MSG_KEY_PROJ_ID astruct msg_buf long mtype; // 消息类型，必须 0 char mtext[128]; // 消息内容; 发送端 (sender.c) // sender.c#include stdio.h#include sys/msg.h#include common.hint main() key_t key = ftok(MSG_KEY_PATH, MSG_KEY_PROJ_ID); int msqid = msgget(key, IPC_CREAT | 0666); struct msg_buf msg = 1, Hello from sender!; // 消息类型为 1 msgsnd(msqid, msg, sizeof(msg.mtext), 0); printf(消息已发送。 ); return 0; 接收端 (receiver.c) // receiver.c#include stdio.h#include sys/msg.h#include common.hint main() key_t key = ftok(MSG_KEY_PATH, MSG_KEY_PROJ_ID); int msqid = msgget(key, IPC_CREAT | 0666); struct msg_buf msg; msgrcv(msqid, msg, sizeof(msg.mtext), 1, 0); // 接收类型为 1 的消息 printf(收到消息: %s , msg.mtext); // 删除消息队列 msgctl(msqid, IPC_RMID, NULL); return 0; B、共享内存 (Shared Memory) 1. 说明与图解 共享内存是最快的 IPC 方式。它将一块物理内存映射到多个进程的虚拟地址空间中，进程可以直接像访问普通变量一样读写这块内存，无需内核介入数据拷贝。 2. 核心函数 shmget(): 创建或获取共享内存 ID (man 2 shmget) #include sys/shm.hint shmget(key_t key, size_t size, int shmflg);// size: 共享内存大小，通常是页大小的整数倍。 shmat(): 映射共享内存到进程地址空间 (man 2 shmat) void *shmat(int shmid, const void *shmaddr, int shmflg);// 返回值是映射到本进程的内存地址指针。 shmdt(): 解除映射 (man 2 shmdt) int shmdt(const void *shmaddr); shmctl(): 控制共享内存 (man 2 shmctl) int shmctl(int shmid, int cmd, struct shmid_ds *buf);// cmd: IPC_RMID 用于删除共享内存段。 3. 示例代码 写进程 (writer.c) // writer.c#include stdio.h#include string.h#include sys/shm.hint main() key_t key = ftok(., b); int shmid = shmget(key, 1024, IPC_CREAT | 0666); char *shm_ptr = (char *)shmat(shmid, NULL, 0); strcpy(shm_ptr, Hello from shared memory!); printf(数据已写入共享内存。 ); shmdt(shm_ptr); // 解除映射 return 0; 读进程 (reader.c) // reader.c#include stdio.h#include sys/shm.hint main() key_t key = ftok(., b); int shmid = shmget(key, 1024, IPC_CREAT | 0666); char *shm_ptr = (char *)shmat(shmid, NULL, 0); printf(从共享内存读取数据: %s , shm_ptr); shmdt(shm_ptr); // 解除映射 shmctl(shmid, IPC_RMID, NULL); // 删除共享内存 return 0; C、信号量 (Semaphore) 1. 说明 信号量本质上是一个计数器，主要用于进程间的同步与互斥，以保护共享资源（如共享内存）不被并发访问破坏。它本身不传输数据。 互斥：确保同一时间只有一个进程能访问临界资源（如厕所只有一把钥匙）。 同步：协调多个进程的执行顺序（如生产者生产完，才能通知消费者消费）。 PV 操作： P 操作 (sem_wait): 申请资源，信号量计数值减 1。如果计数值为 0，则进程阻塞。 V 操作 (sem_post): 释放资源，信号量计数值加 1。 2. POSIX 有名信号量 这是比 System V 信号量更现代、更易用的接口，常用于进程间同步。它在 /dev/shm/ 目录下创建一个文件来表示信号量。 3. 核心函数 (编译时需链接 -pthread) sem_open(): 创建或打开有名信号量 (man 3 sem_open) #include semaphore.hsem_t *sem_open(const char *name, int oflag, mode_t mode, unsigned int value);// name: 信号量名称，格式为 /somename。// oflag: O_CREAT 创建, O_EXCL 确保是新创建。// value: 信号量初始值。 sem_wait(): P 操作 (加锁) (man 3 sem_wait) int sem_wait(sem_t *sem); sem_post(): V 操作 (解锁) (man 3 sem_post) int sem_post(sem_t *sem); sem_close(): 关闭信号量 (man 3 sem_close) int sem_close(sem_t *sem); sem_unlink(): 删除有名信号量 (man 3 sem_unlink) int sem_unlink(const char *name); 4. 示例代码：使用信号量保护共享内存 公共头文件 (common.h) // common.h#include semaphore.h#define SHM_KEY_PATH .#define SHM_KEY_PROJ_ID c#define SEM_NAME /my_semaphore 初始化进程 (init.c) // init.c#include common.h// (包含 shmget/shmat/sem_open 等创建和初始化代码)// sem_t *sem = sem_open(SEM_NAME, O_CREAT, 0666, 1); // 初始值为1，用于互斥// ... 使用共享资源的进程 (proc.c) // proc.c#include common.h#include stdio.h#include sys/shm.h#include unistd.hint main() key_t key = ftok(SHM_KEY_PATH, SHM_KEY_PROJ_ID); int shmid = shmget(key, sizeof(int), 0); int *shared_counter = (int *)shmat(shmid, NULL, 0); sem_t *sem = sem_open(SEM_NAME, 0); for (int i = 0; i 5; i++) sem_wait(sem); // P操作：加锁 // --- 临界区开始 --- int temp = *shared_counter; printf(PID %d: read %d, , getpid(), temp); temp++; sleep(1); // 模拟耗时操作 *shared_counter = temp; printf(write %d , *shared_counter); // --- 临界区结束 --- sem_post(sem); // V操作：解锁 shmdt(shared_counter); sem_close(sem); return 0; 如何运行：先运行一个程序初始化共享内存（设为 0）和信号量（设为 1）。然后同时运行多个 proc 实例。你会看到，由于信号量的保护，共享计数器会从 0、1、2…有序地增加，而不会出现多个进程同时读到相同值导致的“竞争条件”。","tags":[null],"categories":[null,null]},{"title":"内核链表笔记","path":"/data/ES/基础/内核链表用法.html","content":"内核链表用法 以一个贯穿始终的 student 结构体和名为 student_list_head 的链表头为例 #include list.h // 假设你已包含 list.h#include stdlib.h// 示例数据节点：学生struct student int id; char *name; struct list_head list; // 嵌入的“连接扣”，关系管理成员;// 贯穿所有示例的链表头指针// 它的创建方式见下面的初始化部分struct list_head student_list_head; 初始化 INIT_LIST_HEAD - 动态初始化链表头 对一个已分配内存、但未初始化的链表头进行初始化。这是动态创建链表时的必用函数 // 假设链表头是另一个动态结构体的一部分struct class_roster char *class_name; struct list_head student_list; // 链表头在这里;struct class_roster *my_class = malloc(sizeof(struct class_roster));// 对其中的链表头成员进行初始化if (my_class != NULL) INIT_LIST_HEAD(my_class-student_list); 高级工具 list_entry - 从“连接扣”反查“本人” 内核链表的核心魔法。从指向list_head成员的指针，反向计算出其宿主结构体的起始地址。list_for_each_entry等宏在内部调用它 // 假设只拿到了一个 list_head 成员的指针 list_ptrstruct list_head *list_ptr = some_student-list;// 手动转换回 student 结构体指针struct student *the_student;the_student = list_entry(list_ptr, struct student, list); 增 list_add_tail - 在链表尾部添加 (最常用) 将新节点添加到链表头(head)的前面，实现尾部插入效果 struct student *new_stu = malloc(sizeof(struct student));new_stu-id = 101;// 将 new_stu 添加到 student_list_head 的尾部list_add_tail(new_stu-list, student_list_head); list_add - 在链表头部添加 将新节点添加到链表头(head)的后面，实现头部插入效果 struct student *new_stu = malloc(sizeof(struct student));new_stu-id = 99;// 将 new_stu 添加到 student_list_head 的头部list_add(new_stu-list, student_list_head); 删 list_del - 从链中断开节点 将指定节点从链表中“摘出”。节点内存并未释放，可以重新插入或手动释放 // 假设 stu_to_delete 是要删除的节点指针// 1. 从链中断开list_del(stu_to_delete-list);// 2. 手动释放内存free(stu_to_delete); list_for_each_entry_safe - 安全遍历 (删除时专用) 遍历链表，同时允许在循环体内安全地删除当前节点 struct student *p, *next_p;// 安全遍历，准备删除 id 为 101 的学生// 参数为 当前元素 下一个元素 头节点管理点 关系管理元素名list_for_each_entry_safe(p, next_p, head.list, list) if (p-id == 101) list_del(p-list); free(p); 移动 一步完成“摘出”和“插入” list_move - 移动节点到指定位置之后 将节点移动到目标节点的后面 // 把 rose_node 移动到 jack_node 的后面list_move(rose_node-list, jack_node-list); list_move_tail - 移动节点到指定位置之前 将节点移动到目标节点的前面。常用于将节点移动到队尾 // 把 bill_node 移动到整个链表的末尾 (即链表头的前面)list_move_tail(bill_node-list, student_list_head); 查 遍历 list_for_each_entry - 遍历所有节点 (最常用) 安全、方便地遍历链表，在循环中直接获得指向大结构体的指针 struct student *p;// 遍历由 student_list_head 管理的每一个学生// 当前内容 头节点管理节点 节点类型list_for_each_entry(p, head.list, list) // 循环内，p 就是指向当前 student 结构体的指针 printf(ID: %d, Name: %s , p-id, p-name); list_for_each - 遍历链表节点指针 遍历链表的所有 list_head 节点（不直接获取宿主结构体指针），适合只操作链表连接结构时使用。 struct list_head *pos;// 遍历由 student_list_head 管理的链表中的每一个 list_head 节点// 参数为 当前位指针 链表头节点list_for_each(pos, student_list_head) // pos 指向当前节点的 list_head 成员 // 若需获取宿主结构体，需用 list_entry 宏转换： struct student *p = list_entry(pos, struct student, list); printf(ID: %d, Name: %s , p-id, p-name); list_for_each 是基于指针操作的低层次遍历宏，不做类型安全转换 list_empty - 检查链表是否为空 判断链表是否只包含头结点。返回 true (1) 或 false (0) if (list_empty(student_list_head)) printf(学生列表是空的。 );","tags":[null],"categories":[null,null]},{"title":"文件I/O学习笔记","path":"/data/ES/基础/文件IO学习笔记.html","content":"文件 I/O（Input/Output）是与外部存储（如硬盘、SSD）中的文件进行数据交换的基础。 C 语言提供了两套主要的文件操作 API：标准 I/O和系统 I/O。 标准 I/O (Standard I/O): C 语言标准库 (stdio.h) 提供的函数。它们具有良好的可移植性，并内置了用户态缓冲区机制以提高效率。是日常应用开发的首选。 系统 I/O (System I/O): 操作系统内核直接提供的系统调用（System Call），在 Linux/Unix 中遵循 POSIX 标准（如unistd.h, fcntl.h）。它们更接近底层，功能更原始，不带用户态缓冲区（数据直达内核缓冲区）。 特性对比 标准 I/O (stdio.h) 系统 I/O (unistd.h, fcntl.h) 核心标识 FILE * (文件指针) int (文件描述符) 缓冲机制 有 (全/行/无缓冲) 无 (数据直达内核缓冲区) 可移植性 高 (遵循 C 标准) 中 (遵循 POSIX 标准，Windows 有差异) 操作对象 任何 C 程序能识别的“流” 操作系统层面的一切皆“文件” 效率 读写大块数据时，因缓冲而效率高 频繁进行小数据量读写时效率低 常用函数 fopen, fclose, fread, fwrite, fgets open, close, read, write, lseek 比喻 精装的饭店: 提供现成菜品，服务周到 原始的菜市场: 提供原生食材，需自行加工 第一部分：标准 I/O stdio.h 标准 I/O 通过FILE结构体来管理文件流，并利用缓冲区优化性能 文件的打开与关闭 fopen, fclose FILE *fopen(const char *path, const char *mode);: 打开一个文件，返回一个指向FILE结构体的指针（文件指针）。如果失败，返回NULL。 int fclose(FILE *fp);: 关闭文件，将缓冲区剩余数据刷入文件并释放资源。 常用打开模式 mode: 模式 描述 文件不存在 文件存在 r 读模式 (Read) 打开失败 从头读取 w 写模式 (Write) 创建新文件 清空并从头写入 a 追加模式 (Append) 创建新文件 从末尾追加写入 r+ 读写模式 打开失败 从头读写 w+ 读写模式 创建新文件 清空并从头读写 a+ 读写模式 创建新文件 从末尾追加，可读 多种读写方式 1.0 错误处理 feof,ferror feof：(file end of) 判断是否到文件末尾 ferror：(file error) 判断是否遇到文件错误 1.1 按字符读写 fgetc, fputc fgetc 相当于标准输入的 getchar() 成功时返回读取的字符，失败或到文件末尾时返回EOF。 所以必须用int类型变量接收，以区分EOF(-1)和值为 255 的字符。 当fgetc返回EOF时，必须使用feof()和ferror()来进一步区分是文件正常结束还是读写中途发生错误。 feof(fp): 如果是因为到达文件末尾而失败，返回真(非零)。 ferror(fp): 如果是因为发生 I/O 错误而失败，返回真(非零)。 // 从src.txt拷贝到dest.txt，带完整错误处理FILE *fp = fopen(src.txt, r);if (!fp) perror(打开失败); return -1; int ch;while ((ch = fgetc(fp)) != EOF) fputc(ch, dest_fp);if (ferror(fp)) // 检查是否因读取错误而退出循环 perror(读取错误); else if (feof(fp)) // 检查是否因读到文件末尾而退出 printf(成功拷贝 );fclose(fp); 1.2 按字符串（行）读写 fgets, fputs fgets 是读取字符串的安全选择，因为它有边界检查，能有效防止缓冲区溢出 最多读取size-1个字符，或读到换行符 为止 会保留 fputs(buf, fp) 将字符串写入文件，不会自动添加 FILE *fp1 = fopen(argv[1], r);FILE *fp2 = fopen(argv[2], w);char buf[10]; // 缓冲区while (fgets(buf, 10, fp1) != NULL) // fgets一次最多读sizeof(buf)-1个字符，即9个 // 如果一行超过9个字符，它会分多次读取 fputs(buf, fp2);// fgets返回NULL时，同样需要用feof和ferror检查if(feof(fp1)) printf(拷贝完毕! );else if(ferror(fp1)) perror(读取错误);fclose(fp1); fclose(fp2); 1.3 按数据块读写 fread, fwrite 按指定大小的数据块读写，是读写二进制文件或结构体的最常用、最高效的方式 返回值: fread和fwrite都返回成功读/写的数据块（nmemb）数量。 当到达文件末尾时，fread可能没有读最后一块数据（不足一块），此时返回值会小于预期，甚至为 0 此时实际读入缓冲区的数据字节数可能不是size * n 必须结合ftell或自己计算字节数来处理文件末尾不足一个块的数据 // 1. 只读打开源文件、只写目标文件（若不存在则创建，若存在则清空）FILE *fp1 = fopen(file1.txt, r);FILE *fp2 = fopen(file2.txt, w);// 2. 循环读取源文件并放入目标文件char *buf = calloc(5, 20); // 分配了100字节while (1) fseek(fp1, 0, SEEK_END); // 将文件指针移到文件末尾 long file_size = ftell(fp1); // 获取当前文件指针位置，即文件大小 fseek(fp1, 0, SEEK_SET); // 将文件指针移回文件开头，以便后续读取 // fread返回的是整数块，不足一整块的不会被计入n // 但是是可以被正常读取 // 例如读到96个字节，返回4，读到46个字节，返回2，读到16个字节，返回0 int n = fread(buf, 20, 5, fp1); // 用buf缓冲区，读分配fp1指向文件的20字节*5块 if (n 5) // a. 读取失败或到文件尾 if (feof(fp1)) long b = ftell(fp1); // 将剩余的 0-99 个字节拷贝到目标文件 fwrite(buf, b - a, 1, fp2); break; fwrite(buf, 20, 5, fp2); // b. 正常读到100个字节，写入目标文件// 3. 释放资源fclose(fp1); fclose(fp2); 1.4 按格式化 I/O 读写 fscanf, fprintf,snprintf 可以像scanf/printf一样，对文件或字符串进行格式化 I/O。 函数 源 / 目标 描述 scanf / printf 键盘 / 终端 标准输入/输出 fscanf / fprintf 文件 (FILE*) 从/向指定文件流进行格式化 I/O sscanf / sprintf 字符串 (char*) 从/向字符串进行格式化 I/O。sprintf不安全！ snprintf 字符串 (char*) sprintf的安全版本，指定最大写入长度，强烈推荐 FILE *fp1 = fopen(argv[1], r);FILE *fp2 = fopen(argv[2], w);int a; char buf[20]; float f;// fscanf返回成功匹配并赋值的项数while (fscanf(fp1, %d %s %f, a, buf, f) == 3) fprintf(fp2, INT: %d, STR: %s, FLOAT: %.2f , a, buf, f);fclose(fp1); fclose(fp2); (字符串格式化): char buf[100];// 安全地将格式化数据写入字符串snprintf(buf, sizeof(buf), %d %s,%f data ..., 100, hello, 3.14);// 从字符串中解析数据int a; char s[20]; float f;sscanf(buf, %d %s。%f, a, s, f);printf(a: %d, s: %s, f: %f , a, s, f);// 解析结果为：// a: 100// s: hello。3.140000// f: 0.000000// 因为“%s”后面加上字符后,hello和3.14会被连着读 文件定位 fseek, ftell, rewind int fseek(FILE *stream, long offset, int whence);: 移动文件读写指针。 whence: SEEK_SET (文件头), SEEK_CUR (当前位置), SEEK_END (文件尾)。 long ftell(FILE *stream);: 返回当前读写指针相对于文件头的字节偏移量。 void rewind(FILE *stream);: 将指针移回文件头，等价于 fseek(stream, 0, SEEK_SET)。 fp (获取文件大小): FILE *fp = fopen(file.txt, rb);// 1. 将指针移动到文件末尾if (fseek(fp, 0, SEEK_END) != 0) perror(无法读到文件末尾); fclose(fp); return 1;// 2. 获取当前位置，即文件大小long file_size = ftell(fp);if (file_size == -1L) perror(ftell); fclose(fp); return 1;printf(文件： %s 大小: %ld bytes , file.txt, file_size);rewind(fp);// 3. 将指针移回文件开头，以便后续读取fclose(fp); 缓冲区 stdout默认行缓冲，stderr默认无缓冲，普通文件默认全缓冲 缓冲区刷新的 6 大时机: 缓冲区已满 遇到换行符 (仅限行缓冲) 程序正常退出 (return, exit())。abort()等异常退出不会刷新 手动调用 fflush(fp) 关闭文件 fclose(fp) 在一个流上执行任何输入操作前，会先刷新该流的输出缓冲区 setvbuf(fp, buf, mode, size): 自定义缓冲区刷新策略 fp: 文件指针 buf: 缓冲区地址 mode: _IOFBF(全), _IOLBF(行), _IONBF(无)。 size: 缓冲区大小 fprintf(stdout, abcd); // 标准输出模式，默认放入缓冲区fprintf(stderr, 1234); // 标准错误模式，默认直接输出FILE *fp = fopen(test.txt, w+); // 默认先放进缓冲区，所以不会立即放入文件fprintf(fp, 1234); // 默认放入缓冲区char buf[100];setvbuf(fp, buf, _IOLBF, 100); // 设置缓冲区，_IOLBF表示行缓冲fprintf(fp, abcd ); // 修改为了行缓冲，且数据有换行符，立即放入文件abort(); // 此时虽然程序也被强制中断，但数据已经保存到文件中，数据不丢失 第二部分：系统 I/O fcntl.h 系统 I/O 直接与操作系统内核交互，操作的是一个整数——文件描述符 (File Descrip, fd) 它是访问文件的底层句柄，更加强大和灵活，是理解操作系统工作原理的基石 0: 标准输入 (stdin) - STDIN_FILENO 1: 标准输出 (stdout) - STDOUT_FILENO 2: 标准错误 (stderr) - STDERR_FILENO 错误处理机制: errno, perror, strerror 包含在errno.h里 当系统调用失败时，通常会返回 -1，并设置一个全局整型变量 errno 来表示具体的错误原因。 errno 的值只在系统调用或库函数发生错误时才会被设置，因此只有在函数返回错误时检查errno才有意义 perror(const char *s): 先打印自己的字符串 s，然后输出 errno`对应的错误描述 char *strerror(int errnum): 返回错误码对应字符串的指针，可以自定义输出格式 int fd = open(non_existent_file.txt, O_RDONLY);if (fd == -1) // 方法一：使用 perror (推荐) // 输出: 打开文件失败: No such file or directory perror(打开文件失败); // 方法二：使用 strerror (更灵活) // 输出: Error opening file: No such file or directory printf(打开文件失败: %s , strerror(errno)); return 1; 文件的打开与关闭 open,close 包含在fcntl.h里 int open(const char *pathname, int flags, ...);: 打开或创建一个文件。 pathname: 文件路径。 flags: 通过|组合的标志位，决定操作模式。 ...: 可变参数，当flags包含O_CREAT时，必须提供第三个参数mode_t mode来指定新文件的权限（如0644）。 int close(int fd);: 关闭文件描述符，释放相关内核资源。一个进程能打开的文件描述符数量是有限的，务必及时关闭不再使用的fd。 flags 标志位详解 flags 参数通过按位或 | 操作符组合，用于精确控制文件的打开方式。 | 标志 (Flag) | 英文全称 / 释义 | 描述 | | :----------- | :---------------- | :------------------------------------------------------------------------------------------------------------------ | -------------------- | | 访问模式 | | 以下三个标志是互斥的，必须选择其一 | | O_RDONLY | Open Read Only | 以只读模式打开文件。 | | O_WRONLY | Open Write Only | 以只写模式打开文件。 | | O_RDWR | Open Read/Write | 以读写模式打开文件。 | | 可选标志 | | **以下标志可通过 | 与访问模式组合** | | O_CREAT | Open Create | 如果文件不存在，则创建它。使用此标志时必须提供第三个mode参数。 | | O_TRUNC | Open Truncate | 如果文件已存在并且是可写模式打开，则将其长度截断为 0（即清空内容）。 | | O_APPEND | Open Append | 每次写入数据时，都自动将文件指针移动到文件末尾进行追加操作。 | | O_NONBLOCK | Open Non-blocking | 以非阻塞模式打开文件。主要用于设备文件和管道，对它们的读写操作不会被阻塞。 | | O_EXCL | Open Exclusive | 与 O_CREAT 配合使用。如果文件已存在，open调用会失败并返回错误。这是实现“文件锁”或确保文件唯一性的原子操作。 | // 场景1: 读写方式打开，不存在则创建，权限为 rw-r--r--int fd1 = open(log.txt, O_RDWR | O_CREAT | O_TRUNC, 0644);if (fd1 == -1) perror(open log.txt failed); return 1; printf(文件已创建: %d , fd1);close(fd1);// 场景2: 安全地创建文件，如果文件已存在则失败int fd2 = open(lock.file, O_WRONLY | O_CREAT | O_EXCL, 0600);if (fd2 == -1) perror(无法创建文件，可能文件已存在); return 1; printf(文件已创建: %d , fd2);close(fd2); 文件内容读、写与定位 3.1 核心函数: read / write / lseek 存在于unistd.h ssize_t read(int fd, void *buf, size_t count);: 从fd读取最多count字节到buf。返回实际读取的字节数，0表示文件结束，-1表示错误。 ssize_t write(int fd, const void *buf, size_t count);: 将buf中的count字节写入fd。返回实际写入的字节数，可能小于count，需循环写入。 off_t lseek(int fd, off_t offset, int whence);: 移动文件读写指针。 whence 可以是SEEK_SET(文件头), SEEK_CUR(当前位置), SEEK_END(文件尾)。 3.2 实践案例: 获取文件大小 int fd = open(file.txt, O_RDONLY);// 将指针移动到文件末尾，lseek返回值即为文件大小off_t file_size = lseek(fd, 0, SEEK_END);printf(文件%s 大小为 %ld bytes. , argv[1], file_size);close(fd); 3.3 实践案例: 创建文件空洞 int fd = open(file.txt, O_RDWR | O_CREAT | O_TRUNC, 0644);write(fd, start, 5);// 从当前位置向后移动1MB，形成空洞lseek(fd, 1024 * 1024, SEEK_CUR);write(fd, end, 3);close(fd);// 使用 `ls -lh` 和 `du -h` 命令查看文件大小和实际占用空间的区别 高级文件描述符操作 4.1 I/O 重定向: dup / dup2 存在于unistd.h int dup(int oldfd);: 复制oldfd，返回一个新的、当前未被使用的最小文件描述符 int dup2(int oldfd, int newfd);: 将newfd重定向到oldfd。如果newfd已打开，会先关闭它 这是实现 Shell 重定向（如 和 ）的关键。 在 shell 脚本中，0 是标准输入（键盘），1 是标准输出（终端），2 是错误输出 用 dup2（fd,0）；就吧标准输入改为 fd 里，类似于 shell 里的 int log_fd = open(file.txt, O_WRONLY | O_CREAT | O_TRUNC, 0644);// 将标准输出(fd=1)重定向到log_fdif (dup2(log_fd, STDOUT_FILENO) == -1) perror(dup2); return 1; close(log_fd); // 原log_fd可关闭，fd=1已指向日志文件printf(这句话会输出到文件里. );fprintf(stderr, 这句话将直接输出到终端 ); 4.2 文件状态控制: fcntl 存在于fcntl.h int fcntl(int fd, int cmd, ...);: fcntl (file control) 是一个多功能工具箱，能对文件描述符执行多种控制操作 cmd决定了fcntl的功能，常用的有F_GETFL (获取状态) 和 F_SETFL (设置状态) 具体的参数详解可以查看此博客文章：Linux fcntl 函数详解 fp (设置非阻塞 I/O): int fd = STDIN_FILENO; // 用标准输入做演示// 1. 获取当前状态标志long flags = fcntl(fd, F_GETFL);if (flags == -1) perror(获取标准输入状态失败); return 1; // 2. 添加非阻塞标志flags |= O_NONBLOCK;// 3. 应用新标志if (fcntl(fd, F_SETFL, flags) == -1) perror(设置标准输入状态失败); return 1; char buf[10];ssize_t n = read(fd, buf, sizeof(buf));if (n 0) // 非阻塞read在无数据时立即返回-1 // 因为理论上应该从用户输入读取数据，但用户没输入就直接开始读取数据，所以这里出错 perror(在以非阻塞模式读取); else printf(读取了 %ld bytes. , n); 特殊文件 I/O 5.1 设备 I/O 控制: ioctl ioctl (input/output control) 是一个专用于设备 I/O 的“后门”，允许应用程序直接与设备驱动程序通信。 通过这个接口，可以实现在 linux 应用层控制内核层下的驱动，进而控制具体的外设 应用程序通过代码片段与设备节点交互,来操作具体硬件如 LED、读取 ADC 和控制 PWM 设备节点作为接口连接应用和驱动程序,完成用户空间与内核空间的通信,每个节点通过系统调用(如 open())、read()、ioctl())与应用程序交互 驱动程序封装具体的硬件操作逻辑,由设备节点调用,每个驱动程序专注于特定功能模块 linux 系统通过这样的分层封装实现功能分离,硬件工程师负责底层设备操作,应用软件工程师只需使用抽象化设备，无需了解底层原理 ioctl 的行为完全由request命令码和设备驱动的实现决定，具体应用可以查看 linux 编程笔记 linux 驱动基础概念以及驱动程序框架搭建 5.2 内存映射 I/O: mmap 存在于sys/mman.h里 *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);: 将文件或设备直接映射到进程的虚拟内存空间 之后对这块内存的读写就等同于对文件的读写，省去了read/write的系统调用开销和内核/用户态数据拷贝，效率极高 prot: 内存保护标志 (PROT_READ, PROT_WRITE)。 flags: MAP_SHARED（修改会同步到文件）或 MAP_PRIVATE（写时复制，修改不影响文件）。 munmap(void *addr, size_t length) : Memory UNMAP，解除内存映射。 内存映射文件: int fd = open(mmap_test.txt, O_RDWR | O_CREAT, 0644);ftruncate(fd, 100); // 确保文件至少有100字节char *mapped_mem = mmap(NULL, 100, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);if (mapped_mem == MAP_FAILED) perror(内存映射失败); close(fd); return 1; close(fd); // mmap后可以立即关闭fd，映射关系依然存在strcpy(mapped_mem, 你好内存映射，像操作内存一样操作文件,复制这段话到文件);munmap(mapped_mem, 100); // 操作完成，解除映射 第三部分：文件与目录管理 在 linux 系统编程中，除了对文件内容进行读写，我们还经常需要获取和管理文件本身的属性（如大小、权限、类型）以及组织这些文件的目录结构。 这部分操作主要依赖于 POSIX 标准提供的系统调用。 1. 获取文件元数据: stat / fstat / lstat 这组函数用于获取文件的元数据，并将其填充到一个struct stat结构体中 int stat(const char *pathname, struct stat *statbuf);: 通过文件名获取属性 int fstat(int fd, struct stat *statbuf);: 通过文件描述符获取属性 int lstat(const char *pathname, struct stat *statbuf);: 类似stat，但如果pathname是一个符号链接 ，lstat获取的是链接本身的属性，而不是它所指向的文件的属性。 stat则会“穿透”链接，获取目标文件的属性。 1.0 struct stat 结构体 不用记这个结构体，了解大概有什么就行 struct stat dev_t st_dev; /* 存放该文件的设备 ID（device ID） */ ino_t st_ino; /* inode 编号（Inode number） */ mode_t st_mode; /* 文件类型和权限模式（file type mode/permissions） */ nlink_t st_nlink; /* 硬链接数量（number of hard links） */ uid_t st_uid; /* 文件所有者的用户 ID（user ID of owner） */ gid_t st_gid; /* 文件所有者的组 ID（group ID of owner） */ dev_t st_rdev; /* 设备 ID（device ID，特殊文件才有） */ off_t st_size; /* 文件总大小（total size, in bytes） */ blksize_t st_blksize; /* 文件系统 I/O 的建议块大小（block size for filesystem I/O） */ blkcnt_t st_blocks; /* 实际分配的 512 字节块数量（number of 512B blocks allocated） */ struct timespec st_atim; /* 最后一次访问时间（time of last access） */ struct timespec st_mtim; /* 最后一次修改时间（time of last modification） */ struct timespec st_ctim; /* 最后一次状态变化时间（time of last status change） */; 这些字段中要注意的： st_mode: 一个 16 位的字段，包含了文件类型和权限信息。需要使用宏来解析。 st_rdev: 仅当文件是字符设备或块设备时才有意义，表示该设备的设备号。 st_size: 对于普通文件，是文件的字节大小。对于设备文件，此值无意义。 1.1 获取文件信息 不用管前面的那么多参数，只需要下面三个步骤就可以获取上面的信息 具体需要获取什么信息 就用 man 手册查一下结构体内容就行 struct stat st;//申请一个空间存文件信息bzero(st,sizeof(st));//清空文件信息表stat(a.txt, st);//读取文件信息 1.2 实践案例: 实现一个功能完整的 ls -l 这个案例是stat函数最经典的用例，完美展示了如何解析struct stat中的各种信息。 代码示例: #include grp.h // 用于 获取组信息 get by grope id#include pwd.h // 用于 获取用户信息 get password file entry by user ID#include stdio.h#include sys/stat.h#include sys/sysmacros.h // 用于 major 和 minor 宏#include time.h#include unistd.h#include fcntl.h// 辅助函数：解析文件类型char get_file_type(mode_t mode) if (S_ISREG(mode)) return -; if (S_ISDIR(mode)) return d; if (S_ISLNK(mode)) return l; if (S_ISCHR(mode)) return c; if (S_ISBLK(mode)) return b; if (S_ISFIFO(mode)) return p; if (S_ISSOCK(mode)) return s; return ?;// 辅助函数：解析权限void get_permissions(mode_t mode, char *str) str[0] = (mode S_IRUSR) ? r : -; str[1] = (mode S_IWUSR) ? w : -; str[2] = (mode S_IXUSR) ? x : -; str[3] = (mode S_IRGRP) ? r : -; str[4] = (mode S_IWGRP) ? w : -; str[5] = (mode S_IXGRP) ? x : -; str[6] = (mode S_IROTH) ? r : -; str[7] = (mode S_IWOTH) ? w : -; str[8] = (mode S_IXOTH) ? x : -; str[9] = \\0;int main(int argc, char const *argv[]) if (argc != 2) fprintf(stderr, 使用方法: %s 文件或路径参数 , argv[0]); return 1; struct stat st; if (lstat(argv[1], st) == -1) perror(lstat failed); return 1; // 1. 打印文件类型和权限 char perms[10]; get_permissions(st.st_mode, perms); printf(%c%s , get_file_type(st.st_mode), perms); // 2. 打印硬链接数 printf(%ld , st.st_nlink); // 3. 打印所有者和所属组 printf(%s %s , getpwuid(st.st_uid)-pw_name, getgrgid(st.st_gid)-gr_name); // 4. 关键：区分普通文件和设备文件 if (S_ISCHR(st.st_mode) || S_ISBLK(st.st_mode)) // 如果是设备文件，打印主、次设备号 printf(%u, %-4u , major(st.st_rdev), minor(st.st_rdev)); else // 如果是普通文件，打印大小 printf(%8ld , st.st_size); // 5. 打印最后修改时间 char time_buf[20]; strftime(time_buf, sizeof(time_buf), %b %d %H:%M, localtime(st.st_mtime)); printf(%s , time_buf); // 6. 打印文件名 printf(%s , argv[1]); return 0; 2. 目录操作 2.1 核心函数: opendir / readdir / closedir / chdir 核心知识点: DIR *opendir(const char *name);: 打开一个目录，返回一个指向DIR结构体的目录流指针。 struct dirent *readdir(DIR *dirp);: 从目录流中读取下一个目录项。当读取完毕或发生错误时，返回NULL。struct dirent中最重要的成员是d_name（文件名）。 int closedir(DIR *dirp);: 关闭目录流，释放资源。 int chdir(const char *path);: 改变当前进程的工作目录 (Change Directory)。这是一个非常有用的函数，在遍历目录时，可以先chdir到目标目录，然后直接对目录内的文件名使用stat，避免了手动拼接完整路径的麻烦。 2.2 实践案例: 遍历目录并获取文件信息 这个案例展示了如何结合目录遍历和文件属性获取，实现一个简单的目录列表程序。 代码示例: #include stdio.h#include dirent.h#include sys/stat.h#include unistd.h#include stdlib.h#include string.hint main(int argc, char const *argv[]) const char *dirpath = (argc 1) ? argv[1] : .; DIR *dp = opendir(dirpath); if (dp == NULL) perror(opendir failed); return 1; // *** 关键技巧：改变当前工作目录 *** if (chdir(dirpath) == -1) perror(chdir failed); closedir(dp); return 1; printf(Content of directory %s: , dirpath); struct dirent *entry; struct stat st; // 循环读取目录中的每一个条目 while ((entry = readdir(dp)) != NULL) // 跳过隐藏文件 . 和 .. if (strcmp(entry-d_name, .) == 0 || strcmp(entry-d_name, ..) == 0) continue; // 因为已经chdir，所以可以直接对文件名stat if (lstat(entry-d_name, st) == -1) perror(entry-d_name); // 如果stat失败，打印文件名和错误 continue; printf(%-20s \\t Size: %ld bytes , entry-d_name, st.st_size); closedir(dp); // 好的编程习惯是返回到原来的目录，但这非必需 // chdir(..); return 0; 3. 目录的创建与删除: mkdir / rmdir 核心知识点: int mkdir(const char *pathname, mode_t mode);: 创建一个新目录。mode参数指定目录的权限，但会受到umask的影响。 int rmdir(const char *pathname);: 删除一个空目录。如果目录非空，rmdir会失败。 代码示例: #include sys/stat.h#include sys/types.h#include stdio.h#include unistd.hint main() const char *dir_name = my_new_dir; // 创建目录，权限为 rwxr-xr-x if (mkdir(dir_name, 0755) == -1) perror(mkdir failed); return 1; printf(目录 %s 创建成功 , dir_name); // ... 可以在这里做一些操作 ... // 删除目录 if (rmdir(dir_name) == -1) perror(删除失败); return 1; printf(文件夹 %s 删除成功 , dir_name); return 0;","tags":[null],"categories":[null]},{"title":"Linux基础与实战笔记","path":"/data/ES/基础/Linux基础与实战笔记.html","content":"第一部分：配置环境与文件共享 1. 虚拟机与主机网络配置 VMware 网络模式 桥接模式: 虚拟机获取独立的、与宿主机处于同一局域网的 IP 地址，像一台真实的物理机。配置时需在“虚拟网络编辑器”中正确选择桥接的物理网卡（如：无线 WiFi 或有线以太网）。 NAT 模式: 虚拟机通过宿主机共享其 IP 地址访问外部网络。VMware 会创建一个虚拟 NAT 网络（如 VMnet8），为宿主机和虚拟机分配此子网内的 IP，使它们可以互相通信。 仅主机模式: 虚拟机只能与宿主机通信，无法访问外部网络，适用于构建隔离的测试环境。 Ubuntu 网络接口配置 查看接口: 使用 ifconfig 或 ip addr 查看当前网络接口的名称（如ens33, eth0）和状态。 启停接口: sudo ifconfig ens33 up # 启用ens33网卡sudo ifconfig ens33 down # 停用ens33网卡 配置方法 (新版 Ubuntu Netplan): 新版 Ubuntu (17.10+) 采用 Netplan 统一管理网络，配置文件位于 /etc/netplan/ 目录下，格式为 YAML。 动态 IP (DHCP，通过 dhcp 服务器获取 ip): # /etc/netplan/01-network-manager-all.yamlnetwork: version: 2 renderer: NetworkManager ethernets: ens33: dhcp4: yes 配置静态 IP 的步骤 vmware 桥接模式让 ubuntu 虚拟机跟 windows 宿主机使用相同 IP 网段，让局域网其它电脑可以访问虚拟机。 VMware 虚拟机默认使用 NAT 网络模式，NAT 模式会使虚拟机的 IP 与 Windows 宿主机的 IP 网段不同。例如，Windows 宿主机的 IP 是 192.168.0.106，而使用 NAT 模式下虚拟机 Ubuntu 18.04 或 Ubuntu 20.04 的 IP 可能是 192.168.10.101，这样局域网内的其他电脑无法访问虚拟机。 (Windows 宿主机 IP) (使用 NAT 模式的 Ubuntu 虚拟机 IP) 那么如何让局域网的其他电脑可以访问到虚拟机呢？解决办法是配置虚拟机使用桥接网络，让 Ubuntu 虚拟机的 IP 网段与 Windows 宿主机处于同一 IP 网段，这样局域网内的其他电脑就可以访问虚拟机 Ubuntu 了。 第 1 步 配置 VMware 虚拟网络编辑器，设置 VMnet0 为桥接模式 在“桥接至”选项中，不要选择“自动”，而是选择电脑中实际用于上网的网卡。例如，如果你的电脑通过无线网卡连接 WiFi，则选择无线网卡；如果使用有线网卡上网，则选择对应的有线网卡。 第 2 步 编辑虚拟机设置，配置 Ubuntu 虚拟机为桥接模式 第 3 步 修改 Ubuntu 虚拟机的网络配置 适用于 Ubuntu 18.04 以上的环境 编辑网络配置文件 使用以下命令编辑 /etc/netplan/01-network-manager-all.yaml 文件： sudo vim /etc/netplan/01-network-manager-all.yaml 修改配置文件内容 将文件内容修改为以下格式： network: version: 2 renderer: NetworkManager ethernets: ens33: # 网卡名，以Ubuntu操作系统的实际网卡名称为准 dhcp4: no # IPv4关闭DHCP，使用静态模式 dhcp6: no # IPv6关闭DHCP addresses: - 192.168.11.123/24 # 本机IP地址（需与宿主机同一网段，且未被占用） gateway4: 192.168.11.254 # 路由器IP，即宿主机的默认网关 nameservers: # DNS服务器 addresses: [114.114.114.114, 8.8.8.8, 1.1.1.1] 注意事项： 此配置文件为层级结构，分为 5 级，上级与下级文本需右缩进，至少一个空格，不允许使用 Tab 键。 缩进的空格数不固定，但相同层级的元素需左对齐。 大小写敏感，冒号与后面的值之间需有一个空格，否则会报错。 应用网络配置 执行以下命令编译并应用网络配置： sudo netplan apply 验证网络连接 重启网络服务后，使用 ping 命令验证网络是否通畅： ping www.baidu.com [!WARNING] 如果老是配置不上还导致没网了，可以看下面的方法（一招解决虚拟机无法连接网络的问题），然后再看这里的配置方法 配置方法 (旧版 Ubuntu): https://segmentfault.com/q/1010000004380398 网络诊断 ping: 测试到目标主机的网络连通性。 ping www.baidu.com # Ctrl+C 停止 host: 查询域名的 IP 地址，用于诊断 DNS 解析问题。 host www.baidu.com route: 查看和手动配置网关。 route -n # 查看路由表sudo route add default gw 192.168.1.1 # 临时添加默认网关 一招解决虚拟机无法连接网络的问题 教程来自：CSDN 第一步：先关闭虚拟机的 ubuntu 系统，然后虚拟机—设置----网络适配器，选择 NAT 模式。 第二步：编辑—虚拟网络编辑器-----选择更改设置，允许配置。 第三步：还原默认设置 打开虚拟机，大功告成！！ 2. 跨平台文件共享 Samba (Linux 与 Windows 文件共享) 概念: 使 Linux 系统能作为 Windows 网络中的文件/打印服务器，实现无缝文件共享。 安装: sudo apt install samba 配置: 编辑 sudo vi /etc/samba/smb.conf，在文件末尾添加共享节： [share]comment = Ubuntu Share Folderpath = /home/user/share_dir # 指定要共享的Ubuntu目录路径browseable = yeswritable = yespublic = yes # 或者 guest ok = yes，允许匿名访问 创建共享目录并赋予相应权限： mkdir ~/share_dirsudo chmod 777 ~/share_dir 重启服务: sudo service smbd restart 访问: 在 Windows 文件资源管理器的地址栏输入 \\\\ubuntu_ip_address\\ 即可访问。 FTP (vsftpd 服务器) 概念: File Transfer Protocol，一种标准的文件传输协议。vsftpd是 Linux 上一款非常安全和高效的 FTP 服务器软件。 安装: sudo apt install vsftpd 配置: 编辑 sudo vi /etc/vsftpd.conf，确保写入权限已开启： # 取消此行的注释write_enable=YES 重启服务: sudo service vsftpd restart 访问: 使用任何 FTP 客户端（如 FileZilla, FlashFXP）连接，主机为 Ubuntu 的 IP，用户名为 Ubuntu 的系统用户及其密码。 NFS 共享（linux 与开发版文件共享） NFS（Network File System）是一种分布式文件系统协议，它允许 Linux 主机（作为服务器）将目录通过网络共享给其他计算机（如嵌入式开发板，作为客户端）。客户端可以挂载（mount）这个共享目录，像访问本地文件夹一样无缝地进行读写操作，非常适合在 PC 上修改代码、在开发板上直接编译和运行的开发流程。 第一步：在 Ubuntu（服务器端）安装和配置 NFS 安装 NFS 服务软件包(一般自带) 在你的 Ubuntu PC 上更新软件包列表并安装nfs-kernel-server。 sudo apt updatesudo apt install -y nfs-kernel-server 创建用于共享的目录 创建一个专门用于 NFS 共享的目录。例如，在用户主目录下创建一个名为nfs_share的文件夹。 mkdir ~/nfs_share 为了让开发板能自由读写，需要赋予该目录最高权限。 sudo chmod 777 ~/nfs_share 配置共享 编辑 NFS 的配置文件/etc/exports来指定要共享哪个目录以及共享给谁。 sudo vi /etc/exports 在文件末尾添加一行，格式为：共享目录 允许访问的客户端IP(权限选项)。 # 将 /home/你的用户名/nfs_share 目录共享给所有IP地址/home/Skyforever/nfs_share *(rw,sync,no_all_squash,no_root_squash,no_subtree_check) 参数解释： /home/Skyforever/nfs_share: 你在第 2 步创建的共享目录的绝对路径（请将Skyforever替换为你的实际用户名）。 *: 允许任何 IP 地址的客户端连接。为安全起见，你也可以指定一个网段，如 192.168.1.0/24。 rw: 允许客户端进行读写操作。 sync: 数据同步写入内存和硬盘，保证数据一致性。 no_root_squash: 核心选项，允许从客户端以 root 用户身份挂载时，在共享目录中也拥有 root 权限（如创建设备文件）。 no_subtree_check: 禁用子树检查，可以提高性能。 启动并使配置生效 更新 NFS 的共享目录列表，然后启动（或重启）NFS 服务。 sudo exportfs -a # 使/etc/exports中的配置生效sudo systemctl start nfs-kernel-server # 启动NFS服务sudo systemctl enable nfs-kernel-server # 设置开机自启 第二步：在开发板（客户端）挂载 NFS 共享目录 创建挂载点 在开发板上创建一个空目录，作为挂载 NFS 共享目录的接入点。通常在/mnt下创建。 sudo mkdir -p /mnt/nfs_share 执行挂载 使用mount命令将 Ubuntu 上的共享目录挂载到开发板的挂载点上。 # 格式: mount -t nfs Ubuntu的IP地址:共享目录路径 开发板的挂载点sudo mount -t nfs 192.168.11.??:/home/Skyforever/nfs_share /mnt/nfs_share 将192.168.1.10替换为你 Ubuntu 的实际 IP 地址。 将/home/Skyforever/nfs_share替换为你/etc/exports中配置的共享路径。 验证挂载 使用df -h命令查看磁盘空间，如果能看到 NFS 挂载信息，则说明挂载成功。 df -h 输出应类似： 现在，你在 Ubuntu 的~/nfs_share目录中创建或修改任何文件，都会立刻出现在开发板的/mnt/nfs_share目录中 你可以把要开发的程序直接放在共享文件夹中，这样编译完马上就可以运行,不用再用 tftp 服务麻烦的上传下载。 第三步：配置开机自动挂载（可选但推荐） 为了避免每次开发板重启后都需手动挂载，可以将其配置为开机自动挂载。 编辑 fstab 文件 在开发板上编辑/etc/fstab文件。 sudo vi /etc/fstab 添加挂载条目 在文件末尾添加以下内容： Ubuntu的IP地址:共享目录路径 开发板的挂载点 nfs defaults 0 0 例如： 192.168.1.10:/home/Skyforever/nfs_share /mnt/nfs_share nfs defaults 0 0 保存退出后，下次开发板启动时就会自动尝试挂载该 NFS 目录。 SCP (安全远程复制) 概念: secure copy，基于 SSH 协议，提供加密的文件传输，是命令行下最常用的远程复制工具。 用法: # 从本地复制到远程scp /path/to/local_file user@remote_host:/remote/path/# 从远程复制到本地scp user@remote_host:/remote/path/remote_file .# 递归复制整个目录scp -r local_dir/ user@remote_host:/remote/path/ 3. 嵌入式开发连接 串口调试 概念: 嵌入式开发最基础的调试和监控手段，用于查看系统启动信息、内核日志，并进行命令行交互。 硬件: 串口线、USB 转串口转换器（如使用 CH340, PL2303 芯片，需在 Windows 上安装相应驱动）。 软件: 串口终端软件 (如 SecureCRT, MobaXterm, PuTTY)。 关键配置参数: 端口号 (Port): 在 PC 的设备管理器中确认 (如COM3)。 波特率 (Baud rate): 必须与开发板设置完全一致 (如115200, 1500000)。 数据位 (Data bits): 通常为 8。 停止位 (Stop bits): 通常为 1。 校验 (Parity): 通常为 None。 流控 (Flow control): 通常为 None (或关闭)。 TFTP (轻量级文件传输) 概念: Trivial File Transfer Protocol，一种简单的、无认证的文件传输协议，广泛用于在 PC 和嵌入式开发板之间传输内核镜像、文件系统等。 工作流程: PC 端 (服务器): 运行 TFTP 服务器软件（如tftpd32/tftpd64），设置好共享的文件目录和服务器监听的网卡 IP。 开发板端 (客户端): 使用tftp命令进行下载或上传。 # 从PC下载文件 (get/receive)# 格式: tftp [server_ip] -gr [filename][root@board:~]# tftp 192.168.1.10 -gr my_app# 上传文件到PC (put/send)# 格式: tftp [server_ip] -pr [filename][root@board:~]# tftp 192.168.1.10 -pr log_data.txt 交叉编译工具链 概念: 在一种 CPU 架构（如 PC 的 x86）上，编译生成能在另一种不同 CPU 架构（如开发板的 ARM）上运行的程序的工具集（编译器、链接器等）。 配置步骤: 将工具链压缩包解压到合适位置 (如 /opt/toolchains/)。 将工具链的可执行文件目录 (bin目录) 添加到系统的PATH环境变量中，以便全局调用。 # 编辑 ~/.bashrc 文件，在末尾添加export PATH=/opt/toolchains/arm-gcc-10.3/bin:$PATH 使配置立即生效： source ~/.bashrc 验证配置是否成功： arm-linux-gnueabihf-gcc -v# 如果能正确显示编译器版本信息，则表示配置成功。 第二部分：Linux 命令行基础 4. 系统导航与交互 ls 释义: list，列出目录内容。 常见用法: ls # 列出当前目录的文件名ls -l # 列出文件详情 (long format)，包含权限、所有者、大小、修改时间等ls -a # 列出所有文件，包括以.开头的隐藏文件 (all)ls -h # 配合-l使用，以人类可读的格式显示文件大小 (human-readable, e.g., KB, MB)ls -la # 组合使用，列出所有文件的详情ls /etc # 列出指定目录 /etc 的内容 cd 释义: change directory，切换当前工作目录。 常见用法: cd /etc # 切换到 /etc 目录cd # 切换到当前用户的家目录 (等同于 cd ~)cd - # 切换到上一次所在的目录cd .. # 切换到上一级目录 pwd 释义: print working directory，显示当前所在的完整路径。 clear 释义: 清理终端屏幕 (快捷键: Ctrl + L)。 echo 释义: 在终端回显文本或变量值。 常见用法: echo Hello, World # 输出字符串 Hello, Worldecho $PATH # 输出环境变量PATH的值 alias 释义: 为命令创建别名。 常见用法: alias ll=ls -lh 注意: 等号两边不能有空格。此设置为临时生效，永久生效需将此行写入 ~/.bashrc 或 ~/.zshrc。 5. 获取帮助与信息 man 释义: manual，查阅命令或系统函数的帮助手册。 常见用法: man ls # 查阅 ls 命令的帮助手册 (按 q 退出)man -f read # 列出所有与 read 相关的帮助手册章节man 2 read # 查阅第2册(系统调用)中关于 read 的手册 注意: man 手册共 9 册，Ubuntu 默认可能未完全安装。可执行 sudo apt install manpages-dev manpages-posix-dev 安装更完整的手册。 which 释义: 查找并显示命令的可执行文件所在路径。 常见用法: which ls # 输出: /usr/bin/lswhich -a qmake # 列出 $PATH 中所有匹配的qmake命令路径 date 释义: 查看或设置系统日期与时间。 file 释义: 检测并显示文件类型。 6. Shell 核心：管道与文本处理 管道 | 概念: 将前一个命令的标准输出连接到后一个命令的标准输入，形成数据流处理链。 示例: # 统计当前目录下的文件和目录总数ls -1 | wc -l I/O 重定向 概念: Shell 允许你改变命令的默认输入、输出和错误流。 : 标准输出重定向。将命令的输出写入文件，会覆盖文件原有内容。 : 标准输出追加重定向。将命令的输出追加到文件末尾。 2: 标准错误重定向。将命令的错误信息写入文件。 或 21: 重定向标准输出和标准错误。将所有输出（包括错误）都重定向到同一个地方。 示例: # 将 ls -l 的结果写入 files.txt (覆盖)ls -l files.txt# 将 echo 的内容追加到 log.txtecho Process finished at $(date) log.txt# 运行一个可能出错的命令，并将错误信息存入 error.logfind /root -name secret 2 error.log# 将命令的所有输出（正确和错误）都写入 output.log./my_script.sh output.log sort 释义: 对输入行进行排序。 常见用法: sort file.txt # 按字典序升序sort -r file.txt # -r: 降序 (reverse)sort -n file.txt # -n: 按数值 (numeric) 升序 uniq 释义: unique，从输入中删除相邻的重复行。 常见用法: 注意: uniq 只能处理相邻的重复行，因此通常与 sort 配合使用来实现全局去重。 sort file.txt | uniq wc 释义: word count，统计行数、单词数和字符数。 常见用法: wc file.txt # 输出: 行数 单词数 字符数 文件名wc -l file.txt # -l: 只统计行数 (lines) xargs 概念: 从标准输入读取数据，并将其作为参数传递给后续命令。 示例: # 查找所有.tmp文件，并使用rm命令删除它们find . -name *.tmp | xargs rm 第三部分：文件系统管理 7.0 文件类型 在linux中，一共有七种文件类型 联想记忆： 我桌面的普通文件(-)太多，就建了个目录(d)，又怕找不到，就创建了个链接(l)。电脑连着块(b)设备硬盘和字符©设备键盘。上网靠套接字(s)，数据传输用管道(p) 7.1 文件与目录操作 创建 touch: 创建空文件或更新文件时间戳。 mkdir: 创建目录。 mkdir -p project/src/include # -p: 递归创建嵌套目录 复制与移动 cp: 复制文件或目录。 cp source.txt destination.txt # 复制文件cp -r source_dir/ dest_dir/ # -r: 递归复制目录 mv: 移动文件/目录，或用于重命名。 删除 rm: 删除文件或目录。此操作不可逆，请谨慎！ rm file.txtrm -r dir_to_delete/ # -r: 递归删除目录及其内容rm -rf important_dir/ # -f: 强制删除，不提示，极度危险！ rmdir: 删除空目录。 创建链接 ln: 创建文件链接，分为硬链接和软链接（符号链接）。 软链接 (Symbolic Link): ln -s target link_name。像一个快捷方式，存储的是目标的路径。如果目标被删除，链接会失效。 硬链接 (Hard Link): ln target link_name。是文件数据的另一个入口，与原文件共享 inode。删除原文件不影响硬链接。不能跨文件系统，不能对目录创建。 常见用法: # 为 /etc/nginx/sites-available/mysite 创建一个软链接到 sites-enabled 目录sudo ln -s /etc/nginx/sites-available/mysite /etc/nginx/sites-enabled/mysite# 为 file.txt 创建一个硬链接 hardlink.txtln file.txt hardlink.txt 比较 diff: 比较两个文件或目录的差异。 diff file1.txt file2.txt # 比较文件diff -urN dir1/ dir2/ # 比较目录的常用选项组合 8. 文件内容查看与搜索 内容查看 cat: 一次性显示文件全部内容。 less / more: 分页查看长文件，less功能更强。 head / tail: 查看文件头部/尾部内容。 tail -f /var/log/syslog # -f: 实时跟踪文件更新 (follow)，常用于查看日志 od: 以不同进制格式查看二进制文件。 内容搜索 find: 在文件系统中按条件搜索文件。 find /usr/include -name stdio.h # 按名称查找find . -type f -mtime -7 # 查找当前目录及子目录下，7天内修改过的普通文件 grep: 在文件内容中搜索匹配指定模式的行。 grep error app.log # 在app.log中查找包含error的行grep -rn my_function ./src/ # 在src目录中递归(-r)搜索my_function并显示行号(-n) 9. 归档与压缩 tar 释义: Linux 下最核心的归档工具，常与压缩算法结合。 核心参数: c: 创建 (create) | x: 提取 (extract) | t: 查看 (list) v: 显示过程 (verbose) | f: 指定文件名 (file) z: 使用 gzip (.gz) | j: 使用 bzip2 (.bz2) | J: 使用 xz (.xz) 常见用法: # 压缩tar -czvf archive.tar.gz ./my_directory # 打包并用gzip压缩# 查看tar -tf archive.tar.gz # 查看压缩包内容，不解压# 解压tar -xzvf archive.tar.gz # 解压.tar.gztar -xzvf archive.tar.gz -C /tmp # -C: 解压到指定目录 zip / unzip 释义: 跨平台兼容性好的压缩格式。 常见用法: zip -r archive.zip ./my_directory # -r: 递归压缩目录unzip archive.zip 第四部分：系统管理 10. 用户与权限 用户和组管理 whoami / id: 查看当前用户信息。 adduser / deluser: 添加/删除用户（交互式）。 addgroup / delgroup: 添加/删除用户组。 usermod: 修改用户属性。 sudo adduser jack # 添加新用户jacksudo usermod -aG sudo jack # 将用户jack追加(-a)到sudo组(-G)中sudo deluser --remove-home jack # 删除用户并移除其家目录 信息存储: 用户信息在/etc/passwd，密码哈希在/etc/shadow，组信息在/etc/group。 提权命令 sudo: superuser do。允许普通用户以管理员（root）或其他用户的身份执行特定命令，需要在/etc/sudoers文件中配置权限。这是推荐的提权方式。 su: switch user。切换用户身份。 su - username: 完全切换到指定用户，包括环境变量和工作目录。 su -: 切换到 root 用户。 权限管理 chmod: 修改文件/目录权限。 chown: 修改文件/目录所有者。 chgrp: 修改文件/目录所属组。 权限解读 (ls -l): drwxr-xr-- d: 类型（d:目录, -:文件, l:链接） rwx: 所有者权限 (读、写、执行) r-x: 所属组权限 (读、执行) r--: 其他人权限 (读) 数字模式 (chmod): r=4, w=2, x=1。 chmod 755 my_script.sh # rwx r-x r-xchmod 644 config.conf # rw- r-- r--sudo chown jack:developers file.txt # 修改所有者为jack，所属组为developers 11. 软件包管理 (Ubuntu) apt 释义: Advanced Package Tool，高级包管理工具，自动处理依赖。 常见用法: sudo apt update # 更新可用软件包列表sudo apt upgrade # 升级所有已安装的包sudo apt install vim # 安装vimsudo apt remove vim # 卸载vimsudo apt autoremove # 移除不再需要的依赖包apt search htop # 搜索htop包 dpkg 释义: Debian Package，底层包管理工具，用于手动安装.deb文件。 常见用法: sudo dpkg -i package_name.deb # -i: 安装 (install) 注意: dpkg不处理依赖。如果安装后提示依赖问题，可执行 sudo apt -f install 来尝试自动修复。 12. 进程与服务管理 进程查看 ps 释义: process state，获取进程在某个时间点的快照信息。 常见用法: # 显示当前Linux系统中所有运行的进程ps -e# 以BSD风格显示所有进程的详细信息ps aux# 以System V风格显示所有进程的详细信息，并以完整格式显示ps -ef# 常用组合：配合grep查找特定进程ps aux | grep nginx pstree 查看进程树 每一个进程都有其父母进程，但是只有系统进程没有父母进程 top 释义: 动态、实时地显示系统中各个进程的资源占用状况，类似于 Windows 的任务管理器。 常见用法: # 启动top，默认按CPU使用率排序top# 监视指定PID的进程top -p PID 进入界面： 按下shift+L可以查找进程号和进程： 交互操作: P: 按 CPU 使用率排序 (默认)。 M: 按内存使用率排序。 T: 按累计运行时间排序。 k: 输入 PID 后回车，向进程发送信号 (kill)。 q: 退出。 进程控制 kill 释义: 向指定的进程发送一个信号，以实现进程间通信或控制。 常见用法: # 查看系统支持的所有信号列表kill -l# 默认发送SIGTERM (15)，请求进程正常终止kill PID# 发送SIGKILL (9)，强制立即终止进程（最后的手段）kill -9 PID# 或者使用信号名kill -s SIGKILL PID killall 杀死所有和此进程相关的进程，或更改进程状态 # 暂停进程killall -STOP 进程名# 继续进程killall -CONT 进程名 服务管理 (systemctl) 释义: 在使用 Systemd 作为初始化系统的现代 Linux 发行版（如 Ubuntu 16.04+, CentOS 7+）中，systemctl是管理服务（守护进程）的核心工具。 常见用法: # 启动/停止/重启服务sudo systemctl start nginx.servicesudo systemctl stop nginx.servicesudo systemctl restart nginx.service# 查看服务状态sudo systemctl status nginx.service# 设置服务开机自启/禁止开机自启sudo systemctl enable nginx.servicesudo systemctl disable nginx.service# 查看所有已启动的服务systemctl list-units --type=service 13. 磁盘与分区管理 查看磁盘使用情况 df 释义: disk free，查看已挂载文件系统的磁盘空间使用情况。 常见用法: # 以人类可读的格式 (KB, MB, GB) 显示所有已挂载分区的空间信息df -h 文件系统 大小 已用 可用 使用% 挂载点/dev/vda1 50G 6.8G 40G 15% /tmpfs 937M 48K 936M 1% /dev/shm... du 释义: disk usage，估算文件或目录占用的磁盘空间大小。 常见用法: # 查看当前目录下每个子目录和文件的空间占用du# 以人类可读格式，显示当前目录的总大小 (-s: summary)du -sh# 查看指定目录的总大小du -sh /var/log 分区操作 fdisk 释义: 一个功能强大的、用于磁盘分区的命令行工具。 常见用法: # 列出系统中所有可识别的磁盘及其分区表信息（即使未挂载）sudo fdisk -l 提醒: df只能查看已挂载的分区，而fdisk -l可以查看所有已识别的分区，包括未挂载的。这在挂载新硬盘或 U 盘时非常有用，可以先用fdisk -l找到设备名（如/dev/sdb1）。 mount / umount 释义: 挂载/卸载文件系统。在 Linux 中，外部设备（如 U 盘、硬盘分区）必须被“挂载”到一个已存在的目录上，才能被访问。 常见用法: # 挂载分区: 将/dev/sdb1分区挂载到/mnt/usb目录# 首先确保挂载点目录存在sudo mkdir -p /mnt/usbsudo mount /dev/sdb1 /mnt/usb# 卸载分区 (两种等价方式)sudo umount /dev/sdb1 # 按设备名卸载sudo umount /mnt/usb # 按挂载点卸载 注意: 卸载前，请确保没有任何进程正在使用该挂载点下的文件，否则会提示device is busy。 案例实战：磁盘分区与持久化挂载 目标: 在 Skyforever6818 开发板上，将一个闲置的大分区格式化，并挂载到/root目录，以扩展根目录的使用空间。 计划操作: mkfs.ext2 /dev/mmcblk0p7: 将分区格式化为 ext2 文件系统。 mount /dev/mmcblk0p7 /root: 将格式化后的分区挂载到/root目录。 信息侦察与可行性分析 在执行任何破坏性操作（如格式化）之前，必须进行充分的信息收集和分析。 1. 查看已挂载分区 (df -h) [root@Skyforever6818 /]# df -hFilesystem Size Used Available Use% Mounted on/dev/root 492.1M 395.5M 96.7M 80% /... 分析: 根分区 /dev/root 总大小约 492MB，已使用 80%，空间紧张。确实有扩展空间的必要。 2. 查看所有可识别的分区 (fdisk -l) [root@Skyforever6818 /]# fdisk -lDisk /dev/mmcblk0: 7818 MB, 7818182656 bytes... Device Boot Start End Blocks Id System/dev/mmcblk0p1 1 9 65536 83 Linux.../dev/mmcblk0p7 164 951 6324224 83 Linux 分析: 系统中存在一个名为 /dev/mmcblk0p7 的分区。 其大小为 6324224 Blocks (约 6.3GB)，是一个相当大的分区。 在 df -h 的输出中并未看到此分区，证明它当前未被挂载。 结论: /dev/mmcblk0p7 是一个存在的、未挂载的大分区，硬件上可用于我们的目标。 风险评估与操作建议 可以执行吗？ 可以，但必须极其谨慎。 风险点: 数据丢失: mkfs (格式化) 是一个不可逆的操作，会清除 /dev/mmcblk0p7 分区上的所有数据。必须 100%确认该分区上没有重要数据。 挂载点覆盖: 将一个分区挂载到非空目录（如/root）上，会导致该目录原有的内容被临时隐藏。在挂载期间，访问/root将直接访问新分区的内容，原有的文件将不可见，直到分区被卸载。 文件系统选择: ext2: 无日志功能，写入性能稍高，适合资源有限的嵌入式设备。但断电时数据丢失或文件系统损坏的风险更高。 ext3/ext4: 有日志功能，能更好地保证数据一致性，更耐受意外断电。推荐在支持的设备上使用 ext4。 最佳实践建议: 使用新的空目录作为挂载点: 这是最安全、最推荐的做法，可以避免覆盖系统重要目录。 # 创建一个新的、专门的挂载点mkdir /mnt/data 执行格式化: # 格式化为ext2 (按原计划)mkfs.ext2 /dev/mmcblk0p7# (推荐) 格式化为更可靠的ext4mkfs.ext4 /dev/mmcblk0p7 执行挂载: # 挂载到推荐的新挂载点mount /dev/mmcblk0p7 /mnt/data# (按原计划，但有风险) 挂载到/rootmount /dev/mmcblk0p7 /root 验证: 挂载后，使用df -h确认分区是否已成功挂载。 df -h# 此时应能看到 /dev/mmcblk0p7 挂载到了 /mnt/data (或 /root) 持久化挂载配置 (/etc/fstab) mount命令执行的挂载是临时的，系统重启后会失效。要实现开机自动挂载，必须将挂载信息写入 /etc/fstab (file systems table) 文件。 1. 编辑 fstab 文件: vi /etc/fstab 2. 添加挂载条目: 在文件末尾添加新的一行，格式如下： device mount_point filesystem_type options dump pass # 示例: 将/dev/mmcblk0p7以ext2格式挂载到/root/dev/mmcblk0p7 /root ext2 defaults 0 2 字段解释: /dev/mmcblk0p7: 要挂载的设备。 /root: 挂载点目录。 ext2: 文件系统类型（必须与格式化时所用的一致）。 defaults: 使用默认的挂载选项 (通常是 rw,suid,dev,exec,auto,nouser,async)。 0: dump工具的标志位，0表示不备份。 2: fsck文件系统检查的顺序。根分区为1，其他分区为2，0表示不检查。 3. 测试配置 (非常重要): 在重启之前，执行 mount -a 命令。此命令会读取/etc/fstab并尝试挂载所有未挂载的条目。 mount -a 如果此命令没有任何报错，说明fstab文件语法正确。 如果报错，必须根据错误信息修正fstab文件，否则系统可能无法正常启动！ 4. 验证与重启: df -h 再次确认挂载成功。 reboot 重启系统，检查开机后分区是否被自动挂载。 核心忠告: 操作/etc/fstab文件前，请确保你理解每个字段的含义。一个错误的配置可能导致系统启动失败，需要进入救援模式才能修复。 第五部分：网络管理 14. 网络配置与信息查看 hostname 释义: 查看或临时设置系统的主机名。 常见用法: # 查看当前主机名hostname# 临时设置主机名（重启后失效）sudo hostname new-name ifconfig (传统工具) 释义: interface configuration，用于查看和配置网络接口（在较新的系统中，推荐使用ip命令）。 常见用法: # 查看当前所有已激活的网络接口信息ifconfig# 查看所有网络接口，包括未激活的ifconfig -a# 临时设置IP地址 (重启后失效)sudo ifconfig ens33 192.168.1.100 netmask 255.255.255.0 ip (现代网络配置工具) 释义: ip命令是iproute2工具包的一部分，旨在取代ifconfig, route, arp等传统网络工具。功能更强大，信息更全面。 常见子命令: ip addr (或 ip a): 管理 IP 地址和网络接口。 ip a # 查看所有接口的IP地址信息 (等价于 ifconfig)sudo ip addr add 192.168.1.101/24 dev ens33 # 临时添加IPsudo ip addr del 192.168.1.101/24 dev ens33 # 临时删除IP ip link: 管理网络接口本身（物理层/数据链路层）。 ip link show # 查看所有接口状态sudo ip link set ens33 up # 启用接口sudo ip link set ens33 down # 禁用接口 ip route (或 ip r): 管理路由表。 ip r # 查看路由表 (等价于 route -n)sudo ip route add default via 192.168.1.1 # 临时添加默认网关 15. 网络诊断 网络连通性 (ping) 释义: 向目标主机发送 ICMP ECHO_REQUEST 包，测试网络连通性。 常见用法: ping 8.8.8.8 # 测试与IP地址的连通性ping -c 4 baidu.com # 发送4个包后停止 路由追踪 (traceroute) 释义: 显示数据包到达目标主机所经过的路由路径及延迟。 常见用法: traceroute www.google.com DNS 查询 (host, nslookup, dig) 释义: 用于查询域名系统（DNS）记录。 常见用法: host baidu.com # 简单查询A记录nslookup baidu.com # 交互式或非交互式查询dig baidu.com # 提供最详细的DNS查询信息 查看网络连接 (netstat, ss) 释义: 查看网络连接、路由表、接口统计等信息。ss是netstat的现代替代品，速度更快。 常见用法: # 列出所有监听的TCP/UDP端口，并显示程序名 (-p)sudo netstat -tulnp# 使用ss达到同样效果，推荐使用sudo ss -tulnp 16. 防火墙管理 (UFW) 释义: Uncomplicated Firewall，Ubuntu 默认的防火墙管理工具，旨在简化iptables的配置。 常见用法: # 查看防火墙状态sudo ufw status verbose# 启用/禁用防火墙sudo ufw enablesudo ufw disable# 设置默认规则 (推荐：默认拒绝所有入站连接，允许所有出站)sudo ufw default deny incomingsudo ufw default allow outgoing# 允许/拒绝特定端口或服务sudo ufw allow 22/tcp # 允许SSH (端口22, TCP协议)sudo ufw allow 80 # 允许HTTP (端口80)sudo ufw allow Nginx Full # 按应用配置文件允许sudo ufw deny 3306 # 拒绝MySQL (端口3306)# 删除规则sudo ufw delete allow 22/tcp# 按编号删除规则sudo ufw status numbered # 先查看规则编号sudo ufw delete 1 # 删除编号为1的规则","tags":[null],"categories":[null]},{"title":"数据结构与算法笔记","path":"/data/ES/基础/数据结构与算法笔记.html","content":"一：基础入门与算法分析 1. 核心概念 数据结构: 一门研究如何有效组织数据，以提高数据处理效率的学科。它关注数据间的逻辑关系（逻辑结构）和在计算机中的存储方式（存储形式）。 逻辑结构: 指数据元素之间的内在关系，与存储方式无关。常见有： 线性结构: 元素间为一对一关系 (如：线性表、栈、队列)。 非线性结构: 元素间为一对多或多对多关系 (如：树、图)。 存储形式 (物理结构): 指数据在内存中的存储方式。主要有： 顺序存储: 将逻辑上相邻的元素存储在物理位置也相邻的存储单元中（如：数组）。 链式存储: 物理位置不一定相邻，通过指针来表示元素间的逻辑关系（如：链表）。 [info] 核心思想 逻辑结构是“战略”，决定了数据应该如何组织；存储结构是“战术”，决定了数据具体如何存放。一种逻辑结构可以有多种存储实现。 2. 算法性能分析 算法分析旨在评估算法的优劣，主要考量两个维度：时间复杂度和空间复杂度。目标是让程序运行得更快，占用内存更少。 时间复杂度 概念: 衡量算法执行时间随数据规模增长而变化的趋势，通常不考察绝对时间，而是估算基本操作的执行次数（语句频度）。 表示法: 使用大 O 表示法 O()，只关注最高次幂项，忽略常数和低次幂项。 （为什么只关注最大的？看这个视频：） 示例: void func(int n) // 执行 n 次 for (int i = 0; i n; i++) // 执行 n*n 次 for (int j = 0; j n; j++) printf(Hello ); 上述代码总执行次数为 n * n = n^2。因此，时间复杂度为 O(n²)。 不同时间复杂度的增长趋势对比 空间复杂度 概念: 衡量算法在运行过程中临时占用存储空间大小的量度，同样采用大 O 表示法。 时空互换 概念: 在某些场景下，可以通过增加空间消耗来换取更短的执行时间（空间换时间），或者通过增加计算时间来减少内存占用（时间换空间）。 案例实战：快速计算二进制中 1 的位数 问题: 给定一个 int，要求“尽快”求出其二进制表示中 1 的个数。 常规解法 (时间换空间): 循环移位或与操作，逐位判断。 int count_ones(unsigned int n) int count = 0; while (n 0) n = (n - 1); // 每次操作消除最右边的1 count++; return count; 高效解法 (空间换时间): 预计算。创建一个 256 大小的数组，存储 0-255 每个数包含的 1 的个数。对于 32 位整数，分 4 个字节查表相加即可。 // 全局预计算表int bits_in_char[256];void precompute() for (int i = 0; i 256; i++) bits_in_char[i] = (i 1) + bits_in_char[i / 2]; int count_ones_fast(unsigned int n) return bits_in_char[n 0xff] + bits_in_char[(n 8) 0xff] + bits_in_char[(n 16) 0xff] + bits_in_char[(n 24) 0xff]; 这是一种典型的用内存空间（bits_in_char数组）换取固定时间（4 次查表+3 次加法）的策略。 二：线性表 线性表是数据结构世界的基础构件，其两种主要实现——顺序表和链表，在性能上各有取舍，适用于完全不同的场景。 3. 顺序表 定义: 使用一段连续的物理内存来存储逻辑上相邻的数据元素。在 C 语言中，其最直接的体现就是数组。 优点: 随机访问 O(1): 可通过下标直接访问任何元素，速度极快。 存储密度高: 无需额外空间存储元素间的关系。 缺点: 插入/删除 O(n): 在中间或头部操作，需要移动大量元素。 空间不灵活: 容量固定，扩容成本高或实现复杂。 适用场景: 数据量相对稳定，读操作远多于写操作的场景，如配置表、静态数据集等。 4. 链表 问题引入：为什么普通链表不够用？ 我们先看一个普通的学生信息单链表节点： struct student char name[20]; int id; struct student *next; // 指针域耦合了数据类型; 这个设计存在一个致命缺陷：缺乏通用性。next指针的类型是struct student *，这意味着为student链表编写的所有操作函数（如insert_student, remove_student），都无法用于管理teacher或其他任何类型的链表。在像 Linux 内核这样拥有成千上万种数据结构的复杂项目中，为每种结构都重写一套链表代码是不可接受的。 设计哲学：Linux 内核的解决方案——数据与逻辑分离 Linux 内核-内核链表 Linux 内核用一种极其巧妙的方式解决了这个问题：将**“链”的逻辑从“数据”本身**中抽离。 定义一个“纯粹”的链表节点: 创建一个不包含任何业务数据，只负责链接的通用节点结构struct list_head。 // From linux/list.hstruct list_head struct list_head *next, *prev;; 这是一个标准的双向循环链表节点。 “寄生”于用户数据结构: 将这个list_head结构作为一个成员，嵌入到任何需要被链式管理的用户数据结构中。 struct student // --- 用户数据域 --- char name[20]; int id; // --- 链表逻辑域 --- struct list_head list; // 寄生的内核链表节点; 将标准链表节点嵌入用户数据结构 难点攻克：如何从“链”找到“数据”？ 所有链表 API 操作的都是list_head指针，但我们最终需要的是包含业务数据的student结构体。如何从list成员的地址反向推算出其“宿主”student结构体的起始地址？ 这就是内核链表最核心的宏 list_entry 的作用。 原理: 宿主结构体地址 = 成员地址 - 成员在宿主结构体中的偏移量 通过成员地址和偏移量计算宿主地址 C 语言实现: # define list_entry(ptr, type, member) \\ ((type *)((char *)(ptr) - (unsigned long)(((type *)0)-member))) ptr: 指向list_head成员的指针。 type: 宿主结构体的类型 (如 struct student)。 member: list_head成员在宿主结构体中的名字 (如 list)。 ((type *)0)-member: 这是一个编译时技巧，计算出member在type结构体中的偏移量。 代码实战：使用内核链表管理学生信息 以下是一个完整的、可编译的示例，演示如何使用内核链表 API。 (为方便使用，已将内核的list.h相关宏和函数提取整理) kernel_list.h (简化版) #ifndef _KERNEL_LIST_H#define _KERNEL_LIST_H// 1. 核心节点定义struct list_head struct list_head *next, *prev;;// 2. 初始化宏#define LIST_HEAD_INIT(name) (name), (name) #define LIST_HEAD(name) struct list_head name = LIST_HEAD_INIT(name)static inline void INIT_LIST_HEAD(struct list_head *list) list-next = list; list-prev = list;// 3. 核心辅助函数 (内部使用)static inline void __list_add(struct list_head *new, struct list_head *prev, struct list_head *next) next-prev = new; new-next = next; new-prev = prev; prev-next = new;// 4. 对外API: 添加节点static inline void list_add(struct list_head *new, struct list_head *head) __list_add(new, head, head-next); // 头插static inline void list_add_tail(struct list_head *new, struct list_head *head) __list_add(new, head-prev, head); // 尾插// 5. 核心宏：获取宿主结构体#define list_entry(ptr, type, member) \\ ((type *)((char *)(ptr) - (unsigned long)(((type *)0)-member)))// 6. 对外API: 遍历#define list_for_each_entry(pos, head, member) \\ for (pos = list_entry((head)-next, typeof(*pos), member); \\ pos-member != (head); \\ pos = list_entry(pos-member.next, typeof(*pos), member))#endif main.c #include stdio.h#include stdlib.h#include string.h#include kernel_list.h// 用户数据结构struct student int id; char name[32]; struct list_head list; // 嵌入内核链表节点;int main() // 1. 创建并初始化链表头 (这是一个独立的头结点) LIST_HEAD(student_list); // 2. 添加学生信息 printf(Adding students... ); struct student *stu1 = malloc(sizeof(struct student)); stu1-id = 101; strcpy(stu1-name, Alice); list_add_tail(stu1-list, student_list); // 尾插 struct student *stu2 = malloc(sizeof(struct student)); stu2-id = 102; strcpy(stu2-name, Bob); list_add_tail(stu2-list, student_list); // 3. 遍历链表并打印信息 printf( --- Student List --- ); struct student *iter; list_for_each_entry(iter, student_list, list) printf(ID: %d, Name: %s , iter-id, iter-name); // 4. 查找并释放Bob的信息 (演示删除) printf( Finding and removing Bob (ID 102)... ); struct student *temp; list_for_each_entry_safe(iter, temp, student_list, list) // 安全遍历，因为要删除 if (iter-id == 102) list_del(iter-list); // 从链表中脱离 free(iter); // 释放内存 printf(Bob removed. ); printf( --- Updated Student List --- ); list_for_each_entry(iter, student_list, list) printf(ID: %d, Name: %s , iter-id, iter-name); // ... 在程序结束时需要遍历并释放所有剩余节点 return 0; 内核链表精髓总结 通用性: 一套 API，管理所有类型的数据。 高效性: 增删操作为 O(1)，无数据拷贝。 健壮性: 经过 Linux 内核数十年验证，稳定可靠。 思想: 完美的“控制反转”，用户只需关注自己的数据，将组织逻辑交给标准库。 代码实战：单链表的反转 掌握了链表的创建和遍历后，一个最经典的面试题和算法练习便是——反转一个单向链表。 例如，将 1 - 2 - 3 - 4 - 5 变为 5 - 4 - 3 - 2 - 1。 1. 核心挑战 在遍历链表时，每个节点只知道自己的“下一个”是谁。当我们想让 节点2 指向 节点1 时，一旦执行 2-next = 1，我们就会立即丢失通往 节点3 的路径。因此，算法设计的关键在于：在修改指针前，如何保存好“未来的路”。 2. 算法本质 - 三个职责的流转 无论代码怎么写，任何正确的迭代反转算法，都必须在循环的每一步中，清晰地管理好三个核心的“状态职责”： Current (当前): 指向当前正要被反转指向的节点。 Reversed (已反转): 指向已经反转好的新链表的头部。 Upcoming (未反转): 指向Current在原始链表中的下一个节点，作为“路标”以防断链。 算法的每一步，就是这三个职责在指针变量之间的一次优雅“交谊舞”。 3. 思想的多种代码表达 表达一：标准三指针迭代法 (教科书式) 这是最常见、最清晰的实现。我们用三个独立的指针变量来分别扮演这三个角色。 p_rev: 扮演 Reversed 角色。 p_cur: 扮演 Current 角色。 p_upc: 扮演 Upcoming 角色。 void reverse_list(linklist head) if (head == NULL || head-next == NULL) return; linklist p_rev = NULL; linklist p_cur = head-next; linklist p_upc = NULL; while (p_cur != NULL) // 1. 保存未来: Upcoming 指针记住 Current 的下一个节点 p_upc = p_cur-next; // 2. 反转当前: Current 指向已反转链表的头部 p_cur-next = p_rev; // 3. 前进迭代: 更新 Reversed 和 Current 的角色 p_rev = p_cur; p_cur = p_upc; // 4. 收尾: 将头结点指向反转后的新头 head-next = p_rev; 深度思考：通过严谨的排列组合，我们可以证明，只要有三个指针变量，无论哪个变量扮演哪个角色（共 3! = 6 种组合），其核心的四步操作逻辑是完全一致的，都能写出正确的算法。 表达二：头插法 (巧妙利用头结点) 这种方法更加精炼，它巧妙地让“头结点”本身参与到算法中，扮演 Reversed 的角色。 p_cur: 扮演 Current。 p_upc: 扮演 Upcoming。 head-next: 扮演 Reversed 的角色，始终指向新链表的头。 void reverse_list_head_insertion(linklist head) if (head == NULL || head-next == NULL) return; linklist p_cur = head-next; linklist p_upc = NULL; // 先将头结点与原链表断开，它将作为新链表的“锚点” head-next = NULL; while (p_cur != NULL) // 1. 保存未来 p_upc = p_cur-next; // 2. 反转当前 (头插法核心) // 让当前节点指向新链表的头 (即 head-next) p_cur-next = head-next; // 更新新链表的头为当前节点 head-next = p_cur; // 3. 前进迭代 p_cur = p_upc; 表达三：递归法 (时空转换的艺术) 递归将迭代的循环逻辑转换为了函数调用栈的递进与回溯，代码极简，但对理解的要求更高。 递进 (Drill Down): 函数不断调用自身，直到链表末尾。这个过程本身就“记住”了返回的路径。 回溯 (Roll Back): 从链表末尾开始，在每一层函数返回时，将当前层的节点指针反转。 // 辅助递归函数linklist reverse_recursive_helper(linklist current) // 基本情况：到达链表尾部，返回新的头节点 if (current == NULL || current-next == NULL) return current; // 递进：假设后面的部分已经反转好，并拿到新头 linklist new_head = reverse_recursive_helper(current-next); // 回溯时的操作：反转指针 current-next-next = current; current-next = NULL; return new_head;void reverse_list_recursive(linklist head) if (head == NULL) return; head-next = reverse_recursive_helper(head-next); 思维体操总结 算法的“道”与“术”: 链表反转的“道”是管理好Current, Reversed, Upcoming三个状态。而迭代法、头插法、递归法则是实现这个“道”的不同“术”。 没有“碰巧”的正确: 即使写出一个非主流但可行的算法，也绝非巧合，而是无意中构建了一套逻辑自洽的状态流转系统。理解其内在逻辑，比死记标准答案更有价值。 代码是思想的投影: 同一个算法思想，可以有多种代码表达。探索这些不同表达方式的优劣和内在联系，是提升编程内功的关键。 代码实战：约瑟夫环 在掌握了链表的增删改查之后，约瑟夫环问题是另一个绝佳的综合性练习，它完美地融合了循环链表的构建与节点的规律性删除。 问题描述：n 个人（编号 1 到 n）围成一个圈。从第 1 个人开始报数，报到 m 的那个人出列，他的下一个人又从 1 开始报数，报到 m 的那个人再次出列……如此循环，直到所有人出列。请找出最后一个出列的人，或者按顺序输出出列人的序列。 为了解决这个问题，单向循环链表是天然的数据结构。 1. 算法分析与实现 约瑟夫环的核心操作只有两步，循环往复： “走”：从当前节点开始，向后移动 m-1 步，找到那个“倒霉蛋”的前一个节点。 “删”：将“倒霉蛋”从环中移除，并释放其内存。 算法持续进行，直到环中只剩下一个节点。 2. C 语言代码实现 下面是一个完整的、可编译的约瑟夫环问题解决方案。程序会要求输入总人数 n 和报数阈值 m，然后模拟整个过程。 linklist.h (头文件) #ifndef __LINKLIST_H#define __LINKLIST_H#include stdio.h#include stdlib.h// 链表节点定义typedef struct node int data; // 节点数据 (人的编号) struct node *next; listnode, *linklist;// 函数声明linklist create_josephus_ring(int n);void show_list(linklist head);void solve_josephus(linklist head, int m);#endif main.c (主程序) #include linklist.hint main(void) int n, m; printf(请输入总人数 n: ); scanf(%d, n); printf(请输入报数阈值 m: ); scanf(%d, m); if (n 1 || m 1) printf(输入无效，人数和报数阈值必须大于0。 ); return 1; // 1. 创建约瑟夫环 printf( 正在创建包含 %d 人的约瑟夫环... , n); linklist ring_head = create_josephus_ring(n); printf(初始环: ); show_list(ring_head); // 2. 开始模拟并解决问题 printf( 开始淘汰过程 (报数为 %d 的人出列): , m); solve_josephus(ring_head, m); return 0; linklist.c (函数实现) #include linklist.h// 创建一个包含 n 个节点的单向循环链表 (约瑟夫环)linklist create_josephus_ring(int n) if (n 1) return NULL; linklist head = NULL, tail = NULL; for (int i = 1; i = n; i++) // 创建新节点 linklist new_node = malloc(sizeof(listnode)); if (new_node == NULL) perror(创建节点失败); exit(1); new_node-data = i; if (head == NULL) // 第一个节点 head = new_node; tail = new_node; else // 尾插法 tail-next = new_node; tail = new_node; // 将链表头尾相连，形成环 tail-next = head; return head;// 遍历并打印循环链表void show_list(linklist head) if (head == NULL) printf(链表为空 ); return; linklist p = head; do printf(%d , p-data); p = p-next; while (p != head); printf( );// 解决约瑟夫环问题void solve_josephus(linklist head, int m) if (head == NULL) return; // 如果 m=1，特殊处理，避免在原地打转 if (m == 1) linklist p = head; while(p-next != p) printf(%d出列. , p-data); linklist temp = p-next; // 找到p的前一个节点 linklist prev = p; while(prev-next != p) prev = prev-next; prev-next = p-next; free(p); p = temp; printf( 最后幸存者是: %d , p-data); free(p); return; linklist current = head; while (current-next != current) // 循环直到只剩一个节点 // 1. 走: 找到被杀节点的前一个节点 // 因为要找第 m 个，所以需要走 m-2 步 (从当前节点之后开始数) for (int i = 1; i m - 1; i++) current = current-next; // 2. 删: 删除目标节点 linklist kill_node = current-next; printf(%d出列. , kill_node-data); // 从环中移除 current-next = kill_node-next; free(kill_node); // 3. 更新下一次报数的起点 current = current-next; printf( 最后幸存者是: %d , current-data); free(current); // 释放最后一个节点 约瑟夫环问题总结 数据结构选择: 循环链表是该问题最直观、最自然的模型。 算法核心: 关键在于定位到待删除节点的前一个节点，这是安全删除链表节点的通用法则。 指针操作: 每次删除操作后，必须小心地更新当前指针（下一轮的起始点），确保逻辑链条不断裂。 边界情况: 考虑 n=1 或 m=1 等特殊情况，能体现代码的健壮性。例如，当 m=1 时，每次都删除当前节点，指针移动的逻辑需要特别处理。 三：树形结构 二叉搜索树（BST）是利用树结构实现高效查找的典范。它的核心在于维持一个严格的有序性。 5. 二叉搜索树核心特性 定义: 对于树中任意节点，其左子树所有节点的值都小于该节点，其右子树所有节点的值都大于该节点。 价值: 平均情况下，查找、插入、删除操作的时间复杂度均为 O(log n)，效率远超线性表的 O(n)。 6. 难点攻克：二叉树的删除操作 BST 的插入相对简单，只需遵循规则找到空位即可。而删除操作则要复杂得多，因为它必须在删除节点后维持 BST 的有序性。 删除节点 x 的三种情况分析： x 是叶子节点: 最简单的情况，直接删除 x，并将其父节点的相应指针置为NULL。 x 只有一个子节点 (左或右): 将 x 的父节点直接链接到 x 的唯一子节点上，然后释放 x。 x 有两个子节点: 这是最复杂的情况。不能简单删除，否则会断开其两棵子树。 解决策略: 在x的子树中找到一个合适的“替身”来取代x的位置。这个替身有两个选择： 前驱 (predecessor): x 左子树中的最大值。 后继 (successor): x 右子树中的最小值。 操作步骤 (以后继为例): a. 在 x 的右子树中，一路向左，找到最小值节点 s (后继)。 b. 将 s 的值赋给 x。 c. 问题转化为在 x 的右子树中删除节点 s。由于 s 是最小值，它最多只有一个右孩子，问题降级为情况 1 或情况 2。 图解删除双子节点 (删除节点 8) 假设我们要删除根节点 8： 1. 目标：删除节点 8。 a. 找到 8 的后继：在右子树 10, 14, 13 中找到最小值，即 10。 2. 找到后继节点 10。 b. 用后继 10 的值覆盖 8。 3. 用后继的值覆盖待删除节点。 c. 在原右子树中删除后继 10。此时 10 的删除操作属于情况 2（它有一个右孩子 14），将其父节点(现在是新的根10)直接链接到其子节点 14。 4. 递归删除后继节点，完成重构。 代码实现：二叉树删除 typedef struct node int data; struct node *lchild, *rchild; bstNode;// 辅助函数：查找子树中的最小值节点bstNode* findMin(bstNode* root) if (root == NULL) return NULL; while (root-lchild != NULL) root = root-lchild; return root;// BST 删除函数bstNode* bstRemove(bstNode* root, int data) // 1. 基线条件：树为空或未找到 if (root == NULL) return root; // 2. 递归查找 if (data root-data) root-lchild = bstRemove(root-lchild, data); else if (data root-data) root-rchild = bstRemove(root-rchild, data); else // 3. 找到了要删除的节点 // 情况1: 叶子节点 或 情况2: 单子节点 if (root-lchild == NULL) bstNode *temp = root-rchild; free(root); return temp; else if (root-rchild == NULL) bstNode *temp = root-lchild; free(root); return temp; // 情况3: 双子节点 // 找到右子树的最小值 (后继) bstNode *temp = findMin(root-rchild); // 用后继的值覆盖当前节点 root-data = temp-data; // 在右子树中递归删除那个后继节点 root-rchild = bstRemove(root-rchild, temp-data); return root; [!WARNING] 二叉树的退化风险 如果插入的数据是预先有序或基本有序的，BST 会退化成一个倾斜的链表，所有操作的性能将从 O(log n) 急剧下降到 O(n)。这正是**平衡二叉树（如 AVL 树、红黑树）**存在的意义。 四：栈与队列 栈和队列虽然在操作上受到限制，但正是这种限制赋予了它们独特的“先进后出”(LIFO)和“先进先出”(FIFO)特性，使其成为解决特定问题的强大工具。 7. 栈 核心特性: 后进先出 (Last-In, First-Out)。最后压入栈的元素，最先被弹出。 应用场景: 函数调用与递归: 这是栈最经典的应用。每次函数调用，其上下文（参数、返回地址、局部变量）被压入一个系统维护的“调用栈”。函数返回时，从栈顶弹出其上下文。递归本质上是函数调用自身的特例。 表达式求值: 将中缀表达式转换为后缀表达式（逆波兰表示法），然后使用栈进行求值。 括号匹配: 遍历字符串，遇到左括号就入栈，遇到右括号就检查栈顶是否为匹配的左括号，若是则出栈，否则不匹配。 深度优先搜索 (DFS): 在图或树的遍历中，DFS 的递归实现天然利用了调用栈。其迭代实现则需要手动维护一个栈来存储待访问的节点。 实战案例：括号匹配 #include stdio.h#include stdlib.h#include stdbool.h#include string.h// 简单的链式栈实现typedef struct StackNode char data; struct StackNode *next; StackNode;void push(StackNode** top, char data) StackNode* newNode = (StackNode*)malloc(sizeof(StackNode)); newNode-data = data; newNode-next = *top; *top = newNode;bool pop(StackNode** top, char* data) if (*top == NULL) return false; StackNode* temp = *top; *data = temp-data; *top = temp-next; free(temp); return true;// 核心匹配逻辑bool areBracketsBalanced(char* expr) StackNode* stack = NULL; char popped_char; for (int i = 0; i strlen(expr); i++) if (expr[i] == ( || expr[i] == [ || expr[i] == ) push(stack, expr[i]); continue; // 如果遇到右括号但栈为空，则不匹配 if (stack == NULL) return false; switch (expr[i]) case ): pop(stack, popped_char); if (popped_char != () return false; break; case ]: pop(stack, popped_char); if (popped_char != [) return false; break; case : pop(stack, popped_char); if (popped_char != ) return false; break; // 如果遍历完，栈中还有剩余的左括号，则不匹配 return (stack == NULL);int main() char expr1[] = ()[]; char expr2[] = ([)]; printf(%s is %s , expr1, areBracketsBalanced(expr1) ? balanced : not balanced); printf(%s is %s , expr2, areBracketsBalanced(expr2) ? balanced : not balanced); return 0; 8. 队列 (Queue)：FIFO 的应用 核心特性: 先进先出 (First-In, First-Out)。最先进入队列的元素，最先被移出。 应用场景: 资源调度: 操作系统中的任务调度、打印机任务队列等，需要公平地处理请求，先到先服务。 广度优先搜索 (BFS): 在图或树的遍历中，BFS 使用队列来存储待访问的节点，保证按层级顺序进行访问。 缓冲区 (Buffer): 在生产者-消费者模型中，队列作为缓冲区，平衡生产者和消费者之间速度不匹配的问题。 网络数据包排队: 路由器处理数据包时，通常将其放入队列中，按到达顺序转发。 实战案例：树的层序遍历 (BFS) 层序遍历是广度优先搜索在树上的直接应用，其核心就是队列。 // 假设已存在BST的节点定义 bstNode 和一个简单的队列实现// queue.h (包含enQueue, deQueue, isQueueEmpty等函数)void levelOrderTraversal(bstNode* root) if (root == NULL) return; // 1. 创建一个队列并把根节点入队 Queue* q = createQueue(); enQueue(q, root); while (!isQueueEmpty(q)) // 2. 从队列中取出一个节点 bstNode* current = deQueue(q); printf(%d , current-data); // 3. 将该节点的非空子节点入队 if (current-lchild != NULL) enQueue(q, current-lchild); if (current-rchild != NULL) enQueue(q, current-rchild); printf( ); 五：排序算法 排序是计算机科学中最基础也最重要的操作之一。选择合适的排序算法对程序性能至关重要。 9. 快速排序 快速排序是实践中平均性能最好的排序算法，其精髓在于分治思想和高效的**分区（Partition）**操作。 难点攻克：partition函数的多种实现 partition函数的目标是：选择一个基准（pivot），并将数组划分为两部分，使得左边的都小于等于基准，右边的都大于等于基准，最后返回基准的最终位置。 实现一：Lomuto 分区方案 (易于理解) 思路: 选择最后一个元素作为pivot。 维护一个指针i，指向“小于等于pivot”区域的末尾。 遍历数组（除pivot外），如果发现元素arr[j]小于等于pivot，则将i后移一位，并交换arr[i]和arr[j]。 最后，将pivot（原arr[high]）与arr[i+1]交换。 // Lomuto partition schemeint partition_lomuto(int arr[], int low, int high) int pivot = arr[high]; // 选择最后一个元素为基准 int i = (low - 1); // 小于等于pivot区域的边界 for (int j = low; j = high - 1; j++) if (arr[j] = pivot) i++; swap(arr[i], arr[j]); swap(arr[i + 1], arr[high]); return (i + 1); 实现二：Hoare 分区方案 (原始方案，效率更高) 思路: 选择第一个元素作为pivot。 使用两个指针i和j，分别从数组的两端向中间扫描。 i向右扫描，直到找到一个大于pivot的元素。 j向左扫描，直到找到一个小于pivot的元素。 交换arr[i]和arr[j]。 重复 3-5 步，直到i和j交错。 注意: Hoare 方案最后返回的不一定是pivot的最终位置，而是划分的分界点。 // Hoare partition schemeint partition_hoare(int arr[], int low, int high) int pivot = arr[low]; int i = low - 1; int j = high + 1; while (1) // 从左向右找第一个大于等于pivot的元素 do i++; while (arr[i] pivot); // 从右向左找第一个小于等于pivot的元素 do j--; while (arr[j] pivot); // 如果指针交错，则分区完成 if (i = j) return j; swap(arr[i], arr[j]); 完整的快速排序实现 (使用 Lomuto) void quickSort(int arr[], int low, int high) if (low high) // pi 是分区后基准元素的索引 int pi = partition_lomuto(arr, low, high); // 递归地对基准左右两边的子数组进行排序 quickSort(arr, low, pi - 1); quickSort(arr, pi + 1, high); 10. 归并排序 归并排序同样基于分治思想，但其核心操作是**归并（Merge）**而非分区。 核心思想: 分解 (Divide): 将数组递归地对半切分，直到每个子数组只有一个元素（天然有序）。 合并 (Conquer): 将相邻的两个有序子数组合并成一个更大的有序数组。 难点攻克：merge函数的实现 merge函数是归并排序的灵魂。它接收两个已排序的子数组，并将它们合并成一个单一的有序数组。 思路: 创建临时数组来存储合并后的结果。 使用三个指针，i指向第一个子数组，j指向第二个子数组，k指向临时数组。 比较arr[i]和arr[j]，将较小的元素放入临时数组，并移动相应的指针。 重复此过程，直到一个子数组被完全处理。 将另一个子数组中剩余的元素全部复制到临时数组。 最后，将临时数组的内容复制回原数组。 代码实现：归并排序 // Merge two subarrays of arr[].// First subarray is arr[l..m]// Second subarray is arr[m+1..r]void merge(int arr[], int l, int m, int r) int i, j, k; int n1 = m - l + 1; int n2 = r - m; // 创建临时数组 int L[n1], R[n2]; // 拷贝数据到临时数组 for (i = 0; i n1; i++) L[i] = arr[l + i]; for (j = 0; j n2; j++) R[j] = arr[m + 1 + j]; // 合并临时数组回到原数组 arr[l..r] i = 0; j = 0; k = l; while (i n1 j n2) if (L[i] = R[j]) arr[k++] = L[i++]; else arr[k++] = R[j++]; // 拷贝L[]中剩余的元素 while (i n1) arr[k++] = L[i++]; // 拷贝R[]中剩余的元素 while (j n2) arr[k++] = R[j++];void mergeSort(int arr[], int l, int r) if (l r) // 找到中点，避免 (l+r) 溢出 int m = l + (r - l) / 2; // 递归排序左右两半 mergeSort(arr, l, m); mergeSort(arr, m + 1, r); // 合并已排序的两半 merge(arr, l, m, r); 特性对比 快速排序 归并排序 平均时间 O(n log n) O(n log n) 最坏时间 O(n²) (需要优化) O(n log n) 空间复杂度 O(log n) (原地) O(n) (需额外空间) 稳定性 不稳定 稳定 适用场景 内部排序，对空间敏感 外部排序，对稳定性有要求 六：查找算法 查找（Search），是在数据集合中寻找特定元素的过程。看似简单的操作，在面对海量数据时，其效率直接决定了系统的响应速度和用户体验。不同的数据组织方式，催生了截然不同的查找策略。 12. 顺序查找：最朴素的策略 思想: 从数据集合的第一个元素开始，逐一向后比对，直到找到目标或遍历完所有元素。这是一种“地毯式搜索”。 时间复杂度: O(n)。在最坏情况下，需要检查集合中的每一个元素。 适用场景: 数据无序且无法排序: 当数据本身是杂乱无章的，且没有条件或必要去排序时，顺序查找是唯一的选择。 数据量极小: 当 n 非常小时，O(n)的开销可以忽略不计，简单的顺序查找因其实现简单而成为首选。 链式存储结构: 对于单向链表，由于其不支持随机访问，通常也只能采用顺序查找。 [info] 工程视角 不要轻视顺序查找。在很多嵌入式系统或对代码尺寸有严格要求的场景中，如果数据量可控，一个简单、无依赖的for循环远比引入复杂的查找结构更具优势。“简单”本身就是一种强大的工程美学。 13. 二分查找 (Binary Search)：有序世界的利器 当数据集合有序且支持随机访问（如数组）时，二分查找展现出惊人的威力。 思想: 通过不断将搜索区间折半，以对数级的速度逼近目标。每比较一次，就能排除掉一半的不可能选项。 二分查找动态过程 时间复杂度: O(log n)。对于 100 万个数据，最多只需 20 次比较；对于 10 亿个数据，也仅需约 30 次。 难点攻克：二分查找的“魔鬼细节”与鲁棒实现 二分查找的原理简单，但完美实现却充满陷阱。高德纳（Donald Knuth）曾说：“虽然二分查找的基本思想相对简单，但细节可以非常棘手……第一个正确的二分查找算法在 1946 年就已出现，但第一个没有错误的实现直到 1962 年才发表。” 常见的陷阱： 整数溢出: 计算中点时，mid = (low + high) / 2 在low和high都很大时可能导致它们的和溢出。 死循环: 当区间更新逻辑不当时（如 low = mid 或 high = mid），在特定边界条件下可能导致搜索区间无法缩小，陷入死循环。 边界条件处理: 循环的终止条件是low high还是low = high？区间更新是high = mid还是high = mid - 1？这些微小的差异决定了算法的正确性。 实战代码：一个健壮的二分查找模板 这个模板通过精巧的边界设计，可以清晰地处理“查找特定值”、“查找第一个大于/等于某值的位置”等多种变体。 #include stdio.h/** * @brief 在一个升序数组中进行二分查找 * @param arr 有序数组 * @param len 数组长度 * @param target 要查找的目标值 * @return 如果找到，返回目标值的索引；如果未找到，返回-1。 */int binarySearch(int arr[], int len, int target) if (arr == NULL || len = 0) return -1; int low = 0; int high = len - 1; // 循环条件: low = high // 当 low == high 时，区间还有一个元素，需要检查。 // 当 low high 时，区间为空，查找结束。 while (low = high) // 防止溢出的中点计算方式 int mid = low + (high - low) / 2; if (arr[mid] == target) return mid; // 找到了！ else if (arr[mid] target) // 目标在右半部分，mid已经被检查过，所以新区间从 mid + 1 开始 low = mid + 1; else // arr[mid] target // 目标在左半部分，mid已经被检查过，所以新区间到 mid - 1 结束 high = mid - 1; // 循环结束，low high，说明未找到 return -1;int main() int sorted_array[] = 2, 5, 8, 12, 16, 23, 38, 56, 72, 91; int n = sizeof(sorted_array) / sizeof(sorted_array[0]); int target1 = 23; int target2 = 15; int index1 = binarySearch(sorted_array, n, target1); int index2 = binarySearch(sorted_array, n, target2); if (index1 != -1) printf(Target %d found at index: %d , target1, index1); else printf(Target %d not found. , target1); if (index2 != -1) printf(Target %d found at index: %d , target2, index2); else printf(Target %d not found. , target2); return 0; [info] 模板分析 循环条件 low = high: 保证了当搜索区间缩至单个元素时，该元素仍能被检查。 区间更新 low = mid + 1 和 high = mid - 1: 确保每次循环都至少排除mid本身，从而保证了区间的严格缩小，避免死循环。 14. 分块查找：空间换时间的折中艺术 在无法对全部数据进行完全排序，但可以进行宏观分组的场景下，分块查找提供了一种优雅的性能提升方案。 思想: 分块 + 索引。将大数据集分割成若干“块”，为这些块建立一个“索引表”。 ➡️ 从字典的部首检字法到分块查找 结构: 数据块: 原始数据被划分为连续的块。块内元素可以无序，但块间必须有序（例如，第 i+1 块的所有元素都大于第 i 块的所有元素）。 索引表: 一个小数组，每个条目对应一个数据块，存储该块的关键信息（通常是块内最大值）和起始地址/索引。 查找过程: 第一步：在索引表中查找。由于索引表本身是有序且数据量小，可以使用二分查找（或顺序查找）快速定位目标值可能所在的块。 第二步：在数据块内查找。进入定位到的数据块，在块内进行顺序查找。 性能分析: 设数据总量为n，分为b块，则每块大小为n/b。索引查找时间为O(log b)（用二分法），块内查找时间为O(n/b)。总时间复杂度为 O(log b + n/b)。通过调整块的数量b，可以在时间和空间（索引表大小）之间找到平衡点。当b = sqrt(n)时，可以取得较好的理论性能。 工程价值与适用场景 分块查找的真正价值在于它对数据容忍了一定程度的无序，非常适合处理动态变化的数据集。 场景: 数据库索引。数据库的表数据在物理上可能不是完全有序的（因为增删改），但数据库会维护一个 B+树索引（一种高级的多路分块结构）。查找时，先通过索引快速定位到包含目标数据的数据页（块），然后再在数据页内查找。这使得在海量动态数据中进行高效查找成为可能。 优点: 在插入新数据时，只需找到对应的块并插入，无需像维护一个完全有序数组那样移动大量数据。它在查找效率和维护成本之间取得了出色的平衡。 15. 哈希查找 ：O(1) 的理想与现实 前面所有查找算法，都离不开“比较”。而哈希查找另辟蹊径，试图通过一次计算就直接定位到数据。 思想: 哈希函数 (Hash Function): 设计一个函数 h(key)，它能将任意的关键字key映射到一个固定范围的整数，这个整数就是数据在哈希表（通常是一个数组）中的存储位置（索引）。 哈希表 (Hash Table): 一个数组，用于存储数据。 查找: 当要查找一个key时，只需计算 index = h(key)，然后直接访问哈希表的 index 位置即可。 时间复杂度: 理想情况下，每次查找只需一次哈希计算和一次数组访问，时间复杂度为 O(1)。 难点攻克：哈希冲突 理想是丰满的，现实是骨感的。不同的key通过哈希函数可能会计算出相同的index，这就是哈希冲突。 例子: h(key) = key % 10。h(12) 和 h(22) 都会得到索引 2。 解决冲突的常用方法： 开放定址法 (Open Addressing): 如果计算出的位置已被占用，就按照某种规则（线性探测、二次探测等）去寻找下一个空位。 链地址法 (Chaining): （最常用）哈希表的每个位置不再是单个元素，而是一个链表的头指针。所有哈希到同一位置的元素，都以节点的形式挂载到这个链表上。查找时，先计算哈希值定位到链表，再在链表上进行顺序查找。 链地址法解决哈希冲突 性能总结与对比 查找算法 数据要求 平均时间复杂度 最坏时间复杂度 空间复杂度 顺序查找 无 O(n) O(n) O(1) 二分查找 有序, 随机访问 O(log n) O(log n) O(1) 分块查找 块间有序 O(log b + n/b) O(log b + n/b) O(b) 哈希查找 无 O(1) O(n) (全冲突) O(n) 最终洞察: 没有最好的算法，只有最合适的算法。 二分查找是静态有序数据集的王者。 哈希查找是追求极致查询速度（尤其是动态数据集）的首选，但以额外的空间和哈希函数设计为代价。 分块查找和其衍生（如 B 树）是在查找效率和动态维护成本之间寻求平衡的工程典范，是大型数据库和文件系统的基石。","tags":[null],"categories":[null]},{"title":"C语言复习笔记","path":"/data/ES/基础/C语言复习笔记.html","content":"第一部分：C 语言基础 1. helloworld 配置环境 编辑器: Visual Studio Code (VS Code)，一款轻量且强大的代码编辑器。 编译器: MinGW-w64，在 Windows 上提供 GCC 编译环境，可将 C 代码编译为可执行文件。 推荐插件: C/C++ (by Microsoft), Code Runner (用于快速运行代码)。 VSCode 配置 C/C++环境，使用 MinGW 编译器 VS Code安装 Code Runner 插件方法: 点击 VS Code 菜单栏的文件 (File) - “首选项” (Preferences) - “设置” (Settings)，或者使用快捷键 Ctrl + , 。 在设置页面中搜索Run Code configuration。 找到Run In Terminal 选项，并勾选上。 实现程序 在 vscode 中，输入main即可快速实现示例程序 main 函数可以接收来自命令行的参数，这在编写工具类程序时非常有用。 int argc: (Argument Count) 整型变量，存储传递给程序的命令行参数的数量（包括程序本身）。 char *argv[]: (Argument Vector) 字符串数组，argv[0]是程序名，argv[1]是第一个参数，以此类推。 ###include stdio.h// 编译后运行: ./a.out param1 param2int main(int argc, char *argv[]) printf(程序名: %s , argv[0]); // 输出: ./a.out printf(第一个参数: %s , argv[1]); // 输出: param1 printf(第二个参数: %s , argv[2]); // 输出: param2 return 0; 2. 数据类型与格式化 IO 基本数据类型 C 语言中的数据类型定义了变量可以存储的数据种类和范围。 类型分类 关键字 描述 格式说明符 整型 int 基本整数，通常 4 字节 %d short 短整型，通常 2 字节 %hd long 长整型，通常 4 或 8 字节 %ld long long 更长整型，至少 8 字节 %lld unsigned 无符号修饰，范围从 0 开始 %u, %lu, %llu 浮点型 float 单精度浮点数，约 7 位有效数字 %f double 双精度浮点数，约 15 位有效数字 (更常用) %lf 字符型 char 单个字符，本质是 1 字节的整数 (ASCII 码) %c, %hhd(整数) 常量与变量 变量: 内存中用于存储数据的具名空间，其值可以改变。 常量: 值在程序运行期间不可改变。 字面常量: 如 100, 3.14, 'A', hello。 宏定义常量: 使用 #define，在预编译阶段进行文本替换，无类型检查。 const 修饰的变量: 具有类型，会进行类型检查，更安全。 ###define PI 3.14159 // 宏常量int main() int age = 25; // 变量 const int MAX_USERS = 100; // const常量 age = 26; // OK // MAX_USERS = 101; // Error: 试图修改const变量 格式化输入与输出 printf(): 格式化输出函数，将数据按指定格式打印到屏幕。 scanf(): 格式化输入。scanf返回成功读取的项数。如果输入类型不匹配，会返回0并将错误输入留在输入缓冲区 (stdin) 中，可能导致后续读取问题。 scanf需要传入变量的地址，使用 运算符获取。 格式符 描述 示例 %d 十进制整数 123 %f float 类型浮点数 3.14 %lf double 类型浮点数 3.1415926 %c char单个字符 'A' %s string字符串 hello %p point指针地址（十六进制） 0x7ffc... %x hexadecimal十六进制整数 ff %o Octal八进制整数 177 %% 输出一个 % 符号 % 注：printf 使用 %f 即可打印 float 和 double。这是因为在传递给 printf 这样的可变参数函数时，float 类型的实参会被自动提升(promote)为 double 类型。而 scanf 传入的是指针，需要通过 %lf 明确告知函数要写入一个 double 大小的内存。 清理输入缓冲区: 当scanf失败时，必须清理缓冲区中的非法输入。 int a;while (1) printf(请输入一个整数: ); int retval = scanf(%d, a); // a是取地址 if (retval == 1) printf(成功读取: %d , a); break; // 成功则退出循环 else printf(输入错误！正在清理输入缓冲区... ); char buf[10]; // 准备一个“垃圾桶” fgets(buf, 10, stdin); // 把留在输入队列里的垃圾读走，扔到垃圾桶里 //或者用下面这句话，每次读一个来清掉，直到输入队列清空 // while (getchar() != ); 单字符输入输出 (getchar, putchar) 这两个函数效率更高，用于处理单个字符的 I/O。 getchar(): 从stdin读取一个字符，并以int类型返回。 putchar(): 将一个字符（以int形式传递）写入stdout。 ###include stdio.hint main() printf(请输入一个字符: ); int c = getchar(); // 用int接收以处理EOF printf(你输入的字符是: ); putchar(c); putchar( ); return 0; 类型转换 自动类型转换: 在运算中，低精度类型会自动转换为高精度类型。 (char - int - float - double) 强制类型转换: 使用 (目标类型) 语法强制转换。 int a = 10;int b = 3;float result = (float)a / b; // 将a强制转为float，结果为3.333...// 如果不转换，int / int 结果为3int int_result = a / b; // 结果为 3 科学计数法 浮点数可以使用e或E表示 10 的幂，这在表示极大或极小值时很有用。 double large_num = 3.14e8; // 3.14 * 10^8double small_num = 1.23e-5; // 1.23 * 10^-5 数字的进制表示 我们可以用不同进制来输出数字，这对调试程序，操作寄存器等底层硬件非常重要 前缀: 十六进制: 0x 或 0X 八进制: 0 十进制: 无前缀 在内存中，所有进制的数最终都以二进制形式存储。 int dec_val = 100; // 十进制int hex_val = 0x64; // 十六进制 (值为100)int oct_val = 0144; // 八进制 (值为100)// 使用不同格式说明符打印printf(Decimal: %d, %d, %d , dec_val, hex_val, oct_val);printf(Hex: %x, %x, %x , dec_val, hex_val, oct_val);printf(Octal: %o, %o, %o , dec_val, hex_val, oct_val);// 使用#标志位打印进制前缀printf(Hex with prefix: %#x, Octal with prefix: %#o , hex_val, oct_val); 面试题实战-浮点数的安全比较 为什么不能直接用 == 比较两个浮点数？ 由于计算机使用二进制表示浮点数时存在固有的精度误差，直接用 == 比较通常会失败。 例子：十进制 0.1 转二进制计算过程 正确做法是判断两个浮点数之差的绝对值是否小于一个预先设定的极小值（epsilon）。 代码示例: ##include float.h##include math.h##include stdbool.h##include stdio.h/* * 浮点数比较：因存在精度误差，应判断差的绝对值是否小于一个极小阈值(epsilon)， * 而非直接使用 `==`。 */// 1. 绝对误差法##define EPSILON 1e-8 // 定义固定的误差阈值// 判断值是否小于固定阈值。简单，但对极大或极小值可能失效。bool is_zero_abs(double value) return fabs(value) = EPSILON; // 2. 相对误差法 (推荐)// 使用与基准值相关的动态阈值，更通用bool is_zero_rel(double value, double base_value) // 阈值上线随基准值大小动态调整，下线为1.0 double epsilon = EPSILON * fmax(1.0, fabs(base_value)); return fabs(value) = epsilon;int main(int argc, char const *argv[]) // 错：直接用 `==` 比较浮点数，因精度问题导致判断失败 if (0.1 * 3 - 0.3 == 0) printf(是0 ); else printf(不是0 ); // 此行被输出 // 绝对误差法：对于小数值的运算结果比较有效 if (is_zero_abs(0.1 * 3 - 0.3)) printf(是0 ); // 此行被输出 else printf(不是0 ); // 相对误差法：对于大数值的比较也能正确处理 double f1 = 3.5e7; double f2 = f1 + 0.1; if (is_zero_rel(f2 - f1, f1)) printf( f2-f1 是0 ); // 此行被输出 else printf( f2-f1 不是0 ); return 0; 面试题实战-大型字面量后缀 在处理大型数字的宏或常量时，中间计算结果可能会超出默认 int 类型的范围导致溢出，即便最终结果可以存放在 long long 中。 为了避免这种情况，可以使用后缀强制指定字面量的类型。 L 或 l: long LL 或 ll: long long U 或 u: unsigned ULL 或 ull: unsigned long long 代码示例: ##include stdio.h// 错误的方式: 所有数字都是int, 乘法过程中会溢出// #define SECONDS_PER_YEAR (365 * 24 * 60 * 60)// 正确的方式: 确保第一个数是 long long 类型// 后续的乘法都会被提升到 long long 类型进行，避免溢出##define SECONDS_PER_YEAR (365 * 24 * 60 * 60ULL)int main(void) printf(每年秒数: %llu , SECONDS_PER_YEAR); return 0; 面试题实战-类型提升中的符号扩展 当一个宽度较小的有符号类型（如 char, short）被提升为一个宽度较大的类型（如 int）时： 如果原始值是正数，高位用 0 填充。 如果原始值是负数（即最高位为 1），则会发生符号扩展 (Sign Extension)，高位用 1 填充以保持其负值。 代码示例: ##include stdio.hint main(void) // 0xaa 的二进制是 10101010。作为有符号char，其最高位是1，为负数。 char c = 0xaa; // 当 c 被赋值给整型变量 j 时，它被提升为 int // 由于 c 是负数，发生符号扩展，高位全用1填充 int j = c; // 结果: 0xffffffaa printf(j = %#x , j); return 0; 这个特性在处理来自硬件或网络的字节流时尤其重要. 面试题实战-大小端序转换 建议先看下面的内容理解： 字节序探析：大端与小端的比较 简单总结如下： 如果需要逐位运算，或者需要到从个位数开始运算，都是小端序占优势 反之，如果运算只涉及到高位，或者数据的可读性比较重要，则是大端序占优势 所以计算机存储一般都用小端序方便计算，大端序一般方便人类阅读 题目：写一个函数，要求把小端序存放的整数，转换成大端序存放 代码示例: int change(int n) int result=0; unsigned char *p = (unsigned char*)n; unsigned char *q = (unsigned char*)result; for(int i=0; i4; i++) *(q + 3 - i) = *(p + i); return result; 3. 运算符 算术运算符 + (加), - (减), * (乘), / (除), % (取余/模) 自增/自减: ++, -- 前缀 (++a): 先自增，再使用变量的值。 后缀 (a++): 先使用变量的值，再自增。 int a = 5;int b = ++a; // a变为6, b被赋值为6int c = a++; // c被赋值为6, a变为7printf(a=%d, b=%d, c=%d , a, b, c); // 输出: a=7, b=6, c=6 关系与逻辑运算符 关系运算符: (大于), (小于), = (不小于), = (不大于), == (等于), != (不等于)。结果为 1 (真) 或 0 (假)。 逻辑运算符: ! (逻辑非), (逻辑与), || (逻辑或)。 短路求值: expr1 expr2: 如果 expr1 为假，expr2 不会被执行。 expr1 || expr2: 如果 expr1 为真，expr2 不会被执行。 int x = 0, y = 5;// x为0(假)，右侧不执行，y的值不变if (x (y = 10)) /* ... */ printf(y = %d , y); // 输出: y = 5 位运算符 直接对数据的二进制位进行操作。 (按位与), | (按位或), ^ (按位异或),~ (按位取反) (左移): x n 相当于 x * 2^n (右移): x n 相当于 x / 2^n // 常用位操作技巧unsigned char reg = 0b10101100; // 假设这是一个8位寄存器 // 注意二进制字面量 0b10101100 是GCC扩展// 1. 置位 (将第3位置1)reg = reg | (1 3);// 2. 清零 (将第2位清0)reg = reg ~(1 2);// 3. 取反 (翻转第1位)reg = reg ^ (1 1);// 4. 测试 (检查第7位是否为1)if (reg (1 7)) // 位为1 其他运算符 赋值运算符: =, +=, -=, *=, /=, %=, =, |=, ^=, =, = 条件运算符 (三目运算符): 表达式1 ? 表达式2 : 表达式3 int a = 10, b = 20;int max = (a b) ? a : b; // max 的值为 20 sizeof 运算符: 计算数据类型或变量占用的内存字节数。 int arr[10];printf(int类型占 %zu 字节 , sizeof(int)); // 通常输出 4printf(数组arr占 %zu 字节 , sizeof(arr)); // 输出 40 (4 * 10) 运算符优先级与结合性 优先级: 决定了哪个运算符先执行（如 * 优先于 +）。 结合性: 决定了相同优先级的运算符的执行顺序（如赋值=是从右至左）。 黄金法则: 当不确定优先级时，使用圆括号 () 来明确指定运算顺序。 这能避免错误并提高代码可读性。 int x = 2 * 3 + 4; // 乘法优先, x = 6 + 4 = 10int y = 10 5 5 0; // 关系运算符优先于逻辑运算符int a, b, c;a = b = c = 5; // 赋值运算符从右向左结合, c=5, b=5, a=5 面试题实战-字节内比特位反转 问题: 编写一个函数，将一个字节中的 8 个比特位进行反转。 核心知识: 这是对位运算符的深入考察。核心思想是逐位从原字节中取出，然后逐位放入新字节的相反位置。 代码示例: void revert(int len, char A[], char B[]) for (int i = 0; i len; i++) B[i] = 0; for (int k = 0; k 8; k++) B[i] = B[i] 1; // 先移位 B[i] |= (A[i] k) 0x01; // 后赋值 // 最后不会多移位 4. 控制流 分支结构 (if / switch) if-else: 用于二路或多路分支判断。 int score = 85;if (score = 90) printf(优秀 ); else if (score = 60) printf(及格 ); else printf(不及格 ); switch: 用于基于一个整数值的多路分支，通常比 if-else if 更高效、清晰。 case 标签后必须是常量表达式。 每个 case 通常以 break 结束，否则会发生“穿透”，继续执行下一个 case。 default 处理所有未匹配的 case。 int day = 3;switch (day) case 1: printf(周一 ); break; case 2: printf(周二 ); break; case 3: printf(周三 ); break; // case 4 ... 5: ... (GCC/Clang 扩展语法) default: printf(其他 ); break; 循环结构 (while / for / do-while) while 循环: 先判断条件，再执行循环体。可能一次都不执行。 int i = 0;while (i 5) //条件成立执行 printf(%d , i); i++; // 输出: 0 1 2 3 4 for 循环: 集初始化、条件判断、迭代于一体，结构清晰，常用于已知循环次数的场景。 for (int i = 0; i 5; i++) //条件成立执行 printf(%d , i); // 输出: 0 1 2 3 4 do-while 循环: 先执行一次循环体，再判断条件。保证循环体至少执行一次。 int i = 10;do printf(至少执行一次 ); while (i 5); //条件成立执行 跳转语句 (break / continue / goto / return) break: 立即跳出当前所在的 switch 结构或循环结构。 continue: 立即结束本次循环，跳到循环的下一次迭代判断处。 return: 立即终止当前函数的执行。 将一个值（如果函数不是void类型）返回给调用者。 在void函数中，return;可用于提前退出。 int check_value(int val) if (val 0) printf(Error: invalid value. ); return -1; // 提前退出并返回错误码 // ... 正常处理 ... return 0; // 返回成功码 goto: 无条件跳转到同一函数内的标签处。应谨慎使用，易破坏程序结构，通常只在错误处理等多层嵌套退出场景下考虑。 // 示例: goto用于统一的错误处理int func() FILE *fp = fopen(a.txt, r); if (fp == NULL) goto error_handle; char *mem = malloc(1024); if (mem == NULL) fclose(fp); // 释放已获取资源 goto error_handle; // ... 正常逻辑 ... free(mem); fclose(fp); return 0;error_handle: printf(发生错误，程序退出 ); return -1; 面试题实战- fgets字符串输入 与 scanf 不同，fgets 在读取字符串时更加安全，因为它会检查缓冲区的边界，有效防止溢出。 函数原型: char *fgets(char *str, int n, FILE *stream); 参数: str: 用于存储输入字符串的缓冲区。 n: 最多读取 n-1 个字符（最后一个位置留给 \\0）。 stream: 输入流，通常是 stdin（标准输入）。 特点: 安全: 不会超出缓冲区大小。 会读取换行符: 如果输入行中包含换行符 ，fgets 会将其一并读入缓冲区。通常需要手动移除。 ##include stdio.h##include string.hint main() char buffer[10]; printf(请输入一行文字 (最多9个字符): ); if (fgets(buffer, sizeof(buffer), stdin) != NULL) // 移除可能存在的换行符 buffer[strcspn(buffer, )] = \\0; printf(你输入的是: %s , buffer); return 0; 第二部分：内存、函数与程序结构 5. 内存布局与管理 对于嵌入式开发，深刻理解程序内存组织至关重要，它直接影响程序的稳定性、效率和资源消耗。 每个 C 程序都运行在一个独立的虚拟内存空间中，其结构从低地址到高地址通常如下： 代码段 只读！ .text: 存放程序的可执行二进制代码 .init: 存放系统初始化代码 数据段 此区域用于存储**生命周期与整个程序相同的全局变量和静态变量**。 .rodata (Read-only Data)： 存只读数据，如字符串字面量 (hello)、const修饰的全局常量。 .data：存 已初始化的全局变量和静态变量。 .bss (Block Started by Symbol)：存未初始化的全局变量和静态变量，程序启动时，该区域会被系统自动清零。 // 示例：不同变量在数据段中的位置int global_init = 10; // 存放在 .data 段int global_uninit; // 存放在 .bss 段 (值为0)const char* str = hello; // hello在 .rodata 段, 指针str在 .data 段void counter() static int count = 0; // static修饰局部变量，使其存入.data段 // 只在首次调用时初始化为0 count++; printf(Counter called %d times. , count); static 对局部变量的影响 当 static 用于修饰局部变量时，它会改变该变量的存储期： 存储位置: 从栈 (Stack) 移动到 数据段 (.data / .bss)。 生命周期: 从函数调用时创建、返回时销毁（自动存储期），延长为与整个程序运行时间相同（静态存储期）。 这意味着，static 局部变量只在第一次执行其定义时被初始化，并且它的值在函数调用之间得以保留。 （关于 static 的全面总结，看笔记 12.4 节） void counter() // count 存储在数据段，只在首次调用时初始化为0 static int count = 0; count++; printf(函数被调用 %d 次. , count);int main() counter(); // 输出: 函数被调用 1 次. counter(); // 输出: 函数被调用 2 次. return 0; 栈 (Stack) 存储内容: 函数的局部变量、函数参数、环境变量、命令行参数及函数调用的上下文（返回地址等）。 核心特点: 自动管理: 函数调用时，栈向下增长（分配）；函数返回时，栈向上收缩（释放）。程序员无法干预。 空间有限: 栈大小预设且较小，过大的局部变量或过深的递归会导致栈溢出 (Stack Overflow)。 高效率: 分配和释放仅涉及栈指针的移动，速度极快。 void func(int n) // n 和 c 都在 func 的栈帧上 char c[10]; // 函数返回时，栈帧自动销毁，其内存被释放int main() int main_var = 100; // main_var 在 main 函数的栈帧上 func(main_var); return 0; 堆 (Heap) 堆是唯一一块可由程序员完全控制的内存区域，用于动态分配和管理内存。 核心特点: 手动管理: 必须通过函数（如malloc）申请，并通过free释放。忘记释放会导致内存泄漏。 空间巨大: 大小理论上只受限于系统可用物理内存。 匿名访问: 堆内存没有变量名，只能通过指针来访问。 生命周期灵活: 从申请到释放，其生命周期由程序员决定。 涉及函数(stdlib.h): void* malloc(size_t size): 申请 size 字节的内存，内容未初始化（随机值）。 void* calloc(size_t num, size_t size): 申请 num 个 size 字节的内存，内容被自动置零。 void free(void* ptr): 释放由 malloc 或 calloc 申请的内存。 free 最佳实践: free() 后，指针 ptr 会变成一个指向无效内存的悬空指针。 必须在free()后立即将指针置为 NULL，以防止后续误用。 ###include stdlib.hint main() // 申请一块能存放5个int的堆内存 int *arr = (int*)malloc(5 * sizeof(int)); if (arr == NULL) // 检查内存申请是否成功 return -1; // 使用内存 for (int i = 0; i 5; i++) arr[i] = i * 10; free(arr); // 释放内存 arr = NULL; // 防止悬空指针 return 0; 6. 存储期 存储期描述了变量在内存中从创建到销毁的生命周期。它与变量存储在哪个内存区域（栈、堆、数据段）直接相关。 自动存储期 对应内存区域: 栈 (Stack)。 生命周期: 从程序执行进入其所在的代码块开始，到离开该代码块时结束。内存的分配和释放由系统自动完成。 包含变量: 所有局部变量（包括函数参数），除非被static修饰。 void func() int auto_var = 10; // 进入函数时创建 // 离开函数时，auto_var被自动销毁 静态存储期 对应内存区域: 数据段 (.data / .bss)。 生命周期: 与整个程序的运行时间相同。在程序启动时创建，在程序结束时销毁。 包含变量: 所有全局变量（无论是否用static修饰）。 使用 static 修饰的局部变量。 int global_var = 1; // 静态存储期void counter() static int count = 0; // 静态存储期，只在首次调用时初始化 count++; // count的值在函数调用间得以保留 自定义存储期 对应内存区域: 堆 生命周期: 完全由程序员手动控制。从 malloc/calloc 成功调用时开始，到 free 被调用时结束。 核心风险: 忘记调用 free 会导致内存泄漏。 void dynamic_example() int *p = (int*)malloc(sizeof(int)); // 动态内存创建 if (p) *p = 100; // ... 使用 ... free(p); // 手动销毁 p = NULL; static 关键字全面总结 理解 static 的关键在于区分它修饰的是局部变量还是全局变量/函数。 上下文 改变的属性 效果 目的 修饰局部变量 存储期 从 自动 (栈上) 变为 静态 (数据段)。生命周期与程序相同。 在函数调用之间保持变量值的持久性。 修饰全局变量/函数 链接属性 从 外部链接 变为 内部链接。作用域被限制在当前文件。 信息隐藏和避免命名冲突，增强模块化。 详细解释与示例 修饰局部变量 (改变存储期) 默认情况: 局部变量存储在栈上，函数调用时创建，函数返回时销毁。 static 修饰后: 存储位置: 变量从栈移到数据段（.data 或 .bss）。 生命周期: 变量在程序启动时就已创建，直到程序结束才销毁。 初始化: 只在编译时初始化一次。 因此，其初始值必须是一个常量表达式（如字面量10、'c'或hello)，不能是运行时才存在的变量。 核心效果: 变量的值在多次函数调用之间得以保留。 ###include stdio.hvoid counter() // a1 是 static 局部变量，存储在数据段，生命周期贯穿程序 // 它只在程序加载时被初始化一次 static int a1 = 0; // OK: 0是常量 int runtime_var = 10; // static int a2 = runtime_var; // 错误！不能用变量初始化static变量 // a3 是 auto 局部变量，存储在栈上 // 每次调用 counter() 时，a3 都会被重新创建并初始化为 0 int a3 = 0; a1++; a3++; printf(static a1 = %d, auto a3 = %d , a1, a3);int main() counter(); // 输出: static a1 = 1, auto a3 = 1 counter(); // 输出: static a1 = 2, auto a3 = 1 counter(); // 输出: static a1 = 3, auto a3 = 1 return 0; 修饰全局变量/函数 (改变链接属性) 默认情况: 全局变量和函数具有外部链接属性，意味着它们可以被项目中任何其他 .c 文件通过 extern 关键字访问。 static 修饰后: 链接属性: 变为内部链接。 核心效果: 该全局变量或函数的作用域被严格限制在定义它的那个源文件内部，对其他文件不可见。 module_a.c 文件: ###include stdio.h// g_global_var 具有外部链接，可以被其他文件访问int g_global_var = 10;// g_static_var 具有内部链接，仅在此文件内可见static int g_static_var = 20;// global_func() 具有外部链接void global_func() printf(这是全局函数. );// static_func() 具有内部链接static void static_func() printf(这是静态函数，只能在本文件里调用. );void access_vars() printf(在本文件中: g_global_var = %d, g_static_var = %d , g_global_var, g_static_var); static_func(); main.c 文件: // 声明我们希望从 module_a.c 中使用的变量和函数extern int g_global_var;extern void global_func();// 下面的声明会导致链接错误，因为 g_static_var 和 static_func 是 static 的// extern int g_static_var;// extern void static_func();// 声明一个在 module_a.c 中定义的函数extern void access_vars();int main() printf(在主函数中: g_global_var = %d , g_global_var); // OK global_func(); // OK // g_static_var = 30; // 链接错误: undefined reference to `g_static_var` // static_func(); // 链接错误: undefined reference to `static_func` access_vars(); // OK, 调用 module_a 内部的函数来访问其内部变量 return 0; 这个例子清晰地展示了 static 如何作为模块化的工具，将实现细节（g_static_var, static_func）隐藏在模块内部，只暴露公共接口（g_global_var, global_func）。 7. 函数 函数是 C 语言的功能模块，它将一段可重用的代码封装成一个“黑箱”，对外提供清晰的接口，隐藏内部实现。 函数的构成 函数头: 返回类型 函数名(参数列表)，定义了函数的对外接口。 函数体: ... ，包含函数的具体实现。 参数: 形参: 函数定义中的变量，作为输入。 实参: 函数调用时传递的实际值，用于初始化形参。 返回值: 使用 return 关键字从函数中返回一个值。void类型表示不返回任何值。 局部变量: 定义在函数体内的变量，存储在栈上，函数返回后即销毁。严禁返回局部变量的地址。 // 通过指针交换两个变量的值// p1和p2是形参(指针)，temp是局部变量void swap(double *p1, double *p2) double temp = *p1; *p1 = *p2; *p2 = temp;int main(void) double a = 3.14, b = 0.618; // a, b是实参 swap(a, b); // 传递a和b的地址进行交换 return 0; 特殊函数类型 递归函数 函数在体内调用自身。必须包含递推关系和终止条件，否则会因无限递归导致栈溢出。 // 计算阶乘: f(n) = n * f(n-1)long long factorial(int n) if (n == 0) return 1; // 终止条件 return n * factorial(n - 1); // 递推关系 静态函数 使用 static 修饰的函数，其作用域被限制在当前源文件内，用于实现模块化和避免命名冲突。 // 该函数只能在定义它自己所在的.c文件中被调用static void helper_function() /* ... */ 回调函数 通过函数指针作为参数传递给另一函数，由后者在特定时机“回调”执行。这是一种强大的解耦机制，常见于事件处理、分层设计和系统 API 中。 示例 1：简单的策略切换 下面的 eat 函数并不关心具体“做什么菜”，只负责“吃”。具体菜系（yuecai 或 chuancai）由调用方通过函数指针传入，实现了行为的灵活切换。 ###include stdio.h// 定义两个菜系函数，它们的签名（参数、返回值）完全相同void yuecai(int a, float b) printf(做粤菜: %d %.1f , a, b); void chuancai(int a, float b) printf(做川菜: %d %.1f , a, b); // eat函数接收一个函数指针cook作为参数void eat(void (*cook)(int a, float b)) int a = 1; float f = 2.5; cook(a, f); // 调用传入的函数指针 printf(吃饭 );int main() printf(今晚想吃粤菜: ); eat(yuecai); // 传入粤菜函数的地址 printf( 明天想吃川菜: ); eat(chuancai); // 传入川菜函数的地址 return 0; 示例 2：系统事件处理 (信号) 这是回调函数最经典的应用之一。我们告诉操作系统：“当某个事件（如SIGINT信号，即按下 Ctrl+C）发生时，请调用我指定的这个函数（my_handler）”。这个过程就是注册回调。 signal 函数详解 signal 函数是 C 标准库 signal.h 中用于处理异步信号的核心函数。 函数原型: void (*signal(int signum, void (*handler)(int)))(int); 这个原型非常复杂，是“返回函数指针的函数”的典型例子。我们可以用 typedef 来简化理解（这也是推荐的最佳实践）： // 1. 为信号处理函数指针定义一个别名 sighandler_ttypedef void (*sighandler_t)(int);// 2. 原型现在变得清晰易读sighandler_t signal(int signum, sighandler_t handler); 这样就很清楚了：signal 函数接收一个信号编号和一个处理函数指针，并返回一个旧的处理函数指针。 参数说明: int signum: 信号的编号。通常使用标准宏来表示，例如： SIGINT: 中断信号，通常由用户在终端按下 Ctrl+C 产生。 SIGTERM: 终止信号，是 kill 命令发送的默认信号，用于请求程序正常退出。 SIGSEGV: 段错误信号，当程序试图访问其无权访问的内存区域时产生。 sighandler_t handler: 指向信号处理函数的指针。这里可以传递三种值： 一个自定义函数: 这就是我们的回调函数。它必须接收一个 int (信号编号) 参数并返回 void。 SIG_DFL: 一个特殊的宏，表示恢复对该信号的默认处理行为（例如，SIGINT 的默认行为是终止程序）。 SIG_IGN: 一个特殊的宏，表示忽略该信号。 返回值: 成功时: 返回之前的信号处理函数的指针。这允许你保存旧的处理方式，以便之后可以恢复它。 失败时: 返回 SIG_ERR，并设置 errno。 ###include signal.h###include stdio.h###include unistd.h// 1. 实现具体的回调函数 (也称 handler 或钩子函数)void my_handler(int sig) printf( 接收到信号 %d！正在处理... , sig); // 在实际应用中，这里会执行清理工作 // exit(0); // 可以在处理函数中决定是否退出程序int main() // 2. 注册回调：将函数指针my_handler传给signal函数 // 相当于告诉内核：当收到SIGINT信号时，请调用my_handler signal(SIGINT, my_handler); printf(程序正在运行，PID: %d。请按 Ctrl+C 来触发回调... , getpid()); // 无限循环，等待信号的到来 while(1) sleep(1); // sleep可以减少CPU占用 return 0; // 这行通常不会被执行 面试题实战-函数参数传递：传值 vs 传址 C 语言中所有函数参数传递本质上都是传值。但通过传递指针，可以达到“传址”的效果。 传值: 过程: 将实参的副本传递给形参。 效果: 函数内部对形参的任何修改，都不会影响到函数外部的实参。 传址: 过程: 将实参的地址（通过 运算符获取）传递给一个指针类型的形参。 效果: 函数内部通过解引用指针 (*p)，可以直接访问和修改函数外部实参的值。 ##include stdio.h// 传值：a是x的副本void modify_value(int a) a = 99; // 只修改了副本a，不影响外部的x// 传址：p接收了y的地址void modify_address(int *p) *p = 99; // 通过地址，直接修改了外部y的值int main() int x = 10; modify_value(x); printf(传值调用后, x = %d , x); // 输出: 10 int y = 10; modify_address(y); printf(传址调用后, y = %d , y); // 输出: 99 return 0; 8. 作用域 作用域定义了标识符（变量名、函数名等）在代码中的可见范围。合理利用作用域可以避免命名冲突，是模块化编程的基础。 作用域的类型 块作用域: 范围: 一对花括号 内部。 特点: 在代码块内定义的变量（局部变量）仅在该块内可见，从定义处开始到右花括号结束。 遮蔽 : 内层作用域可以定义与外层同名的变量，此时内层变量会临时遮蔽外层变量。 int a = 100; // 全局作用域int main() // main函数的块作用域 int a = 200; // 遮蔽全局a, 此处a为200 // 内部块作用域 int a = 300; // 再次遮蔽, 此处a为300 printf(%d , a); // 输出: 300 printf(%d , a); // 输出: 200, 内部块结束, 遮蔽解除 文件作用域: 范围: 从定义处开始，到当前源文件末尾。 特点: 在任何函数之外定义的变量（全局变量）具有文件作用域。默认情况下，全局变量可以被其他文件通过 extern 关键字访问。 // a.c 文件int global_var = 10; // 全局变量, 文件作用域// b.c 文件extern int global_var; // 声明以访问a.c中的全局变量void use_global() printf(%d , global_var); // 输出: 10 函数原型作用域: 范围: 仅限于函数声明的括号内。 特点: 参数名只在声明中起解释作用，在编译时会被忽略，可以省略。 // a 和 b 的作用域仅在此行void func(int a, int b); static 对全局变量/函数的影响 当 static 用于修饰全局变量或函数时，它会改变标识符的链接属性，从“外部链接(external)”改为“内部链接(internal)”。 效果: static 修饰的全局变量或函数的作用域被限制在当前源文件内，其他 .c 文件无法通过 extern 关键字访问它们。 这对于信息隐藏和模块化编程至关重要，可以有效避免不同模块间的命名冲突。 （关于 static 的全面总结，看笔记 12.4 节） // a.c 文件static int file_local_var = 5; // 此变量仅在 a.c 中可见static void helper_func() /* ... */ // 此函数仅在 a.c 中可调用// b.c 文件// extern int file_local_var; // 错误！无法链接到 a.c 中的 static 变量// extern void helper_func(); // 错误！无法链接到 a.c 中的 static 函数 第三部分：C 语言的精髓：指针与复合类型 9. 数组 数组定义与初始化 定义: 类型说明符 数组名 [常量表达式]; 初始化: int b1[5] = 1, 2, 3, 4, 5; // 完全初始化int b3[5] = 1, 2, 3; // 部分初始化，其余元素为未知int b4[] = 1, 2, 3, 4, 5; // 根据初始化内容推断大小int b6[5] = [0 ... 4] = 1; // GCC/Clang 的扩展：指定初始化所有元素为1 数组元素引用 通过下标访问: 数组名[下标]，下标从 0 开始。 long a[5] = 1, 2, 3, 4, 5;printf(%d , a[1]); // 输出第二个元素: 2 字符数组与多维数组 字符数组初始化: char s1[3] = a, b, c;char s3[5] = abc; // 自动在末尾添加 \\0 多维数组定义与初始化: //编译器里只有一维数组int (c[3]); // 内存分布： |int|int|int|//二维数组定义分为以下两个部分// 1, x[3] 是数组的定义，表示该数组拥有3个元素// 2, int [4]是元素的类型，表示该数组元素是一个具有4个元素的整型数组int (x[3]) [4]; // 内存分布： |int[4]|int[4]|int[4]| // 定义一个3行4列的二维数组int y1[3][4] = 1,2,3,4, 4,5,6,7, 6,7,8,9 ;// 可以省略第一维的大小int y4[][4] = 1,2,3,4, 4,5,6,7 ; [面试题实战] 二维数组边界元素遍历 这是一个常见的算法问题，考验对二维数组索引的精确控制能力。 代码示例 (天彩电子-23.c) ##include stdio.h##include stdlib.h##include time.hvoid show(int N, int w[N][N]) for(int i=0; iN; i++) for(int j=0; jN; j++) printf(%d\\t, w[i][j]); printf( ); int main(int argc, char const *argv[]) int N = 5; // 示例大小 int w[N][N]; srand(time(NULL)); for(int i=0; iN; i++) for(int j=0; jN; j++) w[i][j] = rand()%1000; printf(生成的 %d x %d 数组: , N, N); show(N, w); if(N == 1) printf(周围数据平均数是: %f , (float)w[0][0]); return 0; float sum = 0.0; // 累加首行和末行 for(int i=0; iN; i++) sum += w[0][i]; // Top row sum += w[N-1][i]; // Bottom row // 累加首列和末列（不含已计算过的角点） for(int i=1; iN-1; i++) sum += w[i][0]; // Left column (excluding corners) sum += w[i][N-1]; // Right column (excluding corners) // 总边界元素个数为 4*N - 4 printf( 边界元素总和: %.2f , sum); printf(边界元素平均数是: %f , sum / (4.0 * N - 4.0)); return 0; 10. 指针 指针定义与赋值 指针: 存储另一个变量的内存地址。 定义: 类型说明符 *指针变量名; 赋值 (取地址): 使用 运算符获取变量地址。 int a;int *p; // p是一个指针，准备指向一个int型变量p = a; // 将变量a的地址赋给p（取地址） 指针解引用 解引用: 使用 * 运算符访问指针指向的内存地址中的值。 *p = 100; // 将p指向的地址(即变量a)的值设为100printf(%d, a); // 输出 100 野指针与空指针 野指针: 指向不确定或已释放内存的指针。 避免: 初始化时置为 NULL，释放后也置为 NULL。 空指针: 不指向任何对象的指针，其值为 NULL。 int *p = NULL; // 良好习惯：初始化指针为NULL 指针运算 对指针进行 +, - 运算，其移动的单位是指针所指向类型的大小。 long a[5] = 1, 2, 3, 4, 5;// a是数组首元素地址，a+1指向第二个元素printf(%d , *(a + 1)); // 输出 2 面试题实战 - const指针的三种模式辨析 const int *p: 常目标指针。指针指向的内容 *p 不可变，但指针自身 p 的指向可以改变。 记忆：const 在 * 左边，修饰的是目标。 int * const p: 常指针。指针自身 p 的指向不可变，但指针指向的内容 *p 可以改变。 记忆：const 在 * 右边，修饰的是指针 p。 const int * const p: 指针自身和其指向的内容都不可变。 代码示例： int a = 10, b = 20;// 1. 常目标指针const int *p1 = a;// *p1 = 100; // 错误: 不能通过p1修改a的值p1 = b; // 正确: p1可以指向其他变量// 2. 常指针int * const p2 = a;*p2 = 100; // 正确: 可以通过p2修改a的值// p2 = b; // 错误: p2的指向不能改变// 3. 两者都不可变const int * const p3 = a;// *p3 = 100; // 错误// p3 = b; // 错误 11. 数组与指针的关系 数组名即指针 在任意表达式中（除了 sizeof 和之外），数组名 a 都代表数组的首地址 a[i] 本质上是 *(a + i) 的语法糖。 long a[5] = 1, 2, 3, 4, 5;// a[1] 和 *(a[0]+1) 和 *(a+1) 是等价的printf(%d , a[1]); // 输出 2printf(%d , *(a + 1)); // 输出 2printf(%d , *a); //1printf(%#lun , a); //a的首地址 另外一个例子： 如果看起来吃力，可以先看 7.0 复杂指针解读方法 #include stdio.hint main(int argc, char const* argv[]) // a: 二维整型数组 // a 是一个包含2个元素的数组，它的每个元素是“一个包含3个int的数组”。 int a[2][3] = 1, 2, 3, 5, 6, 7; // b: 数组指针 // b 是一个指针数组，它其中的每个元素指向的目标是“一个包含3个int的数组”。 int (*b)[3]; int sum = 0; b = a; for (int i = 0; i sizeof(a) / 4; i++) // b 指向 a 的第一行，*b 的类型是 int[3] // 在表达式中，*b 会退化为指向其首元素(a[0][0])的指针 // 因此 **b 就是 a[0][0] 的值 sum += *(*b + i); // c: 数组指针的数组 // c 是一个包含2个元素的数组，它的每个元素是“一个指向包含3个int的数组的指针”。 int (*c[2])[3] = a[0], a[1]; // c[]存a[]的地址 for (int i = 0; i 2; i++) for (int j = 0; j 3; j++) // c[i]存a[i]的地址,a[i]是个数组 // 因为这是一个数组，所以也可以等于首元素1的地址 // 向右移动int类型的4字节，得到2的地址 // **c[i]解引用得到地址里的值2 sum += *(*c[i] + j); // d: 二维指针数组 // d 的每个元素(d[i][j])的类型是“指向int的指针(int *)”。 int* d[2][3]; for (int i = 0; i 2; i++) for (int j = 0; j 3; j++) d[i][j] = a[i][j]; for (int i = 0; i 2; i++) for (int j = 0; j 3; j++) sum += *d[i][j]; printf(%d , sum); return 0; 函数中的数组参数 数组作为函数参数时，实际上传递的是指向数组首元素的指针。 void func(int arr[]) 的写法本质上等价于 void func(int *arr)。编译器会自动将数组形式的参数转换为指针。 核心规则: 在任意表达式中（除了 sizeof 和之外），数组名 a 都代表数组的首地址。当数组名作为函数实参传递时，它被转化为指向其首元素的指针。 #include stdio.h// 参数 k[3] 实际上是一个指针 (int *k)，因此 sizeof(k) 会得到指针的大小（通常是8字节 on 64-bit system）// 而不是数组的大小 (3 * 4 = 12 字节)。void f1(int a, float f, int *p, int k[3]) printf(sizeof(k) in function: %ld , sizeof(k)); // 输出指针大小, e.g., 8int main(int argc, char const *argv[]) int a = 100; float f = 1.23; int *p = a; int k[3] = 1, 2, 3; printf(sizeof(k) in main: %ld , sizeof(k)); // 输出数组大小, 12 // 当数组 k 作为参数传递时，它退化为指向 k[0] 的指针 f1(a, f, p, k); return 0; 12. 特殊数组与高级指针 复杂指针解读方法 核心方法：右左法则 (Right-Left Rule) 从 变量名 开始。 优先向 右 看，遇到 [] (数组) 或 () (函数)。 再向 左 看，遇到 * (指针)。 遇到括号，先解析完括号内的，再跳出。 最后，读最左边的 类型名。 示例 1：数组指针 int (*b[2])[3];// 1. b: b 是一个...// 2. b[2]: ...包含2个元素的数组// 3. (*b[2]): 数组的元素是 指针// 4. (*b[2])[3]: 指针指向 一个含3个int类型元素的数组// 结论: b 是一个包含2个元素的数组，每个元素都是一个指针，指向一个包含3个int的数组 示例 2：函数指针与 typedef 最佳实践 对于极端复杂的声明，手动分析既困难又易错。最佳实践是使用 typedef 定义别名。 识别步骤 找到标识符 signal。 向右看，是 ()，说明 signal 是一个函数。 signal 函数括号内接收两个参数：int sig 和 void (*func)(int) 对于第二个参数 func，我们可以独立应用右左法则：func 是一个指向“接收 int，返回 void”的函数的指针 解析完函数参数，回到 signal，向左看，是 *。说明 signal 函数的返回值是一个指针 跳出 signal(…) 的范围，继续向右看，是 (int)。说明 signal 返回的那个指针，指向一个接收 int 参数的函数 最后，看最左边的类型 void。这个函数返回 void 类型 // 原始声明，难以阅读void (*signal(int sig, void (*func)(int)))(int);// 最佳实践: 使用 typedef 别名简化// 1. 为该函数指针类型起一个清晰的别名typedef void (*handler_t)(int);// 2. 使用别名重写声明，一目了然handler_t signal(int sig, handler_t func); 零长数组 GNU C 扩展，type name[0]，用于变长结构体，不占用结构体大小。 struct stu int age; float score; char sign[0]; // 零长数组成员;// 为结构体和签名分配连续内存struct stu *s = malloc(sizeof(struct stu) + 10);strcpy(s-sign, helloworl);printf(%s , s-sign); // 输出 helloworl 变长数组 C99 标准引入，数组大小在运行时由变量确定。 注意: 变长数组具有自动存储期（即在栈上分配），因此不能使用 static 关键字修饰。 int len = 5;int b[len]; // 正确：在栈上创建变长数组// static int c[len]; // 错误：static数组的大小必须在编译时确定// 无法在编译时给运行时确定大小的数组初始化// int b[len] = 1,2,3,4,5;for (int i = 0; i len; i++) b[i] = 666; 字符指针 char *s = hello; 指针 s 指向一个字符串字面量（是只读的）。 char *p = abcd;printf(%s , p + 1); // 输出 bcdchar *k[3] = 12345, abcddegg, www.yeu;printf(%s , *k); // 12345printf(%s , *(k + 1)); // 输出 abcddeggprintf(%s , k[0] + 1); // 2345printf(%c , *(k[0] + 1)); //2 [!WARNING] 通过 char *p = “hello”; 创建的指针 p 指向的是一个字符串字面量。字符串字面量通常存储在内存的只读数据段 (.rodata)。 任何试图通过指针修改其内容的行为都是未定义的，通常会导致程序崩溃（段错误）。 char *p = hello;p[0] = H; // 错误！非常危险的操作！ 如果你需要一个可以修改的字符串，必须使用数组来创建：char s[] = “hello”; void 指针 通用指针 void *，可存储任何类型的地址，但不能直接解引用，需先强制类型转换。 void *m = malloc(20);// 将void*指针转换为int*指针再进行操作for (int i = 0; i 5; i++) *((int *)m + i) = i*100; printf(%d , *((int *)m + i)); const 指针 const int *p: const 修饰*p，指针指向的内容不可变 (常目标指针)。 int const *p: const 修饰*p，指针指向的内容不可变 (常目标指针)。 int * const p: const 修饰 p，指针自身存的地址不可变 (常指针)。 int a = 100;// 常指针: const修饰指针变量p，p的指向不可改，但*p的值可改 (可读写它指向的内容但无法修改它指向谁)int *const p = a;*p = 200; // OK// p = b; // Error// 常目标指针: const修饰类型int，*k的值不可改，但k的指向可改（只读不写）const int *k = a;// *k = 300; // Errork = b; // OK 多级指针 指向指针的指针，如 int **p。 int w [10]; // w的类型是int [10]int (*pw) [10]; // 一级指针int (**pw2)[10]; // 二级指针，pw2--pw --w(*pw) [0] = 666;(**pw2)[0] = 666;printf(%p , w); // 输出 数组w的首地值printf(%d , w[0]); // 输出: 666printf(%d , (*pw)[0]); // 输出: 666 函数指针 指向函数的指针，是实现回调函数等高级技巧的基础。 定义: 返回类型 (*指针名)(参数列表); #include stdio.h// 这是一个普通函数int maxValue(int a, int b) return a b ? a : b;// 这是一个接收函数指针作为参数的函数void f(int (*function)(int a, int b)) printf(通过函数指针调用，结果: %d , function(7, 8));int main(int argc, char const *argv[]) // 1. 定义一个函数指针p，它专门指向“接收两个int，返回int”的函数 int (*p)(int a, int b); // 2. 将函数maxValue的地址赋给p // 特殊语法：函数名取地址时，可以省略 p = maxValue; // 3. 通过函数名直接调用 int m = maxValue(2, 3); printf(直接调用，结果: %d , m); // 4. 通过函数指针p间接调用 // 特殊语法：通过��数指针调用函数时，解引用*可以省略 int n = p(3, 4); printf(通过指针调用，结果: %d , n); // 5. 将函数名作为参数传递 f(maxValue); return 0; 13. 结构体 (Struct) 结构体是 C 语言的核心特性，它允许我们将不同类型的数据项组合成一个单一的、逻辑相关的整体。 定义、初始化与使用 定义: 使用 struct 关键字创建一个“蓝图”，描述这个复合数据类型包含哪些成员。 变量: 根据“蓝图”定义实际的结构体变量。 初始化: 传统初始化: 按顺序为成员赋值 ...。 指定成员初始化: 使用 .成员名 = 值 的方式，可以不按顺序，更清晰。 成员访问: 对结构体变量，使用点运算符 .。 对结构体指针，使用箭头运算符 - (它等价于 (*指针).成员 的语法糖)。 ###include stdio.h###include stdlib.h// 1. 定义一个结构体类型（设计蓝图）// 结构体类型名叫studentstruct student // 成员 int age; float score; char *name; // 内嵌结构体 struct char *name; float price; book;//结构体变量叫book;// 推荐将结构体作为指针传递，避免内存拷贝开销void show_student_info(const struct student *p);int main(int argc, char const *argv[]) // 2. 定义结构体变量并初始化 // 传统初始化，按成员顺序赋值 struct student zhangsan = 20, 90.0, zhangsan, 嵌入式参考书, 40.5; // 指定成员初始化 (推荐) // 顺序改变不影响给成员赋值 struct student lisi = .age = 21, .name = lisi, .book = .name = 数学书, .price = 20.0, .score = 70.0; // 3. 访问成员 printf(姓名：%s , zhangsan.name); printf(教材价格：%f , zhangsan.book.price); // 推荐通过指针访问，指针只有8字节，而结构体变量本身可能很大 // 如果直接传递结构体（值传递），会复制整个结构体到栈上，开销巨大 struct student *p = lisi; printf(姓名：%s , p-name); // 箭头运算符 printf(分数：%f , (*p).score); // 等价的点运算符形式 show_student_info(zhangsan); return 0;void show_student_info(const struct student *p) printf(----学生信息---- ); printf(姓名：%s , p-name); printf(分数：%f , p-score); 结构体内存对齐 为了让 CPU 高效访问内存，编译器会自动对结构体成员进行对齐。 对齐规则: 每个成员的地址会是其自身大小的整数倍。例如，int (4 字节) 会被放在能被 4 整除的地址上。 填充: 为了满足对齐，编译器可能会在成员之间填充一些“空白”字节。 整体大小: 整个结构体的大小，会是其最宽成员大小的整数倍。 取消对齐: 在某些特定场景（如处理硬件数据流），可以使用 __attribute__((packed)) (GCC/Clang 扩展)来告诉编译器不要进行内存对齐，以节省空间。 ###include stdio.h// M = 结构体成员占用最大的成员占用大小 = 4struct node int a; // 4字节, 放在偏移0处, size=4 char c; // 1字节, 放在偏移4处, size=5 short f; // 2字节, 放在偏移6处(需对齐到2的倍数), size=8 // 编译器在c和f之间填充了1个字节; // 整体大小需为M(4)的倍数, 8已经是4的倍数, 所以最终大小为8// 使用packed属性取消对齐struct node_packed int a; char c; short f; __attribute__((packed));int main(int argc, char const *argv[]) printf(默认对齐大小: %ld , sizeof(struct node)); // 输出: 8 printf(取消对齐大小: %ld , sizeof(struct node_packed)); // 输出: 7 (4+1+2) return 0; 位域 (Bit-field) 位域允许我们在结构体中定义宽度为“位”(bit)的成员，这对于需要精确控制内存布局（如硬件寄存器、网络协议）的场景非常有用。 定义: 类型 成员名 : 位数; 限制: 成员必须是整型 (int, unsigned int, char等)。 不能对位域成员取地址 ()。 建议成员尽量是同类型，不然对于某些平台可能会出现内存没有按照预期对齐的问题 ###include stdio.h// 模拟一个硬件设备的数据包struct device_data // 2字节(16位)上存储了温度和湿度 unsigned short temp : 8; // 低8位 unsigned short humi : 8; // 高8位 // 1字节(8位)上存储了8个开关状态 unsigned char door1 : 1; unsigned char door2 : 1; unsigned char door3 : 1; unsigned char door4 : 1; unsigned char light1 : 1; unsigned char light2 : 1; unsigned char light3 : 1; unsigned char light4 : 1;;int main(int argc, char const *argv[]) struct device_data d; unsigned int input_data = 0x5A96F5; // 假设从硬件读到数据 // 将数据直接映射到结构体 d = *(struct device_data *)input_data; printf(原始数据: %#x , input_data); printf(温度：%d°C , d.temp); // 0xF5 - 245 printf(湿度：%d%% , d.humi); // 0x96 - 150 printf(门1的状态：%s , d.door1 ? 开 : 关); // 0x5 - 0101, door1=1 printf(灯4的状态：%s , d.light4 ? 开 : 关); // 0x5 - 0101, light4=0 return 0; 14. 联合体 (Union) 联合体所有成员共享同一块内存空间，其大小由最大的成员决定。这使得联合体非常适合表示“互斥”的数据。 特点: 任何时刻，只有一个成员是有效的。 对一个成员赋值，会覆盖其他成员的值。 初始化: 默认初始化第一个成员。 使用指定成员初始化法可以初始化任意成员，但只有最后被初始化的那个有效。 ###include stdio.h// 定义一个联合体类型union attribute int i_val; char c_val; double d_val;;int main(int argc, char const *argv[]) printf(联合体大小: %ld , sizeof(union attribute)); // 8, 由double决定 // 指定成员初始化，只有最后一个有效 union attribute attr = .i_val = 100, .c_val = k, .d_val = 3.14; // 此时只有 d_val 是有效的 printf(d_val: %lf , attr.d_val); // 正确输出 3.14 // 读取其他成员会得到无意义的数据 printf(i_val: %d , attr.i_val); // 输出垃圾值 printf(c_val: %c , attr.c_val); // 输出垃圾值 // 重新赋值 attr.i_val = 999; printf( 赋值后 i_val: %d , attr.i_val); // 正确输出 999 printf(d_val: %lf , attr.d_val); // d_val被覆盖，输出垃圾值 return 0; 15. 枚举 (Enum) 枚举用于定义一组命名的整数常量，它比使用 #define 更具优势，因为枚举是类型安全的，且调试器可以识别枚举名。 定义: enum 枚举名 常量1, 常量2, ...; 赋值: 默认从 0 开始，依次递增。 -可以手动为任何一个常量指定一个整数值，后续未指定的常量会在此基础上递增。 ###include stdio.h// 定义交通灯颜色的枚举enum traffic_light RED, // 默认为 0 GREEN, // 在RED基础上+1, 为 1 YELLOW=10, // 手动指定为 10 BLUE // 在YELLOW基础上+1, 为 11;int main(int argc, char const *argv[]) // 定义枚举变量 enum traffic_light color = YELLOW; printf(RED=%d, GREEN=%d, YELLOW=%d, BLUE=%d , RED, GREEN, YELLOW, BLUE); if (color == YELLOW) printf(当前颜色是黄灯, 请注意! ); return 0; 第四部分：构建大型程序 16. volatile关键字 volatile 是一个类型修饰符，它告诉编译器，被修饰的变量可能会在任何时候被程序外部的因素（如硬件、中断服务程序、其他线程）意外地改变。 核心作用: 防止编译器过度优化。确保每次访问该变量时，都直接从其内存地址中读取，而不是使用可能已过时的寄存器缓存值。 使用场景: 硬件寄存器: 嵌入式系统中，硬件状态寄存器的值会由硬件实时更新。 多线程共享变量: 一个变量被多个线程共享和修改时。 中断服务程序: 中断处理函数中会修改的全局变量。 代码示例 // 示例：一个可能被硬件修改的状态寄存器volatile unsigned int *DEVICE_STATUS_REGISTER = (unsigned int *)0x12345678;void check_device() // 每次循环都必须从内存地址0x12345678重新读取状态 // 如果没有volatile，编译器可能优化为只读一次，导致死循环 while (*DEVICE_STATUS_REGISTER == 0) // 等待设备就绪... // ...设备已就绪，继续操作... 17. 预处理与高级技巧 高级宏定义 宏在预处理阶段进行简单的文本替换，功能强大但易出错。 宏运算符# (字符串化) ## (连接) #: 将宏参数转换为一个字符串字面量。 ##: 将两个记号（token）连接成一个记号。 ###include stdio.h// 使用 # 将宏参数 a 和 b 变成字符串###define DOMAIN_NAME(a, b) www. #a . #b .com// 使用 ## 连接参数，构造函数名###define LAYER_INITCALL(num, layer) __zinitcall_##layer##_##num// 模拟内核的初始化函数void __zinitcall_service_1(void) printf(%s , __FUNCTION__); void __zinitcall_feature_2(void) printf(%s , __FUNCTION__); int main(int argc, char const *argv[]) // # 的使用 printf(%s , DOMAIN_NAME(yueqian, lab)); // 输出: www.yueqian.lab.com // ## 的使用 LAYER_INITCALL(1, service)(); // 宏展开为: __zinitcall_service_1(); LAYER_INITCALL(2, feature)(); // 宏展开为: __zinitcall_feature_2(); return 0; 安全的带参宏 (GCC 扩展) 简单的带参宏有副作用风险（如 MAX(a++, b)）。Linux 内核中广泛使用 (...) 语句表达式和 typeof 关键字 (均为 GCC 扩展) 来创建更安全的宏。 typeof(x): 获取变量 x 的类型。 (...): 语句表达式，将多条语句包裹成一个单一的表达式，其值为最后一条语句的结果 将多句话整合为一句话 ()将内部的 {…} 代码块“提升”为一个表达式，使其可以被赋值或用在其他需要值的地方。 ###include stdio.h// 传统宏的风险// #define MAX(a, b) ((a) (b) ? (a) : (b))// 安全的、类型通用的宏 (Linux内核风格)###define MAX(a, b) ( \\ typeof(a) _a = (a); \\ typeof(b) _b = (b); \\ (void) (_a == _b); /* 警告: 如果a和b类型不同 */ \\ _a _b ? _a : _b; \\)int main(int argc, char const *argv[]) int x = 10; int y = 20; // 对于 MAX(x++, y++)，传统宏会将++执行两次，而安全宏只执行一次 printf(Max is %d , MAX(x, y)); float f1 = 3.14, f2 = 2.71; printf(Max is %f , MAX(f1, f2)); // 不同类型的参数会产生编译警告 // printf(Max is %f , MAX(x, f1)); return 0; 内联函数 (inline) 对于功能简单、调用频繁的函数，函数调用的开销可能超过函数本身的执行时间。inline 关键字建议编译器将函数体直接嵌入到调用处，以消除调用开销。 特点: 它是对编译器的建议，而非强制命令。 相比宏函数，内联函数有类型检查，更安全。 内联函数的定义通常放在头文件中。 适用场景: 函数体小，且被频繁调用的函数。 inline.h 文件: // inline.h###ifndef INLINE_H###define INLINE_H// 将简短、频繁调用的函数定义为inlinestatic inline int max2(int a, int b) return a b ? a : b;###endif main.c 文件: ###include stdio.h###include inline.hint main(int argc, char const *argv[]) // 编译器可能会将 max2 的函数体直接替换到这里 printf(%d , max2(1, 2)); printf(%d , max2(10, 20)); return 0; 18. 多文件编程与头文件 随着项目变大，将所有代码放在一个.c文件里是不可行的。我们需要将代码按模块拆分到多个.c和.h文件中。 条件编译 条件编译允许我们根据编译时定义的宏，来决定哪些代码块被编译，哪些被忽略。这对于编写平台兼容代码、管理调试信息等非常有用。 #if / #elif / #else / #endif: 基于宏的值进行判断，功能类似if-else。 #ifdef 宏名: (if defined) 如果宏宏名已被定义，则编译后续代码。 #ifndef 宏名: (if not defined) 如果宏宏名未被定义，则编译后续代码。 ###include stdio.h// 可以在代码中定义宏###define FEATURE_A 1###define FEATURE_B 0// 也可以在编译时通过-D选项定义，例如: gcc -DDEBUG_MODE condition.c// #define DEBUG_MODEint main(int argc, char const *argv[]) #if FEATURE_A printf(功能A已启用。 ); #endif #if FEATURE_B printf(功能B已启用。 ); #else printf(功能B未启用。 ); #endif // 常用于输出调试信息 #ifdef DEBUG_MODE printf(调试信息: 进入函数 %s, 第 %d 行 , __FUNCTION__, __LINE__); #endif #ifndef RELEASE_MODE printf(当前为非发布版本。 ); #endif return 0; 头文件的作用与设计 头文件 (.h) 是多文件编程的核心，它扮演着模块“接口说明书”的角色。 头文件的内容: 全局变量的声明: 使用 extern 关键字告知其他文件该变量的存在。 (extern int g_count;) 函数声明: 告知其他文件该函数的存在。 (void print_hello(void);) 宏定义: 模块提供的常量或宏函数。 (#define MAX_USERS 100) 结构体/联合体/枚举的定义: 允许多个.c文件使用相同的数据结构。 static inline 函数: 对于小且频繁调用的函数，可以定义在头文件中。 头文件防卫 : 为了防止同一个头文件在编译时被重复包含（这会导致重定义错误），必须使用ifndef机制。这是强制性的最佳实践。 my_module.h 文件示例: // 1. 头文件防卫开始###ifndef __MY_MODULE_H__###define __MY_MODULE_H__// 2. 包含此模块依赖的其他头文件###include stdio.h// 3. 模块的“接口”声明###define MODULE_VERSION 1.0extern int g_module_status; // 全局变量声明struct my_data; // 结构体声明void module_init(void); // 函数声明int module_get_status(void);// static inline函数可以直接在头文件中实现static inline void print_version() printf(Version: %s , MODULE_VERSION);// 4. 头文件防卫结束###endif // __MY_MODULE_H__ my_module.c 文件 (模块的实现): ###include my_module.h // 首先包含自己的头文件// 全局变量的定义int g_module_status = 0;// 结构体的具体定义struct my_data int id; char *name;;// 函数的具体实现void module_init(void) g_module_status = 1; printf(模块已初始化。 );int module_get_status(void) return g_module_status; main.c 文件 (模块的使用者): ###include my_module.h // 包含模块头文件以使用其功能int main() module_init(); printf(模块状态: %d , module_get_status()); print_version(); return 0; 19. 常用字符串函数 strlen - 获取长度 lenth 返回字符串的长度，不包括末尾的 \\0。 size_t len = strlen(hello); // len 的值为 5 strcpy - 字符串复制 copy strncpy是strcpy的安全版本，推荐使用以防止内存溢出。 char dest[10] = 123456789;// 复制hello到dest，最多复制sizeof(dest)-1个字符strncpy(dest, hello, sizeof(dest) - 1);dest[sizeof(dest) - 1] = \\0; // 确保字符串以\\0结尾// dest现在是 hello strcat - 字符串拼接 catch strncat是strcat的安全版本，推荐使用。 char dest[10] = Hi, ;// 将Bob拼接到dest末尾strncat(dest, Bob, sizeof(dest) - strlen(dest) - 1);// dest现在是 Hi, Bob strcmp - 字符串比较 compare 按字典序比较字符串，返回 0 (s1s2), 0 (s1==s2), 0 (s1s2)。 int result = strcmp(abc, abd); // result 0 strchr - 查找字符 char strchr: 从左向右查找第一个匹配的字符。 strrchr: 从右向左查找第一个匹配的字符。 char *p = strchr(a.b.c.d, .); // p 指向 .b.c.d strstr - 查找子串 string 在字符串中查找子字符串首次出现的位置。 char *p = strstr(main.c, .c); // p 指向 .c strtok - 分割字符串 token 注意: 此函数会修改原始字符串。首次调用传入字符串，后续调用传入 NULL。 char str[] = www.yueqian.com;char *p = strtok(str, .); // p 指向 wwwwhile (p != NULL) printf(%s , p); p = strtok(NULL, .);// 依次输出: www, yueqian, com 第五部分：高级应用入门 20. 算法入门 经典排序：冒泡排序 问题: 实现冒泡排序算法。 核心知识: 通过重复遍历数组，比较相邻元素并交换，每一趟都将当前未排序部分的最大（或最小）元素“冒泡”到最终位置。 代码示例: void bubble_sort(int len, int A[]) for (int i = 0; i len - 1; i++) for (int j = 0; j len - i - 1; j++) if (A[j] A[j + 1]) int temp = A[j]; A[j] = A[j + 1]; A[j + 1] = temp; 21. 数据结构入门 单链表 单链表是一种动态数据结构，它由一系列节点组成，每个节点包含数据和一个指向下一个节点的指针。 核心思想: 在堆内存中动态创建节点 (malloc)，并通过指针将这些分散的节点链接成一个有序序列。 关键知识点: struct 结构体：用于定义链表节点。 malloc / free：动态内存分配和释放。 指针操作：通过 p-next 遍历和操作链表。 ###include stdio.h###include stdlib.h// 1. 定义链表节点结构体typedef struct Node int data; struct Node *next; Node;// 2. 创建新节点Node* create_node(int data) Node *new_node = (Node*)malloc(sizeof(Node)); if (new_node == NULL) return NULL; new_node-data = data; new_node-next = NULL; return new_node;// 3. 打印链表void print_list(Node *head) Node *current = head; while (current != NULL) printf(%d - , current-data); current = current-next; printf(NULL );int main() // 创建链表: head - node1 - node2 Node *head = create_node(10); head-next = create_node(20); head-next-next = create_node(30); print_list(head); // 输出: 10 - 20 - 30 - NULL // 释放链表内存 (此处省略) return 0; 22. 面试题精选 巧妙的级数求和 问题: 计算 S = 1 - 1/2 + 1/3 - 1/4 + ... + 1/99 - 1/100。 核心知识: 直接计算涉及大量浮点减法，可能损失精度。通过数学变换可以优化： S = (1 + ... + 1/100) - 2 * (1/2 + ... + 1/100) = (1 + ... + 1/100) - (1 + ... + 1/50) = 1/51 + ... + 1/100 这个变换将问题转换成了一个简单的正项级数求和。 代码示例: ##include stdio.h// 计算 S = 1 - 1/2 + 1/3 - 1/4 + ... + 1/99 - 1/100 的值int main(int argc, char const *argv[]) float sum = 0; int i = 1; while (i = 100) if (i % 2 == 1) sum += 1.0 / i; else sum -= 1.0 / i; // 或者：sum+=pow(-1,i+1)*(1/(float)i); //用(-1)的i+1次方代替判断，需要引用数学库 // 或者：sum+=1/(i*(i+1)); //规律是（1-1/2=1/2）(1/3-1/4=1/12)(1/5-1/6=1/30) // 或者 // for (int i = 51; i = 100; i++) sum_a += 1.0 / i; // 将加法和减法分开： // S = (1 + 1/3 + 1/5 + ... + 1/99) - (1/2 + 1/4 + 1/6 + ... + 1/100) // 然后，加上减去的部分，减去两倍的部分： // S = (1 + 1/2 + 1/3 + ... + 1/100) - 2 * (1/2 + 1/4 + 1/6 + ... + 1/100) // 然后吧后半部分的2乘进去： // S = (1 + 1/2 + 1/3 + ... + 1/100) - (1 + 1/2 + 1/3 + ... + 1/50) // 所以： // S = (1/51 + 1/52 + 1/53 + ... + 1/100) i++; printf(%f ,sum); return 0; 凑零钱问题 ##include stdio.hint main(int argc, char const *argv[]) // 目标：用1元、2元、5元的纸币凑出100元 int num = 0; for(int i=0; i=20; i++) // i个5元 for(int j=0; j=50; j++) // j个2元 // 剩下的用1元补足 if(100 - i*5 - j*2 = 0) num++; printf(num: %d, num); return 0; 解法二 ##include stdio.hint main() int count = 0; for (int i = 0; i = 100 / 5; i++) for (int j = 0; j = (100 - 5 * i) / 2; j++) int k = 100 - 5 * i - 2 * j; // printf(5元: %d个, 2元: %d个, 1元: %d个, i, j, k); count++; printf(使用数值 1, 2, 5 组合成 %d，共有 %d 种不同的组合。, 100, count); return 0; 统计数字’1’的出现次数 ##include stdio.h// 计算从1到n的整数中，数字1出现的总次数long long count(int n) if (n 1) return 0; long long count = 0; long long base = 1; int round = n; while (round 0) int weight = round % 10; round /= 10; count += round * base; if (weight == 1) count += (n % base) + 1; else if (weight 1) count += base; base *= 10; return count;int main() unsigned int n = 213; printf(从 1 到 %u, 数字 1 出现的总次数为: %lld, n, count(n)); return 0; 二维数组边界元素求平均值 ##include stdio.h##include stdlib.h##include time.hvoid show(int N, int w[N][N]) for(int i=0; iN; i++) for(int j=0; jN; j++) printf(%d , w[i][j]); printf(); int main(int argc, char const *argv[]) int N = 5; // Example size int w[N][N]; srand(time(NULL)); for(int i=0; iN; i++) for(int j=0; jN; j++) w[i][j] = rand()%1000; show(N, w); if(N == 1) printf(周围数据平均数是: %f, (float)w[0][0]); return 0; float sum = 0.0; for(int i=0; iN; i++) sum += w[0][i]; // Top row sum += w[N-1][i]; // Bottom row for(int i=1; iN-1; i++) sum += w[i][0]; // Left column (excluding corners) sum += w[i][N-1]; // Right column (excluding corners) printf(周围数据平均数是: %f, sum/(4.0*N-4.0)); return 0; 23. 扩展阅读 (待补充…) 24. 笔记总结 C 语言的核心是围绕指针、内存管理和作用域/存储期这三大支柱展开的，static关键字是贯穿其中的关键。 基础与类型系统：程序由main函数启动，其根本是数据类型。必须精确掌握int, char, double等类型与printf/scanf格式说明符的对应关系： printf中%f可通用打印float和double（因float参数会自动提升为double）；而scanf接收double必须用%lf。 scanf通过传递变量地址来实现对调用方变量的修改，务必警惕其输入缓冲区的残留问题。 运算符与表达式：重点掌握逻辑运算的短路求值（, ||）、高效的位运算（, |, ^, ~, , ）、条件运算符? :以及sizeof（它是一个运算符，不是函数）。当不确定优先级时，用**圆括号()**是最佳实践。 控制流：熟练运用if-else、switch（牢记case的穿透特性与break的重要性）、for/while/do-while循环，以及break（跳出循环/switch）、continue（跳过本次迭代）、return（终止函数）三种跳转语句。 指针（难点中的难点）： 核心操作：指针是存储地址的变量，用取地址、*解引用。必须初始化为NULL以防野指针。 数组与指针：在表达式中（除sizeof和外），数组名会 “降维/退化” 为指向其首元素的指针，因此a[i]本质是*(a+i)的语法糖。这也导致数组作为函数参数时，sizeof在函数内外结果不同。 const修饰：必须严格区分“指向常量的指针”（const int *p，*p不可改，p可改）和“常量指针”（int * const p，p不可改，*p可改）。 高级指针：理解void*作为通用指针（使用前须强制类型转换），以及函数指针（返回类型 (*指针名)(参数)）作为实现回调函数的基础。 内存布局： 代码段 (.text)：存放二进制指令，只读。 数据段： .rodata：存放字符串字面量、const全局变量，只读。 .data：存放已初始化的全局变量和静态变量。 .bss：存放未初始化的全局变量和静态变量，程序启动时系统自动清零。 栈 (Stack)：存放函数的局部变量和参数，由编译器自动管理，空间有限，有栈溢出风险。严禁返回局部变量的地址，因其在函数返回后即被销毁。 堆 (Heap)：由程序员通过malloc/calloc/realloc/free手动管理，空间巨大但易产生内存泄漏（忘记free）或悬空指针（free后未置NULL）。 static关键字（重中之重）： 修饰局部变量：改变其存储期（从自动存储期改为静态存储期），使其从栈移至数据段。变量生命周期与程序相同，其值在函数多次调用间保持不变。 修饰全局变量/函数：改变其链接属性（从外部链接改为内部链接），使其作用域被限制在当前源文件内，是实现模块化和信息隐藏的关键。 复合类型： struct：将不同类型数据聚合成单一实体，是 C 语言实现面向对象思想的基础。通过.（变量）或-（指针）访问成员，并须注意编译器为提高效率而进行的内存对齐，以及用于硬件编程的位域。 union：所有成员共享同一块内存，大小由最大成员决定，常用于节省空间。 enum：创建类型安全的命名整型常量，比#define更优。 预处理：在编译前执行的文本替换。核心指令包括#include（文件包含）、#define（定义宏，可用\\换行）、#if/#ifdef等条件编译指令。宏操作符#（字符串化）和##（符号连接）功能强大。多文件编程中，必须使用**#ifndef...#define...#endif**结构进行 头文件防卫 ，防止重复包含。 高级关键字：volatile的应用场景与原理，二维数组，边界元素遍历，const指针的三种模式辨析，数组与指针的异同","tags":[null]}]