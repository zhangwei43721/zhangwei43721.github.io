<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.33.1" theme-name="Stellar" theme-version="1.33.1"><meta name="generator" content="Hexo 7.3.0"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="preconnect" href="https://gcore.jsdelivr.net" crossorigin><link rel="preconnect" href="https://unpkg.com" crossorigin><link rel="preconnect" href="https://cdn.bootcdn.net" crossorigin><meta name="renderer" content="webkit"><meta name="force-rendering" content="webkit"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="HandheldFriendly" content="True"><meta name="mobile-web-app-capable" content="yes"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000"><meta name="theme-color" content="#f9fafb"><title>C语言复习笔记 - Sky Blog</title><meta name="description" content="一份围绕c语言指针、内存管理和作用域&#x2F;存储期三大支柱展开的笔记"><meta property="og:type" content="website"><meta property="og:title" content="C语言复习笔记"><meta property="og:url" content="http://skyforever.top/data/ES/%E5%9F%BA%E7%A1%80/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="Sky Blog"><meta property="og:description" content="一份围绕c语言指针、内存管理和作用域&#x2F;存储期三大支柱展开的笔记"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2025-07-14T01:09:48.000Z"><meta property="article:modified_time" content="2025-07-14T01:09:48.000Z"><meta property="article:author" content="Skyforever"><meta property="article:tag" content="基础&#x2F;C语言"><meta name="twitter:card" content="summary"><meta name="keywords" content=""><link rel="stylesheet" href="/css/main.css?v=1.33.1"><link rel="shortcut icon" href="https://image.skyforever.top/blog/2025/08/c25707b5a37360e74c54764d71d1724c.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Website","@id":"http://skyforever.top/data/ES/%E5%9F%BA%E7%A1%80/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/","author":{"@type":"Person","name":"Skyforever","sameAs":[]},"name":"C语言复习笔记","description":"一份围绕c语言指针、内存管理和作用域/存储期三大支柱展开的笔记","url":"http://skyforever.top/data/ES/%E5%9F%BA%E7%A1%80/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"}</script></head><body><div class="l_body content" id="start" layout="page" type="tech"><aside class="l_left"><div class="sidebg"></div><div class="leftbar-container"><header class="header"><div class="logo-wrap"><div class="icon"><img no-lazy class="icon" src="/images/icons/cloud.png" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></div><a class="title" href="/"><div class="main">Sky Blog</div><div class="sub normal cap">记录走下的每一步</div><div class="sub hover cap" style="opacity:0">Write by Skyforever</div></a></div></header><div class="nav-area"><nav class="menu dis-select"><a class="nav-item" title="博客" href="/"><span>博客</span></a><a class="nav-item" title="项目" href="/wiki/"><span>项目</span></a><a class="nav-item" title="笔记" href="/notebooks/"><span>笔记</span></a></nav></div><div class="widgets"><div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" data-filter="/note/ES" placeholder="在 嵌入式 中搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div><widget class="widget-wrapper post-list"><div class="widget-header dis-select"><span class="name">标签</span></div><div class="widget-body fs14 tag-tree"><div class="tag-subtree leaf-tag expanded" data-tag=""><a class="link" href="/note/ES/"><span class="toc-text">所有笔记 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a></div><div class="tag-subtree parent-tag expanded" data-tag="图形界面开发"><a class="link" href="/note/ES/tags/%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91/"><span class="toc-text"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>图形界面开发 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a><div class="tag-subtree parent-tag expanded" data-tag="图形界面开发/lvgl"><a class="link" href="/note/ES/tags/%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91/lvgl/"><span class="toc-text" style="padding-left:.875rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>LVGL </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a><div class="tag-subtree leaf-tag expanded" data-tag="图形界面开发/lvgl/多媒体"><a class="link" href="/note/ES/tags/%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91/lvgl/%E5%A4%9A%E5%AA%92%E4%BD%93/"><span class="toc-text" style="padding-left:1.75rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>多媒体 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a></div><div class="tag-subtree leaf-tag expanded" data-tag="图形界面开发/lvgl/核心概念"><a class="link" href="/note/ES/tags/%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91/lvgl/%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/"><span class="toc-text" style="padding-left:1.75rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>核心概念 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a></div></div></div><div class="tag-subtree parent-tag expanded" data-tag="基础"><a class="link" href="/note/ES/tags/%E5%9F%BA%E7%A1%80/"><span class="toc-text"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>基础 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a><div class="tag-subtree leaf-tag expanded" data-tag="基础/c语言"><a class="link" href="/note/ES/tags/%E5%9F%BA%E7%A1%80/c%E8%AF%AD%E8%A8%80/"><span class="toc-text" style="padding-left:.875rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>C语言 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a></div><div class="tag-subtree leaf-tag expanded" data-tag="基础/linux基础"><a class="link" href="/note/ES/tags/%E5%9F%BA%E7%A1%80/linux%E5%9F%BA%E7%A1%80/"><span class="toc-text" style="padding-left:.875rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>Linux基础 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a></div><div class="tag-subtree leaf-tag expanded" data-tag="基础/库与框架"><a class="link" href="/note/ES/tags/%E5%9F%BA%E7%A1%80/%E5%BA%93%E4%B8%8E%E6%A1%86%E6%9E%B6/"><span class="toc-text" style="padding-left:.875rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>库与框架 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a></div><div class="tag-subtree parent-tag expanded" data-tag="基础/数据结构与算法"><a class="link" href="/note/ES/tags/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="toc-text" style="padding-left:.875rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>数据结构与算法 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a><div class="tag-subtree leaf-tag expanded" data-tag="基础/数据结构与算法/内核链表"><a class="link" href="/note/ES/tags/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/"><span class="toc-text" style="padding-left:1.75rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>内核链表 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a></div></div><div class="tag-subtree leaf-tag expanded" data-tag="基础/文件io"><a class="link" href="/note/ES/tags/%E5%9F%BA%E7%A1%80/%E6%96%87%E4%BB%B6io/"><span class="toc-text" style="padding-left:.875rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>文件IO </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a></div></div><div class="tag-subtree parent-tag expanded" data-tag="硬件"><a class="link" href="/note/ES/tags/%E7%A1%AC%E4%BB%B6/"><span class="toc-text"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>硬件 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a><div class="tag-subtree leaf-tag expanded" data-tag="硬件/stm32"><a class="link" href="/note/ES/tags/%E7%A1%AC%E4%BB%B6/stm32/"><span class="toc-text" style="padding-left:.875rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>STM32 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a></div><div class="tag-subtree leaf-tag expanded" data-tag="硬件/电子基础"><a class="link" href="/note/ES/tags/%E7%A1%AC%E4%BB%B6/%E7%94%B5%E5%AD%90%E5%9F%BA%E7%A1%80/"><span class="toc-text" style="padding-left:.875rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>电子基础 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a></div></div><div class="tag-subtree parent-tag expanded" data-tag="进阶"><a class="link" href="/note/ES/tags/%E8%BF%9B%E9%98%B6/"><span class="toc-text"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>进阶 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a><div class="tag-subtree parent-tag expanded" data-tag="进阶/linux并发编程"><a class="link" href="/note/ES/tags/%E8%BF%9B%E9%98%B6/linux%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><span class="toc-text" style="padding-left:.875rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>Linux并发编程 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a><div class="tag-subtree leaf-tag expanded" data-tag="进阶/linux并发编程/线程"><a class="link" href="/note/ES/tags/%E8%BF%9B%E9%98%B6/linux%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B/"><span class="toc-text" style="padding-left:1.75rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>线程 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a></div><div class="tag-subtree leaf-tag expanded" data-tag="进阶/linux并发编程/进程"><a class="link" href="/note/ES/tags/%E8%BF%9B%E9%98%B6/linux%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E8%BF%9B%E7%A8%8B/"><span class="toc-text" style="padding-left:1.75rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>进程 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a></div></div><div class="tag-subtree leaf-tag expanded" data-tag="进阶/linux网络"><a class="link" href="/note/ES/tags/%E8%BF%9B%E9%98%B6/linux%E7%BD%91%E7%BB%9C/"><span class="toc-text" style="padding-left:.875rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>Linux网络 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a></div><div class="tag-subtree leaf-tag expanded" data-tag="进阶/mqtt物联网"><a class="link" href="/note/ES/tags/%E8%BF%9B%E9%98%B6/mqtt%E7%89%A9%E8%81%94%E7%BD%91/"><span class="toc-text" style="padding-left:.875rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>MQTT物联网 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a></div></div></div></widget><widget class="widget-wrapper recent post-list"><div class="widget-header dis-select"><span class="name">最近更新</span></div><div class="widget-body fs14"><a class="item title" href="/data/ES/%E7%A1%AC%E4%BB%B6/%E6%95%B0%E7%94%B5%E5%9F%BA%E7%A1%80/"><span class="title">数字电路基础</span></a><a class="item title" href="/data/ES/%E7%A1%AC%E4%BB%B6/%E6%A8%A1%E7%94%B5%E5%9F%BA%E7%A1%80/"><span class="title">模拟电路基础</span></a><a class="item title" href="/data/ES/%E7%A1%AC%E4%BB%B6/%E7%94%B5%E5%AD%A6%E6%A6%82%E5%BF%B5/"><span class="title">电学概念</span></a><a class="item title" href="/data/ES/%E8%BF%9B%E9%98%B6/MQTT%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"><span class="title">MQTT 使用笔记</span></a><a class="item title" href="/data/ES/%E8%BF%9B%E9%98%B6/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><span class="title">Linux 网络编程</span></a><a class="item title" href="/data/ES/%E8%BF%9B%E9%98%B6/%E7%BA%BF%E7%A8%8B/"><span class="title">Linux 多线程编程：Pthreads 核心函数与资源管理详解</span></a><a class="item title" href="/data/ES/%E8%BF%9B%E9%98%B6/%E8%BF%9B%E7%A8%8B/"><span class="title">Linux 进程管理与调度</span></a><a class="item title" href="/data/ES/%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91/LVGL%20%E5%9B%BE%E5%83%8F%E4%B8%8E%E5%AD%97%E4%BD%93%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"><span class="title">LVGL 图像与字体使用笔记</span></a><a class="item title" href="/data/ES/%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91/LVGL%20%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E7%AC%94%E8%AE%B0/"><span class="title">LVGL 核心概念笔记</span></a><a class="item title" href="/data/ES/%E5%9F%BA%E7%A1%80/C%E8%AF%AD%E8%A8%80-%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C%E5%92%8C%E4%BD%BF%E7%94%A8/"><span class="title">C语言-库的制作和使用</span></a></div></widget></div><footer class="footer dis-select"><div class="social-wrap"><a class="social" href="https://github.com/zhangwei43721" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://api.iconify.design/icon-park/github.svg"></a><a class="social" href="https://music.163.com/#/user/home?id=1654800754" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://api.iconify.design/ri:netease-cloud-music-line.svg"></a><a class="social" href="mailto:zhangwei4372@outlook.com" rel="noopener noreferrer"><img src="https://api.iconify.design/clarity/email-outline-badged.svg"></a></div></footer></div></aside><div class="l_main" id="main"><div class="article banner top"><div class="content"><div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a> <span class="sep"></span> <a class="cap breadcrumb" href="/notebooks/">笔记本</a> <span class="sep"></span> <a class="cap breadcrumb" href="/note/ES/">嵌入式</a></div><div class="flex-row" id="post-meta"><span class="text created">更新于：<time datetime="2025-07-14T01:09:48.000Z">2025-07-14</time></span><span class="sep updated"></span><span class="text updated">发布于：<time datetime="2025-07-14T01:09:48.000Z">2025-07-14</time></span></div></div></div><div class="bottom only-title"><div class="text-area"><h1 class="text title"><span>C语言复习笔记</span></h1></div></div></div></div><article class="md-text content"><h2 id="第一部分c-语言基础"><a class="markdownIt-Anchor" href="#第一部分c-语言基础"></a> 第一部分：C 语言基础</h2><h3 id="1-helloworld"><a class="markdownIt-Anchor" href="#1-helloworld"></a> 1. helloworld</h3><h4 id="配置环境"><a class="markdownIt-Anchor" href="#配置环境"></a> 配置环境</h4><ul><li><strong>编辑器</strong>: <a target="_blank" rel="noopener" href="https://code.visualstudio.com/">Visual Studio Code (VS Code)</a>，一款轻量且强大的代码编辑器。</li><li><strong>编译器</strong>: <a target="_blank" rel="noopener" href="https://www.mingw-w64.org/">MinGW-w64</a>，在 Windows 上提供 GCC 编译环境，可将 C 代码编译为可执行文件。</li><li><strong>推荐插件</strong>: <code>C/C++</code> (by Microsoft), <code>Code Runner</code> (用于快速运行代码)。</li></ul><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/kekehuizi/article/details/124277082">VSCode 配置 C/C++环境，使用 MinGW 编译器</a></p><ul><li><p>VS Code<strong>安装 Code Runner 插件方法:</strong></p><ol><li>点击 VS Code 菜单栏的&quot;文件&quot; (File) -&gt; “首选项” (Preferences) -&gt; “设置” (Settings)，或者使用快捷键 <code>Ctrl + ,</code> 。</li><li>在设置页面中搜索&quot;Run Code configuration&quot;。</li><li>找到&quot;Run In Terminal&quot; 选项，并勾选上。</li></ol></li></ul><h4 id="实现程序"><a class="markdownIt-Anchor" href="#实现程序"></a> 实现程序</h4><p>在 vscode 中，输入<code>main</code>即可快速实现示例程序</p><p><code>main</code> 函数可以接收来自命令行的参数，这在编写工具类程序时非常有用。</p><ul><li><strong><code>int argc</code></strong>: (Argument Count) 整型变量，存储传递给程序的命令行参数的数量（包括程序本身）。</li><li><strong><code>char *argv[]</code></strong>: (Argument Vector) 字符串数组，<code>argv[0]</code>是程序名，<code>argv[1]</code>是第一个参数，以此类推。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">##<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后运行: ./a.out param1 param2</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;程序名: %s\n&quot;</span>, argv[<span class="number">0</span>]);       <span class="comment">// 输出: ./a.out</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第一个参数: %s\n&quot;</span>, argv[<span class="number">1</span>]);   <span class="comment">// 输出: param1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第二个参数: %s\n&quot;</span>, argv[<span class="number">2</span>]);   <span class="comment">// 输出: param2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-数据类型与格式化-io"><a class="markdownIt-Anchor" href="#2-数据类型与格式化-io"></a> 2. 数据类型与格式化 IO</h3><h4 id="基本数据类型"><a class="markdownIt-Anchor" href="#基本数据类型"></a> 基本数据类型</h4><p>C 语言中的数据类型定义了变量可以存储的数据种类和范围。</p><table><thead><tr><th style="text-align:left">类型分类</th><th style="text-align:left">关键字</th><th style="text-align:left">描述</th><th style="text-align:left">格式说明符</th></tr></thead><tbody><tr><td style="text-align:left"><strong>整型</strong></td><td style="text-align:left"><code>int</code></td><td style="text-align:left">基本整数，通常 4 字节</td><td style="text-align:left"><code>%d</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>short</code></td><td style="text-align:left">短整型，通常 2 字节</td><td style="text-align:left"><code>%hd</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>long</code></td><td style="text-align:left">长整型，通常 4 或 8 字节</td><td style="text-align:left"><code>%ld</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>long long</code></td><td style="text-align:left">更长整型，至少 8 字节</td><td style="text-align:left"><code>%lld</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>unsigned</code></td><td style="text-align:left">无符号修饰，范围从 0 开始</td><td style="text-align:left"><code>%u</code>, <code>%lu</code>, <code>%llu</code></td></tr><tr><td style="text-align:left"><strong>浮点型</strong></td><td style="text-align:left"><code>float</code></td><td style="text-align:left">单精度浮点数，约 7 位有效数字</td><td style="text-align:left"><code>%f</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>double</code></td><td style="text-align:left">双精度浮点数，约 15 位有效数字 (更常用)</td><td style="text-align:left"><code>%lf</code></td></tr><tr><td style="text-align:left"><strong>字符型</strong></td><td style="text-align:left"><code>char</code></td><td style="text-align:left">单个字符，本质是 1 字节的整数 (ASCII 码)</td><td style="text-align:left"><code>%c</code>, <code>%hhd</code>(整数)</td></tr></tbody></table><h4 id="常量与变量"><a class="markdownIt-Anchor" href="#常量与变量"></a> 常量与变量</h4><ul><li><strong>变量</strong>: 内存中用于存储数据的具名空间，其值可以改变。</li><li><strong>常量</strong>: 值在程序运行期间不可改变。<ul><li><strong>字面常量</strong>: 如 <code>100</code>, <code>3.14</code>, <code>'A'</code>, <code>&quot;hello&quot;</code>。</li><li><strong>宏定义常量</strong>: 使用 <code>#define</code>，在预编译阶段进行文本替换，无类型检查。</li><li><strong><code>const</code> 修饰的变量</strong>: 具有类型，会进行类型检查，更安全。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">##<span class="meta">#<span class="keyword">define</span> PI 3.14159 <span class="comment">// 宏常量</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> age = <span class="number">25</span>;           <span class="comment">// 变量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAX_USERS = <span class="number">100</span>; <span class="comment">// const常量</span></span><br><span class="line">    age = <span class="number">26</span>;               <span class="comment">// OK</span></span><br><span class="line">    <span class="comment">// MAX_USERS = 101;      // Error: 试图修改const变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="格式化输入与输出"><a class="markdownIt-Anchor" href="#格式化输入与输出"></a> 格式化输入与输出</h4><ul><li><strong><code>printf()</code></strong>: 格式化输出函数，将数据按指定格式打印到屏幕。</li><li><strong><code>scanf()</code></strong>: 格式化输入。<code>scanf</code>返回成功读取的项数。如果输入类型不匹配，会返回<code>0</code>并将错误输入留在<strong>输入缓冲区 (<code>stdin</code>)</strong> 中，可能导致后续读取问题。 <code>scanf</code>需要传入变量的<strong>地址</strong>，使用 <code>&amp;</code> 运算符获取。</li></ul><table><thead><tr><th style="text-align:left">格式符</th><th style="text-align:left">描述</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left"><code>%d</code></td><td style="text-align:left">十进制整数</td><td style="text-align:left"><code>123</code></td></tr><tr><td style="text-align:left"><code>%f</code></td><td style="text-align:left"><code>float</code> 类型浮点数</td><td style="text-align:left"><code>3.14</code></td></tr><tr><td style="text-align:left"><code>%lf</code></td><td style="text-align:left"><code>double</code> 类型浮点数</td><td style="text-align:left"><code>3.1415926</code></td></tr><tr><td style="text-align:left"><code>%c</code></td><td style="text-align:left"><code>char</code>单个字符</td><td style="text-align:left"><code>'A'</code></td></tr><tr><td style="text-align:left"><code>%s</code></td><td style="text-align:left"><code>string</code>字符串</td><td style="text-align:left"><code>&quot;hello&quot;</code></td></tr><tr><td style="text-align:left"><code>%p</code></td><td style="text-align:left"><code>point</code>指针地址（十六进制）</td><td style="text-align:left"><code>0x7ffc...</code></td></tr><tr><td style="text-align:left"><code>%x</code></td><td style="text-align:left"><code>hexadecimal</code>十六进制整数</td><td style="text-align:left"><code>ff</code></td></tr><tr><td style="text-align:left"><code>%o</code></td><td style="text-align:left"><code>Octal</code>八进制整数</td><td style="text-align:left"><code>177</code></td></tr><tr><td style="text-align:left"><code>%%</code></td><td style="text-align:left">输出一个 <code>%</code> 符号</td><td style="text-align:left"><code>%</code></td></tr></tbody></table><p><em>注：printf 使用 %f 即可打印 float 和 double。这是因为在传递给 printf 这样的可变参数函数时，float 类型的实参会被自动提升(promote)为 double 类型。而 scanf 传入的是指针，需要通过 %lf 明确告知函数要写入一个 double 大小的内存。</em></p><ul><li><p><strong>清理输入缓冲区</strong>: 当<code>scanf</code>失败时，必须清理缓冲区中的非法输入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个整数: &quot;</span>);</span><br><span class="line">    <span class="type">int</span> retval = <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a); <span class="comment">// &amp;a是取地址</span></span><br><span class="line">    <span class="keyword">if</span> (retval == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;成功读取: %d\n&quot;</span>, a);</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 成功则退出循环</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入错误！正在清理输入缓冲区...\n&quot;</span>);</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">10</span>]; <span class="comment">// 准备一个“垃圾桶”</span></span><br><span class="line">        fgets(buf, <span class="number">10</span>, <span class="built_in">stdin</span>); <span class="comment">// 把留在输入队列里的垃圾读走，扔到垃圾桶里</span></span><br><span class="line">        <span class="comment">//或者用下面这句话，每次读一个来清掉，直到输入队列清空</span></span><br><span class="line">        <span class="comment">// while (getchar() != &#x27;\n&#x27;);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="单字符输入输出-getchar-putchar"><a class="markdownIt-Anchor" href="#单字符输入输出-getchar-putchar"></a> 单字符输入输出 (<code>getchar</code>, <code>putchar</code>)</h4><p>这两个函数效率更高，用于处理单个字符的 I/O。</p><ul><li><strong><code>getchar()</code></strong>: 从<code>stdin</code>读取一个字符，并以<code>int</code>类型返回。</li><li><strong><code>putchar()</code></strong>: 将一个字符（以<code>int</code>形式传递）写入<code>stdout</code>。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">##<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;请输入一个字符: &quot;</span>);</span><br><span class="line">   <span class="type">int</span> c = getchar(); <span class="comment">// 用int接收以处理EOF</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;你输入的字符是: &quot;</span>);</span><br><span class="line">   <span class="built_in">putchar</span>(c);</span><br><span class="line">   <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类型转换"><a class="markdownIt-Anchor" href="#类型转换"></a> 类型转换</h4><ul><li><p><strong>自动类型转换</strong>: 在运算中，低精度类型会自动转换为高精度类型。 (<code>char</code> -&gt; <code>int</code> -&gt; <code>float</code> -&gt; <code>double</code>)</p></li><li><p><strong>强制类型转换</strong>: 使用 <code>(目标类型)</code> 语法强制转换。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="type">float</span> result = (<span class="type">float</span>)a / b; <span class="comment">// 将a强制转为float，结果为3.333...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不转换，int / int 结果为3</span></span><br><span class="line"><span class="type">int</span> int_result = a / b; <span class="comment">// 结果为 3</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="科学计数法"><a class="markdownIt-Anchor" href="#科学计数法"></a> <strong>科学计数法</strong></h4><p>浮点数可以使用<code>e</code>或<code>E</code>表示 10 的幂，这在表示极大或极小值时很有用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> large_num = <span class="number">3.14e8</span>;  <span class="comment">// 3.14 * 10^8</span></span><br><span class="line"><span class="type">double</span> small_num = <span class="number">1.23e-5</span>; <span class="comment">// 1.23 * 10^-5</span></span><br></pre></td></tr></table></figure><h4 id="数字的进制表示"><a class="markdownIt-Anchor" href="#数字的进制表示"></a> 数字的进制表示</h4><p>我们可以用不同进制来输出数字，这对调试程序，操作寄存器等底层硬件非常重要</p><ul><li><strong>前缀</strong>:<ul><li><strong>十六进制</strong>: <code>0x</code> 或 <code>0X</code></li><li><strong>八进制</strong>: <code>0</code></li><li><strong>十进制</strong>: 无前缀</li></ul></li><li><strong>在内存中，所有进制的数最终都以二进制形式存储。</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dec_val = <span class="number">100</span>;         <span class="comment">// 十进制</span></span><br><span class="line"><span class="type">int</span> hex_val = <span class="number">0x64</span>;        <span class="comment">// 十六进制 (值为100)</span></span><br><span class="line"><span class="type">int</span> oct_val = <span class="number">0144</span>;        <span class="comment">// 八进制 (值为100)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用不同格式说明符打印</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Decimal: %d, %d, %d\n&quot;</span>, dec_val, hex_val, oct_val);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hex: %x, %x, %x\n&quot;</span>, dec_val, hex_val, oct_val);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Octal: %o, %o, %o\n&quot;</span>, dec_val, hex_val, oct_val);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用&#x27;#&#x27;标志位打印进制前缀</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hex with prefix: %#x, Octal with prefix: %#o\n&quot;</span>, hex_val, oct_val);</span><br></pre></td></tr></table></figure><h4 id="面试题实战-浮点数的安全比较"><a class="markdownIt-Anchor" href="#面试题实战-浮点数的安全比较"></a> 面试题实战-浮点数的安全比较</h4><p>为什么不能直接用 <code>==</code> 比较两个浮点数？</p><p>由于计算机使用二进制表示浮点数时存在固有的精度误差，直接用 <code>==</code> 比较通常会失败。</p><p>例子：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Renyi-Fan/p/12324664.html">十进制 0.1 转二进制计算过程</a></p><p>正确做法是判断两个浮点数之差的<strong>绝对值</strong>是否小于一个预先设定的极小值（epsilon）。</p><p><strong>代码示例</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;float.h&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 浮点数比较：因存在精度误差，应判断差的绝对值是否小于一个极小阈值(epsilon)，</span></span><br><span class="line"><span class="comment"> * 而非直接使用 `==`。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 绝对误差法</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> EPSILON 1e-8  <span class="comment">// 定义固定的误差阈值</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断值是否小于固定阈值。简单，但对极大或极小值可能失效。</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_zero_abs</span><span class="params">(<span class="type">double</span> value)</span> &#123; <span class="keyword">return</span> <span class="built_in">fabs</span>(value) &lt;= EPSILON; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 相对误差法 (推荐)</span></span><br><span class="line"><span class="comment">// 使用与基准值相关的动态阈值，更通用</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_zero_rel</span><span class="params">(<span class="type">double</span> value, <span class="type">double</span> base_value)</span> &#123;</span><br><span class="line">  <span class="comment">// 阈值上线随基准值大小动态调整，下线为1.0</span></span><br><span class="line">  <span class="type">double</span> epsilon = EPSILON * fmax(<span class="number">1.0</span>, <span class="built_in">fabs</span>(base_value));</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">fabs</span>(value) &lt;= epsilon;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="comment">// 错：直接用 `==` 比较浮点数，因精度问题导致判断失败</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0.1</span> * <span class="number">3</span> - <span class="number">0.3</span> == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;是0\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;不是0\n&quot;</span>);  <span class="comment">// 此行被输出</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绝对误差法：对于小数值的运算结果比较有效</span></span><br><span class="line">  <span class="keyword">if</span> (is_zero_abs(<span class="number">0.1</span> * <span class="number">3</span> - <span class="number">0.3</span>))</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;是0\n&quot;</span>);  <span class="comment">// 此行被输出</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;不是0\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 相对误差法：对于大数值的比较也能正确处理</span></span><br><span class="line">  <span class="type">double</span> f1 = <span class="number">3.5e7</span>;</span><br><span class="line">  <span class="type">double</span> f2 = f1 + <span class="number">0.1</span>;</span><br><span class="line">  <span class="keyword">if</span> (is_zero_rel(f2 - f1, f1))</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; f2-f1 是0\n&quot;</span>);  <span class="comment">// 此行被输出</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; f2-f1 不是0\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="面试题实战-大型字面量后缀"><a class="markdownIt-Anchor" href="#面试题实战-大型字面量后缀"></a> 面试题实战-大型字面量后缀</h4><p>在处理大型数字的宏或常量时，中间计算结果可能会超出默认 <code>int</code> 类型的范围导致溢出，即便最终结果可以存放在 <code>long long</code> 中。</p><p>为了避免这种情况，可以使用后缀强制指定字面量的类型。</p><ul><li><code>L</code> 或 <code>l</code>: <code>long</code></li><li><code>LL</code> 或 <code>ll</code>: <code>long long</code></li><li><code>U</code> 或 <code>u</code>: <code>unsigned</code></li><li><code>ULL</code> 或 <code>ull</code>: <code>unsigned long long</code></li></ul><p><strong>代码示例</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误的方式: 所有数字都是int, 乘法过程中会溢出</span></span><br><span class="line"><span class="comment">// #define SECONDS_PER_YEAR (365 * 24 * 60 * 60)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的方式: 确保第一个数是 long long 类型</span></span><br><span class="line"><span class="comment">// 后续的乘法都会被提升到 long long 类型进行，避免溢出</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> SECONDS_PER_YEAR (365 * 24 * 60 * 60ULL)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;每年秒数: %llu\n&quot;</span>, SECONDS_PER_YEAR);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="面试题实战-类型提升中的符号扩展"><a class="markdownIt-Anchor" href="#面试题实战-类型提升中的符号扩展"></a> 面试题实战-类型提升中的符号扩展</h4><p>当一个宽度较小的<strong>有符号</strong>类型（如 <code>char</code>, <code>short</code>）被提升为一个宽度较大的类型（如 <code>int</code>）时：</p><ul><li>如果原始值是<strong>正数</strong>，高位用 <code>0</code> 填充。</li><li>如果原始值是<strong>负数</strong>（即最高位为 1），则会发生<strong>符号扩展 (Sign Extension)</strong>，高位用 <code>1</code> 填充以保持其负值。</li></ul><p><strong>代码示例</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 0xaa 的二进制是 10101010。作为有符号char，其最高位是1，为负数。</span></span><br><span class="line">    <span class="type">char</span> c = <span class="number">0xaa</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当 c 被赋值给整型变量 j 时，它被提升为 int</span></span><br><span class="line">    <span class="comment">// 由于 c 是负数，发生符号扩展，高位全用1填充</span></span><br><span class="line">    <span class="type">int</span> j = c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结果: 0xffffffaa</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;j = %#x\n&quot;</span>, j);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个特性在处理来自硬件或网络的字节流时尤其重要.</p><h4 id="面试题实战-大小端序转换"><a class="markdownIt-Anchor" href="#面试题实战-大小端序转换"></a> 面试题实战-大小端序转换</h4><p>建议先看下面的内容理解：<br><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2022/06/endianness-analysis.html">字节序探析：大端与小端的比较</a></p><p>简单总结如下：</p><ul><li>如果需要逐位运算，或者需要到从个位数开始运算，都是小端序占优势</li><li>反之，如果运算只涉及到高位，或者数据的可读性比较重要，则是大端序占优势</li><li><strong><u>所以计算机存储一般都用小端序方便计算，大端序一般方便人类阅读</u></strong></li></ul><p>题目：写一个函数，要求把小端序存放的整数，转换成大端序存放</p><p><strong>代码示例</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">  <span class="type">int</span> result=<span class="number">0</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> *p = (<span class="type">unsigned</span> <span class="type">char</span>*)&amp;n;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> *q = (<span class="type">unsigned</span> <span class="type">char</span>*)&amp;result;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)&#123;</span><br><span class="line">    *(q + <span class="number">3</span> - i) = *(p + i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-运算符"><a class="markdownIt-Anchor" href="#3-运算符"></a> 3. 运算符</h3><h4 id="算术运算符"><a class="markdownIt-Anchor" href="#算术运算符"></a> 算术运算符</h4><p><code>+</code> (加), <code>-</code> (减), <code>*</code> (乘), <code>/</code> (除), <code>%</code> (取余/模)</p><ul><li><p><strong>自增/自减</strong>: <code>++</code>, <code>--</code></p><ul><li><strong>前缀 (<code>++a</code>)</strong>: 先自增，再使用变量的值。</li><li><strong>后缀 (<code>a++</code>)</strong>: 先使用变量的值，再自增。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> b = ++a; <span class="comment">// a变为6, b被赋值为6</span></span><br><span class="line"><span class="type">int</span> c = a++; <span class="comment">// c被赋值为6, a变为7</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d, b=%d, c=%d\n&quot;</span>, a, b, c); <span class="comment">// 输出: a=7, b=6, c=6</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="关系与逻辑运算符"><a class="markdownIt-Anchor" href="#关系与逻辑运算符"></a> 关系与逻辑运算符</h4><ul><li><p><strong>关系运算符</strong>: <code>&gt;</code> (大于), <code>&lt;</code> (小于), <code>&gt;=</code> (不小于), <code>&lt;=</code> (不大于), <code>==</code> (等于), <code>!=</code> (不等于)。结果为 <code>1</code> (真) 或 <code>0</code> (假)。</p></li><li><p><strong>逻辑运算符</strong>: <code>!</code> (逻辑非), <code>&amp;&amp;</code> (逻辑与), <code>||</code> (逻辑或)。</p></li><li><p><strong>短路求值</strong>:</p><ul><li><code>expr1 &amp;&amp; expr2</code>: 如果 <code>expr1</code> 为假，<code>expr2</code> 不会被执行。</li><li><code>expr1 || expr2</code>: 如果 <code>expr1</code> 为真，<code>expr2</code> 不会被执行。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// x为0(假)，&amp;&amp;右侧不执行，y的值不变</span></span><br><span class="line"><span class="keyword">if</span> (x &amp;&amp; (y = <span class="number">10</span>)) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;y = %d\n&quot;</span>, y); <span class="comment">// 输出: y = 5</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="位运算符"><a class="markdownIt-Anchor" href="#位运算符"></a> 位运算符</h4><p>直接对数据的二进制位进行操作。</p><ul><li><code>&amp;</code> (按位与), <code>|</code> (按位或), <code>^</code> (按位异或),<code>~</code> (按位取反)</li><li><code>&lt;&lt;</code> (左移): <code>x &lt;&lt; n</code> 相当于 <code>x * 2^n</code></li><li><code>&gt;&gt;</code> (右移): <code>x &gt;&gt; n</code> 相当于 <code>x / 2^n</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常用位操作技巧</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> reg = <span class="number">0b10101100</span>; <span class="comment">// 假设这是一个8位寄存器</span></span><br><span class="line">        <span class="comment">// 注意二进制字面量 0b10101100 是GCC扩展</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 置位 (将第3位置1)</span></span><br><span class="line">reg = reg | (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 清零 (将第2位清0)</span></span><br><span class="line">reg = reg &amp; ~(<span class="number">1</span> &lt;&lt; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 取反 (翻转第1位)</span></span><br><span class="line">reg = reg ^ (<span class="number">1</span> &lt;&lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 测试 (检查第7位是否为1)</span></span><br><span class="line"><span class="keyword">if</span> (reg &amp; (<span class="number">1</span> &lt;&lt; <span class="number">7</span>)) &#123;</span><br><span class="line">    <span class="comment">// 位为1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="其他运算符"><a class="markdownIt-Anchor" href="#其他运算符"></a> 其他运算符</h4><ul><li><p><strong>赋值运算符</strong>: <code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>&amp;=</code>, <code>|=</code>, <code>^=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code></p></li><li><p><strong>条件运算符 (三目运算符)</strong>: <code>表达式1 ? 表达式2 : 表达式3</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> max = (a &gt; b) ? a : b; <span class="comment">// max 的值为 20</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>sizeof</code> 运算符</strong>: 计算数据类型或变量占用的内存字节数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;int类型占 %zu 字节\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));   <span class="comment">// 通常输出 4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;数组arr占 %zu 字节\n&quot;</span>, <span class="keyword">sizeof</span>(arr)); <span class="comment">// 输出 40 (4 * 10)</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="运算符优先级与结合性"><a class="markdownIt-Anchor" href="#运算符优先级与结合性"></a> 运算符优先级与结合性</h4><ul><li><strong>优先级</strong>: 决定了哪个运算符先执行（如 <code>*</code> 优先于 <code>+</code>）。</li><li><strong>结合性</strong>: 决定了相同优先级的运算符的执行顺序（如赋值<code>=</code>是<strong>从右至左</strong>）。</li><li><strong>黄金法则</strong>: <strong>当不确定优先级时，使用圆括号 <code>()</code> 来明确指定运算顺序。</strong> 这能避免错误并提高代码可读性。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">2</span> * <span class="number">3</span> + <span class="number">4</span>; <span class="comment">// 乘法优先, x = 6 + 4 = 10</span></span><br><span class="line"><span class="type">int</span> y = <span class="number">10</span> &gt; <span class="number">5</span> &amp;&amp; <span class="number">5</span> &gt; <span class="number">0</span>; <span class="comment">// 关系运算符优先于逻辑运算符</span></span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line">a = b = c = <span class="number">5</span>; <span class="comment">// 赋值运算符从右向左结合, c=5, b=5, a=5</span></span><br></pre></td></tr></table></figure><h4 id="面试题实战-字节内比特位反转"><a class="markdownIt-Anchor" href="#面试题实战-字节内比特位反转"></a> 面试题实战-字节内比特位反转</h4><p><strong>问题</strong>: 编写一个函数，将一个字节中的 8 个比特位进行反转。</p><p><strong>核心知识</strong>: 这是对位运算符的深入考察。核心思想是逐位从原字节中取出，然后逐位放入新字节的相反位置。</p><p><strong>代码示例</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">revert</span><span class="params">(<span class="type">int</span> len, <span class="type">char</span> A[], <span class="type">char</span> B[])</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    B[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++) &#123;</span><br><span class="line">      B[i] = B[i] &lt;&lt; <span class="number">1</span>;               <span class="comment">// 先移位</span></span><br><span class="line">      B[i] |= (A[i] &gt;&gt; k) &amp; <span class="number">0x01</span>;     <span class="comment">// 后赋值</span></span><br><span class="line">    &#125;                                 <span class="comment">// 最后不会多移位</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="4-控制流"><a class="markdownIt-Anchor" href="#4-控制流"></a> 4. 控制流</h3><h4 id="分支结构-if-switch"><a class="markdownIt-Anchor" href="#分支结构-if-switch"></a> 分支结构 (if / switch)</h4><ul><li><p><strong><code>if-else</code></strong>: 用于二路或多路分支判断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> score = <span class="number">85</span>;</span><br><span class="line"><span class="keyword">if</span> (score &gt;= <span class="number">90</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;优秀\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;及格\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;不及格\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>switch</code></strong>: 用于基于一个整数值的多路分支，通常比 <code>if-else if</code> 更高效、清晰。</p><ul><li><code>case</code> 标签后必须是常量表达式。</li><li>每个 <code>case</code> 通常以 <code>break</code> 结束，否则会发生“穿透”，继续执行下一个 <code>case</code>。</li><li><code>default</code> 处理所有未匹配的 <code>case</code>。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> day = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">printf</span>(<span class="string">&quot;周一\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">printf</span>(<span class="string">&quot;周二\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: <span class="built_in">printf</span>(<span class="string">&quot;周三\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// case 4 ... 5: ... (GCC/Clang 扩展语法)</span></span><br><span class="line">    <span class="keyword">default</span>: <span class="built_in">printf</span>(<span class="string">&quot;其他\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="循环结构-while-for-do-while"><a class="markdownIt-Anchor" href="#循环结构-while-for-do-while"></a> 循环结构 (while / for / do-while)</h4><ul><li><p><strong><code>while</code> 循环</strong>: 先判断条件，再执行循环体。可能一次都不执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;  <span class="comment">//条件成立执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">    i++;</span><br><span class="line">&#125; <span class="comment">// 输出: 0 1 2 3 4</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>for</code> 循环</strong>: 集初始化、条件判断、迭代于一体，结构清晰，常用于已知循环次数的场景。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;  <span class="comment">//条件成立执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">&#125; <span class="comment">// 输出: 0 1 2 3 4</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>do-while</code> 循环</strong>: 先执行一次循环体，再判断条件。保证循环体至少执行一次。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;至少执行一次\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">5</span>);  <span class="comment">//条件成立执行</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="跳转语句-break-continue-goto-return"><a class="markdownIt-Anchor" href="#跳转语句-break-continue-goto-return"></a> 跳转语句 (break / continue / goto / return)</h4><ul><li><p><strong><code>break</code></strong>: 立即<strong>跳出</strong>当前所在的 <code>switch</code> 结构或循环结构。</p></li><li><p><strong><code>continue</code></strong>: 立即<strong>结束本次</strong>循环，跳到循环的下一次迭代判断处。</p></li><li><p><strong><code>return</code></strong>:</p><ol><li>立即终止当前函数的执行。</li><li>将一个值（如果函数不是<code>void</code>类型）返回给调用者。</li><li>在<code>void</code>函数中，<code>return;</code>可用于提前退出。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">check_value</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (val &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error: invalid value.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 提前退出并返回错误码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 正常处理 ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回成功码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>goto</code></strong>: 无条件跳转到同一函数内的标签处。<strong>应谨慎使用</strong>，易破坏程序结构，通常只在错误处理等多层嵌套退出场景下考虑。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例: goto用于统一的错误处理</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;a.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> error_handle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *mem = <span class="built_in">malloc</span>(<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">if</span> (mem == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        fclose(fp); <span class="comment">// 释放已获取资源</span></span><br><span class="line">        <span class="keyword">goto</span> error_handle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 正常逻辑 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(mem);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">error_handle:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;发生错误，程序退出\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="面试题实战-fgets字符串输入"><a class="markdownIt-Anchor" href="#面试题实战-fgets字符串输入"></a> 面试题实战- <code>fgets</code>字符串输入</h4><p>与 <code>scanf</code> 不同，<code>fgets</code> 在读取字符串时更加安全，因为它会检查缓冲区的边界，有效防止溢出。</p><ul><li><strong>函数原型</strong>: <code>char *fgets(char *str, int n, FILE *stream);</code></li><li><strong>参数</strong>:<ul><li><code>str</code>: 用于存储输入字符串的缓冲区。</li><li><code>n</code>: 最多读取 <code>n-1</code> 个字符（最后一个位置留给 <code>\0</code>）。</li><li><code>stream</code>: 输入流，通常是 <code>stdin</code>（标准输入）。</li></ul></li><li><strong>特点</strong>:<ul><li><strong>安全</strong>: 不会超出缓冲区大小。</li><li><strong>会读取换行符</strong>: 如果输入行中包含换行符 <code>\n</code>，<code>fgets</code> 会将其一并读入缓冲区。通常需要手动移除。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一行文字 (最多9个字符): &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fgets(buffer, <span class="keyword">sizeof</span>(buffer), <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 移除可能存在的换行符</span></span><br><span class="line">        buffer[<span class="built_in">strcspn</span>(buffer, <span class="string">&quot;\n&quot;</span>)] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;你输入的是: &#x27;%s&#x27;\n&quot;</span>, buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二部分内存-函数与程序结构"><a class="markdownIt-Anchor" href="#第二部分内存-函数与程序结构"></a> 第二部分：内存、函数与程序结构</h2><h3 id="5-内存布局与管理"><a class="markdownIt-Anchor" href="#5-内存布局与管理"></a> 5. 内存布局与管理</h3><p>对于嵌入式开发，深刻理解程序内存组织至关重要，它直接影响程序的稳定性、效率和资源消耗。</p><p>每个 C 程序都运行在一个独立的<strong>虚拟内存空间</strong>中，其结构从低地址到高地址通常如下：</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://image.skyforever.top/blog/2025/10/02d44c1a801ce5cf439adcd768b1aa90.webp" alt="C Process Virtual Memory Layout"></p><h4 id="代码段"><a class="markdownIt-Anchor" href="#代码段"></a> 代码段</h4><p><strong><u>只读</u>！</strong></p><ul><li><strong>.text</strong>: 存放程序的可执行二进制代码</li><li><strong>.init</strong>: 存放系统初始化代码</li></ul><h4 id="数据段"><a class="markdownIt-Anchor" href="#数据段"></a> 数据段</h4><p>此区域用于存储**<u>生命周期与整个程序相同</u><strong>的</strong>全局变量<strong>和</strong>静态变量**。</p><ul><li><strong>.rodata (Read-only Data)</strong>： 存只读数据，如字符串字面量 (<code>&quot;hello&quot;</code>)、<code>const</code>修饰的全局常量。</li><li><strong>.data</strong>：存 <strong>已初始化</strong>的全局变量和静态变量。</li><li><strong>.bss (Block Started by Symbol)</strong>：存<strong>未初始化</strong>的全局变量和静态变量，程序启动时，该区域会被系统<strong>自动清零</strong>。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：不同变量在数据段中的位置</span></span><br><span class="line"><span class="type">int</span> global_init = <span class="number">10</span>;      <span class="comment">// 存放在 .data 段</span></span><br><span class="line"><span class="type">int</span> global_uninit;         <span class="comment">// 存放在 .bss 段 (值为0)</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;hello&quot;</span>; <span class="comment">// &quot;hello&quot;在 .rodata 段, 指针str在 .data 段</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">counter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;  <span class="comment">// &#x27;static&#x27;修饰局部变量，使其存入.data段</span></span><br><span class="line">                           <span class="comment">// 只在首次调用时初始化为0</span></span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Counter called %d times.\n&quot;</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="static-对局部变量的影响"><a class="markdownIt-Anchor" href="#static-对局部变量的影响"></a> <code>static</code> 对局部变量的影响</h5><p>当 <code>static</code> 用于修饰<strong>局部变量</strong>时，它会改变该变量的<strong>存储期</strong>：</p><ul><li><strong>存储位置</strong>: 从<strong>栈 (Stack)</strong> 移动到 <strong>数据段 (.data / .bss)</strong>。</li><li><strong>生命周期</strong>: 从函数调用时创建、返回时销毁（自动存储期），延长为与整个程序运行时间相同（静态存储期）。</li></ul><p>这意味着，<code>static</code> 局部变量只在第一次执行其定义时被初始化，并且它的值在函数调用之间得以<strong>保留</strong>。</p><p><em>（关于 <code>static</code> 的全面总结，看笔记 12.4 节）</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">counter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// &#x27;count&#x27; 存储在数据段，只在首次调用时初始化为0</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;函数被调用 %d 次.\n&quot;</span>, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    counter(); <span class="comment">// 输出: 函数被调用 1 次.</span></span><br><span class="line">    counter(); <span class="comment">// 输出: 函数被调用 2 次.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="栈-stack"><a class="markdownIt-Anchor" href="#栈-stack"></a> 栈 (Stack)</h4><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://image.skyforever.top/blog/2025/10/4c82b162e43122eccdf166a0117a3deb.webp" alt="Stack Growth"></p><ul><li><strong>存储内容</strong>: 函数的<strong>局部变量</strong>、<strong>函数参数</strong>、环境变量、命令行参数及函数调用的上下文（返回地址等）。</li><li><strong>核心特点</strong>:<ul><li><strong>自动管理</strong>: 函数调用时，栈向下增长（分配）；函数返回时，栈向上收缩（释放）。程序员无法干预。</li><li><strong>空间有限</strong>: 栈大小预设且较小，过大的局部变量或过深的递归会导致<strong>栈溢出 (Stack Overflow)</strong>。</li><li><strong>高效率</strong>: 分配和释放仅涉及栈指针的移动，速度极快。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> n)</span> &#123; <span class="comment">// n 和 c 都在 func 的栈帧上</span></span><br><span class="line">    <span class="type">char</span> c[<span class="number">10</span>];</span><br><span class="line">&#125; <span class="comment">// 函数返回时，栈帧自动销毁，其内存被释放</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> main_var = <span class="number">100</span>; <span class="comment">// main_var 在 main 函数的栈帧上</span></span><br><span class="line">    func(main_var);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="堆-heap"><a class="markdownIt-Anchor" href="#堆-heap"></a> 堆 (Heap)</h4><p>堆是唯一一块可由程序员<strong>完全控制</strong>的内存区域，用于动态分配和管理内存。</p><ul><li><p><strong>核心特点</strong>:</p><ul><li><strong>手动管理</strong>: 必须通过函数（如<code>malloc</code>）申请，并通过<code>free</code>释放。忘记释放会导致<strong>内存泄漏</strong>。</li><li><strong>空间巨大</strong>: 大小理论上只受限于系统可用物理内存。</li><li><strong>匿名访问</strong>: 堆内存没有变量名，只能通过指针来访问。</li><li><strong>生命周期灵活</strong>: 从申请到释放，其生命周期由程序员决定。</li></ul></li><li><p><strong>涉及函数(<code>&lt;stdlib.h&gt;</code>)</strong>:</p><ul><li><code>void* malloc(size_t size)</code>: 申请 <code>size</code> 字节的内存，内容<strong>未初始化</strong>（随机值）。</li><li><code>void* calloc(size_t num, size_t size)</code>: 申请 <code>num</code> 个 <code>size</code> 字节的内存，内容被<strong>自动置零</strong>。</li><li><code>void free(void* ptr)</code>: 释放由 <code>malloc</code> 或 <code>calloc</code> 申请的内存。</li></ul></li><li><p><strong><code>free</code> 最佳实践</strong>:</p><ul><li><code>free()</code> 后，指针 <code>ptr</code> 会变成一个指向无效内存的<strong>悬空指针</strong>。</li><li><strong>必须</strong>在<code>free()</code>后立即将指针置为 <code>NULL</code>，以防止后续误用。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">##<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 申请一块能存放5个int的堆内存</span></span><br><span class="line">    <span class="type">int</span> *arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">NULL</span>) &#123; <span class="comment">// 检查内存申请是否成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用内存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        arr[i] = i * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(arr);   <span class="comment">// 释放内存</span></span><br><span class="line">    arr = <span class="literal">NULL</span>;  <span class="comment">// 防止悬空指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-存储期"><a class="markdownIt-Anchor" href="#6-存储期"></a> 6. 存储期</h3><p>存储期描述了变量在内存中从创建到销毁的<strong>生命周期</strong>。它与变量存储在哪个内存区域（栈、堆、数据段）直接相关。</p><h4 id="自动存储期"><a class="markdownIt-Anchor" href="#自动存储期"></a> 自动存储期</h4><ul><li><strong>对应内存区域</strong>: <strong>栈 (Stack)</strong>。</li><li><strong>生命周期</strong>: 从程序执行进入其所在的代码块开始，到离开该代码块时结束。内存的分配和释放由系统<strong>自动</strong>完成。</li><li><strong>包含变量</strong>: 所有<strong>局部变量</strong>（包括函数参数），除非被<code>static</code>修饰。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> auto_var = <span class="number">10</span>; <span class="comment">// 进入函数时创建</span></span><br><span class="line">&#125; <span class="comment">// 离开函数时，auto_var被自动销毁</span></span><br></pre></td></tr></table></figure><h4 id="静态存储期"><a class="markdownIt-Anchor" href="#静态存储期"></a> 静态存储期</h4><ul><li><strong>对应内存区域</strong>: <strong>数据段 (.data / .bss)</strong>。</li><li><strong>生命周期</strong>: 与整个程序的运行时间相同。在程序启动时创建，在程序结束时销毁。</li><li><strong>包含变量</strong>:<ul><li>所有<strong>全局变量</strong>（无论是否用<code>static</code>修饰）。</li><li>使用 <code>static</code> 修饰的<strong>局部变量</strong>。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> global_var = <span class="number">1</span>; <span class="comment">// 静态存储期</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">counter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 静态存储期，只在首次调用时初始化</span></span><br><span class="line">    count++; <span class="comment">// count的值在函数调用间得以保留</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义存储期"><a class="markdownIt-Anchor" href="#自定义存储期"></a> 自定义存储期</h4><ul><li><strong>对应内存区域</strong>: <strong>堆</strong></li><li><strong>生命周期</strong>: 完全由程序员<strong>手动控制</strong>。从 <code>malloc</code>/<code>calloc</code> 成功调用时开始，到 <code>free</code> 被调用时结束。</li><li><strong>核心风险</strong>: 忘记调用 <code>free</code> 会导致<strong>内存泄漏</strong>。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dynamic_example</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 动态内存创建</span></span><br><span class="line">    <span class="keyword">if</span> (p) &#123;</span><br><span class="line">        *p = <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// ... 使用 ...</span></span><br><span class="line">        <span class="built_in">free</span>(p); <span class="comment">// 手动销毁</span></span><br><span class="line">        p = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="static-关键字全面总结"><a class="markdownIt-Anchor" href="#static-关键字全面总结"></a> <code>static</code> 关键字全面总结</h4><p>理解 <code>static</code> 的关键在于区分它修饰的是<strong>局部变量</strong>还是<strong>全局变量/函数</strong>。</p><table><thead><tr><th style="text-align:left">上下文</th><th style="text-align:left">改变的属性</th><th style="text-align:left">效果</th><th style="text-align:left">目的</th></tr></thead><tbody><tr><td style="text-align:left"><strong>修饰局部变量</strong></td><td style="text-align:left"><strong>存储期</strong></td><td style="text-align:left">从 <strong>自动</strong> (栈上) 变为 <strong>静态</strong> (数据段)。生命周期与程序相同。</td><td style="text-align:left">在函数调用之间<strong>保持变量值的持久性</strong>。</td></tr><tr><td style="text-align:left"><strong>修饰全局变量/函数</strong></td><td style="text-align:left"><strong>链接属性</strong></td><td style="text-align:left">从 <strong>外部链接</strong> 变为 <strong>内部链接</strong>。作用域被限制在<strong>当前文件</strong>。</td><td style="text-align:left"><strong>信息隐藏</strong>和<strong>避免命名冲突</strong>，增强模块化。</td></tr></tbody></table><p><strong>详细解释与示例</strong></p><h6 id="修饰局部变量-改变存储期"><a class="markdownIt-Anchor" href="#修饰局部变量-改变存储期"></a> 修饰局部变量 (改变存储期)</h6><ul><li><p><strong>默认情况</strong>: 局部变量存储在<strong>栈</strong>上，函数调用时创建，函数返回时销毁。</p></li><li><p><strong><code>static</code> 修饰后</strong>:</p><ul><li><p><strong>存储位置</strong>: 变量从栈移到<strong>数据段</strong>（.data 或 .bss）。</p></li><li><p><strong>生命周期</strong>: 变量在程序启动时就已创建，直到程序结束才销毁。</p></li><li><p><strong>初始化</strong>: 只在编译时初始化一次。</p><p><u><strong>因此，其初始值必须是一个常量表达式（如字面量<code>10</code>、<code>'c'</code>或<code>&quot;hello&quot;</code>)，不能是运行时才存在的变量。</strong></u></p></li><li><p><strong>核心效果</strong>: 变量的值在多次函数调用之间得以<strong>保留</strong>。</p></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">##<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">counter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// a1 是 static 局部变量，存储在数据段，生命周期贯穿程序</span></span><br><span class="line">    <span class="comment">// 它只在程序加载时被初始化一次</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a1 = <span class="number">0</span>; <span class="comment">// OK: 0是常量</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> runtime_var = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// static int a2 = runtime_var; // 错误！不能用变量初始化static变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// a3 是 auto 局部变量，存储在栈上</span></span><br><span class="line">    <span class="comment">// 每次调用 counter() 时，a3 都会被重新创建并初始化为 0</span></span><br><span class="line">    <span class="type">int</span> a3 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    a1++;</span><br><span class="line">    a3++;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;static a1 = %d, auto a3 = %d\n&quot;</span>, a1, a3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    counter(); <span class="comment">// 输出: static a1 = 1, auto a3 = 1</span></span><br><span class="line">    counter(); <span class="comment">// 输出: static a1 = 2, auto a3 = 1</span></span><br><span class="line">    counter(); <span class="comment">// 输出: static a1 = 3, auto a3 = 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="修饰全局变量函数-改变链接属性"><a class="markdownIt-Anchor" href="#修饰全局变量函数-改变链接属性"></a> 修饰全局变量/函数 (改变链接属性)</h6><ul><li><strong>默认情况</strong>: 全局变量和函数具有<strong>外部链接</strong>属性，意味着它们可以被项目中任何其他 <code>.c</code> 文件通过 <code>extern</code> 关键字访问。</li><li><strong><code>static</code> 修饰后</strong>:<ul><li><strong>链接属性</strong>: 变为<strong>内部链接</strong>。</li><li><strong>核心效果</strong>: 该全局变量或函数的作用域被严格限制在<strong>定义它的那个源文件内部</strong>，对其他文件不可见。</li></ul></li></ul><p><strong><code>module_a.c</code> 文件:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">##<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// g_global_var 具有外部链接，可以被其他文件访问</span></span><br><span class="line"><span class="type">int</span> g_global_var = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// g_static_var 具有内部链接，仅在此文件内可见</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_static_var = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// global_func() 具有外部链接</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">global_func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;这是全局函数.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// static_func() 具有内部链接</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">static_func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;这是静态函数，只能在本文件里调用.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">access_vars</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;在本文件中: g_global_var = %d, g_static_var = %d\n&quot;</span>, g_global_var, g_static_var);</span><br><span class="line">    static_func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>main.c</code> 文件:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明我们希望从 module_a.c 中使用的变量和函数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> g_global_var;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">global_func</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的声明会导致链接错误，因为 g_static_var 和 static_func 是 static 的</span></span><br><span class="line"><span class="comment">// extern int g_static_var;</span></span><br><span class="line"><span class="comment">// extern void static_func();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个在 module_a.c 中定义的函数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">access_vars</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;在主函数中: g_global_var = %d\n&quot;</span>, g_global_var); <span class="comment">// OK</span></span><br><span class="line">    global_func(); <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// g_static_var = 30; // 链接错误: undefined reference to `g_static_var`</span></span><br><span class="line">    <span class="comment">// static_func();     // 链接错误: undefined reference to `static_func`</span></span><br><span class="line"></span><br><span class="line">    access_vars(); <span class="comment">// OK, 调用 module_a 内部的函数来访问其内部变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子清晰地展示了 <code>static</code> 如何作为模块化的工具，将实现细节（<code>g_static_var</code>, <code>static_func</code>）隐藏在模块内部，只暴露公共接口（<code>g_global_var</code>, <code>global_func</code>）。</p><hr><h3 id="7-函数"><a class="markdownIt-Anchor" href="#7-函数"></a> 7. 函数</h3><p>函数是 C 语言的功能模块，它将一段可重用的代码封装成一个“黑箱”，对外提供清晰的接口，隐藏内部实现。</p><h4 id="函数的构成"><a class="markdownIt-Anchor" href="#函数的构成"></a> 函数的构成</h4><ul><li><strong>函数头</strong>: <code>返回类型 函数名(参数列表)</code>，定义了函数的对外接口。</li><li><strong>函数体</strong>: <code>&#123; ... &#125;</code>，包含函数的具体实现。</li><li><strong>参数</strong>:<ul><li><strong>形参</strong>: 函数定义中的变量，作为输入。</li><li><strong>实参</strong>: 函数调用时传递的实际值，用于初始化形参。</li></ul></li><li><strong>返回值</strong>: 使用 <code>return</code> 关键字从函数中返回一个值。<code>void</code>类型表示不返回任何值。</li><li><strong>局部变量</strong>: 定义在函数体内的变量，存储在<strong>栈</strong>上，函数返回后即销毁。<strong>严禁</strong>返回局部变量的地址。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过指针交换两个变量的值</span></span><br><span class="line"><span class="comment">// p1和p2是形参(指针)，temp是局部变量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">double</span> *p1, <span class="type">double</span> *p2)</span> &#123;</span><br><span class="line">    <span class="type">double</span> temp = *p1;</span><br><span class="line">    *p1 = *p2;</span><br><span class="line">    *p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">double</span> a = <span class="number">3.14</span>, b = <span class="number">0.618</span>; <span class="comment">// a, b是实参</span></span><br><span class="line">    swap(&amp;a, &amp;b); <span class="comment">// 传递a和b的地址进行交换</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="特殊函数类型"><a class="markdownIt-Anchor" href="#特殊函数类型"></a> 特殊函数类型</h4><h5 id="递归函数"><a class="markdownIt-Anchor" href="#递归函数"></a> 递归函数</h5><p>函数在体内调用自身。必须包含<strong>递推关系</strong>和<strong>终止条件</strong>，否则会因无限递归导致栈溢出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算阶乘: f(n) = n * f(n-1)</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>); <span class="comment">// 递推关系</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="静态函数"><a class="markdownIt-Anchor" href="#静态函数"></a> 静态函数</h5><p>使用 <code>static</code> 修饰的函数，其作用域被限制在<strong>当前源文件</strong>内，用于实现模块化和避免命名冲突。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该函数只能在定义它自己所在的.c文件中被调用</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">helper_function</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure><h5 id="回调函数"><a class="markdownIt-Anchor" href="#回调函数"></a> 回调函数</h5><p>通过<strong>函数指针</strong>作为参数传递给另一函数，由后者在特定时机“回调”执行。这是一种强大的解耦机制，常见于事件处理、分层设计和系统 API 中。</p><p><strong>示例 1：简单的策略切换</strong><br>下面的 <code>eat</code> 函数并不关心具体“做什么菜”，只负责“吃”。具体菜系（<code>yuecai</code> 或 <code>chuancai</code>）由调用方通过函数指针传入，实现了行为的灵活切换。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">##<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义两个菜系函数，它们的签名（参数、返回值）完全相同</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">yuecai</span><span class="params">(<span class="type">int</span> a, <span class="type">float</span> b)</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;做粤菜: %d %.1f\n&quot;</span>, a, b); &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">chuancai</span><span class="params">(<span class="type">int</span> a, <span class="type">float</span> b)</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;做川菜: %d %.1f\n&quot;</span>, a, b); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// eat函数接收一个函数指针cook作为参数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">eat</span><span class="params">(<span class="type">void</span> (*cook)(<span class="type">int</span> a, <span class="type">float</span> b))</span> &#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="type">float</span> f = <span class="number">2.5</span>;</span><br><span class="line">  cook(a, f); <span class="comment">// 调用传入的函数指针</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;吃饭\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;今晚想吃粤菜:\n&quot;</span>);</span><br><span class="line">  eat(yuecai); <span class="comment">// 传入粤菜函数的地址</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n明天想吃川菜:\n&quot;</span>);</span><br><span class="line">  eat(chuancai); <span class="comment">// 传入川菜函数的地址</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 2：系统事件处理 (信号)</strong><br>这是回调函数最经典的应用之一。我们告诉操作系统：“当某个事件（如<code>SIGINT</code>信号，即按下 Ctrl+C）发生时，请调用我指定的这个函数（<code>my_handler</code>）”。这个过程就是<strong>注册回调</strong>。</p><h6 id="signal-函数详解"><a class="markdownIt-Anchor" href="#signal-函数详解"></a> <code>signal</code> 函数详解</h6><p><code>signal</code> 函数是 C 标准库 <code>&lt;signal.h&gt;</code> 中用于处理异步信号的核心函数。</p><ul><li><p><strong>函数原型</strong>: <code>void (*signal(int signum, void (*handler)(int)))(int);</code><br>这个原型非常复杂，是“返回函数指针的函数”的典型例子。我们可以用 <code>typedef</code> 来简化理解（这也是推荐的最佳实践）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 为信号处理函数指针定义一个别名 sighandler_t</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 原型现在变得清晰易读</span></span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;</span><br></pre></td></tr></table></figure><p>这样就很清楚了：<code>signal</code> 函数接收一个信号编号和一个处理函数指针，并返回一个<strong>旧的</strong>处理函数指针。</p></li><li><p><strong>参数说明</strong>:</p><ol><li><code>int signum</code>: 信号的编号。通常使用标准宏来表示，例如：<ul><li><code>SIGINT</code>: 中断信号，通常由用户在终端按下 <code>Ctrl+C</code> 产生。</li><li><code>SIGTERM</code>: 终止信号，是 <code>kill</code> 命令发送的默认信号，用于请求程序正常退出。</li><li><code>SIGSEGV</code>: 段错误信号，当程序试图访问其无权访问的内存区域时产生。</li></ul></li><li><code>sighandler_t handler</code>: 指向信号处理函数的指针。这里可以传递三种值：<ul><li><strong>一个自定义函数</strong>: 这就是我们的回调函数。它必须接收一个 <code>int</code> (信号编号) 参数并返回 <code>void</code>。</li><li><code>SIG_DFL</code>: 一个特殊的宏，表示恢复对该信号的<strong>默认处理行为</strong>（例如，<code>SIGINT</code> 的默认行为是终止程序）。</li><li><code>SIG_IGN</code>: 一个特殊的宏，表示<strong>忽略</strong>该信号。</li></ul></li></ol></li><li><p><strong>返回值</strong>:</p><ul><li><strong>成功时</strong>: 返回<strong>之前</strong>的信号处理函数的指针。这允许你保存旧的处理方式，以便之后可以恢复它。</li><li><strong>失败时</strong>: 返回 <code>SIG_ERR</code>，并设置 <code>errno</code>。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">##<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line">##<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">##<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 实现具体的回调函数 (也称 handler 或钩子函数)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n接收到信号 %d！正在处理...\n&quot;</span>, sig);</span><br><span class="line">    <span class="comment">// 在实际应用中，这里会执行清理工作</span></span><br><span class="line">    <span class="comment">// exit(0); // 可以在处理函数中决定是否退出程序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 2. 注册回调：将函数指针my_handler传给signal函数</span></span><br><span class="line">    <span class="comment">// 相当于告诉内核：当收到SIGINT信号时，请调用my_handler</span></span><br><span class="line">    signal(SIGINT, my_handler);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;程序正在运行，PID: %d。请按 Ctrl+C 来触发回调...\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无限循环，等待信号的到来</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>); <span class="comment">// sleep可以减少CPU占用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 这行通常不会被执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="面试题实战-函数参数传递传值-vs-传址"><a class="markdownIt-Anchor" href="#面试题实战-函数参数传递传值-vs-传址"></a> 面试题实战-函数参数传递：传值 vs 传址</h4><p>C 语言中所有函数参数传递<strong>本质上都是传值</strong>。但通过传递指针，可以达到“传址”的效果。</p><ul><li><p><strong>传值</strong>:</p><ul><li><strong>过程</strong>: 将实参的<strong>副本</strong>传递给形参。</li><li><strong>效果</strong>: 函数内部对形参的任何修改，都<strong>不会</strong>影响到函数外部的实参。</li></ul></li><li><p><strong>传址</strong>:</p><ul><li><strong>过程</strong>: 将实参的<strong>地址</strong>（通过 <code>&amp;</code> 运算符获取）传递给一个指针类型的形参。</li><li><strong>效果</strong>: 函数内部通过解引用指针 (<code>*p</code>)，可以直接访问和修改函数外部实参的值。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传值：a是x的副本</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">modify_value</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    a = <span class="number">99</span>; <span class="comment">// 只修改了副本a，不影响外部的x</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传址：p接收了y的地址</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">modify_address</span><span class="params">(<span class="type">int</span> *p)</span> &#123;</span><br><span class="line">    *p = <span class="number">99</span>; <span class="comment">// 通过地址，直接修改了外部y的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    modify_value(x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;传值调用后, x = %d\n&quot;</span>, x); <span class="comment">// 输出: 10</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> y = <span class="number">10</span>;</span><br><span class="line">    modify_address(&amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;传址调用后, y = %d\n&quot;</span>, y); <span class="comment">// 输出: 99</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="8-作用域"><a class="markdownIt-Anchor" href="#8-作用域"></a> 8. 作用域</h3><p>作用域定义了标识符（变量名、函数名等）在代码中的可见范围。合理利用作用域可以避免命名冲突，是模块化编程的基础。</p><h4 id="作用域的类型"><a class="markdownIt-Anchor" href="#作用域的类型"></a> 作用域的类型</h4><ul><li><p><strong>块作用域</strong>:</p><ul><li><p><strong>范围</strong>: 一对花括号 <code>&#123;&#125;</code> 内部。</p></li><li><p><strong>特点</strong>: 在代码块内定义的变量（<strong>局部变量</strong>）仅在该块内可见，从定义处开始到右花括号结束。</p></li><li><p><strong>遮蔽 <strong>: 内层作用域可以定义与外层同名的变量，此时内层变量会</strong>临时遮蔽</strong>外层变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">100</span>; <span class="comment">// 全局作用域</span></span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// main函数的块作用域</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">200</span>; <span class="comment">// 遮蔽全局a, 此处a为200</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 内部块作用域</span></span><br><span class="line">        <span class="type">int</span> a = <span class="number">300</span>; <span class="comment">// 再次遮蔽, 此处a为300</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a); <span class="comment">// 输出: 300</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a); <span class="comment">// 输出: 200, 内部块结束, 遮蔽解除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>文件作用域</strong>:</p><ul><li><p><strong>范围</strong>: 从定义处开始，到当前源文件末尾。</p></li><li><p><strong>特点</strong>: 在任何函数之外定义的变量（<strong>全局变量</strong>）具有文件作用域。默认情况下，全局变量可以被其他文件通过 <code>extern</code> 关键字访问。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.c 文件</span></span><br><span class="line"><span class="type">int</span> global_var = <span class="number">10</span>; <span class="comment">// 全局变量, 文件作用域</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// b.c 文件</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> global_var; <span class="comment">// 声明以访问a.c中的全局变量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">use_global</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, global_var); <span class="comment">// 输出: 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>函数原型作用域</strong>:</p><ul><li><p><strong>范围</strong>: 仅限于函数声明的括号内。</p></li><li><p><strong>特点</strong>: 参数名只在声明中起解释作用，在编译时会被忽略，可以省略。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a 和 b 的作用域仅在此行</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="static-对全局变量函数的影响"><a class="markdownIt-Anchor" href="#static-对全局变量函数的影响"></a> <code>static</code> 对全局变量/函数的影响</h4><p>当 <code>static</code> 用于修饰<strong>全局变量</strong>或<strong>函数</strong>时，它会改变标识符的<strong>链接属性</strong>，从“外部链接(external)”改为“内部链接(internal)”。</p><ul><li><strong>效果</strong>: <code>static</code> 修饰的全局变量或函数的作用域被限制在<strong>当前源文件内</strong>，其他 <code>.c</code> 文件无法通过 <code>extern</code> 关键字访问它们。</li></ul><p>这对于<strong>信息隐藏</strong>和<strong>模块化编程</strong>至关重要，可以有效避免不同模块间的命名冲突。</p><p><em>（关于 <code>static</code> 的全面总结，看笔记 12.4 节）</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.c 文件</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> file_local_var = <span class="number">5</span>; <span class="comment">// 此变量仅在 a.c 中可见</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">helper_func</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125; <span class="comment">// 此函数仅在 a.c 中可调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// b.c 文件</span></span><br><span class="line"><span class="comment">// extern int file_local_var; // 错误！无法链接到 a.c 中的 static 变量</span></span><br><span class="line"><span class="comment">// extern void helper_func();  // 错误！无法链接到 a.c 中的 static 函数</span></span><br></pre></td></tr></table></figure><h3 id="第三部分c-语言的精髓指针与复合类型"><a class="markdownIt-Anchor" href="#第三部分c-语言的精髓指针与复合类型"></a> 第三部分：C 语言的精髓：指针与复合类型</h3><h3 id="9-数组"><a class="markdownIt-Anchor" href="#9-数组"></a> 9. 数组</h3><h4 id="数组定义与初始化"><a class="markdownIt-Anchor" href="#数组定义与初始化"></a> 数组定义与初始化</h4><ul><li><p><strong>定义</strong>: <code>类型说明符 数组名 [常量表达式];</code></p></li><li><p><strong>初始化</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b1[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;      <span class="comment">// 完全初始化</span></span><br><span class="line"><span class="type">int</span> b3[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;            <span class="comment">// 部分初始化，其余元素为未知</span></span><br><span class="line"><span class="type">int</span> b4[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;       <span class="comment">// 根据初始化内容推断大小</span></span><br><span class="line"><span class="type">int</span> b6[<span class="number">5</span>] = &#123;[<span class="number">0</span> ... <span class="number">4</span>] = <span class="number">1</span>&#125;;      <span class="comment">// GCC/Clang 的扩展：指定初始化所有元素为1</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="数组元素引用"><a class="markdownIt-Anchor" href="#数组元素引用"></a> 数组元素引用</h4><ul><li><p>通过下标访问: <code>数组名[下标]</code>，下标从 <code>0</code> 开始。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[<span class="number">1</span>]); <span class="comment">// 输出第二个元素: 2</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="字符数组与多维数组"><a class="markdownIt-Anchor" href="#字符数组与多维数组"></a> 字符数组与多维数组</h4><ul><li><p><strong>字符数组初始化</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s1[<span class="number">3</span>] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"><span class="type">char</span> s3[<span class="number">5</span>] = <span class="string">&quot;abc&quot;</span>; <span class="comment">// 自动在末尾添加 &#x27;\0&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>多维数组定义与初始化</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译器里只有一维数组</span></span><br><span class="line"><span class="type">int</span> (c[<span class="number">3</span>]);      <span class="comment">// 内存分布： |int|int|int|</span></span><br><span class="line"><span class="comment">//二维数组定义分为以下两个部分</span></span><br><span class="line"><span class="comment">// 1, x[3]   是数组的定义，表示该数组拥有3个元素</span></span><br><span class="line"><span class="comment">// 2, int [4]是元素的类型，表示该数组元素是一个具有4个元素的整型数组</span></span><br><span class="line"><span class="type">int</span> (x[<span class="number">3</span>]) [<span class="number">4</span>];  <span class="comment">// 内存分布： |int[4]|int[4]|int[4]|</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个3行4列的二维数组</span></span><br><span class="line"><span class="type">int</span> y1[<span class="number">3</span>][<span class="number">4</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;, &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;, &#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125; &#125;;</span><br><span class="line"><span class="comment">// 可以省略第一维的大小</span></span><br><span class="line"><span class="type">int</span> y4[][<span class="number">4</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;, &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125; &#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="面试题实战-二维数组边界元素遍历"><a class="markdownIt-Anchor" href="#面试题实战-二维数组边界元素遍历"></a> [面试题实战] 二维数组边界元素遍历</h4><p>这是一个常见的算法问题，考验对二维数组索引的精确控制能力。</p><h4 id="代码示例-天彩电子-23c"><a class="markdownIt-Anchor" href="#代码示例-天彩电子-23c"></a> 代码示例 (<code>天彩电子-23.c</code>)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> w[N][N])</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;N; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, w[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> N = <span class="number">5</span>; <span class="comment">// 示例大小</span></span><br><span class="line">    <span class="type">int</span> w[N][N];</span><br><span class="line"></span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;N; j++) &#123;</span><br><span class="line">            w[i][j] = rand()%<span class="number">1000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;生成的 %d x %d 数组:\n&quot;</span>, N, N);</span><br><span class="line">    show(N, w);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(N == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;周围数据平均数是: %f\n&quot;</span>, (<span class="type">float</span>)w[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="comment">// 累加首行和末行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">        sum += w[<span class="number">0</span>][i];    <span class="comment">// Top row</span></span><br><span class="line">        sum += w[N<span class="number">-1</span>][i];  <span class="comment">// Bottom row</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 累加首列和末列（不含已计算过的角点）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;N<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        sum += w[i][<span class="number">0</span>];    <span class="comment">// Left column (excluding corners)</span></span><br><span class="line">        sum += w[i][N<span class="number">-1</span>];  <span class="comment">// Right column (excluding corners)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 总边界元素个数为 4*N - 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n边界元素总和: %.2f\n&quot;</span>, sum);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;边界元素平均数是: %f\n&quot;</span>, sum / (<span class="number">4.0</span> * N - <span class="number">4.0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="10-指针"><a class="markdownIt-Anchor" href="#10-指针"></a> 10. 指针</h3><h4 id="指针定义与赋值"><a class="markdownIt-Anchor" href="#指针定义与赋值"></a> 指针定义与赋值</h4><ul><li><p><strong>指针</strong>: 存储另一个变量的内存地址。</p></li><li><p><strong>定义</strong>: <code>类型说明符 *指针变量名;</code></p></li><li><p><strong>赋值 (取地址)</strong>: 使用 <code>&amp;</code> 运算符获取变量地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> *p;   <span class="comment">// p是一个指针，准备指向一个int型变量</span></span><br><span class="line">p = &amp;a;   <span class="comment">// 将变量a的地址赋给p（取地址）</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="指针解引用"><a class="markdownIt-Anchor" href="#指针解引用"></a> 指针解引用</h4><ul><li><p><strong>解引用</strong>: 使用 <code>*</code> 运算符访问指针指向的内存地址中的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*p = <span class="number">100</span>; <span class="comment">// 将p指向的地址(即变量a)的值设为100</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a); <span class="comment">// 输出 100</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="野指针与空指针"><a class="markdownIt-Anchor" href="#野指针与空指针"></a> 野指针与空指针</h4><ul><li><p><strong>野指针</strong>: 指向不确定或已释放内存的指针。</p><ul><li><strong>避免</strong>: 初始化时置为 <code>NULL</code>，释放后也置为 <code>NULL</code>。</li></ul></li><li><p><strong>空指针</strong>: 不指向任何对象的指针，其值为 <code>NULL</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>; <span class="comment">// 良好习惯：初始化指针为NULL</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="指针运算"><a class="markdownIt-Anchor" href="#指针运算"></a> 指针运算</h4><ul><li><p>对指针进行 <code>+</code>, <code>-</code> 运算，其移动的单位是指针所指向类型的大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// a是数组首元素地址，a+1指向第二个元素</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *(a + <span class="number">1</span>)); <span class="comment">// 输出 2</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="面试题实战-const指针的三种模式辨析"><a class="markdownIt-Anchor" href="#面试题实战-const指针的三种模式辨析"></a> 面试题实战 - <code>const</code>指针的三种模式辨析</h4><ul><li><p><strong><code>const int *p</code></strong>: <strong>常目标指针</strong>。指针指向的内容 <code>*p</code> 不可变，但指针自身 <code>p</code> 的指向可以改变。</p><ul><li>记忆：<code>const</code> 在 <code>*</code> 左边，修饰的是目标。</li></ul></li><li><p><strong><code>int * const p</code></strong>: <strong>常指针</strong>。指针自身 <code>p</code> 的指向不可变，但指针指向的内容 <code>*p</code> 可以改变。</p><ul><li>记忆：<code>const</code> 在 <code>*</code> 右边，修饰的是指针 <code>p</code>。</li></ul></li><li><p><strong><code>const int * const p</code></strong>: 指针自身和其指向的内容都不可变。</p><p>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 常目标指针</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p1 = &amp;a;</span><br><span class="line"><span class="comment">// *p1 = 100; // 错误: 不能通过p1修改a的值</span></span><br><span class="line">p1 = &amp;b;   <span class="comment">// 正确: p1可以指向其他变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 常指针</span></span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> p2 = &amp;a;</span><br><span class="line">*p2 = <span class="number">100</span>; <span class="comment">// 正确: 可以通过p2修改a的值</span></span><br><span class="line"><span class="comment">// p2 = &amp;b;   // 错误: p2的指向不能改变</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 两者都不可变</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p3 = &amp;a;</span><br><span class="line"><span class="comment">// *p3 = 100; // 错误</span></span><br><span class="line"><span class="comment">// p3 = &amp;b;   // 错误</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="11-数组与指针的关系"><a class="markdownIt-Anchor" href="#11-数组与指针的关系"></a> 11. 数组与指针的关系</h3><h4 id="数组名即指针"><a class="markdownIt-Anchor" href="#数组名即指针"></a> 数组名即指针</h4><ul><li><p><u><strong>在任意表达式中（除了 sizeof 和&amp;之外），数组名 a 都代表数组的首地址</strong></u></p></li><li><p><code>a[i]</code> 本质上是 <code>*(a + i)</code> 的语法糖。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// a[1] 和 *(&amp;a[0]+1) 和 *(a+1) 是等价的</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[<span class="number">1</span>]);       <span class="comment">// 输出 2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *(a + <span class="number">1</span>));   <span class="comment">// 输出 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *a);         <span class="comment">//1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%#lun\n&quot;</span>, a);       <span class="comment">//a的首地址</span></span><br></pre></td></tr></table></figure></li><li><p>另外一个例子：</p><p>如果看起来吃力，可以先看 7.0 复杂指针解读方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span>* argv[])</span> &#123;</span><br><span class="line">  <span class="comment">// a: 二维整型数组</span></span><br><span class="line">  <span class="comment">// a 是一个包含2个元素的数组，它的每个元素是“一个包含3个int的数组”。</span></span><br><span class="line">  <span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// b: 数组指针</span></span><br><span class="line">  <span class="comment">// b 是一个指针数组，它其中的每个元素指向的目标是“一个包含3个int的数组”。</span></span><br><span class="line">  <span class="type">int</span> (*b)[<span class="number">3</span>];</span><br><span class="line">  <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  b = a;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(a) / <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// b 指向 a 的第一行，*b 的类型是 int[3]</span></span><br><span class="line">    <span class="comment">// 在表达式中，*b 会退化为指向其首元素(a[0][0])的指针</span></span><br><span class="line">    <span class="comment">// 因此 **b 就是 a[0][0] 的值</span></span><br><span class="line">    sum += *(*b + i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// c: 数组指针的数组</span></span><br><span class="line">  <span class="comment">// c 是一个包含2个元素的数组，它的每个元素是“一个指向包含3个int的数组的指针”。</span></span><br><span class="line">  <span class="type">int</span> (*c[<span class="number">2</span>])[<span class="number">3</span>] = &#123;&amp;a[<span class="number">0</span>], &amp;a[<span class="number">1</span>]&#125;;  <span class="comment">// c[]存a[]的地址</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">      <span class="comment">// c[i]存a[i]的地址,a[i]是个数组</span></span><br><span class="line">      <span class="comment">// 因为这是一个数组，所以也可以等于首元素1的地址</span></span><br><span class="line">      <span class="comment">// 向右移动int类型的4字节，得到2的地址</span></span><br><span class="line">      <span class="comment">// **c[i]解引用得到地址里的值2</span></span><br><span class="line">      sum += *(*c[i] + j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// d: 二维指针数组</span></span><br><span class="line">  <span class="comment">// d 的每个元素(d[i][j])的类型是“指向int的指针(int *)”。</span></span><br><span class="line">  <span class="type">int</span>* d[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">      d[i][j] = &amp;a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">      sum += *d[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="函数中的数组参数"><a class="markdownIt-Anchor" href="#函数中的数组参数"></a> 函数中的数组参数</h4><ul><li><p>数组作为函数参数时，实际上传递的是指向数组首元素的指针。</p></li><li><p><code>void func(int arr[])</code> 的写法本质上等价于 <code>void func(int *arr)</code>。编译器会自动将数组形式的参数转换为指针。</p></li><li><p><strong>核心规则</strong>: <u><strong>在任意表达式中（除了 sizeof 和&amp;之外），数组名 a 都代表数组的首地址</strong></u>。当数组名作为函数实参传递时，它被转化为指向其首元素的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数 k[3] 实际上是一个指针 (int *k)，因此 sizeof(k) 会得到指针的大小（通常是8字节 on 64-bit system）</span></span><br><span class="line"><span class="comment">// 而不是数组的大小 (3 * 4 = 12 字节)。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> a, <span class="type">float</span> f, <span class="type">int</span> *p, <span class="type">int</span> k[<span class="number">3</span>])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(k) in function: %ld\n&quot;</span>, <span class="keyword">sizeof</span>(k)); <span class="comment">// 输出指针大小, e.g., 8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">  <span class="type">float</span> f = <span class="number">1.23</span>;</span><br><span class="line">  <span class="type">int</span> *p = &amp;a;</span><br><span class="line">  <span class="type">int</span> k[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sizeof(k) in main: %ld\n&quot;</span>, <span class="keyword">sizeof</span>(k)); <span class="comment">// 输出数组大小, 12</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当数组 k 作为参数传递时，它退化为指向 k[0] 的指针</span></span><br><span class="line">  f1(a, f, p, k);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://image.skyforever.top/blog/2025/10/54df2499a6f4acf0f37c737d7318cad0.webp" alt="指针定义"></p><h3 id="12-特殊数组与高级指针"><a class="markdownIt-Anchor" href="#12-特殊数组与高级指针"></a> 12. 特殊数组与高级指针</h3><h4 id="复杂指针解读方法"><a class="markdownIt-Anchor" href="#复杂指针解读方法"></a> <strong>复杂指针解读方法</strong></h4><ul><li><p><strong>核心方法：右左法则 (Right-Left Rule)</strong></p><ol><li>从 <strong>变量名</strong> 开始。</li><li>优先向 <strong>右</strong> 看，遇到 <code>[]</code> (数组) 或 <code>()</code> (函数)。</li><li>再向 <strong>左</strong> 看，遇到 <code>*</code> (指针)。</li><li>遇到括号，先解析完括号内的，再跳出。</li><li>最后，读最左边的 <strong>类型名</strong>。</li></ol></li><li><p><strong>示例 1：数组指针</strong></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*b[<span class="number">2</span>])[<span class="number">3</span>];</span><br><span class="line"><span class="comment">// 1. b:                b 是一个...</span></span><br><span class="line"><span class="comment">// 2. b[2]:             ...包含2个元素的数组</span></span><br><span class="line"><span class="comment">// 3. (*b[2]):          数组的元素是 指针</span></span><br><span class="line"><span class="comment">// 4. (*b[2])[3]:       指针指向 一个含3个int类型元素的数组</span></span><br><span class="line"><span class="comment">// 结论: b 是一个包含2个元素的数组，每个元素都是一个指针，指向一个包含3个int的数组</span></span><br></pre></td></tr></table></figure><ul><li><strong>示例 2：函数指针与 <code>typedef</code> 最佳实践</strong></li></ul><p>对于极端复杂的声明，手动分析既困难又易错。最佳实践是使用 <code>typedef</code> 定义别名。</p><ul><li><p>识别步骤</p><ol><li><p>找到标识符 <strong>signal</strong>。</p></li><li><p>向右看，是 ()，说明 signal 是一个<strong>函数</strong>。</p></li><li><p>signal 函数括号内接收两个参数：int sig 和 void (*func)(int)</p><p>对于第二个参数 func，我们可以独立应用右左法则：func 是一个指向“接收 int，返回 void”的函数的指针</p></li><li><p>解析完函数参数，回到 signal，向左看，是 *。说明 signal 函数的<strong>返回值是一个指针</strong></p></li><li><p>跳出 signal(…) 的范围，继续向右看，是 (int)。说明 signal 返回的那个指针，指向一个<strong>接收 int 参数的函数</strong></p></li><li><p>最后，看最左边的类型 void。这个函数返回 <strong>void 类型</strong></p></li></ol></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始声明，难以阅读</span></span><br><span class="line"><span class="type">void</span> (*signal(<span class="type">int</span> sig, <span class="type">void</span> (*func)(<span class="type">int</span>)))(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最佳实践: 使用 typedef 别名简化</span></span><br><span class="line"><span class="comment">// 1. 为该函数指针类型起一个清晰的别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">handler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用别名重写声明，一目了然</span></span><br><span class="line"><span class="type">handler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> sig, <span class="type">handler_t</span> func)</span>;</span><br></pre></td></tr></table></figure><h4 id="零长数组"><a class="markdownIt-Anchor" href="#零长数组"></a> 零长数组</h4><ul><li><p>GNU C 扩展，<code>type name[0]</code>，用于变长结构体，不占用结构体大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="type">float</span> score;</span><br><span class="line">  <span class="type">char</span> sign[<span class="number">0</span>]; <span class="comment">// 零长数组成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 为结构体和签名分配连续内存</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">s</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> stu) + <span class="number">10</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(s-&gt;sign, <span class="string">&quot;helloworl&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s-&gt;sign); <span class="comment">// 输出 &quot;helloworl&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="变长数组"><a class="markdownIt-Anchor" href="#变长数组"></a> 变长数组</h4><ul><li><p>C99 标准引入，数组大小在运行时由变量确定。</p></li><li><p><strong>注意</strong>: 变长数组具有自动存储期（即在栈上分配），因此<strong>不能使用 <code>static</code> 关键字修饰</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> len = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> b[len]; <span class="comment">// 正确：在栈上创建变长数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// static int c[len]; // 错误：static数组的大小必须在编译时确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法在编译时给运行时确定大小的数组初始化</span></span><br><span class="line"><span class="comment">// int b[len] = &#123;1,2,3,4,5&#125;;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) b[i] = <span class="number">666</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="字符指针"><a class="markdownIt-Anchor" href="#字符指针"></a> 字符指针</h4><ul><li><p><code>char *s = &quot;hello&quot;;</code> 指针 <code>s</code> 指向一个字符串字面量（是只读的）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, p + <span class="number">1</span>); <span class="comment">// 输出 &quot;bcd&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *k[<span class="number">3</span>] = &#123;<span class="string">&quot;12345&quot;</span>, <span class="string">&quot;abcddegg&quot;</span>, <span class="string">&quot;www.yeu&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *k);           <span class="comment">// &quot;12345&quot;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(k + <span class="number">1</span>));     <span class="comment">// 输出 &quot;abcddegg&quot;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, k[<span class="number">0</span>] + <span class="number">1</span>);     <span class="comment">// &quot;2345&quot;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, *(k[<span class="number">0</span>] + <span class="number">1</span>));  <span class="comment">//&#x27;2</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>[!WARNING]</p><p>通过 char *p = “hello”; 创建的指针 p 指向的是一个<strong>字符串字面量</strong>。字符串字面量通常存储在内存的<strong>只读数据段 (.rodata)</strong>。</p><p><strong>任何试图通过指针修改其内容的行为都是未定义的，通常会导致程序崩溃（段错误）。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">p[<span class="number">0</span>] = <span class="string">&#x27;H&#x27;</span>; <span class="comment">// 错误！非常危险的操作！</span></span><br></pre></td></tr></table></figure><p>如果你需要一个可以修改的字符串，必须使用数组来创建：char s[] = “hello”;</p></blockquote><h4 id="void-指针"><a class="markdownIt-Anchor" href="#void-指针"></a> <code>void</code> 指针</h4><ul><li><p>通用指针 <code>void *</code>，可存储任何类型的地址，但不能直接解引用，需先强制类型转换。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *m = <span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line"><span class="comment">// 将void*指针转换为int*指针再进行操作</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  *((<span class="type">int</span> *)m + i) = i*<span class="number">100</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *((<span class="type">int</span> *)m + i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="const-指针"><a class="markdownIt-Anchor" href="#const-指针"></a> <code>const</code> 指针</h4><ul><li><p><code>const int *p</code>: const 修饰*p，指针指向的内容不可变 (常目标指针)。</p></li><li><p><code>int const *p</code>: const 修饰*p，指针指向的内容不可变 (常目标指针)。</p></li><li><p><code>int * const p</code>: const 修饰 p，指针自身存的地址不可变 (常指针)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="comment">// 常指针: const修饰指针变量p，p的指向不可改，但*p的值可改 (可读写它指向的内容但无法修改它指向谁)</span></span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p = &amp;a;</span><br><span class="line">*p = <span class="number">200</span>; <span class="comment">// OK</span></span><br><span class="line"><span class="comment">// p = &amp;b; // Error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常目标指针: const修饰类型int，*k的值不可改，但k的指向可改（只读不写）</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *k = &amp;a;</span><br><span class="line"><span class="comment">// *k = 300; // Error</span></span><br><span class="line">k = &amp;b; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="多级指针"><a class="markdownIt-Anchor" href="#多级指针"></a> 多级指针</h4><ul><li><p>指向指针的指针，如 <code>int **p</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> w      [<span class="number">10</span>];  <span class="comment">// w的类型是int [10]</span></span><br><span class="line"><span class="type">int</span> (*pw)  [<span class="number">10</span>];  <span class="comment">// 一级指针</span></span><br><span class="line"><span class="type">int</span> (**pw2)[<span class="number">10</span>];  <span class="comment">// 二级指针，pw2--&gt;pw --&gt;w</span></span><br><span class="line"></span><br><span class="line">(*pw)  [<span class="number">0</span>] = <span class="number">666</span>;</span><br><span class="line">(**pw2)[<span class="number">0</span>] = <span class="number">666</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, w); <span class="comment">// 输出 数组w的首地值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, w[<span class="number">0</span>]);      <span class="comment">// 输出: 666</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (*pw)[<span class="number">0</span>]);   <span class="comment">// 输出: 666</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="函数指针"><a class="markdownIt-Anchor" href="#函数指针"></a> 函数指针</h4><ul><li><p>指向函数的指针，是实现回调函数等高级技巧的基础。</p></li><li><p><strong>定义</strong>: <code>返回类型 (*指针名)(参数列表);</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个普通函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxValue</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个接收函数指针作为参数的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> (*function)(<span class="type">int</span> a, <span class="type">int</span> b))</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;通过函数指针调用，结果: %d\n&quot;</span>, function(<span class="number">7</span>, <span class="number">8</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="comment">// 1. 定义一个函数指针p，它专门指向“接收两个int，返回int”的函数</span></span><br><span class="line">  <span class="type">int</span> (*p)(<span class="type">int</span> a, <span class="type">int</span> b);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 将函数maxValue的地址赋给p</span></span><br><span class="line">  <span class="comment">// 特殊语法：函数名取地址时，&amp;可以省略</span></span><br><span class="line">  p = maxValue;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 通过函数名直接调用</span></span><br><span class="line">  <span class="type">int</span> m = maxValue(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;直接调用，结果: %d\n&quot;</span>, m);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 通过函数指针p间接调用</span></span><br><span class="line">  <span class="comment">// 特殊语法：通过函数指针调用函数时，解引用*可以省略</span></span><br><span class="line">  <span class="type">int</span> n = p(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;通过指针调用，结果: %d\n&quot;</span>, n);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5. 将函数名作为参数传递</span></span><br><span class="line">  f(maxValue);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="13-结构体-struct"><a class="markdownIt-Anchor" href="#13-结构体-struct"></a> 13. 结构体 (Struct)</h3><p>结构体是 C 语言的核心特性，它允许我们将不同类型的数据项组合成一个单一的、逻辑相关的整体。</p><h4 id="定义-初始化与使用"><a class="markdownIt-Anchor" href="#定义-初始化与使用"></a> 定义、初始化与使用</h4><ul><li><strong>定义</strong>: 使用 <code>struct</code> 关键字创建一个“蓝图”，描述这个复合数据类型包含哪些成员。</li><li><strong>变量</strong>: 根据“蓝图”定义实际的结构体变量。</li><li><strong>初始化</strong>:<ul><li><strong>传统初始化</strong>: 按顺序为成员赋值 <code>&#123;...&#125;</code>。</li><li><strong>指定成员初始化</strong>: 使用 <code>.成员名 = 值</code> 的方式，可以不按顺序，更清晰。</li></ul></li><li><strong>成员访问</strong>:<ul><li>对结构体变量，使用点运算符 <code>.</code>。</li><li>对结构体指针，使用箭头运算符 <code>-&gt;</code> (它等价于 <code>(*指针).成员</code> 的语法糖)。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">##<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">##<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 定义一个结构体类型（设计蓝图）</span></span><br><span class="line"><span class="comment">// 结构体类型名叫student</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 成员</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内嵌结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">char</span> *name;</span><br><span class="line">        <span class="type">float</span> price;</span><br><span class="line">    &#125; book;<span class="comment">//结构体变量叫book</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐将结构体作为指针传递，避免内存拷贝开销</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_student_info</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> student *p)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 2. 定义结构体变量并初始化</span></span><br><span class="line">    <span class="comment">// 传统初始化，按成员顺序赋值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">zhangsan</span> =</span> &#123;<span class="number">20</span>, <span class="number">90.0</span>, <span class="string">&quot;zhangsan&quot;</span>, &#123;<span class="string">&quot;嵌入式参考书&quot;</span>, <span class="number">40.5</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定成员初始化 (推荐)</span></span><br><span class="line">    <span class="comment">// 顺序改变不影响给成员赋值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">lisi</span> =</span> &#123;</span><br><span class="line">        .age = <span class="number">21</span>,</span><br><span class="line">        .name = <span class="string">&quot;lisi&quot;</span>,</span><br><span class="line">        .book = &#123;</span><br><span class="line">            .name = <span class="string">&quot;数学书&quot;</span>,</span><br><span class="line">            .price = <span class="number">20.0</span>&#125;,</span><br><span class="line">        .score = <span class="number">70.0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 访问成员</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;姓名：%s\n&quot;</span>, zhangsan.name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;教材价格：%f\n&quot;</span>, zhangsan.book.price);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 推荐通过指针访问，指针只有8字节，而结构体变量本身可能很大</span></span><br><span class="line">    <span class="comment">// 如果直接传递结构体（值传递），会复制整个结构体到栈上，开销巨大</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">p</span> =</span> &amp;lisi;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;姓名：%s\n&quot;</span>, p-&gt;name); <span class="comment">// 箭头运算符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;分数：%f\n&quot;</span>, (*p).score); <span class="comment">// 等价的点运算符形式</span></span><br><span class="line"></span><br><span class="line">    show_student_info(&amp;zhangsan);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_student_info</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> student *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;----学生信息----\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;姓名：%s\n&quot;</span>, p-&gt;name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;分数：%f\n&quot;</span>, p-&gt;score);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结构体内存对齐"><a class="markdownIt-Anchor" href="#结构体内存对齐"></a> 结构体内存对齐</h4><p>为了让 CPU 高效访问内存，编译器会自动对结构体成员进行<strong>对齐</strong>。</p><ul><li><strong>对齐规则</strong>: 每个成员的地址会是其自身大小的整数倍。例如，<code>int</code> (4 字节) 会被放在能被 4 整除的地址上。</li><li><strong>填充</strong>: 为了满足对齐，编译器可能会在成员之间填充一些“空白”字节。</li><li><strong>整体大小</strong>: 整个结构体的大小，会是其<strong>最宽成员</strong>大小的整数倍。</li><li><strong>取消对齐</strong>: 在某些特定场景（如处理硬件数据流），可以使用 <code>__attribute__((packed))</code> (GCC/Clang 扩展)来告诉编译器不要进行内存对齐，以节省空间。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">##<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// M = 结构体成员占用最大的成员占用大小 = 4</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> a;   <span class="comment">// 4字节, 放在偏移0处, size=4</span></span><br><span class="line">    <span class="type">char</span> c;  <span class="comment">// 1字节, 放在偏移4处, size=5</span></span><br><span class="line">    <span class="type">short</span> f; <span class="comment">// 2字节, 放在偏移6处(需对齐到2的倍数), size=8</span></span><br><span class="line">    <span class="comment">// 编译器在c和f之间填充了1个字节</span></span><br><span class="line">&#125;; <span class="comment">// 整体大小需为M(4)的倍数, 8已经是4的倍数, 所以最终大小为8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用packed属性取消对齐</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_packed</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">short</span> f;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;默认对齐大小: %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> node));       <span class="comment">// 输出: 8</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;取消对齐大小: %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> node_packed)); <span class="comment">// 输出: 7 (4+1+2)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="位域-bit-field"><a class="markdownIt-Anchor" href="#位域-bit-field"></a> 位域 (Bit-field)</h4><p>位域允许我们在结构体中定义宽度为“位”(bit)的成员，这对于需要精确控制内存布局（如硬件寄存器、网络协议）的场景非常有用。</p><ul><li><strong>定义</strong>: <code>类型 成员名 : 位数;</code></li><li><strong>限制</strong>:<ul><li>成员必须是整型 (<code>int</code>, <code>unsigned int</code>, <code>char</code>等)。</li><li>不能对位域成员取地址 (<code>&amp;</code>)。</li><li><strong><u>建议成员尽量是同类型，不然对于某些平台可能会出现内存没有按照预期对齐的问题</u></strong></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">##<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟一个硬件设备的数据包</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 2字节(16位)上存储了温度和湿度</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> temp : <span class="number">8</span>; <span class="comment">// 低8位</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> humi : <span class="number">8</span>; <span class="comment">// 高8位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1字节(8位)上存储了8个开关状态</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> door1 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> door2 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> door3 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> door4 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> light1 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> light2 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> light3 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> light4 : <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_data</span> <span class="title">d</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> input_data = <span class="number">0x5A96F5</span>; <span class="comment">// 假设从硬件读到数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数据直接映射到结构体</span></span><br><span class="line">    d = *(<span class="keyword">struct</span> device_data *)&amp;input_data;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;原始数据: %#x\n&quot;</span>, input_data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;温度：%d°C\n&quot;</span>, d.temp);     <span class="comment">// 0xF5 -&gt; 245</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;湿度：%d%%\n&quot;</span>, d.humi);       <span class="comment">// 0x96 -&gt; 150</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;门1的状态：%s\n&quot;</span>, d.door1 ? <span class="string">&quot;开&quot;</span> : <span class="string">&quot;关&quot;</span>); <span class="comment">// 0x5 -&gt; 0101, door1=1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;灯4的状态：%s\n&quot;</span>, d.light4 ? <span class="string">&quot;开&quot;</span> : <span class="string">&quot;关&quot;</span>); <span class="comment">// 0x5 -&gt; 0101, light4=0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-联合体-union"><a class="markdownIt-Anchor" href="#14-联合体-union"></a> 14. 联合体 (Union)</h3><p>联合体所有成员<strong>共享同一块内存空间</strong>，其大小由<strong>最大</strong>的成员决定。这使得联合体非常适合表示“互斥”的数据。</p><ul><li><strong>特点</strong>:<ul><li>任何时刻，只有一个成员是有效的。</li><li>对一个成员赋值，会覆盖其他成员的值。</li></ul></li><li><strong>初始化</strong>:<ul><li>默认初始化第一个成员。</li><li>使用指定成员初始化法可以初始化任意成员，但只有最后被初始化的那个有效。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">##<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个联合体类型</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">attribute</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> i_val;</span><br><span class="line">    <span class="type">char</span> c_val;</span><br><span class="line">    <span class="type">double</span> d_val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;联合体大小: %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">union</span> attribute)); <span class="comment">// 8, 由double决定</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定成员初始化，只有最后一个有效</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">attribute</span> <span class="title">attr</span> =</span> &#123;.i_val = <span class="number">100</span>, .c_val = <span class="string">&#x27;k&#x27;</span>, .d_val = <span class="number">3.14</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时只有 d_val 是有效的</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d_val: %lf\n&quot;</span>, attr.d_val); <span class="comment">// 正确输出 3.14</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取其他成员会得到无意义的数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i_val: %d\n&quot;</span>, attr.i_val);   <span class="comment">// 输出垃圾值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c_val: %c\n&quot;</span>, attr.c_val);   <span class="comment">// 输出垃圾值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新赋值</span></span><br><span class="line">    attr.i_val = <span class="number">999</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n赋值后 i_val: %d\n&quot;</span>, attr.i_val); <span class="comment">// 正确输出 999</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d_val: %lf\n&quot;</span>, attr.d_val); <span class="comment">// d_val被覆盖，输出垃圾值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-枚举-enum"><a class="markdownIt-Anchor" href="#15-枚举-enum"></a> 15. 枚举 (Enum)</h3><p>枚举用于定义一组命名的整数常量，它比使用 <code>#define</code> 更具优势，因为枚举是类型安全的，且调试器可以识别枚举名。</p><ul><li><p><strong>定义</strong>: <code>enum 枚举名 &#123;常量1, 常量2, ...&#125;;</code></p></li><li><p><strong>赋值</strong>:</p><p>默认从 <code>0</code> 开始，依次递增。 -可以手动为任何一个常量指定一个整数值，后续未指定的常量会在此基础上递增。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">##<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义交通灯颜色的枚举</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">traffic_light</span> &#123;</span></span><br><span class="line">    RED,      <span class="comment">// 默认为 0</span></span><br><span class="line">    GREEN,    <span class="comment">// 在RED基础上+1, 为 1</span></span><br><span class="line">    YELLOW=<span class="number">10</span>,  <span class="comment">// 手动指定为 10</span></span><br><span class="line">    BLUE      <span class="comment">// 在YELLOW基础上+1, 为 11</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义枚举变量</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">traffic_light</span> <span class="title">color</span> =</span> YELLOW;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;RED=%d, GREEN=%d, YELLOW=%d, BLUE=%d\n&quot;</span>, RED, GREEN, YELLOW, BLUE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (color == YELLOW)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;当前颜色是黄灯, 请注意!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第四部分构建大型程序"><a class="markdownIt-Anchor" href="#第四部分构建大型程序"></a> 第四部分：构建大型程序</h3><h3 id="16-volatile关键字"><a class="markdownIt-Anchor" href="#16-volatile关键字"></a> 16. <code>volatile</code>关键字</h3><p><code>volatile</code> 是一个类型修饰符，它告诉编译器，被修饰的变量可能会在任何时候被程序外部的因素（如硬件、中断服务程序、其他线程）意外地改变。</p><ul><li><p><strong>核心作用</strong>: <strong>防止编译器过度优化</strong>。确保每次访问该变量时，都直接从其内存地址中读取，而不是使用可能已过时的寄存器缓存值。</p></li><li><p><strong>使用场景</strong>:</p><ol><li><strong>硬件寄存器</strong>: 嵌入式系统中，硬件状态寄存器的值会由硬件实时更新。</li><li><strong>多线程共享变量</strong>: 一个变量被多个线程共享和修改时。</li><li><strong>中断服务程序</strong>: 中断处理函数中会修改的全局变量。</li></ol></li></ul><h4 id="代码示例"><a class="markdownIt-Anchor" href="#代码示例"></a> 代码示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：一个可能被硬件修改的状态寄存器</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *DEVICE_STATUS_REGISTER = (<span class="type">unsigned</span> <span class="type">int</span> *)<span class="number">0x12345678</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">check_device</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 每次循环都必须从内存地址0x12345678重新读取状态</span></span><br><span class="line">    <span class="comment">// 如果没有volatile，编译器可能优化为只读一次，导致死循环</span></span><br><span class="line">    <span class="keyword">while</span> (*DEVICE_STATUS_REGISTER == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 等待设备就绪...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...设备已就绪，继续操作...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17-预处理与高级技巧"><a class="markdownIt-Anchor" href="#17-预处理与高级技巧"></a> 17. 预处理与高级技巧</h3><h4 id="高级宏定义"><a class="markdownIt-Anchor" href="#高级宏定义"></a> 高级宏定义</h4><p><strong><u>宏在预处理阶段进行简单的文本替换</u></strong>，功能强大但易出错。</p><h5 id="宏运算符-字符串化-连接"><a class="markdownIt-Anchor" href="#宏运算符-字符串化-连接"></a> 宏运算符<code>#</code> (字符串化) <code>##</code> (连接)</h5><ul><li><strong><code>#</code></strong>: 将宏参数转换为一个字符串字面量。</li><li><strong><code>##</code></strong>: 将两个记号（token）连接成一个记号。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">##<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 # 将宏参数 a 和 b 变成字符串</span></span><br><span class="line">##<span class="meta">#<span class="keyword">define</span> DOMAIN_NAME(a, b) <span class="string">&quot;www.&quot;</span> #a <span class="string">&quot;.&quot;</span> #b <span class="string">&quot;.com&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 ## 连接参数，构造函数名</span></span><br><span class="line">##<span class="meta">#<span class="keyword">define</span> LAYER_INITCALL(num, layer)  __zinitcall_##layer##_##num</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟内核的初始化函数</span></span><br><span class="line"><span class="type">void</span> __zinitcall_service_1(<span class="type">void</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, __FUNCTION__); &#125;</span><br><span class="line"><span class="type">void</span> __zinitcall_feature_2(<span class="type">void</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, __FUNCTION__); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// # 的使用</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, DOMAIN_NAME(yueqian, lab)); <span class="comment">// 输出: &quot;www.yueqian.lab.com&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ## 的使用</span></span><br><span class="line">    LAYER_INITCALL(<span class="number">1</span>, service)(); <span class="comment">// 宏展开为: __zinitcall_service_1();</span></span><br><span class="line">    LAYER_INITCALL(<span class="number">2</span>, feature)(); <span class="comment">// 宏展开为: __zinitcall_feature_2();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="安全的带参宏-gcc-扩展"><a class="markdownIt-Anchor" href="#安全的带参宏-gcc-扩展"></a> 安全的带参宏 (GCC 扩展)</h5><p>简单的带参宏有副作用风险（如 <code>MAX(a++, b)</code>）。Linux 内核中广泛使用 <code>(&#123;...&#125;)</code> 语句表达式和 <code>typeof</code> 关键字 (均为 GCC 扩展) 来创建更安全的宏。</p><ul><li><strong><code>typeof(x)</code></strong>: 获取变量 <code>x</code> 的类型。</li><li><strong><code>(&#123;...&#125;)</code></strong>: 语句表达式，将多条语句包裹成一个单一的表达式，其值为最后一条语句的结果<ul><li><code>&#123;&#125;</code>将多句话整合为一句话</li><li><code>()</code>将内部的 {…} 代码块“提升”为一个表达式，使其可以被赋值或用在其他需要值的地方。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">##<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统宏的风险</span></span><br><span class="line"><span class="comment">// #define MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全的、类型通用的宏 (Linux内核风格)</span></span><br><span class="line">##<span class="meta">#<span class="keyword">define</span> MAX(a, b) (&#123; \</span></span><br><span class="line"><span class="meta">    typeof(a) _a = (a); \</span></span><br><span class="line"><span class="meta">    typeof(b) _b = (b); \</span></span><br><span class="line"><span class="meta">    (void) (&amp;_a == &amp;_b); <span class="comment">/* 警告: 如果a和b类型不同 */</span> \</span></span><br><span class="line"><span class="meta">    _a &gt; _b ? _a : _b; \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// 对于 MAX(x++, y++)，传统宏会将++执行两次，而安全宏只执行一次</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Max is %d\n&quot;</span>, MAX(x, y));</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> f1 = <span class="number">3.14</span>, f2 = <span class="number">2.71</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Max is %f\n&quot;</span>, MAX(f1, f2));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不同类型的参数会产生编译警告</span></span><br><span class="line">    <span class="comment">// printf(&quot;Max is %f\n&quot;, MAX(x, f1));</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内联函数-inline"><a class="markdownIt-Anchor" href="#内联函数-inline"></a> 内联函数 (inline)</h4><p>对于功能简单、调用频繁的函数，函数调用的开销可能超过函数本身的执行时间。<code>inline</code> 关键字建议编译器将函数体直接嵌入到调用处，以消除调用开销。</p><ul><li><strong>特点</strong>:<ul><li>它是对编译器的<strong>建议</strong>，而非强制命令。</li><li>相比宏函数，内联函数有<strong>类型检查</strong>，更安全。</li><li>内联函数的定义通常放在头文件中。</li></ul></li><li><strong>适用场景</strong>: 函数体小，且被频繁调用的函数。</li></ul><p><strong><code>inline.h</code> 文件:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inline.h</span></span><br><span class="line">##<span class="meta">#<span class="keyword">ifndef</span> INLINE_H</span></span><br><span class="line">##<span class="meta">#<span class="keyword">define</span> INLINE_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将简短、频繁调用的函数定义为inline</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">max2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">##<span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong><code>main.c</code> 文件:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">##<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">##<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;inline.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 编译器可能会将 max2 的函数体直接替换到这里</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, max2(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, max2(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="18-多文件编程与头文件"><a class="markdownIt-Anchor" href="#18-多文件编程与头文件"></a> 18. 多文件编程与头文件</h3><p>随着项目变大，将所有代码放在一个<code>.c</code>文件里是不可行的。我们需要将代码按模块拆分到多个<code>.c</code>和<code>.h</code>文件中。</p><h4 id="条件编译"><a class="markdownIt-Anchor" href="#条件编译"></a> 条件编译</h4><p>条件编译允许我们根据编译时定义的宏，来决定哪些代码块被编译，哪些被忽略。这对于编写平台兼容代码、管理调试信息等非常有用。</p><ul><li><strong><code>#if</code> / <code>#elif</code> / <code>#else</code> / <code>#endif</code></strong>: 基于宏的值进行判断，功能类似<code>if-else</code>。</li><li><strong><code>#ifdef 宏名</code></strong>: (if defined) 如果宏<code>宏名</code><strong>已被定义</strong>，则编译后续代码。</li><li><strong><code>#ifndef 宏名</code></strong>: (if not defined) 如果宏<code>宏名</code><strong>未被定义</strong>，则编译后续代码。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">##<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以在代码中定义宏</span></span><br><span class="line">##<span class="meta">#<span class="keyword">define</span> FEATURE_A 1</span></span><br><span class="line">##<span class="meta">#<span class="keyword">define</span> FEATURE_B 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以在编译时通过-D选项定义，例如: gcc -DDEBUG_MODE condition.c</span></span><br><span class="line"><span class="comment">// #define DEBUG_MODE</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> FEATURE_A</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;功能A已启用。\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> FEATURE_B</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;功能B已启用。\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;功能B未启用。\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 常用于输出调试信息</span></span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> DEBUG_MODE</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;调试信息: 进入函数 %s, 第 %d 行\n&quot;</span>, __FUNCTION__, __LINE__);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">ifndef</span> RELEASE_MODE</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;当前为非发布版本。\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="头文件的作用与设计"><a class="markdownIt-Anchor" href="#头文件的作用与设计"></a> 头文件的作用与设计</h4><p>头文件 (<code>.h</code>) 是多文件编程的核心，它扮演着模块“接口说明书”的角色。</p><ul><li><p><strong>头文件的内容</strong>:</p><ol><li><strong>全局变量的声明</strong>: 使用 <code>extern</code> 关键字告知其他文件该变量的存在。 (<code>extern int g_count;</code>)</li><li><strong>函数声明</strong>: 告知其他文件该函数的存在。 (<code>void print_hello(void);</code>)</li><li><strong>宏定义</strong>: 模块提供的常量或宏函数。 (<code>#define MAX_USERS 100</code>)</li><li><strong>结构体/联合体/枚举的定义</strong>: 允许多个<code>.c</code>文件使用相同的数据结构。</li><li><strong><code>static inline</code> 函数</strong>: 对于小且频繁调用的函数，可以定义在头文件中。</li></ol></li><li><p><strong>头文件防卫 <strong>:<br>为了防止同一个头文件在编译时被重复包含（这会导致重定义错误），必须使用<code>ifndef</code>机制。这是</strong>强制性</strong>的最佳实践。</p></li></ul><p><strong><code>my_module.h</code> 文件示例:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 头文件防卫开始</span></span><br><span class="line">##<span class="meta">#<span class="keyword">ifndef</span> __MY_MODULE_H__</span></span><br><span class="line">##<span class="meta">#<span class="keyword">define</span> __MY_MODULE_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 包含此模块依赖的其他头文件</span></span><br><span class="line">##<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 模块的“接口”声明</span></span><br><span class="line">##<span class="meta">#<span class="keyword">define</span> MODULE_VERSION <span class="string">&quot;1.0&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> g_module_status; <span class="comment">// 全局变量声明</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_data</span>;</span> <span class="comment">// 结构体声明</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">module_init</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// 函数声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">module_get_status</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// static inline函数可以直接在头文件中实现</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">print_version</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Version: %s\n&quot;</span>, MODULE_VERSION);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 头文件防卫结束</span></span><br><span class="line">##<span class="meta">#<span class="keyword">endif</span> <span class="comment">// __MY_MODULE_H__</span></span></span><br></pre></td></tr></table></figure><p><strong><code>my_module.c</code> 文件 (模块的实现):</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">##<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;my_module.h&quot;</span> <span class="comment">// 首先包含自己的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量的定义</span></span><br><span class="line"><span class="type">int</span> g_module_status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体的具体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_data</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数的具体实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">module_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    g_module_status = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;模块已初始化。\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">module_get_status</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> g_module_status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>main.c</code> 文件 (模块的使用者):</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">##<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;my_module.h&quot;</span> <span class="comment">// 包含模块头文件以使用其功能</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    module_init();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;模块状态: %d\n&quot;</span>, module_get_status());</span><br><span class="line">    print_version();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h3 id="19-常用字符串函数"><a class="markdownIt-Anchor" href="#19-常用字符串函数"></a> 19. 常用字符串函数</h3><h4 id="strlen-获取长度"><a class="markdownIt-Anchor" href="#strlen-获取长度"></a> <code>strlen</code> - 获取长度</h4><p><strong>lenth</strong></p><p>返回字符串的长度，不包括末尾的 <code>\0</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> len = <span class="built_in">strlen</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// len 的值为 5</span></span><br></pre></td></tr></table></figure><h4 id="strcpy-字符串复制"><a class="markdownIt-Anchor" href="#strcpy-字符串复制"></a> <code>strcpy</code> - 字符串复制</h4><p><strong>copy</strong></p><p><code>strncpy</code>是<code>strcpy</code>的安全版本，推荐使用以防止内存溢出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> dest[<span class="number">10</span>] = <span class="string">&quot;123456789&quot;</span>;</span><br><span class="line"><span class="comment">// 复制&quot;hello&quot;到dest，最多复制sizeof(dest)-1个字符</span></span><br><span class="line"><span class="built_in">strncpy</span>(dest, <span class="string">&quot;hello&quot;</span>, <span class="keyword">sizeof</span>(dest) - <span class="number">1</span>);</span><br><span class="line">dest[<span class="keyword">sizeof</span>(dest) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 确保字符串以&#x27;\0&#x27;结尾</span></span><br><span class="line"><span class="comment">// dest现在是 &quot;hello&quot;</span></span><br></pre></td></tr></table></figure><h4 id="strcat-字符串拼接"><a class="markdownIt-Anchor" href="#strcat-字符串拼接"></a> <code>strcat</code> - 字符串拼接</h4><p><strong>catch</strong></p><p><code>strncat</code>是<code>strcat</code>的安全版本，推荐使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> dest[<span class="number">10</span>] = <span class="string">&quot;Hi, &quot;</span>;</span><br><span class="line"><span class="comment">// 将&quot;Bob&quot;拼接到dest末尾</span></span><br><span class="line"><span class="built_in">strncat</span>(dest, <span class="string">&quot;Bob&quot;</span>, <span class="keyword">sizeof</span>(dest) - <span class="built_in">strlen</span>(dest) - <span class="number">1</span>);</span><br><span class="line"><span class="comment">// dest现在是 &quot;Hi, Bob&quot;</span></span><br></pre></td></tr></table></figure><h4 id="strcmp-字符串比较"><a class="markdownIt-Anchor" href="#strcmp-字符串比较"></a> <code>strcmp</code> - 字符串比较</h4><p><strong>compare</strong></p><p>按字典序比较字符串，返回 <code>&lt;0</code> (s1&lt;s2), <code>0</code> (s1==s2), <code>&gt;0</code> (s1&gt;s2)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> result = <span class="built_in">strcmp</span>(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abd&quot;</span>); <span class="comment">// result &lt; 0</span></span><br></pre></td></tr></table></figure><h4 id="strchr-查找字符"><a class="markdownIt-Anchor" href="#strchr-查找字符"></a> <code>strchr</code> - 查找字符</h4><p><strong>char</strong></p><ul><li><code>strchr</code>: 从左向右查找第一个匹配的字符。</li><li><code>strrchr</code>: 从右向左查找第一个匹配的字符。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p = <span class="built_in">strchr</span>(<span class="string">&quot;a.b.c.d&quot;</span>, <span class="string">&#x27;.&#x27;</span>); <span class="comment">// p 指向 &quot;.b.c.d&quot;</span></span><br></pre></td></tr></table></figure><h4 id="strstr-查找子串"><a class="markdownIt-Anchor" href="#strstr-查找子串"></a> <code>strstr</code> - 查找子串</h4><p><strong>string</strong></p><p>在字符串中查找子字符串首次出现的位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p = <span class="built_in">strstr</span>(<span class="string">&quot;main.c&quot;</span>, <span class="string">&quot;.c&quot;</span>); <span class="comment">// p 指向 &quot;.c&quot;</span></span><br></pre></td></tr></table></figure><h4 id="strtok-分割字符串"><a class="markdownIt-Anchor" href="#strtok-分割字符串"></a> <code>strtok</code> - 分割字符串</h4><p><strong>token</strong></p><p><strong>注意</strong>: 此函数会修改原始字符串。首次调用传入字符串，后续调用传入 <code>NULL</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;www.yueqian.com&quot;</span>;</span><br><span class="line"><span class="type">char</span> *p = strtok(str, <span class="string">&quot;.&quot;</span>); <span class="comment">// p 指向 &quot;www&quot;</span></span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, p);</span><br><span class="line">    p = strtok(<span class="literal">NULL</span>, <span class="string">&quot;.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 依次输出: www, yueqian, com</span></span><br></pre></td></tr></table></figure><h3 id="第五部分高级应用入门"><a class="markdownIt-Anchor" href="#第五部分高级应用入门"></a> 第五部分：高级应用入门</h3><h3 id="20-算法入门"><a class="markdownIt-Anchor" href="#20-算法入门"></a> 20. 算法入门</h3><h4 id="经典排序冒泡排序"><a class="markdownIt-Anchor" href="#经典排序冒泡排序"></a> 经典排序：冒泡排序</h4><p><strong>问题</strong>: 实现冒泡排序算法。</p><p><strong>核心知识</strong>: 通过重复遍历数组，比较相邻元素并交换，每一趟都将当前未排序部分的最大（或最小）元素“冒泡”到最终位置。</p><p><strong>代码示例</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bubble_sort</span><span class="params">(<span class="type">int</span> len, <span class="type">int</span> A[])</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[j] &gt; A[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> temp = A[j];</span><br><span class="line">                A[j] = A[j + <span class="number">1</span>];</span><br><span class="line">                A[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="21-数据结构入门"><a class="markdownIt-Anchor" href="#21-数据结构入门"></a> 21. 数据结构入门</h3><h4 id="单链表"><a class="markdownIt-Anchor" href="#单链表"></a> 单链表</h4><p>单链表是一种动态数据结构，它由一系列节点组成，每个节点包含数据和一个指向下一个节点的指针。</p><ul><li><strong>核心思想</strong>: 在堆内存中动态创建节点 (<code>malloc</code>)，并通过指针将这些分散的节点链接成一个有序序列。</li><li><strong>关键知识点</strong>:<ul><li><code>struct</code> 结构体：用于定义链表节点。</li><li><code>malloc</code> / <code>free</code>：动态内存分配和释放。</li><li>指针操作：通过 <code>p-&gt;next</code> 遍历和操作链表。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">##<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">##<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 定义链表节点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建新节点</span></span><br><span class="line">Node* <span class="title function_">create_node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node *new_node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span> (new_node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    new_node-&gt;data = data;</span><br><span class="line">    new_node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> new_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 打印链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_list</span><span class="params">(Node *head)</span> &#123;</span><br><span class="line">    Node *current = head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, current-&gt;data);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建链表: head -&gt; node1 -&gt; node2</span></span><br><span class="line">    Node *head = create_node(<span class="number">10</span>);</span><br><span class="line">    head-&gt;next = create_node(<span class="number">20</span>);</span><br><span class="line">    head-&gt;next-&gt;next = create_node(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    print_list(head); <span class="comment">// 输出: 10 -&gt; 20 -&gt; 30 -&gt; NULL</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放链表内存 (此处省略)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="22-面试题精选"><a class="markdownIt-Anchor" href="#22-面试题精选"></a> 22. 面试题精选</h3><h4 id="巧妙的级数求和"><a class="markdownIt-Anchor" href="#巧妙的级数求和"></a> 巧妙的级数求和</h4><p><strong>问题</strong>: 计算 <code>S = 1 - 1/2 + 1/3 - 1/4 + ... + 1/99 - 1/100</code>。</p><p><strong>核心知识</strong>: 直接计算涉及大量浮点减法，可能损失精度。通过数学变换可以优化：<br><code>S = (1 + ... + 1/100) - 2 * (1/2 + ... + 1/100) = (1 + ... + 1/100) - (1 + ... + 1/50) = 1/51 + ... + 1/100</code><br>这个变换将问题转换成了一个简单的正项级数求和。</p><p><strong>代码示例</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 计算 S = 1 - 1/2 + 1/3 - 1/4 + ... + 1/99 - 1/100 的值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">float</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">      sum += <span class="number">1.0</span> / i;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      sum -= <span class="number">1.0</span> / i;</span><br><span class="line">    <span class="comment">// 或者：sum+=pow(-1,i+1)*(1/(float)i); //用(-1)的i+1次方代替判断，需要引用数学库</span></span><br><span class="line">    <span class="comment">// 或者：sum+=1/(i*(i+1));              //规律是（1-1/2=1/2）(1/3-1/4=1/12)(1/5-1/6=1/30)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 或者</span></span><br><span class="line">    <span class="comment">// for (int i = 51; i &lt;= 100; i++) sum_a += 1.0 / i;</span></span><br><span class="line">                                            <span class="comment">// 将加法和减法分开：</span></span><br><span class="line">                                            <span class="comment">// S = (1 + 1/3 + 1/5 + ... + 1/99) - (1/2 + 1/4 + 1/6 + ... + 1/100)</span></span><br><span class="line">                                            <span class="comment">// 然后，加上减去的部分，减去两倍的部分：</span></span><br><span class="line">                                            <span class="comment">// S = (1 + 1/2 + 1/3 + ... + 1/100) - 2 * (1/2 + 1/4 + 1/6 + ... + 1/100)</span></span><br><span class="line">                                            <span class="comment">// 然后吧后半部分的2乘进去：</span></span><br><span class="line">                                            <span class="comment">// S = (1 + 1/2 + 1/3 + ... + 1/100) - (1 + 1/2 + 1/3 + ... + 1/50)</span></span><br><span class="line">                                            <span class="comment">// 所以：</span></span><br><span class="line">                                            <span class="comment">// S = (1/51 + 1/52 + 1/53 + ... + 1/100)</span></span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,sum);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="凑零钱问题"><a class="markdownIt-Anchor" href="#凑零钱问题"></a> 凑零钱问题</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 目标：用1元、2元、5元的纸币凑出100元</span></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=<span class="number">20</span>; i++) <span class="comment">// i个5元</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;=<span class="number">50</span>; j++) <span class="comment">// j个2元</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 剩下的用1元补足</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="number">100</span> - i*<span class="number">5</span> - j*<span class="number">2</span> &gt;= <span class="number">0</span>)</span><br><span class="line">                num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num: %d</span></span><br><span class="line"><span class="string">&quot;</span>, num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法二</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span> / <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= (<span class="number">100</span> - <span class="number">5</span> * i) / <span class="number">2</span>; j++) &#123;</span><br><span class="line">      <span class="type">int</span> k = <span class="number">100</span> - <span class="number">5</span> * i - <span class="number">2</span> * j;</span><br><span class="line">      <span class="comment">// printf(&quot;5元: %d个, 2元: %d个, 1元: %d个</span></span><br><span class="line"><span class="string">&quot;, i, j, k);</span></span><br><span class="line"><span class="string">      count++;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  printf(&quot;</span>使用数值 <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span> 组合成 %d，共有 %d 种不同的组合。</span><br><span class="line"><span class="string">&quot;, 100, count);</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="统计数字1的出现次数"><a class="markdownIt-Anchor" href="#统计数字1的出现次数"></a> 统计数字’1’的出现次数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算从1到n的整数中，数字&#x27;1&#x27;出现的总次数</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">count</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> base = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> round = n;</span><br><span class="line">  <span class="keyword">while</span> (round &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">int</span> weight = round % <span class="number">10</span>;</span><br><span class="line">    round /= <span class="number">10</span>;</span><br><span class="line">    count += round * base;</span><br><span class="line">    <span class="keyword">if</span> (weight == <span class="number">1</span>)</span><br><span class="line">      count += (n % base) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (weight &gt; <span class="number">1</span>)</span><br><span class="line">      count += base;</span><br><span class="line">    base *= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> n = <span class="number">213</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;从 1 到 %u, 数字 1 出现的总次数为: %lld</span></span><br><span class="line"><span class="string">&quot;</span>, n, count(n));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二维数组边界元素求平均值"><a class="markdownIt-Anchor" href="#二维数组边界元素求平均值"></a> 二维数组边界元素求平均值</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> w[N][N])</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;N; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, w[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> N = <span class="number">5</span>; <span class="comment">// Example size</span></span><br><span class="line">    <span class="type">int</span> w[N][N];</span><br><span class="line"></span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;N; j++) &#123;</span><br><span class="line">            w[i][j] = rand()%<span class="number">1000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    show(N, w);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(N == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;周围数据平均数是: %f</span></span><br><span class="line"><span class="string">&quot;</span>, (<span class="type">float</span>)w[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">        sum += w[<span class="number">0</span>][i];    <span class="comment">// Top row</span></span><br><span class="line">        sum += w[N<span class="number">-1</span>][i];  <span class="comment">// Bottom row</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;N<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        sum += w[i][<span class="number">0</span>];    <span class="comment">// Left column (excluding corners)</span></span><br><span class="line">        sum += w[i][N<span class="number">-1</span>];  <span class="comment">// Right column (excluding corners)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;周围数据平均数是: %f</span></span><br><span class="line"><span class="string">&quot;</span>, sum/(<span class="number">4.0</span>*N<span class="number">-4.0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="23-扩展阅读"><a class="markdownIt-Anchor" href="#23-扩展阅读"></a> 23. 扩展阅读</h3><p>(待补充…)</p><h3 id="24-笔记总结"><a class="markdownIt-Anchor" href="#24-笔记总结"></a> 24. 笔记总结</h3><p>C 语言的核心是围绕<strong>指针、内存管理和作用域/存储期</strong>这三大支柱展开的，<code>static</code>关键字是贯穿其中的关键。</p><ul><li><p><strong>基础与类型系统</strong>：程序由<code>main</code>函数启动，其根本是<strong>数据类型</strong>。必须精确掌握<code>int</code>, <code>char</code>, <code>double</code>等类型与<code>printf</code>/<code>scanf</code>格式说明符的对应关系：</p><ul><li><p><code>printf</code>中<code>%f</code>可通用打印<code>float</code>和<code>double</code>（因<code>float</code>参数会自动<strong>提升</strong>为<code>double</code>）；而<code>scanf</code>接收<code>double</code>必须用<code>%lf</code>。</p></li><li><p><code>scanf</code>通过传递变量<strong>地址<code>&amp;</code><strong>来实现对调用方变量的修改，务必警惕其</strong>输入缓冲区</strong>的残留问题。</p></li></ul></li><li><p><strong>运算符与表达式</strong>：重点掌握逻辑运算的<strong>短路求值</strong>（<code>&amp;&amp;</code>, <code>||</code>）、高效的<strong>位运算</strong>（<code>&amp;</code>, <code>|</code>, <code>^</code>, <code>~</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>）、条件运算符<code>? :</code>以及<code>sizeof</code>（它是一个<strong>运算符</strong>，不是函数）。当不确定优先级时，用**圆括号<code>()</code>**是最佳实践。</p></li><li><p><strong>控制流</strong>：熟练运用<code>if-else</code>、<code>switch</code>（牢记<code>case</code>的<strong>穿透</strong>特性与<code>break</code>的重要性）、<code>for</code>/<code>while</code>/<code>do-while</code>循环，以及<code>break</code>（跳出循环/switch）、<code>continue</code>（跳过本次迭代）、<code>return</code>（终止函数）三种跳转语句。</p></li><li><p><strong>指针（难点中的难点）</strong>：</p><ul><li><strong>核心操作</strong>：指针是存储地址的变量，用<code>&amp;</code>取地址、<code>*</code>解引用。必须初始化为<code>NULL</code>以防<strong>野指针</strong>。</li><li><strong>数组与指针</strong>：在表达式中（除<code>sizeof</code>和<code>&amp;</code>外），数组名会 <strong>“降维/退化”</strong> 为指向其首元素的指针，因此<code>a[i]</code>本质是<code>*(a+i)</code>的语法糖。这也导致数组作为函数参数时，<code>sizeof</code>在函数内外结果不同。</li><li><strong><code>const</code>修饰</strong>：必须严格区分“<strong>指向常量的指针</strong>”（<code>const int *p</code>，<code>*p</code>不可改，<code>p</code>可改）和“<strong>常量指针</strong>”（<code>int * const p</code>，<code>p</code>不可改，<code>*p</code>可改）。</li><li><strong>高级指针</strong>：理解<code>void*</code>作为通用指针（使用前须<strong>强制类型转换</strong>），以及<strong>函数指针</strong>（<code>返回类型 (*指针名)(参数)</code>）作为实现<strong>回调函数</strong>的基础。</li></ul></li><li><p><strong>内存布局</strong>：</p><ul><li><strong>代码段 (<code>.text</code>)</strong>：存放二进制指令，只读。</li><li><strong>数据段</strong>：<ul><li><code>.rodata</code>：存放字符串字面量、<code>const</code>全局变量，只读。</li><li><code>.data</code>：存放<strong>已初始化</strong>的全局变量和静态变量。</li><li><code>.bss</code>：存放<strong>未初始化</strong>的全局变量和静态变量，程序启动时系统自动清零。</li></ul></li><li><strong>栈 (Stack)</strong>：存放函数的<strong>局部变量</strong>和<strong>参数</strong>，由编译器<strong>自动管理</strong>，空间有限，有<strong>栈溢出</strong>风险。<strong>严禁返回局部变量的地址</strong>，因其在函数返回后即被销毁。</li><li><strong>堆 (Heap)</strong>：由程序员通过<code>malloc</code>/<code>calloc</code>/<code>realloc</code>/<code>free</code><strong>手动管理</strong>，空间巨大但易产生<strong>内存泄漏</strong>（忘记<code>free</code>）或<strong>悬空指针</strong>（<code>free</code>后未置<code>NULL</code>）。</li></ul></li><li><p><strong><code>static</code>关键字（重中之重）</strong>：</p><ul><li><strong>修饰局部变量</strong>：改变其<strong>存储期</strong>（从自动存储期改为静态存储期），使其从<strong>栈</strong>移至<strong>数据段</strong>。变量生命周期与程序相同，其值在函数多次调用间<strong>保持不变</strong>。</li><li><strong>修饰全局变量/函数</strong>：改变其<strong>链接属性</strong>（从外部链接改为内部链接），使其作用域被<strong>限制在当前源文件内</strong>，是实现模块化和信息隐藏的关键。</li></ul></li><li><p><strong>复合类型</strong>：</p><ul><li><code>struct</code>：将不同类型数据聚合成单一实体，是 C 语言实现面向对象思想的基础。通过<code>.</code>（变量）或<code>-&gt;</code>（指针）访问成员，并须注意编译器为提高效率而进行的<strong>内存对齐</strong>，以及用于硬件编程的<strong>位域</strong>。</li><li><code>union</code>：所有成员<strong>共享同一块内存</strong>，大小由最大成员决定，常用于节省空间。</li><li><code>enum</code>：创建类型安全的<strong>命名整型常量</strong>，比<code>#define</code>更优。</li></ul></li><li><p><strong>预处理</strong>：在编译前执行的文本替换。核心指令包括<code>#include</code>（文件包含）、<code>#define</code>（定义宏，可用<code>\</code>换行）、<code>#if</code>/<code>#ifdef</code>等<strong>条件编译</strong>指令。宏操作符<code>#</code>（<strong>字符串化</strong>）和<code>##</code>（<strong>符号连接</strong>）功能强大。多文件编程中，必须使用**<code>#ifndef...#define...#endif</code>**结构进行 <strong>头文件防卫</strong> ，防止重复包含。</p></li></ul><p>高级关键字：<code>volatile</code>的应用场景与原理，二维数组，边界元素遍历，<code>const</code>指针的三种模式辨析，数组与指针的异同</p><div class="tag-list"><a class="tag" href="/note/ES/tags/%E5%9F%BA%E7%A1%80/c%E8%AF%AD%E8%A8%80/">基础/C语言</a></div></article><div class="article-footer"><section id="license"><div class="header"><span>许可协议</span></div><div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p></div></section><section id="share"><div class="header"><span>分享文章</span></div><div class="body"><div class="link"><input class="copy-area" readonly id="copy-link" value="http://skyforever.top/data/ES/%E5%9F%BA%E7%A1%80/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0"></div><div class="social-wrap dis-select"><a class="social share-item wechat" onclick="util.toggle(&quot;qrcode-wechat&quot;)"><img src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/b32ef3da1162a.svg"></a><a class="social share-item weibo" target="_blank" rel="external nofollow noopener noreferrer" href="https://service.weibo.com/share/share.php?url=http://skyforever.top/data/ES/%E5%9F%BA%E7%A1%80/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0&title=C语言复习笔记 - Sky Blog&summary=一份围绕c语言指针、内存管理和作用域/存储期三大支柱展开的笔记"><img src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/80c07e4dbb303.svg"></a><a class="social share-item email" href="mailto:?subject=C语言复习笔记 - Sky Blog&amp;body=http://skyforever.top/data/ES/%E5%9F%BA%E7%A1%80/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0"><img src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/a1b00e20f425d.svg"></a><a class="social share-item link" onclick="util.copy(&quot;copy-link&quot;, &quot;复制成功&quot;)"><img src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/8411ed322ced6.svg"></a></div><div class="qrcode" id="qrcode-wechat" style="opacity:0;height:0"><img src="https://api.qrserver.com/v1/create-qr-code/?size=256x256&data=http://skyforever.top/data/ES/%E5%9F%BA%E7%A1%80/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0"></div></div></section></div><div class="related-wrap md-text" id="comments"><section class="header cmt-title cap theme"><p>快来参与讨论吧~</p></section><section class="body cmt-body giscus"><svg class="loading" style="vertical-align:middle;fill:currentColor;overflow:hidden" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg><div id="giscus" src="https://giscus.app/client.js" data-repo="zhangwei43721/zhangwei43721.github.io" data-repo-id="R_kgDOOC101w" data-category="Announcements" data-category-id="DIC_kwDOOC10184Cv2Lm" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous"></div></section></div><footer class="page-footer footnote"><hr><div class="sitemap" style="column-count:3"><div class="sitemap-group"><span class="fs15">博客</span><a href="/">近期发布</a><a href="/categories/">分类</a><a href="/tags/">标签</a><a href="/archives/">归档</a></div><div class="sitemap-group"><span class="fs15">项目</span><a href="/wiki/LVGL-CarDashboard/">车载仪表盘</a><a href="/wiki/Smart_Home_System/">智能家居系统</a></div><div class="sitemap-group"><span class="fs15">笔记</span><a href="/note/college/">大学笔记</a><a href="/note/ES/">嵌入式笔记</a></div></div><div class="text"><p>本站由 <a href="/">Skyforever</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.33.1">Stellar 1.33.1</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p><p><img src="https://image.skyforever.top/blog/2025/10/7c7d60c27511edf9f4ae10cb62c8f4ae.png" width="13" height="13"> <a target="_blank" rel="noopener" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=51142102511609">川公网安备51142102511609</a> <a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">蜀ICP备2024105035号</a></p></div></footer><div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right"><div class="widgets"><widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86c-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80"><span class="toc-text">第一部分：C 语言基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-helloworld"><span class="toc-text">1. helloworld</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83"><span class="toc-text">配置环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%A8%8B%E5%BA%8F"><span class="toc-text">实现程序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%A0%BC%E5%BC%8F%E5%8C%96-io"><span class="toc-text">2. 数据类型与格式化 IO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">基本数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F"><span class="toc-text">常量与变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA"><span class="toc-text">格式化输入与输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA-getchar-putchar"><span class="toc-text">单字符输入输出 (getchar, putchar)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%91%E5%AD%A6%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-text">科学计数法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E7%9A%84%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA"><span class="toc-text">数字的进制表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AE%9E%E6%88%98-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83"><span class="toc-text">面试题实战-浮点数的安全比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AE%9E%E6%88%98-%E5%A4%A7%E5%9E%8B%E5%AD%97%E9%9D%A2%E9%87%8F%E5%90%8E%E7%BC%80"><span class="toc-text">面试题实战-大型字面量后缀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AE%9E%E6%88%98-%E7%B1%BB%E5%9E%8B%E6%8F%90%E5%8D%87%E4%B8%AD%E7%9A%84%E7%AC%A6%E5%8F%B7%E6%89%A9%E5%B1%95"><span class="toc-text">面试题实战-类型提升中的符号扩展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AE%9E%E6%88%98-%E5%A4%A7%E5%B0%8F%E7%AB%AF%E5%BA%8F%E8%BD%AC%E6%8D%A2"><span class="toc-text">面试题实战-大小端序转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">3. 运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">算术运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E4%B8%8E%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">关系与逻辑运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">位运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">其他运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%8E%E7%BB%93%E5%90%88%E6%80%A7"><span class="toc-text">运算符优先级与结合性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AE%9E%E6%88%98-%E5%AD%97%E8%8A%82%E5%86%85%E6%AF%94%E7%89%B9%E4%BD%8D%E5%8F%8D%E8%BD%AC"><span class="toc-text">面试题实战-字节内比特位反转</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="toc-text">4. 控制流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84-if-switch"><span class="toc-text">分支结构 (if &#x2F; switch)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84-while-for-do-while"><span class="toc-text">循环结构 (while &#x2F; for &#x2F; do-while)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5-break-continue-goto-return"><span class="toc-text">跳转语句 (break &#x2F; continue &#x2F; goto &#x2F; return)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AE%9E%E6%88%98-fgets%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%85%A5"><span class="toc-text">面试题实战- fgets字符串输入</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%E5%86%85%E5%AD%98-%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-text">第二部分：内存、函数与程序结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E7%AE%A1%E7%90%86"><span class="toc-text">5. 内存布局与管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%AE%B5"><span class="toc-text">代码段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%AE%B5"><span class="toc-text">数据段</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#static-%E5%AF%B9%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-text">static 对局部变量的影响</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88-stack"><span class="toc-text">栈 (Stack)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86-heap"><span class="toc-text">堆 (Heap)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%AD%98%E5%82%A8%E6%9C%9F"><span class="toc-text">6. 存储期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%AD%98%E5%82%A8%E6%9C%9F"><span class="toc-text">自动存储期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E6%9C%9F"><span class="toc-text">静态存储期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%98%E5%82%A8%E6%9C%9F"><span class="toc-text">自定义存储期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static-%E5%85%B3%E9%94%AE%E5%AD%97%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93"><span class="toc-text">static 关键字全面总结</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F-%E6%94%B9%E5%8F%98%E5%AD%98%E5%82%A8%E6%9C%9F"><span class="toc-text">修饰局部变量 (改变存储期)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%87%BD%E6%95%B0-%E6%94%B9%E5%8F%98%E9%93%BE%E6%8E%A5%E5%B1%9E%E6%80%A7"><span class="toc-text">修饰全局变量&#x2F;函数 (改变链接属性)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%87%BD%E6%95%B0"><span class="toc-text">7. 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%84%E6%88%90"><span class="toc-text">函数的构成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-text">特殊函数类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0"><span class="toc-text">递归函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0"><span class="toc-text">静态函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-text">回调函数</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#signal-%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3"><span class="toc-text">signal 函数详解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AE%9E%E6%88%98-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E4%BC%A0%E5%80%BC-vs-%E4%BC%A0%E5%9D%80"><span class="toc-text">面试题实战-函数参数传递：传值 vs 传址</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">8. 作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">作用域的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static-%E5%AF%B9%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%87%BD%E6%95%B0%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-text">static 对全局变量&#x2F;函数的影响</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86c-%E8%AF%AD%E8%A8%80%E7%9A%84%E7%B2%BE%E9%AB%93%E6%8C%87%E9%92%88%E4%B8%8E%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-text">第三部分：C 语言的精髓：指针与复合类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%95%B0%E7%BB%84"><span class="toc-text">9. 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">数组定义与初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%BC%95%E7%94%A8"><span class="toc-text">数组元素引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">字符数组与多维数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AE%9E%E6%88%98-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E8%BE%B9%E7%95%8C%E5%85%83%E7%B4%A0%E9%81%8D%E5%8E%86"><span class="toc-text">[面试题实战] 二维数组边界元素遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-%E5%A4%A9%E5%BD%A9%E7%94%B5%E5%AD%90-23c"><span class="toc-text">代码示例 (天彩电子-23.c)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E6%8C%87%E9%92%88"><span class="toc-text">10. 指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%AE%9A%E4%B9%89%E4%B8%8E%E8%B5%8B%E5%80%BC"><span class="toc-text">指针定义与赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E8%A7%A3%E5%BC%95%E7%94%A8"><span class="toc-text">指针解引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8E%E6%8C%87%E9%92%88%E4%B8%8E%E7%A9%BA%E6%8C%87%E9%92%88"><span class="toc-text">野指针与空指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97"><span class="toc-text">指针运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AE%9E%E6%88%98-const%E6%8C%87%E9%92%88%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F%E8%BE%A8%E6%9E%90"><span class="toc-text">面试题实战 - const指针的三种模式辨析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">11. 数组与指针的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%90%8D%E5%8D%B3%E6%8C%87%E9%92%88"><span class="toc-text">数组名即指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E5%8F%82%E6%95%B0"><span class="toc-text">函数中的数组参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E7%89%B9%E6%AE%8A%E6%95%B0%E7%BB%84%E4%B8%8E%E9%AB%98%E7%BA%A7%E6%8C%87%E9%92%88"><span class="toc-text">12. 特殊数组与高级指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E6%8C%87%E9%92%88%E8%A7%A3%E8%AF%BB%E6%96%B9%E6%B3%95"><span class="toc-text">复杂指针解读方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%B6%E9%95%BF%E6%95%B0%E7%BB%84"><span class="toc-text">零长数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%95%BF%E6%95%B0%E7%BB%84"><span class="toc-text">变长数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88"><span class="toc-text">字符指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#void-%E6%8C%87%E9%92%88"><span class="toc-text">void 指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const-%E6%8C%87%E9%92%88"><span class="toc-text">const 指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E6%8C%87%E9%92%88"><span class="toc-text">多级指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-text">函数指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E7%BB%93%E6%9E%84%E4%BD%93-struct"><span class="toc-text">13. 结构体 (Struct)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-text">定义、初始化与使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90"><span class="toc-text">结构体内存对齐</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E5%9F%9F-bit-field"><span class="toc-text">位域 (Bit-field)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E8%81%94%E5%90%88%E4%BD%93-union"><span class="toc-text">14. 联合体 (Union)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E6%9E%9A%E4%B8%BE-enum"><span class="toc-text">15. 枚举 (Enum)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86%E6%9E%84%E5%BB%BA%E5%A4%A7%E5%9E%8B%E7%A8%8B%E5%BA%8F"><span class="toc-text">第四部分：构建大型程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-volatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">16. volatile关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-text">代码示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E9%A2%84%E5%A4%84%E7%90%86%E4%B8%8E%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7"><span class="toc-text">17. 预处理与高级技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="toc-text">高级宏定义</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%8F%E8%BF%90%E7%AE%97%E7%AC%A6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%96-%E8%BF%9E%E6%8E%A5"><span class="toc-text">宏运算符# (字符串化) ## (连接)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%9A%84%E5%B8%A6%E5%8F%82%E5%AE%8F-gcc-%E6%89%A9%E5%B1%95"><span class="toc-text">安全的带参宏 (GCC 扩展)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0-inline"><span class="toc-text">内联函数 (inline)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-text">18. 多文件编程与头文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91"><span class="toc-text">条件编译</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E8%AE%BE%E8%AE%A1"><span class="toc-text">头文件的作用与设计</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="toc-text">19. 常用字符串函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#strlen-%E8%8E%B7%E5%8F%96%E9%95%BF%E5%BA%A6"><span class="toc-text">strlen - 获取长度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strcpy-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%8D%E5%88%B6"><span class="toc-text">strcpy - 字符串复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strcat-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5"><span class="toc-text">strcat - 字符串拼接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strcmp-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83"><span class="toc-text">strcmp - 字符串比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strchr-%E6%9F%A5%E6%89%BE%E5%AD%97%E7%AC%A6"><span class="toc-text">strchr - 查找字符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strstr-%E6%9F%A5%E6%89%BE%E5%AD%90%E4%B8%B2"><span class="toc-text">strstr - 查找子串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strtok-%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">strtok - 分割字符串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E5%85%A5%E9%97%A8"><span class="toc-text">第五部分：高级应用入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8"><span class="toc-text">20. 算法入门</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-text">经典排序：冒泡排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8"><span class="toc-text">21. 数据结构入门</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-text">单链表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89"><span class="toc-text">22. 面试题精选</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A7%E5%A6%99%E7%9A%84%E7%BA%A7%E6%95%B0%E6%B1%82%E5%92%8C"><span class="toc-text">巧妙的级数求和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%91%E9%9B%B6%E9%92%B1%E9%97%AE%E9%A2%98"><span class="toc-text">凑零钱问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E6%95%B0%E5%AD%971%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0"><span class="toc-text">统计数字’1’的出现次数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E8%BE%B9%E7%95%8C%E5%85%83%E7%B4%A0%E6%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC"><span class="toc-text">二维数组边界元素求平均值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB"><span class="toc-text">23. 扩展阅读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93"><span class="toc-text">24. 笔记总结</span></a></li></ol></div><div class="widget-footer"><a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="1.5"><path stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/><path d="M7 3.338A9.95 9.95 0 0 1 12 2c5.523 0 10 4.477 10 10s-4.477 10-10 10S2 17.523 2 12c0-1.821.487-3.53 1.338-5"/></g></svg><span>回到顶部</span></a><a class="buttom" onclick="util.scrollComment()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="1.5" d="M8 10.5h8M8 14h5.5M17 3.338A9.95 9.95 0 0 0 12 2C6.477 2 2 6.477 2 12c0 1.6.376 3.112 1.043 4.453c.178.356.237.763.134 1.148l-.595 2.226a1.3 1.3 0 0 0 1.591 1.592l2.226-.596a1.63 1.63 0 0 1 1.149.133A9.96 9.96 0 0 0 12 22c5.523 0 10-4.477 10-10c0-1.821-.487-3.53-1.338-5"/></svg><span>参与讨论</span></a></div></widget></div></aside><div class="float-panel"><button type="button" style="display:none" class="laptop-only rightbar-toggle mobile" onclick="sidebar.rightbar()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></button> <button type="button" style="display:none" class="mobile-only leftbar-toggle mobile" onclick="sidebar.leftbar()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg></button></div></div><div class="scripts"><script>window.canonical={originalHost:null,officialHosts:["localhost"],encoded:""};let ctx={date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前"},root:"/",tag_plugins:{chat:Object.assign({api:"https://siteinfo.listentothewind.cn/api/v1"})},search:{}};if((ctx.search.service="local_search")==ctx.search.service){let e=Object.assign({},'{"field":"all","path":"/search.json","content":true,"skip_search":null,"sort":"-date"}');ctx.search[ctx.search.service]=e}let def={avatar:"https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg",cover:"https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg",loading:"https://api.iconify.design/eos-icons:three-dots-loading.svg?color=%231cd0fd"},deps={jquery:"https://gcore.jsdelivr.net/npm/jquery@3.7/dist/jquery.min.js",marked:"https://gcore.jsdelivr.net/npm/marked@13.0/lib/marked.umd.min.js",lazyload:"/%5Bobject%20Object%5D"}</script><script>function RunItem(){function o(e,t){this.name=t||e.name,this.run=()=>{try{e()}catch(e){console.log(e)}}}this.list=[],this.start=()=>{for(var e=0;e<this.list.length;e++)this.list[e].run()},this.push=(e,t,r=!0)=>{let i=e,s=new o(i=r?()=>{utils.requestAnimationFrame(e)}:i,t);this.list.push(s)},this.remove=t=>{for(let e=0;e<this.list.length;e++)this.list[e].name==t&&this.list.splice(e,1)}}let utils={css:(e,t,r,i)=>{var s,o,a=window.document,n=a.createElement("link"),l=(o=t||(s=(a.body||a.getElementsByTagName("head")[0]).childNodes)[s.length-1],a.styleSheets);if(i)for(var d in i)i.hasOwnProperty(d)&&n.setAttribute(d,i[d]);n.rel="stylesheet",n.href=e,n.media="only x",function e(t){if(a.body)return t();setTimeout(function(){e(t)})}(function(){o.parentNode.insertBefore(n,t?o:o.nextSibling)});function u(e){for(var t=n.href,r=l.length;r--;)if(l[r].href===t)return e();setTimeout(function(){u(e)})}function h(){n.addEventListener&&n.removeEventListener("load",h),n.media=r||"all"}return n.addEventListener&&n.addEventListener("load",h),n.onloadcssdefined=u,u(h),n},js:(s,o)=>new Promise((t,e)=>{var r=document.createElement("script");if(s.startsWith("/")&&(s=ctx.root+s.substring(1)),r.src=s,o)for(var i of Object.keys(o))r[i]=o[i];else r.async=!0;r.onerror=e,r.onload=r.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(r.onload=r.onreadystatechange=null,t())},document.head.appendChild(r)}),jq:e=>{"undefined"==typeof jQuery?utils.js(deps.jquery).then(e):e()},onLoading:e=>{e&&$(e).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>')},onLoadSuccess:e=>{e&&$(e).find(".loading-wrap").remove()},onLoadFailure:e=>{e&&($(e).find(".loading-wrap svg").remove(),$(e).find(".loading-wrap").append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>'),$(e).find(".loading-wrap").addClass("error"))},request:(a,e,n,l)=>{let d=0;return new Promise((i,s)=>{let o=()=>{utils.onLoading?.(a);let t=!1,r=setTimeout(()=>{t=!0,console.warn("[request] 超时:",e),3<=++d?(utils.onLoadFailure?.(a),l?.(),s("请求超时")):setTimeout(o,1e3)},5e3);fetch(e).then(e=>{if(!t){if(clearTimeout(r),e.ok)return e;throw new Error("响应失败")}}).then(e=>{t||(utils.onLoadSuccess?.(a),n(e),i(e))}).catch(e=>{clearTimeout(r),console.warn("[request] 错误:",e),3<=++d?(utils.onLoadFailure?.(a),l?.(),s(e)):setTimeout(o,1e3)})};o()})},requestWithoutLoading:(e,a={},n=2,l=5e3)=>new Promise((r,i)=>{let s=0,o=()=>{let t=setTimeout(()=>{++s>n?i("timeout"):o()},l);fetch(e,a).then(e=>{if(clearTimeout(t),!e.ok)throw new Error("bad response");r(e)}).catch(e=>{clearTimeout(t),++s>n?i(e):setTimeout(o,500)})};o()}),requestAnimationFrame:e=>{window.requestAnimationFrame||(window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame),window.requestAnimationFrame(e)},dark:{}};utils.dark.method={toggle:new RunItem},utils.dark=Object.assign(utils.dark,{push:utils.dark.method.toggle.push})</script><script>let sidebar={leftbar:()=>{l_body&&(l_body.toggleAttribute("leftbar"),l_body.removeAttribute("rightbar"))},rightbar:()=>{l_body&&(l_body.toggleAttribute("rightbar"),l_body.removeAttribute("leftbar"))},dismiss:()=>{l_body&&(l_body.removeAttribute("leftbar"),l_body.removeAttribute("rightbar"))},toggleTOC:()=>{document.querySelector("#data-toc").classList.toggle("collapse")}}</script><script>(()=>{var e;for(e of document.querySelectorAll(".tag-subtree.parent-tag > a > .tag-switcher-wrapper"))e.addEventListener("click",e=>{e.target.closest(".tag-subtree.parent-tag").classList.toggle("expanded"),e.preventDefault()});var t=new URLSearchParams(window.location.search).get("tag");if(t){let e=document.querySelector(`.tag-subtree[data-tag="${t}"]`);if(e)for(e.querySelector("a").classList.add("active");e;)e.classList.add("expanded"),e=e.parentElement.closest(".tag-subtree.parent-tag")}})()</script><script async src="https://gcore.jsdelivr.net/npm/vanilla-lazyload@19.1/dist/lazyload.min.js"></script><script>window.lazyLoadOptions={elements_selector:".lazy",callback_loaded:e=>{e.classList.add("loaded");e=e.closest(".lazy-box")?.querySelector(".lazy-icon");e&&e.remove()}},window.addEventListener("LazyLoad::Initialized",function(e){window.lazyLoadInstance=e.detail.instance},!1),document.addEventListener("DOMContentLoaded",function(){window.lazyLoadInstance?.update()}),window.wrapLazyloadImages=e=>{(e="string"==typeof e?document.querySelector(e):e)&&(e.querySelectorAll("img").forEach(e=>{var a,t,d;e.classList.contains("lazy")||(d=e.getAttribute("src"))&&((a=document.createElement("div")).className="lazy-box",(t=e.cloneNode()).removeAttribute("src"),t.setAttribute("data-src",d),t.classList.add("lazy"),(d=document.createElement("div")).className="lazy-icon",def.loading&&(d.style.backgroundImage=`url("${def.loading}")`),a.appendChild(t),a.appendChild(d),e.replaceWith(a))}),window.lazyLoadInstance?.update)&&window.lazyLoadInstance.update()}</script><script src="/js/main.js?v=1.33.1" defer></script><script>let applyTheme=e=>{"auto"===e?document.documentElement.removeAttribute("data-theme"):document.documentElement.setAttribute("data-theme",e)},applyThemeToGiscus=e=>{var t=document.getElementById("giscus"),t=(t&&t.setAttribute("data-theme",e),document.querySelector("#comments > section.giscus > iframe"));t&&(e=t.src.replace(/theme=[\w]+/,"theme="+e),t.src=e)},switchTheme=()=>{let e;switch(document.documentElement.getAttribute("data-theme")){case"light":e="dark";break;case"dark":e="auto";break;default:e="light"}applyTheme(e),window.localStorage.setItem("Stellar.theme",e),utils.dark.mode="auto"===e?window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light":e,utils.dark.method.toggle.start(),hud?.toast?.({light:"切换到浅色模式",dark:"切换到深色模式",auto:"切换到跟随系统配色"}[e])};(()=>{var e=window.localStorage.getItem("Stellar.theme");null!==e?applyTheme(e):utils.dark.mode=window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light",utils.dark.method.toggle.start()})()</script><script type="module">const el = document.querySelector('#comments #giscus');
  util.viewportLazyload(el, load_discus, false);

  function load_discus() {
    if (!el) return;
    try {
        el.innerHTML = '';
      } catch (error) {
        console.error(error);
      }
      const script = document.createElement('script');
      script.async = true;
      for (const key of Object.keys(el.attributes)) {
        const attr = el.attributes[key];
        if (['class', 'id'].includes(attr.name) === false) {
          script.setAttribute(attr.name, attr.value);
        }
      }
      el.appendChild(script);
  }</script><script defer>window.addEventListener("DOMContentLoaded",e=>{ctx.services=Object.assign({},JSON.parse('{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"rating":{"js":"/js/services/rating.js","api":"https://star-vote.xaox.cc/api/rating"},"vote":{"js":"/js/services/vote.js","api":"https://star-vote.xaox.cc/api/vote"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"friends_and_posts":{"js":"/js/services/friends_and_posts.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"},"voice":{"js":"/js/plugins/voice.js"},"video":{"js":"/js/plugins/video.js"},"download-file":{"js":"/js/plugins/download-file.js"},"twikoo":{"js":"/js/services/twikoo_latest_comment.js"},"waline":{"js":"/js/services/waline_latest_comment.js"},"artalk":{"js":"/js/services/artalk_latest_comment.js"},"giscus":{"js":"/js/services/giscus_latest_comment.js"},"contributors":{"edit_this_page":{"_posts/":null,"wiki/stellar/":"https://github.com/xaoxuu/hexo-theme-stellar-docs/blob/main/"},"js":"/js/services/contributors.js"}}'));for(let s of Object.keys(ctx.services)){let e=ctx.services[s].js;"siteinfo"==s?(ctx.cardlinks=document.querySelectorAll("a.link-card[cardlink]"),0<ctx.cardlinks?.length&&utils.js(e,{defer:!0}).then(function(){setCardLink(ctx.cardlinks)})):"voice"==s?(ctx.voiceAudios=document.querySelectorAll(".voice>audio"),0<ctx.voiceAudios?.length&&utils.js(e,{defer:!0}).then(function(){createVoiceDom(ctx.voiceAudios)})):"video"==s?(ctx.videos=document.querySelectorAll(".video>video"),0<ctx.videos?.length&&utils.js(e,{defer:!0}).then(function(){videoEvents(ctx.videos)})):"download-file"==s?(ctx.files=document.querySelectorAll(".file"),0<ctx.files?.length&&utils.js(e,{defer:!0}).then(function(){downloadFileEvent(ctx.files)})):0<document.getElementsByClassName("ds-"+s)?.length&&utils.jq(()=>{s,utils.js(deps.marked).then(function(){utils.js(e,{defer:!0})})})}let o=document.querySelectorAll(".chat .status-bar .time");var s,t;function i(){for(let e=0;e<o.length;++e){var s=o[e],t=new Date,i=t.getHours(),t=t.getMinutes();s.innerHTML=n(i)+":"+n(t)}}function n(e){return e<10?"0"+e:e}0<o.length&&(i(),s=(new Date).getSeconds(),t=setInterval(function(){i(),clearInterval(t),setInterval(i,6e4)},1e3*(60-s)));let c=new IntersectionObserver((e,t)=>{e.filter(e=>e.isIntersecting).sort((e,s)=>e.intersectionRect.y!==s.intersectionRect.y?e.intersectionRect.y-s.intersectionRect.y:e.intersectionRect.x-s.intersectionRect.x).forEach((e,s)=>{t.unobserve(e.target),setTimeout(()=>{e.target.classList.add("quote-blink"),setTimeout(()=>{e.target.classList.remove("quote-blink")},1e3)},Math.max(100,16)*(s+1))})}),r=document.querySelectorAll(".chat .talk .quote");r.forEach(i=>{i.addEventListener("click",function(){var e,s,t=document.getElementById("quote-"+i.getAttribute("quotedCellTag"));t&&(s=(e=t.parentElement).clientHeight/2,t.offsetTop>s-t.clientHeight/2?e.scrollTo({top:t.offsetTop-s+t.clientHeight/2,behavior:"smooth"}):e.scrollTo({top:0,behavior:"smooth"}),c.observe(t))})})})</script><script>window.addEventListener("DOMContentLoaded",e=>{ctx.search={path:"/search.json"},utils.js("/js/search/local-search.js",{defer:!0})})</script><script>window.FPConfig={delay:0,ignoreKeywords:[],maxRPS:5,hoverDelay:25}</script><script defer src="https://gcore.jsdelivr.net/npm/flying-pages@2/flying-pages.min.js"></script><script>ctx.fancybox={selector:'.md-text img[alt]:not([alt="icon"]):not([alt="cover"])',css:"https://gcore.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css",js:"https://gcore.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js"};var selector="[data-fancybox]:not(.error), .with-fancybox .atk-content img:not([atk-emoticon])",needFancybox=(ctx.fancybox.selector&&(selector+=", "+ctx.fancybox.selector),0!==document.querySelectorAll(selector).length);if(!needFancybox){let t=document.getElementsByClassName("ds-memos"),e=(null!=t&&0<t.length&&(needFancybox=!0),document.getElementsByClassName("with-fancybox"));null!=e&&0<e.length&&(needFancybox=!0)}needFancybox&&(utils.css(ctx.fancybox.css),utils.js(ctx.fancybox.js,{defer:!0}).then(function(){Fancybox.bind(selector,{hideScrollbar:!1,Thumbs:{autoStart:!1},caption:(t,e)=>e.triggerEl.alt||e.triggerEl.dataset.caption||null})}))</script><script>window.addEventListener("DOMContentLoaded",e=>{let t=document.getElementById("swiper-api");null!=t&&(utils.css("https://unpkg.com/swiper@10.3/swiper-bundle.min.css"),utils.js("https://unpkg.com/swiper@10.3/swiper-bundle.min.js",{defer:!0}).then(function(){var e=t.getAttribute("effect")||"";new Swiper(".swiper#swiper-api",{slidesPerView:"auto",spaceBetween:8,centeredSlides:!0,effect:e,rewind:!0,pagination:{el:".swiper-pagination",clickable:!0},navigation:{nextEl:".swiper-button-next",prevEl:".swiper-button-prev"}})}))})</script><link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/katex@0.16/dist/katex.min.css"><script defer src="https://gcore.jsdelivr.net/npm/mermaid@v9/dist/mermaid.min.js"></script><script>window.addEventListener("DOMContentLoaded",e=>{var a={startOnLoad:!0,theme:window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"neutral",logLevel:3,themeVariables:{darkMode:!0},flowchart:{useMaxWidth:!1,htmlLabels:!0,curve:"linear"},gantt:{axisFormat:"%Y/%m/%d"},sequence:{actorMargin:50}};mermaid.initialize(a)})</script><script>document.addEventListener("DOMContentLoaded",function(){window.codeElements=document.querySelectorAll(".code"),0<window.codeElements.length&&(ctx.copycode={default_text:"Copy",success_text:"Copied",toast:"复制成功"},utils.js("/js/plugins/copycode.js"))})</script><script>var _hmt=_hmt||[];(()=>{var e=document.createElement("script"),t=(e.src="https://hm.baidu.com/hm.js?b5a2afc20b06445af155f3af37777902",document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)})()</script><script>((e,t,n,r,a,c)=>{e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)},(a=t.createElement(r)).async=1,a.src="https://www.clarity.ms/tag/rp0i6z4yyg",(c=t.getElementsByTagName(r)[0]).parentNode.insertBefore(a,c)})(window,document,"clarity","script")</script></div><style>[bg-lazy]{background-image:none!important;background-color:#eee!important}</style><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:3,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})})</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o=d[n],i=function(){d=d.filter(function(t){return o!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(o)};(t=o).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),i()):(e=new Image,a=t.getAttribute("data-original"),e.onload=function(){t.src=a,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),i()},e.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=a},t.src!==a&&(e.src=a)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this)</script></body></html>