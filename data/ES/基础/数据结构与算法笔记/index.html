<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.33.1" theme-name="Stellar" theme-version="1.33.1"><meta name="generator" content="Hexo 7.3.0"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="preconnect" href="https://gcore.jsdelivr.net" crossorigin><link rel="preconnect" href="https://unpkg.com" crossorigin><link rel="preconnect" href="https://cdn.bootcdn.net" crossorigin><meta name="renderer" content="webkit"><meta name="force-rendering" content="webkit"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="HandheldFriendly" content="True"><meta name="mobile-web-app-capable" content="yes"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000"><meta name="theme-color" content="#f9fafb"><title>数据结构与算法笔记 - Sky Blog</title><meta name="description" content="数据结构与算法复习笔记，涵盖从基础复杂度分析、线性表、栈、队列到树、排序和查找等核心内容，注重理论与C语言代码实战结合。"><meta property="og:type" content="website"><meta property="og:title" content="数据结构与算法笔记"><meta property="og:url" content="http://skyforever.top/data/ES/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="Sky Blog"><meta property="og:description" content="数据结构与算法复习笔记，涵盖从基础复杂度分析、线性表、栈、队列到树、排序和查找等核心内容，注重理论与C语言代码实战结合。"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2025-07-20T02:00:00.000Z"><meta property="article:modified_time" content="2025-07-20T02:00:00.000Z"><meta property="article:author" content="Skyforever"><meta property="article:tag" content="基础&#x2F;数据结构与算法"><meta name="twitter:card" content="summary"><meta name="keywords" content="数据结构, 算法, C语言, 链表, 树, 排序, 查找, 笔记, 教程, 栈, 队列"><link rel="stylesheet" href="/css/main.css?v=1.33.1"><link rel="shortcut icon" href="https://image.skyforever.top/blog/2025/08/c25707b5a37360e74c54764d71d1724c.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Website","@id":"http://skyforever.top/data/ES/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/","author":{"@type":"Person","name":"Skyforever","sameAs":[]},"name":"数据结构与算法笔记","description":"数据结构与算法复习笔记，涵盖从基础复杂度分析、线性表、栈、队列到树、排序和查找等核心内容，注重理论与C语言代码实战结合。","url":"http://skyforever.top/data/ES/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}</script></head><body><div class="l_body content" id="start" layout="page" type="tech"><aside class="l_left"><div class="sidebg"></div><div class="leftbar-container"><header class="header"><div class="logo-wrap"><div class="icon"><img no-lazy class="icon" src="/images/icons/cloud.png" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></div><a class="title" href="/"><div class="main">Sky Blog</div><div class="sub normal cap">记录走下的每一步</div><div class="sub hover cap" style="opacity:0">Write by Skyforever</div></a></div></header><div class="nav-area"><nav class="menu dis-select"><a class="nav-item" title="博客" href="/"><span>博客</span></a><a class="nav-item" title="项目" href="/wiki/"><span>项目</span></a><a class="nav-item" title="笔记" href="/notebooks/"><span>笔记</span></a></nav></div><div class="widgets"><div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" data-filter="/note/ES" placeholder="在 嵌入式 中搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div><widget class="widget-wrapper post-list"><div class="widget-header dis-select"><span class="name">标签</span></div><div class="widget-body fs14 tag-tree"><div class="tag-subtree leaf-tag expanded" data-tag=""><a class="link" href="/note/ES/"><span class="toc-text">所有笔记 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a></div><div class="tag-subtree parent-tag expanded" data-tag="图形界面开发"><a class="link" href="/note/ES/tags/%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91/"><span class="toc-text"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>图形界面开发 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a><div class="tag-subtree parent-tag expanded" data-tag="图形界面开发/lvgl"><a class="link" href="/note/ES/tags/%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91/lvgl/"><span class="toc-text" style="padding-left:.875rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>LVGL </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a><div class="tag-subtree leaf-tag expanded" data-tag="图形界面开发/lvgl/多媒体"><a class="link" href="/note/ES/tags/%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91/lvgl/%E5%A4%9A%E5%AA%92%E4%BD%93/"><span class="toc-text" style="padding-left:1.75rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>多媒体 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a></div><div class="tag-subtree leaf-tag expanded" data-tag="图形界面开发/lvgl/核心概念"><a class="link" href="/note/ES/tags/%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91/lvgl/%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/"><span class="toc-text" style="padding-left:1.75rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>核心概念 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a></div></div></div><div class="tag-subtree parent-tag expanded" data-tag="基础"><a class="link" href="/note/ES/tags/%E5%9F%BA%E7%A1%80/"><span class="toc-text"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>基础 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a><div class="tag-subtree leaf-tag expanded" data-tag="基础/c语言"><a class="link" href="/note/ES/tags/%E5%9F%BA%E7%A1%80/c%E8%AF%AD%E8%A8%80/"><span class="toc-text" style="padding-left:.875rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>C语言 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a></div><div class="tag-subtree leaf-tag expanded" data-tag="基础/linux基础"><a class="link" href="/note/ES/tags/%E5%9F%BA%E7%A1%80/linux%E5%9F%BA%E7%A1%80/"><span class="toc-text" style="padding-left:.875rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>Linux基础 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a></div><div class="tag-subtree leaf-tag expanded" data-tag="基础/库与框架"><a class="link" href="/note/ES/tags/%E5%9F%BA%E7%A1%80/%E5%BA%93%E4%B8%8E%E6%A1%86%E6%9E%B6/"><span class="toc-text" style="padding-left:.875rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>库与框架 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a></div><div class="tag-subtree parent-tag expanded" data-tag="基础/数据结构与算法"><a class="link" href="/note/ES/tags/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="toc-text" style="padding-left:.875rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>数据结构与算法 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a><div class="tag-subtree leaf-tag expanded" data-tag="基础/数据结构与算法/内核链表"><a class="link" href="/note/ES/tags/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/"><span class="toc-text" style="padding-left:1.75rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>内核链表 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a></div></div><div class="tag-subtree leaf-tag expanded" data-tag="基础/文件io"><a class="link" href="/note/ES/tags/%E5%9F%BA%E7%A1%80/%E6%96%87%E4%BB%B6io/"><span class="toc-text" style="padding-left:.875rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>文件IO </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a></div></div><div class="tag-subtree parent-tag expanded" data-tag="硬件"><a class="link" href="/note/ES/tags/%E7%A1%AC%E4%BB%B6/"><span class="toc-text"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>硬件 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a><div class="tag-subtree leaf-tag expanded" data-tag="硬件/stm32"><a class="link" href="/note/ES/tags/%E7%A1%AC%E4%BB%B6/stm32/"><span class="toc-text" style="padding-left:.875rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>STM32 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a></div></div><div class="tag-subtree parent-tag expanded" data-tag="进阶"><a class="link" href="/note/ES/tags/%E8%BF%9B%E9%98%B6/"><span class="toc-text"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>进阶 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a><div class="tag-subtree parent-tag expanded" data-tag="进阶/linux并发编程"><a class="link" href="/note/ES/tags/%E8%BF%9B%E9%98%B6/linux%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><span class="toc-text" style="padding-left:.875rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>Linux并发编程 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a><div class="tag-subtree leaf-tag expanded" data-tag="进阶/linux并发编程/线程"><a class="link" href="/note/ES/tags/%E8%BF%9B%E9%98%B6/linux%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B/"><span class="toc-text" style="padding-left:1.75rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>线程 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a></div><div class="tag-subtree leaf-tag expanded" data-tag="进阶/linux并发编程/进程"><a class="link" href="/note/ES/tags/%E8%BF%9B%E9%98%B6/linux%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E8%BF%9B%E7%A8%8B/"><span class="toc-text" style="padding-left:1.75rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>进程 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a></div></div><div class="tag-subtree leaf-tag expanded" data-tag="进阶/linux网络"><a class="link" href="/note/ES/tags/%E8%BF%9B%E9%98%B6/linux%E7%BD%91%E7%BB%9C/"><span class="toc-text" style="padding-left:.875rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>Linux网络 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a></div><div class="tag-subtree leaf-tag expanded" data-tag="进阶/mqtt物联网"><a class="link" href="/note/ES/tags/%E8%BF%9B%E9%98%B6/mqtt%E7%89%A9%E8%81%94%E7%BD%91/"><span class="toc-text" style="padding-left:.875rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>MQTT物联网 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a></div></div></div></widget><widget class="widget-wrapper recent post-list"><div class="widget-header dis-select"><span class="name">最近更新</span></div><div class="widget-body fs14"><a class="item title" href="/data/ES/%E8%BF%9B%E9%98%B6/MQTT%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"><span class="title">MQTT 使用笔记</span></a><a class="item title" href="/data/ES/%E8%BF%9B%E9%98%B6/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><span class="title">Linux 网络编程</span></a><a class="item title" href="/data/ES/%E8%BF%9B%E9%98%B6/%E7%BA%BF%E7%A8%8B/"><span class="title">Linux 多线程编程：Pthreads 核心函数与资源管理详解</span></a><a class="item title" href="/data/ES/%E8%BF%9B%E9%98%B6/%E8%BF%9B%E7%A8%8B/"><span class="title">Linux 进程管理与调度</span></a><a class="item title" href="/data/ES/%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91/LVGL%20%E5%9B%BE%E5%83%8F%E4%B8%8E%E5%AD%97%E4%BD%93%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"><span class="title">LVGL 图像与字体使用笔记</span></a><a class="item title" href="/data/ES/%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91/LVGL%20%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E7%AC%94%E8%AE%B0/"><span class="title">LVGL 核心概念笔记</span></a><a class="item title" href="/data/ES/%E5%9F%BA%E7%A1%80/C%E8%AF%AD%E8%A8%80-%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C%E5%92%8C%E4%BD%BF%E7%94%A8/"><span class="title">C语言-库的制作和使用</span></a><a class="item title" href="/data/ES/%E5%9F%BA%E7%A1%80/%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8%E7%94%A8%E6%B3%95/"><span class="title">内核链表笔记</span></a><a class="item title" href="/data/ES/%E5%9F%BA%E7%A1%80/%E6%96%87%E4%BB%B6IO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">文件I/O学习笔记</span></a><a class="item title" href="/data/ES/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"><span class="title">数据结构与算法笔记</span></a></div></widget></div><footer class="footer dis-select"><div class="social-wrap"><a class="social" href="https://github.com/zhangwei43721" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/08a41b181ce68.svg"></a><a class="social" href="https://music.163.com/#/user/home?id=1654800754" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/3845874.svg"></a></div></footer></div></aside><div class="l_main" id="main"><div class="article banner top"><div class="content"><div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a> <span class="sep"></span> <a class="cap breadcrumb" href="/notebooks/">笔记本</a> <span class="sep"></span> <a class="cap breadcrumb" href="/note/ES/">嵌入式</a></div><div class="flex-row" id="post-meta"><span class="text created">更新于：<time datetime="2025-07-20T02:00:00.000Z">2025-07-20</time></span><span class="sep updated"></span><span class="text updated">发布于：<time datetime="2025-07-20T02:00:00.000Z">2025-07-20</time></span></div></div></div><div class="bottom only-title"><div class="text-area"><h1 class="text title"><span>数据结构与算法笔记</span></h1></div></div></div></div><article class="md-text content"><h1 id="一基础入门与算法分析"><a class="markdownIt-Anchor" href="#一基础入门与算法分析"></a> 一：基础入门与算法分析</h1><h2 id="1-核心概念"><a class="markdownIt-Anchor" href="#1-核心概念"></a> 1. 核心概念</h2><ul><li><strong>数据结构</strong>: 一门研究如何有效组织数据，以提高数据处理效率的学科。它关注数据间的逻辑关系（逻辑结构）和在计算机中的存储方式（存储形式）。</li><li><strong>逻辑结构</strong>: 指数据元素之间的内在关系，与存储方式无关。常见有：<ul><li><strong>线性结构</strong>: 元素间为一对一关系 (如：线性表、栈、队列)。</li><li><strong>非线性结构</strong>: 元素间为一对多或多对多关系 (如：树、图)。</li></ul></li><li><strong>存储形式 (物理结构)</strong>: 指数据在内存中的存储方式。主要有：<ul><li><strong>顺序存储</strong>: 将逻辑上相邻的元素存储在物理位置也相邻的存储单元中（如：数组）。</li><li><strong>链式存储</strong>: 物理位置不一定相邻，通过指针来表示元素间的逻辑关系（如：链表）。</li></ul></li></ul><blockquote><p><strong>[info] 核心思想</strong></p><p>逻辑结构是“战略”，决定了数据应该如何组织；存储结构是“战术”，决定了数据具体如何存放。一种逻辑结构可以有多种存储实现。</p></blockquote><h2 id="2-算法性能分析"><a class="markdownIt-Anchor" href="#2-算法性能分析"></a> 2. 算法性能分析</h2><p>算法分析旨在评估算法的优劣，主要考量两个维度：<strong>时间复杂度</strong>和<strong>空间复杂度</strong>。目标是让程序运行得更快，占用内存更少。</p><h3 id="时间复杂度"><a class="markdownIt-Anchor" href="#时间复杂度"></a> <strong>时间复杂度</strong></h3><ul><li><p><strong>概念</strong>: 衡量算法执行时间随数据规模增长而变化的趋势，通常不考察绝对时间，而是估算<strong>基本操作的执行次数</strong>（语句频度）。</p></li><li><p><strong>表示法</strong>: 使用大 O 表示法 <code>O()</code>，只关注最高次幂项，忽略常数和低次幂项。</p><p>（为什么只关注最大的？看这个视频：）</p></li><li><p><strong>示例</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 执行 n 次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 执行 n*n 次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Hello\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码总执行次数为 <code>n * n = n^2</code>。因此，时间复杂度为 <strong>O(n²)</strong>。</p></li></ul><center><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="http://edu.yueqian.com.cn/group1/M00/03/88/wKgP3GCJBTyAIq5hAAA-8fy9K3w031.png?token=null&ts=null"><br><i>不同时间复杂度的增长趋势对比</i></center><h3 id="空间复杂度"><a class="markdownIt-Anchor" href="#空间复杂度"></a> <strong>空间复杂度</strong></h3><ul><li><strong>概念</strong>: 衡量算法在运行过程中临时占用存储空间大小的量度，同样采用大 O 表示法。</li></ul><h3 id="时空互换"><a class="markdownIt-Anchor" href="#时空互换"></a> <strong>时空互换</strong></h3><ul><li><p><strong>概念</strong>: 在某些场景下，可以通过增加空间消耗来换取更短的执行时间（空间换时间），或者通过增加计算时间来减少内存占用（时间换空间）。</p></li><li><p><strong>案例实战：快速计算二进制中 1 的位数</strong></p><ul><li><p><strong>问题</strong>: 给定一个 int，要求“尽快”求出其二进制表示中 1 的个数。</p></li><li><p><strong>常规解法 (时间换空间)</strong>: 循环移位或与操作，逐位判断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">count_ones</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        n &amp;= (n - <span class="number">1</span>); <span class="comment">// 每次操作消除最右边的1</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>高效解法 (空间换时间)</strong>: 预计算。创建一个 256 大小的数组，存储 0-255 每个数包含的 1 的个数。对于 32 位整数，分 4 个字节查表相加即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局预计算表</span></span><br><span class="line"><span class="type">int</span> bits_in_char[<span class="number">256</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">precompute</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">        bits_in_char[i] = (i &amp; <span class="number">1</span>) + bits_in_char[i / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">count_ones_fast</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> bits_in_char[n &amp; <span class="number">0xff</span>] +</span><br><span class="line">           bits_in_char[(n &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>] +</span><br><span class="line">           bits_in_char[(n &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>] +</span><br><span class="line">           bits_in_char[(n &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一种典型的用内存空间（<code>bits_in_char</code>数组）换取固定时间（4 次查表+3 次加法）的策略。</p></li></ul></li></ul><h1 id="二线性表"><a class="markdownIt-Anchor" href="#二线性表"></a> 二：线性表</h1><p>线性表是数据结构世界的基础构件，其两种主要实现——顺序表和链表，在性能上各有取舍，适用于完全不同的场景。</p><h2 id="3-顺序表"><a class="markdownIt-Anchor" href="#3-顺序表"></a> 3. 顺序表</h2><ul><li><strong>定义</strong>: 使用一段<strong>连续的物理内存</strong>来存储逻辑上相邻的数据元素。在 C 语言中，其最直接的体现就是<strong>数组</strong>。</li><li><strong>优点</strong>:<ul><li><strong>随机访问 O(1)</strong>: 可通过下标直接访问任何元素，速度极快。</li><li><strong>存储密度高</strong>: 无需额外空间存储元素间的关系。</li></ul></li><li><strong>缺点</strong>:<ul><li><strong>插入/删除 O(n)</strong>: 在中间或头部操作，需要移动大量元素。</li><li><strong>空间不灵活</strong>: 容量固定，扩容成本高或实现复杂。</li></ul></li><li><strong>适用场景</strong>: 数据量相对稳定，<strong>读操作远多于写操作</strong>的场景，如配置表、静态数据集等。</li></ul><h2 id="4-链表"><a class="markdownIt-Anchor" href="#4-链表"></a> 4. 链表</h2><h3 id="问题引入为什么普通链表不够用"><a class="markdownIt-Anchor" href="#问题引入为什么普通链表不够用"></a> <strong>问题引入：为什么普通链表不够用？</strong></h3><p>我们先看一个普通的学生信息单链表节点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">next</span>;</span> <span class="comment">// 指针域耦合了数据类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个设计存在一个致命缺陷：<strong>缺乏通用性</strong>。<code>next</code>指针的类型是<code>struct student *</code>，这意味着为<code>student</code>链表编写的所有操作函数（如<code>insert_student</code>, <code>remove_student</code>），都无法用于管理<code>teacher</code>或其他任何类型的链表。在像 Linux 内核这样拥有成千上万种数据结构的复杂项目中，为每种结构都重写一套链表代码是不可接受的。</p><h3 id="设计哲学linux-内核的解决方案数据与逻辑分离"><a class="markdownIt-Anchor" href="#设计哲学linux-内核的解决方案数据与逻辑分离"></a> <strong>设计哲学：Linux 内核的解决方案——数据与逻辑分离</strong></h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/18341284">Linux 内核-内核链表</a></p><p>Linux 内核用一种极其巧妙的方式解决了这个问题：将**“链”的逻辑<strong>从</strong>“数据”本身**中抽离。</p><ol><li><p><strong>定义一个“纯粹”的链表节点</strong>: 创建一个不包含任何业务数据，只负责链接的通用节点结构<code>struct list_head</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// From &lt;linux/list.h&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是一个标准的<strong>双向循环链表</strong>节点。</p></li><li><p><strong>“寄生”于用户数据结构</strong>: 将这个<code>list_head</code>结构作为一个<strong>成员</strong>，嵌入到任何需要被链式管理的用户数据结构中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="comment">// --- 用户数据域 ---</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="comment">// --- 链表逻辑域 ---</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span> <span class="comment">// &quot;寄生&quot;的内核链表节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><center><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="http://edu.yueqian.com.cn/group1/M00/00/43/rBJlJmMQDpGAaeADAAAzjlD9YqM143.png?token=null&ts=null" , width="450"><br><i>将标准链表节点嵌入用户数据结构</i></center><h3 id="难点攻克如何从链找到数据"><a class="markdownIt-Anchor" href="#难点攻克如何从链找到数据"></a> <strong>难点攻克：如何从“链”找到“数据”？</strong></h3><p>所有链表 API 操作的都是<code>list_head</code>指针，但我们最终需要的是包含业务数据的<code>student</code>结构体。如何从<code>list</code>成员的地址反向推算出其“宿主”<code>student</code>结构体的起始地址？</p><p>这就是内核链表最核心的宏 <code>list_entry</code> 的作用。</p><ul><li><strong>原理</strong>: <code>宿主结构体地址 = 成员地址 - 成员在宿主结构体中的偏移量</code></li></ul><center><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="http://edu.yueqian.com.cn/group1/M00/00/43/rBJlJmMQDpGAGF7WAABqCbxNuW8845.png?token=null&ts=null" , width="470"><br><i>通过成员地址和偏移量计算宿主地址</i></center><ul><li><p><strong>C 语言实现</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> list_entry(ptr, type, member) \</span></span><br><span class="line"><span class="meta">     ((type *)((char *)(ptr) - (unsigned long)(&amp;((type *)0)-&gt;member)))</span></span><br></pre></td></tr></table></figure><ul><li><code>ptr</code>: 指向<code>list_head</code>成员的指针。</li><li><code>type</code>: 宿主结构体的类型 (如 <code>struct student</code>)。</li><li><code>member</code>: <code>list_head</code>成员在宿主结构体中的名字 (如 <code>list</code>)。</li><li><code>&amp;((type *)0)-&gt;member</code>: 这是一个编译时技巧，计算出<code>member</code>在<code>type</code>结构体中的<strong>偏移量</strong>。</li></ul></li></ul><h3 id="代码实战使用内核链表管理学生信息"><a class="markdownIt-Anchor" href="#代码实战使用内核链表管理学生信息"></a> <strong>代码实战：使用内核链表管理学生信息</strong></h3><p>以下是一个完整的、可编译的示例，演示如何使用内核链表 API。<br><em>(为方便使用，已将内核的<code>list.h</code>相关宏和函数提取整理)</em></p><p><strong><code>kernel_list.h</code> (简化版)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _KERNEL_LIST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _KERNEL_LIST_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 核心节点定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 初始化宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_HEAD_INIT(name) &#123; &amp;(name), &amp;(name) &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_HEAD(name) struct list_head name = LIST_HEAD_INIT(name)</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">INIT_LIST_HEAD</span><span class="params">(<span class="keyword">struct</span> list_head *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">list</span>-&gt;next = <span class="built_in">list</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;prev = <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 核心辅助函数 (内部使用)</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __list_add(<span class="keyword">struct</span> list_head *new,</span><br><span class="line">                              <span class="keyword">struct</span> list_head *prev,</span><br><span class="line">                              <span class="keyword">struct</span> list_head *next) &#123;</span><br><span class="line">    next-&gt;prev = new;</span><br><span class="line">    new-&gt;next = next;</span><br><span class="line">    new-&gt;prev = prev;</span><br><span class="line">    prev-&gt;next = new;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 对外API: 添加节点</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_add</span><span class="params">(<span class="keyword">struct</span> list_head *new, <span class="keyword">struct</span> list_head *head)</span> &#123;</span><br><span class="line">    __list_add(new, head, head-&gt;next); <span class="comment">// 头插</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_add_tail</span><span class="params">(<span class="keyword">struct</span> list_head *new, <span class="keyword">struct</span> list_head *head)</span> &#123;</span><br><span class="line">    __list_add(new, head-&gt;prev, head); <span class="comment">// 尾插</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 核心宏：获取宿主结构体</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> list_entry(ptr, type, member) \</span></span><br><span class="line"><span class="meta">    ((type *)((char *)(ptr) - (unsigned long)(&amp;((type *)0)-&gt;member)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 对外API: 遍历</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> list_for_each_entry(pos, head, member) \</span></span><br><span class="line"><span class="meta">    for (pos = list_entry((head)-&gt;next, typeof(*pos), member); \</span></span><br><span class="line"><span class="meta">         &amp;pos-&gt;member != (head); \</span></span><br><span class="line"><span class="meta">         pos = list_entry(pos-&gt;member.next, typeof(*pos), member))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong><code>main.c</code></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel_list.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span> <span class="comment">// 嵌入内核链表节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 创建并初始化链表头 (这是一个独立的头结点)</span></span><br><span class="line">    LIST_HEAD(student_list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 添加学生信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Adding students...\n&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">stu1</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> student));</span><br><span class="line">    stu1-&gt;id = <span class="number">101</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(stu1-&gt;name, <span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    list_add_tail(&amp;stu1-&gt;<span class="built_in">list</span>, &amp;student_list); <span class="comment">// 尾插</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">stu2</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> student));</span><br><span class="line">    stu2-&gt;id = <span class="number">102</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(stu2-&gt;name, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    list_add_tail(&amp;stu2-&gt;<span class="built_in">list</span>, &amp;student_list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 遍历链表并打印信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n--- Student List ---\n&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">iter</span>;</span></span><br><span class="line">    list_for_each_entry(iter, &amp;student_list, <span class="built_in">list</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ID: %d, Name: %s\n&quot;</span>, iter-&gt;id, iter-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 查找并释放Bob的信息 (演示删除)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nFinding and removing Bob (ID 102)...\n&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">temp</span>;</span></span><br><span class="line">    list_for_each_entry_safe(iter, temp, &amp;student_list, <span class="built_in">list</span>) &#123; <span class="comment">// 安全遍历，因为要删除</span></span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;id == <span class="number">102</span>) &#123;</span><br><span class="line">            list_del(&amp;iter-&gt;<span class="built_in">list</span>); <span class="comment">// 从链表中脱离</span></span><br><span class="line">            <span class="built_in">free</span>(iter);            <span class="comment">// 释放内存</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Bob removed.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n--- Updated Student List ---\n&quot;</span>);</span><br><span class="line">    list_for_each_entry(iter, &amp;student_list, <span class="built_in">list</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ID: %d, Name: %s\n&quot;</span>, iter-&gt;id, iter-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 在程序结束时需要遍历并释放所有剩余节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>内核链表精髓总结</strong></p><ul><li><strong>通用性</strong>: 一套 API，管理所有类型的数据。</li><li><strong>高效性</strong>: 增删操作为 O(1)，无数据拷贝。</li><li><strong>健壮性</strong>: 经过 Linux 内核数十年验证，稳定可靠。</li><li><strong>思想</strong>: 完美的“控制反转”，用户只需关注自己的数据，将组织逻辑交给标准库。</li></ul></blockquote><h3 id="代码实战单链表的反转"><a class="markdownIt-Anchor" href="#代码实战单链表的反转"></a> 代码实战：单链表的反转</h3><p>掌握了链表的创建和遍历后，一个最经典的面试题和算法练习便是——<strong>反转一个单向链表</strong>。</p><p>例如，将 <code>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</code> 变为 <code>5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1</code>。</p><h4 id="1-核心挑战"><a class="markdownIt-Anchor" href="#1-核心挑战"></a> 1. 核心挑战</h4><p>在遍历链表时，每个节点只知道自己的“下一个”是谁。当我们想让 <code>节点2</code> 指向 <code>节点1</code> 时，一旦执行 <code>2-&gt;next = 1</code>，我们就会立即丢失通往 <code>节点3</code> 的路径。因此，算法设计的关键在于：<strong>在修改指针前，如何保存好“未来的路”</strong>。</p><h4 id="2-算法本质-三个职责的流转"><a class="markdownIt-Anchor" href="#2-算法本质-三个职责的流转"></a> 2. 算法本质 - 三个职责的流转</h4><p>无论代码怎么写，任何正确的迭代反转算法，都必须在循环的每一步中，清晰地管理好三个核心的“状态职责”：</p><ol><li><strong><code>Current</code> (当前)</strong>: 指向当前正要被反转指向的节点。</li><li><strong><code>Reversed</code> (已反转)</strong>: 指向已经反转好的新链表的头部。</li><li><strong><code>Upcoming</code> (未反转)</strong>: 指向<code>Current</code>在原始链表中的下一个节点，作为“路标”以防断链。</li></ol><p>算法的每一步，就是这三个职责在指针变量之间的一次优雅“交谊舞”。</p><h4 id="3-思想的多种代码表达"><a class="markdownIt-Anchor" href="#3-思想的多种代码表达"></a> 3. 思想的多种代码表达</h4><h5 id="表达一标准三指针迭代法-教科书式"><a class="markdownIt-Anchor" href="#表达一标准三指针迭代法-教科书式"></a> <strong>表达一：标准三指针迭代法 (教科书式)</strong></h5><p>这是最常见、最清晰的实现。我们用三个独立的指针变量来分别扮演这三个角色。</p><ul><li><code>p_rev</code>: 扮演 <code>Reversed</code> 角色。</li><li><code>p_cur</code>: 扮演 <code>Current</code> 角色。</li><li><code>p_upc</code>: 扮演 <code>Upcoming</code> 角色。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">reverse_list</span><span class="params">(linklist head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    linklist p_rev = <span class="literal">NULL</span>;</span><br><span class="line">    linklist p_cur = head-&gt;next;</span><br><span class="line">    linklist p_upc = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p_cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 1. 保存未来: Upcoming 指针记住 Current 的下一个节点</span></span><br><span class="line">        p_upc = p_cur-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 反转当前: Current 指向已反转链表的头部</span></span><br><span class="line">        p_cur-&gt;next = p_rev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 前进迭代: 更新 Reversed 和 Current 的角色</span></span><br><span class="line">        p_rev = p_cur;</span><br><span class="line">        p_cur = p_upc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 收尾: 将头结点指向反转后的新头</span></span><br><span class="line">    head-&gt;next = p_rev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>深度思考</strong>：通过严谨的排列组合，我们可以证明，只要有三个指针变量，无论哪个变量扮演哪个角色（共 <code>3! = 6</code> 种组合），其核心的四步操作逻辑是完全一致的，都能写出正确的算法。</p><h5 id="表达二头插法-巧妙利用头结点"><a class="markdownIt-Anchor" href="#表达二头插法-巧妙利用头结点"></a> <strong>表达二：头插法 (巧妙利用头结点)</strong></h5><p>这种方法更加精炼，它巧妙地让“头结点”本身参与到算法中，扮演 <code>Reversed</code> 的角色。</p><ul><li><code>p_cur</code>: 扮演 <code>Current</code>。</li><li><code>p_upc</code>: 扮演 <code>Upcoming</code>。</li><li><code>head-&gt;next</code>: <strong>扮演 <code>Reversed</code> 的角色</strong>，始终指向新链表的头。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">reverse_list_head_insertion</span><span class="params">(linklist head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    linklist p_cur = head-&gt;next;</span><br><span class="line">    linklist p_upc = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先将头结点与原链表断开，它将作为新链表的“锚点”</span></span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p_cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 1. 保存未来</span></span><br><span class="line">        p_upc = p_cur-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 反转当前 (头插法核心)</span></span><br><span class="line">        <span class="comment">//    让当前节点指向新链表的头 (即 head-&gt;next)</span></span><br><span class="line">        p_cur-&gt;next = head-&gt;next;</span><br><span class="line">        <span class="comment">//    更新新链表的头为当前节点</span></span><br><span class="line">        head-&gt;next = p_cur;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 前进迭代</span></span><br><span class="line">        p_cur = p_upc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="表达三递归法-时空转换的艺术"><a class="markdownIt-Anchor" href="#表达三递归法-时空转换的艺术"></a> <strong>表达三：递归法 (时空转换的艺术)</strong></h5><p>递归将迭代的循环逻辑转换为了函数调用栈的递进与回溯，代码极简，但对理解的要求更高。</p><ul><li><strong>递进 (Drill Down)</strong>: 函数不断调用自身，直到链表末尾。这个过程本身就“记住”了返回的路径。</li><li><strong>回溯 (Roll Back)</strong>: 从链表末尾开始，在每一层函数返回时，将当前层的节点指针反转。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 辅助递归函数</span></span><br><span class="line">linklist <span class="title function_">reverse_recursive_helper</span><span class="params">(linklist current)</span> &#123;</span><br><span class="line">    <span class="comment">// 基本情况：到达链表尾部，返回新的头节点</span></span><br><span class="line">    <span class="keyword">if</span> (current == <span class="literal">NULL</span> || current-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递进：假设后面的部分已经反转好，并拿到新头</span></span><br><span class="line">    linklist new_head = reverse_recursive_helper(current-&gt;next);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯时的操作：反转指针</span></span><br><span class="line">    current-&gt;next-&gt;next = current;</span><br><span class="line">    current-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverse_list_recursive</span><span class="params">(linklist head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    head-&gt;next = reverse_recursive_helper(head-&gt;next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>思维体操总结</strong></p><ul><li><strong>算法的“道”与“术”</strong>: 链表反转的“道”是管理好<code>Current</code>, <code>Reversed</code>, <code>Upcoming</code>三个状态。而迭代法、头插法、递归法则是实现这个“道”的不同“术”。</li><li><strong>没有“碰巧”的正确</strong>: 即使写出一个非主流但可行的算法，也绝非巧合，而是无意中构建了一套逻辑自洽的状态流转系统。理解其内在逻辑，比死记标准答案更有价值。</li><li><strong>代码是思想的投影</strong>: 同一个算法思想，可以有多种代码表达。探索这些不同表达方式的优劣和内在联系，是提升编程内功的关键。</li></ul></blockquote><h3 id="代码实战约瑟夫环"><a class="markdownIt-Anchor" href="#代码实战约瑟夫环"></a> 代码实战：约瑟夫环</h3><p>在掌握了链表的增删改查之后，约瑟夫环问题是另一个绝佳的综合性练习，它完美地融合了<strong>循环链表的构建</strong>与<strong>节点的规律性删除</strong>。</p><p><strong>问题描述</strong>：n 个人（编号 1 到 n）围成一个圈。从第 1 个人开始报数，报到 m 的那个人出列，他的下一个人又从 1 开始报数，报到 m 的那个人再次出列……如此循环，直到所有人出列。请找出最后一个出列的人，或者按顺序输出出列人的序列。</p><p>为了解决这个问题，<strong>单向循环链表</strong>是天然的数据结构。</p><h4 id="1-算法分析与实现"><a class="markdownIt-Anchor" href="#1-算法分析与实现"></a> 1. 算法分析与实现</h4><p>约瑟夫环的核心操作只有两步，循环往复：</p><ol><li><strong>“走”</strong>：从当前节点开始，向后移动 <code>m-1</code> 步，找到那个“倒霉蛋”的前一个节点。</li><li><strong>“删”</strong>：将“倒霉蛋”从环中移除，并释放其内存。</li></ol><p>算法持续进行，直到环中只剩下一个节点。</p><h4 id="2-c-语言代码实现"><a class="markdownIt-Anchor" href="#2-c-语言代码实现"></a> 2. C 语言代码实现</h4><p>下面是一个完整的、可编译的约瑟夫环问题解决方案。程序会要求输入总人数 <code>n</code> 和报数阈值 <code>m</code>，然后模拟整个过程。</p><p><strong><code>linklist.h</code> (头文件)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LINKLIST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LINKLIST_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表节点定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> data;           <span class="comment">// 节点数据 (人的编号)</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; listnode, *linklist;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line">linklist <span class="title function_">create_josephus_ring</span><span class="params">(<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">show_list</span><span class="params">(linklist head)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">solve_josephus</span><span class="params">(linklist head, <span class="type">int</span> m)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong><code>main.c</code> (主程序)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;linklist.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入总人数 n: &quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入报数阈值 m: &quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">1</span> || m &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入无效，人数和报数阈值必须大于0。\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 创建约瑟夫环</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n正在创建包含 %d 人的约瑟夫环...\n&quot;</span>, n);</span><br><span class="line">  linklist ring_head = create_josephus_ring(n);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;初始环: &quot;</span>);</span><br><span class="line">  show_list(ring_head);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 开始模拟并解决问题</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n开始淘汰过程 (报数为 %d 的人出列):\n&quot;</span>, m);</span><br><span class="line">  solve_josephus(ring_head, m);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>linklist.c</code> (函数实现)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;linklist.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个包含 n 个节点的单向循环链表 (约瑟夫环)</span></span><br><span class="line">linklist <span class="title function_">create_josephus_ring</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    linklist head = <span class="literal">NULL</span>, tail = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 创建新节点</span></span><br><span class="line">        linklist new_node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(listnode));</span><br><span class="line">        <span class="keyword">if</span> (new_node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;创建节点失败&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        new_node-&gt;data = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 第一个节点</span></span><br><span class="line">            head = new_node;</span><br><span class="line">            tail = new_node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 尾插法</span></span><br><span class="line">            tail-&gt;next = new_node;</span><br><span class="line">            tail = new_node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将链表头尾相连，形成环</span></span><br><span class="line">    tail-&gt;next = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历并打印循环链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_list</span><span class="params">(linklist head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;链表为空\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    linklist p = head;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (p != head);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决约瑟夫环问题</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">solve_josephus</span><span class="params">(linklist head, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 m=1，特殊处理，避免在原地打转</span></span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span>) &#123;</span><br><span class="line">        linklist p = head;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next != p) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d出列. &quot;</span>, p-&gt;data);</span><br><span class="line">            linklist temp = p-&gt;next;</span><br><span class="line">            <span class="comment">// 找到p的前一个节点</span></span><br><span class="line">            linklist prev = p;</span><br><span class="line">            <span class="keyword">while</span>(prev-&gt;next != p) prev = prev-&gt;next;</span><br><span class="line">            prev-&gt;next = p-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(p);</span><br><span class="line">            p = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n最后幸存者是: %d\n&quot;</span>, p-&gt;data);</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    linklist current = head;</span><br><span class="line">    <span class="keyword">while</span> (current-&gt;next != current) &#123; <span class="comment">// 循环直到只剩一个节点</span></span><br><span class="line">        <span class="comment">// 1. &quot;走&quot;: 找到被杀节点的前一个节点</span></span><br><span class="line">        <span class="comment">//    因为要找第 m 个，所以需要走 m-2 步 (从当前节点之后开始数)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. &quot;删&quot;: 删除目标节点</span></span><br><span class="line">        linklist kill_node = current-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d出列. &quot;</span>, kill_node-&gt;data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从环中移除</span></span><br><span class="line">        current-&gt;next = kill_node-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(kill_node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 更新下一次报数的起点</span></span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n最后幸存者是: %d\n&quot;</span>, current-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(current); <span class="comment">// 释放最后一个节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>约瑟夫环问题总结</strong></p><ul><li><strong>数据结构选择</strong>: 循环链表是该问题最直观、最自然的模型。</li><li><strong>算法核心</strong>: 关键在于定位到<strong>待删除节点的前一个节点</strong>，这是安全删除链表节点的通用法则。</li><li><strong>指针操作</strong>: 每次删除操作后，必须小心地更新当前指针（下一轮的起始点），确保逻辑链条不断裂。</li><li><strong>边界情况</strong>: 考虑 <code>n=1</code> 或 <code>m=1</code> 等特殊情况，能体现代码的健壮性。例如，当 <code>m=1</code> 时，每次都删除当前节点，指针移动的逻辑需要特别处理。</li></ul></blockquote><h1 id="三树形结构"><a class="markdownIt-Anchor" href="#三树形结构"></a> 三：树形结构</h1><p>二叉搜索树（BST）是利用树结构实现高效查找的典范。它的核心在于维持一个严格的有序性。</p><h2 id="5-二叉搜索树核心特性"><a class="markdownIt-Anchor" href="#5-二叉搜索树核心特性"></a> 5. 二叉搜索树核心特性</h2><ul><li><strong>定义</strong>: 对于树中任意节点，其<strong>左子树</strong>所有节点的值都<strong>小于</strong>该节点，其<strong>右子树</strong>所有节点的值都<strong>大于</strong>该节点。</li><li><strong>价值</strong>: 平均情况下，查找、插入、删除操作的时间复杂度均为 <strong>O(log n)</strong>，效率远超线性表的 O(n)。</li></ul><center><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="http://edu.yueqian.com.cn/group1/M00/04/89/wKgP3GCt8PiAD_zQAACL_g4P5r0780.png?token=null&ts=null" , width="450"></center><h2 id="6-难点攻克二叉树的删除操作"><a class="markdownIt-Anchor" href="#6-难点攻克二叉树的删除操作"></a> 6. 难点攻克：二叉树的删除操作</h2><p>BST 的插入相对简单，只需遵循规则找到空位即可。而删除操作则要复杂得多，因为它必须在删除节点后<strong>维持 BST 的有序性</strong>。</p><p><strong>删除节点 <code>x</code> 的三种情况分析：</strong></p><ol><li><strong><code>x</code> 是叶子节点</strong>: 最简单的情况，直接删除 <code>x</code>，并将其父节点的相应指针置为<code>NULL</code>。</li><li><strong><code>x</code> 只有一个子节点 (左或右)</strong>: 将 <code>x</code> 的父节点直接链接到 <code>x</code> 的唯一子节点上，然后释放 <code>x</code>。</li><li><strong><code>x</code> 有两个子节点</strong>: 这是最复杂的情况。不能简单删除，否则会断开其两棵子树。<ul><li><strong>解决策略</strong>: 在<code>x</code>的子树中找到一个合适的“替身”来取代<code>x</code>的位置。这个替身有两个选择：<ul><li><strong>前驱 (predecessor)</strong>: <code>x</code> 左子树中的最大值。</li><li><strong>后继 (successor)</strong>: <code>x</code> 右子树中的最小值。</li></ul></li><li><strong>操作步骤 (以后继为例)</strong>:<br>a. 在 <code>x</code> 的右子树中，一路向左，找到最小值节点 <code>s</code> (后继)。<br>b. 将 <code>s</code> 的值赋给 <code>x</code>。<br>c. 问题转化为<strong>在 <code>x</code> 的右子树中删除节点 <code>s</code></strong>。由于 <code>s</code> 是最小值，它最多只有一个右孩子，问题降级为情况 1 或情况 2。</li></ul></li></ol><p><strong>图解删除双子节点 (删除节点 8)</strong></p><p>假设我们要删除根节点 <code>8</code>：</p><center><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://image.skyforever.top/img/bst-delete-1.png" , width="500"><br><i>1. 目标：删除节点 8。</i></center><p>a. 找到 <code>8</code> 的后继：在右子树 <code>&#123;10, 14, 13&#125;</code> 中找到最小值，即 <code>10</code>。</p><center><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://image.skyforever.top/img/bst-delete-2.png" , width="500"><br><i>2. 找到后继节点 10。</i></center><p>b. 用后继 <code>10</code> 的值覆盖 <code>8</code>。</p><center><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://image.skyforever.top/img/bst-delete-3.png" , width="500"><br><i>3. 用后继的值覆盖待删除节点。</i></center><p>c. 在原右子树中删除后继 <code>10</code>。此时 <code>10</code> 的删除操作属于情况 2（它有一个右孩子 <code>14</code>），将其父节点(现在是新的根<code>10</code>)直接链接到其子节点 <code>14</code>。</p><center><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://image.skyforever.top/img/bst-delete-4.png" , width="500"><br><i>4. 递归删除后继节点，完成重构。</i></center><h3 id="代码实现二叉树删除"><a class="markdownIt-Anchor" href="#代码实现二叉树删除"></a> <strong>代码实现：二叉树删除</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; bstNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：查找子树中的最小值节点</span></span><br><span class="line">bstNode* <span class="title function_">findMin</span><span class="params">(bstNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (root-&gt;lchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root = root-&gt;lchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BST 删除函数</span></span><br><span class="line">bstNode* <span class="title function_">bstRemove</span><span class="params">(bstNode* root, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 基线条件：树为空或未找到</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 递归查找</span></span><br><span class="line">    <span class="keyword">if</span> (data &lt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;lchild = bstRemove(root-&gt;lchild, data);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data &gt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;rchild = bstRemove(root-&gt;rchild, data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 3. 找到了要删除的节点</span></span><br><span class="line">        <span class="comment">// 情况1: 叶子节点 或 情况2: 单子节点</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            bstNode *temp = root-&gt;rchild;</span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            bstNode *temp = root-&gt;lchild;</span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 情况3: 双子节点</span></span><br><span class="line">        <span class="comment">// 找到右子树的最小值 (后继)</span></span><br><span class="line">        bstNode *temp = findMin(root-&gt;rchild);</span><br><span class="line">        <span class="comment">// 用后继的值覆盖当前节点</span></span><br><span class="line">        root-&gt;data = temp-&gt;data;</span><br><span class="line">        <span class="comment">// 在右子树中递归删除那个后继节点</span></span><br><span class="line">        root-&gt;rchild = bstRemove(root-&gt;rchild, temp-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>[!WARNING] 二叉树的退化风险</strong><br>如果插入的数据是预先有序或基本有序的，BST 会退化成一个倾斜的链表，所有操作的性能将从 O(log n) 急剧下降到 O(n)。这正是**平衡二叉树（如 AVL 树、红黑树）**存在的意义。</p></blockquote><h1 id="四栈与队列"><a class="markdownIt-Anchor" href="#四栈与队列"></a> 四：栈与队列</h1><p>栈和队列虽然在操作上受到限制，但正是这种限制赋予了它们独特的“先进后出”(LIFO)和“先进先出”(FIFO)特性，使其成为解决特定问题的强大工具。</p><h2 id="7-栈"><a class="markdownIt-Anchor" href="#7-栈"></a> 7. 栈</h2><ul><li><strong>核心特性</strong>: <strong>后进先出 (Last-In, First-Out)</strong>。最后压入栈的元素，最先被弹出。</li><li><strong>应用场景</strong>:<ol><li><strong>函数调用与递归</strong>: 这是栈最经典的应用。每次函数调用，其上下文（参数、返回地址、局部变量）被压入一个系统维护的“调用栈”。函数返回时，从栈顶弹出其上下文。递归本质上是函数调用自身的特例。</li><li><strong>表达式求值</strong>: 将中缀表达式转换为后缀表达式（逆波兰表示法），然后使用栈进行求值。</li><li><strong>括号匹配</strong>: 遍历字符串，遇到左括号就入栈，遇到右括号就检查栈顶是否为匹配的左括号，若是则出栈，否则不匹配。</li><li><strong>深度优先搜索 (DFS)</strong>: 在图或树的遍历中，DFS 的递归实现天然利用了调用栈。其迭代实现则需要手动维护一个栈来存储待访问的节点。</li></ol></li></ul><h3 id="实战案例括号匹配"><a class="markdownIt-Anchor" href="#实战案例括号匹配"></a> <strong>实战案例：括号匹配</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单的链式栈实现</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; StackNode;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(StackNode** top, <span class="type">char</span> data)</span> &#123;</span><br><span class="line">    StackNode* newNode = (StackNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = *top;</span><br><span class="line">    *top = newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">pop</span><span class="params">(StackNode** top, <span class="type">char</span>* data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (*top == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    StackNode* temp = *top;</span><br><span class="line">    *data = temp-&gt;data;</span><br><span class="line">    *top = temp-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 核心匹配逻辑</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">areBracketsBalanced</span><span class="params">(<span class="type">char</span>* expr)</span> &#123;</span><br><span class="line">    StackNode* <span class="built_in">stack</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> popped_char;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(expr); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (expr[i] == <span class="string">&#x27;(&#x27;</span> || expr[i] == <span class="string">&#x27;[&#x27;</span> || expr[i] == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            push(&amp;<span class="built_in">stack</span>, expr[i]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果遇到右括号但栈为空，则不匹配</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">stack</span> == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (expr[i]) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                pop(&amp;<span class="built_in">stack</span>, &amp;popped_char);</span><br><span class="line">                <span class="keyword">if</span> (popped_char != <span class="string">&#x27;(&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">                pop(&amp;<span class="built_in">stack</span>, &amp;popped_char);</span><br><span class="line">                <span class="keyword">if</span> (popped_char != <span class="string">&#x27;[&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">                pop(&amp;<span class="built_in">stack</span>, &amp;popped_char);</span><br><span class="line">                <span class="keyword">if</span> (popped_char != <span class="string">&#x27;&#123;&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果遍历完，栈中还有剩余的左括号，则不匹配</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">stack</span> == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> expr1[] = <span class="string">&quot;&#123;()&#125;[]&quot;</span>;</span><br><span class="line">    <span class="type">char</span> expr2[] = <span class="string">&quot;([)]&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s is %s\n&quot;</span>, expr1, areBracketsBalanced(expr1) ? <span class="string">&quot;balanced&quot;</span> : <span class="string">&quot;not balanced&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s is %s\n&quot;</span>, expr2, areBracketsBalanced(expr2) ? <span class="string">&quot;balanced&quot;</span> : <span class="string">&quot;not balanced&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-队列-queuefifo-的应用"><a class="markdownIt-Anchor" href="#8-队列-queuefifo-的应用"></a> 8. 队列 (Queue)：FIFO 的应用</h2><ul><li><strong>核心特性</strong>: <strong>先进先出 (First-In, First-Out)</strong>。最先进入队列的元素，最先被移出。</li><li><strong>应用场景</strong>:<ol><li><strong>资源调度</strong>: 操作系统中的任务调度、打印机任务队列等，需要公平地处理请求，先到先服务。</li><li><strong>广度优先搜索 (BFS)</strong>: 在图或树的遍历中，BFS 使用队列来存储待访问的节点，保证按层级顺序进行访问。</li><li><strong>缓冲区 (Buffer)</strong>: 在生产者-消费者模型中，队列作为缓冲区，平衡生产者和消费者之间速度不匹配的问题。</li><li><strong>网络数据包排队</strong>: 路由器处理数据包时，通常将其放入队列中，按到达顺序转发。</li></ol></li></ul><h3 id="实战案例树的层序遍历-bfs"><a class="markdownIt-Anchor" href="#实战案例树的层序遍历-bfs"></a> <strong>实战案例：树的层序遍历 (BFS)</strong></h3><p>层序遍历是广度优先搜索在树上的直接应用，其核心就是队列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设已存在BST的节点定义 bstNode 和一个简单的队列实现</span></span><br><span class="line"><span class="comment">// queue.h (包含enQueue, deQueue, isQueueEmpty等函数)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">levelOrderTraversal</span><span class="params">(bstNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建一个队列并把根节点入队</span></span><br><span class="line">    Queue* q = createQueue();</span><br><span class="line">    enQueue(q, root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!isQueueEmpty(q)) &#123;</span><br><span class="line">        <span class="comment">// 2. 从队列中取出一个节点</span></span><br><span class="line">        bstNode* current = deQueue(q);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, current-&gt;data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 将该节点的非空子节点入队</span></span><br><span class="line">        <span class="keyword">if</span> (current-&gt;lchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            enQueue(q, current-&gt;lchild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;rchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            enQueue(q, current-&gt;rchild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="五排序算法"><a class="markdownIt-Anchor" href="#五排序算法"></a> 五：排序算法</h1><p>排序是计算机科学中最基础也最重要的操作之一。选择合适的排序算法对程序性能至关重要。</p><h2 id="9-快速排序"><a class="markdownIt-Anchor" href="#9-快速排序"></a> 9. 快速排序</h2><p>快速排序是实践中平均性能最好的排序算法，其精髓在于<strong>分治思想</strong>和高效的**分区（Partition）**操作。</p><h3 id="难点攻克partition函数的多种实现"><a class="markdownIt-Anchor" href="#难点攻克partition函数的多种实现"></a> <strong>难点攻克：<code>partition</code>函数的多种实现</strong></h3><p><code>partition</code>函数的目标是：选择一个基准（pivot），并将数组划分为两部分，使得左边的都小于等于基准，右边的都大于等于基准，最后返回基准的最终位置。</p><h4 id="实现一lomuto-分区方案-易于理解"><a class="markdownIt-Anchor" href="#实现一lomuto-分区方案-易于理解"></a> <strong>实现一：Lomuto 分区方案</strong> (易于理解)</h4><ul><li><strong>思路</strong>:<ol><li>选择最后一个元素作为<code>pivot</code>。</li><li>维护一个指针<code>i</code>，指向“小于等于<code>pivot</code>”区域的末尾。</li><li>遍历数组（除<code>pivot</code>外），如果发现元素<code>arr[j]</code>小于等于<code>pivot</code>，则将<code>i</code>后移一位，并交换<code>arr[i]</code>和<code>arr[j]</code>。</li><li>最后，将<code>pivot</code>（原<code>arr[high]</code>）与<code>arr[i+1]</code>交换。</li></ol></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lomuto partition scheme</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition_lomuto</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[high]; <span class="comment">// 选择最后一个元素为基准</span></span><br><span class="line">    <span class="type">int</span> i = (low - <span class="number">1</span>);     <span class="comment">// 小于等于pivot区域的边界</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = low; j &lt;= high - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt;= pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            swap(&amp;arr[i], &amp;arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(&amp;arr[i + <span class="number">1</span>], &amp;arr[high]);</span><br><span class="line">    <span class="keyword">return</span> (i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现二hoare-分区方案-原始方案效率更高"><a class="markdownIt-Anchor" href="#实现二hoare-分区方案-原始方案效率更高"></a> <strong>实现二：Hoare 分区方案</strong> (原始方案，效率更高)</h4><ul><li><strong>思路</strong>:<ol><li>选择第一个元素作为<code>pivot</code>。</li><li>使用两个指针<code>i</code>和<code>j</code>，分别从数组的两端向中间扫描。</li><li><code>i</code>向右扫描，直到找到一个大于<code>pivot</code>的元素。</li><li><code>j</code>向左扫描，直到找到一个小于<code>pivot</code>的元素。</li><li>交换<code>arr[i]</code>和<code>arr[j]</code>。</li><li>重复 3-5 步，直到<code>i</code>和<code>j</code>交错。</li></ol></li><li><strong>注意</strong>: Hoare 方案最后返回的<strong>不一定是</strong><code>pivot</code>的最终位置，而是划分的分界点。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hoare partition scheme</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition_hoare</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[low];</span><br><span class="line">    <span class="type">int</span> i = low - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> j = high + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 从左向右找第一个大于等于pivot的元素</span></span><br><span class="line">        <span class="keyword">do</span> &#123; i++; &#125; <span class="keyword">while</span> (arr[i] &lt; pivot);</span><br><span class="line">        <span class="comment">// 从右向左找第一个小于等于pivot的元素</span></span><br><span class="line">        <span class="keyword">do</span> &#123; j--; &#125; <span class="keyword">while</span> (arr[j] &gt; pivot);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果指针交错，则分区完成</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">return</span> j;</span><br><span class="line"></span><br><span class="line">        swap(&amp;arr[i], &amp;arr[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整的快速排序实现-使用-lomuto"><a class="markdownIt-Anchor" href="#完整的快速排序实现-使用-lomuto"></a> <strong>完整的快速排序实现 (使用 Lomuto)</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="comment">// pi 是分区后基准元素的索引</span></span><br><span class="line">        <span class="type">int</span> pi = partition_lomuto(arr, low, high);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归地对基准左右两边的子数组进行排序</span></span><br><span class="line">        quickSort(arr, low, pi - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, pi + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-归并排序"><a class="markdownIt-Anchor" href="#10-归并排序"></a> 10. 归并排序</h2><p>归并排序同样基于<strong>分治思想</strong>，但其核心操作是**归并（Merge）**而非分区。</p><ul><li><strong>核心思想</strong>:<ol><li><strong>分解 (Divide)</strong>: 将数组递归地对半切分，直到每个子数组只有一个元素（天然有序）。</li><li><strong>合并 (Conquer)</strong>: 将相邻的两个有序子数组合并成一个更大的有序数组。</li></ol></li></ul><h3 id="难点攻克merge函数的实现"><a class="markdownIt-Anchor" href="#难点攻克merge函数的实现"></a> <strong>难点攻克：<code>merge</code>函数的实现</strong></h3><p><code>merge</code>函数是归并排序的灵魂。它接收两个已排序的子数组，并将它们合并成一个单一的有序数组。</p><ul><li><strong>思路</strong>:<ol><li>创建临时数组来存储合并后的结果。</li><li>使用三个指针，<code>i</code>指向第一个子数组，<code>j</code>指向第二个子数组，<code>k</code>指向临时数组。</li><li>比较<code>arr[i]</code>和<code>arr[j]</code>，将较小的元素放入临时数组，并移动相应的指针。</li><li>重复此过程，直到一个子数组被完全处理。</li><li>将另一个子数组中剩余的元素全部复制到临时数组。</li><li>最后，将临时数组的内容复制回原数组。</li></ol></li></ul><h3 id="代码实现归并排序"><a class="markdownIt-Anchor" href="#代码实现归并排序"></a> <strong>代码实现：归并排序</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Merge two subarrays of arr[].</span></span><br><span class="line"><span class="comment">// First subarray is arr[l..m]</span></span><br><span class="line"><span class="comment">// Second subarray is arr[m+1..r]</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="type">int</span> n1 = m - l + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> n2 = r - m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建临时数组</span></span><br><span class="line">    <span class="type">int</span> L[n1], R[n2];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝数据到临时数组</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n1; i++) L[i] = arr[l + i];</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n2; j++) R[j] = arr[m + <span class="number">1</span> + j];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并临时数组回到原数组 arr[l..r]</span></span><br><span class="line">    i = <span class="number">0</span>; j = <span class="number">0</span>; k = l;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L[i] &lt;= R[j]) &#123;</span><br><span class="line">            arr[k++] = L[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arr[k++] = R[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝L[]中剩余的元素</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1) arr[k++] = L[i++];</span><br><span class="line">    <span class="comment">// 拷贝R[]中剩余的元素</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; n2) arr[k++] = R[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="comment">// 找到中点，避免 (l+r) 溢出</span></span><br><span class="line">        <span class="type">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归排序左右两半</span></span><br><span class="line">        mergeSort(arr, l, m);</span><br><span class="line">        mergeSort(arr, m + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并已排序的两半</span></span><br><span class="line">        merge(arr, l, m, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">特性对比</th><th style="text-align:left">快速排序</th><th style="text-align:left">归并排序</th></tr></thead><tbody><tr><td style="text-align:left"><strong>平均时间</strong></td><td style="text-align:left">O(n log n)</td><td style="text-align:left">O(n log n)</td></tr><tr><td style="text-align:left"><strong>最坏时间</strong></td><td style="text-align:left">O(n²) (需要优化)</td><td style="text-align:left"><strong>O(n log n)</strong></td></tr><tr><td style="text-align:left"><strong>空间复杂度</strong></td><td style="text-align:left">O(log n) (原地)</td><td style="text-align:left">O(n) (需额外空间)</td></tr><tr><td style="text-align:left"><strong>稳定性</strong></td><td style="text-align:left">不稳定</td><td style="text-align:left"><strong>稳定</strong></td></tr><tr><td style="text-align:left"><strong>适用场景</strong></td><td style="text-align:left">内部排序，对空间敏感</td><td style="text-align:left">外部排序，对稳定性有要求</td></tr></tbody></table><h1 id="六查找算法"><a class="markdownIt-Anchor" href="#六查找算法"></a> 六：查找算法</h1><p>查找（Search），是在数据集合中寻找特定元素的过程。看似简单的操作，在面对海量数据时，其效率直接决定了系统的响应速度和用户体验。不同的数据组织方式，催生了截然不同的查找策略。</p><h2 id="12-顺序查找最朴素的策略"><a class="markdownIt-Anchor" href="#12-顺序查找最朴素的策略"></a> 12. 顺序查找：最朴素的策略</h2><ul><li><strong>思想</strong>: 从数据集合的第一个元素开始，逐一向后比对，直到找到目标或遍历完所有元素。这是一种“地毯式搜索”。</li><li><strong>时间复杂度</strong>: <strong>O(n)</strong>。在最坏情况下，需要检查集合中的每一个元素。</li><li><strong>适用场景</strong>:<ol><li><strong>数据无序且无法排序</strong>: 当数据本身是杂乱无章的，且没有条件或必要去排序时，顺序查找是唯一的选择。</li><li><strong>数据量极小</strong>: 当 n 非常小时，O(n)的开销可以忽略不计，简单的顺序查找因其实现简单而成为首选。</li><li><strong>链式存储结构</strong>: 对于单向链表，由于其不支持随机访问，通常也只能采用顺序查找。</li></ol></li></ul><blockquote><p><strong>[info] 工程视角</strong></p><p>不要轻视顺序查找。在很多嵌入式系统或对代码尺寸有严格要求的场景中，如果数据量可控，一个简单、无依赖的<code>for</code>循环远比引入复杂的查找结构更具优势。<strong>“简单”本身就是一种强大的工程美学</strong>。</p></blockquote><h2 id="13-二分查找-binary-search有序世界的利器"><a class="markdownIt-Anchor" href="#13-二分查找-binary-search有序世界的利器"></a> 13. 二分查找 (Binary Search)：有序世界的利器</h2><p>当数据集合<strong>有序</strong>且支持<strong>随机访问</strong>（如数组）时，二分查找展现出惊人的威力。</p><ul><li><strong>思想</strong>: 通过不断将搜索区间<strong>折半</strong>，以对数级的速度逼近目标。每比较一次，就能排除掉一半的不可能选项。</li></ul><center><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://image.skyforever.top/img/binary-search-animated.gif" width="500"><br><i>二分查找动态过程</i></center><ul><li><strong>时间复杂度</strong>: <strong>O(log n)</strong>。对于 100 万个数据，最多只需 20 次比较；对于 10 亿个数据，也仅需约 30 次。</li></ul><h3 id="难点攻克二分查找的魔鬼细节与鲁棒实现"><a class="markdownIt-Anchor" href="#难点攻克二分查找的魔鬼细节与鲁棒实现"></a> <strong>难点攻克：二分查找的“魔鬼细节”与鲁棒实现</strong></h3><p>二分查找的原理简单，但完美实现却充满陷阱。高德纳（Donald Knuth）曾说：“虽然二分查找的基本思想相对简单，但细节可以非常棘手……第一个正确的二分查找算法在 1946 年就已出现，但第一个没有错误的实现直到 1962 年才发表。”</p><p><strong>常见的陷阱：</strong></p><ol><li><strong>整数溢出</strong>: 计算中点时，<code>mid = (low + high) / 2</code> 在<code>low</code>和<code>high</code>都很大时可能导致它们的和溢出。</li><li><strong>死循环</strong>: 当区间更新逻辑不当时（如 <code>low = mid</code> 或 <code>high = mid</code>），在特定边界条件下可能导致搜索区间无法缩小，陷入死循环。</li><li><strong>边界条件处理</strong>: 循环的终止条件是<code>low &lt; high</code>还是<code>low &lt;= high</code>？区间更新是<code>high = mid</code>还是<code>high = mid - 1</code>？这些微小的差异决定了算法的正确性。</li></ol><h3 id="实战代码一个健壮的二分查找模板"><a class="markdownIt-Anchor" href="#实战代码一个健壮的二分查找模板"></a> <strong>实战代码：一个健壮的二分查找模板</strong></h3><p>这个模板通过精巧的边界设计，可以清晰地处理“查找特定值”、“查找第一个大于/等于某值的位置”等多种变体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在一个升序数组中进行二分查找</span></span><br><span class="line"><span class="comment"> * @param arr 有序数组</span></span><br><span class="line"><span class="comment"> * @param len 数组长度</span></span><br><span class="line"><span class="comment"> * @param target 要查找的目标值</span></span><br><span class="line"><span class="comment"> * @return 如果找到，返回目标值的索引；如果未找到，返回-1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">NULL</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> high = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环条件: low &lt;= high</span></span><br><span class="line">    <span class="comment">// 当 low == high 时，区间还有一个元素，需要检查。</span></span><br><span class="line">    <span class="comment">// 当 low &gt; high 时，区间为空，查找结束。</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="comment">// 防止溢出的中点计算方式</span></span><br><span class="line">        <span class="type">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid; <span class="comment">// 找到了！</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">            <span class="comment">// 目标在右半部分，mid已经被检查过，所以新区间从 mid + 1 开始</span></span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// arr[mid] &gt; target</span></span><br><span class="line">            <span class="comment">// 目标在左半部分，mid已经被检查过，所以新区间到 mid - 1 结束</span></span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环结束，low &gt; high，说明未找到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sorted_array[] = &#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">16</span>, <span class="number">23</span>, <span class="number">38</span>, <span class="number">56</span>, <span class="number">72</span>, <span class="number">91</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(sorted_array) / <span class="keyword">sizeof</span>(sorted_array[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> target1 = <span class="number">23</span>;</span><br><span class="line">    <span class="type">int</span> target2 = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> index1 = binarySearch(sorted_array, n, target1);</span><br><span class="line">    <span class="type">int</span> index2 = binarySearch(sorted_array, n, target2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index1 != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Target %d found at index: %d\n&quot;</span>, target1, index1);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Target %d not found.\n&quot;</span>, target1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index2 != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Target %d found at index: %d\n&quot;</span>, target2, index2);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Target %d not found.\n&quot;</span>, target2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>[info] 模板分析</strong></p><ul><li><strong>循环条件 <code>low &lt;= high</code></strong>: 保证了当搜索区间缩至单个元素时，该元素仍能被检查。</li><li><strong>区间更新 <code>low = mid + 1</code> 和 <code>high = mid - 1</code></strong>: 确保每次循环都至少排除<code>mid</code>本身，从而保证了区间的严格缩小，避免死循环。</li></ul></blockquote><h2 id="14-分块查找空间换时间的折中艺术"><a class="markdownIt-Anchor" href="#14-分块查找空间换时间的折中艺术"></a> 14. 分块查找：空间换时间的折中艺术</h2><p>在无法对全部数据进行完全排序，但可以进行宏观分组的场景下，分块查找提供了一种优雅的性能提升方案。</p><ul><li><strong>思想</strong>: <strong>分块 + 索引</strong>。将大数据集分割成若干“块”，为这些块建立一个“索引表”。</li></ul><center><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="http://edu.yueqian.com.cn/group1/M00/05/F7/wKgP3GD8CTWARY-fAACKyv3-Dyo313.PNG?token=null&ts=null" width="200"> <span style="font-size:3em;vertical-align:middle;margin:0 20px">➡️</span> <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://image.skyforever.top/img/block-search.png" width="400"><br><i>从字典的部首检字法到分块查找</i></center><ul><li><p><strong>结构</strong>:</p><ol><li><strong>数据块</strong>: 原始数据被划分为连续的块。<strong>块内元素可以无序，但块间必须有序</strong>（例如，第 i+1 块的所有元素都大于第 i 块的所有元素）。</li><li><strong>索引表</strong>: 一个小数组，每个条目对应一个数据块，存储该块的<strong>关键信息</strong>（通常是块内最大值）和<strong>起始地址/索引</strong>。</li></ol></li><li><p><strong>查找过程</strong>:</p><ol><li><strong>第一步：在索引表中查找</strong>。由于索引表本身是有序且数据量小，可以使用二分查找（或顺序查找）快速定位目标值可能所在的块。</li><li><strong>第二步：在数据块内查找</strong>。进入定位到的数据块，在块内进行顺序查找。</li></ol></li><li><p><strong>性能分析</strong>: 设数据总量为<code>n</code>，分为<code>b</code>块，则每块大小为<code>n/b</code>。索引查找时间为<code>O(log b)</code>（用二分法），块内查找时间为<code>O(n/b)</code>。总时间复杂度为 <strong>O(log b + n/b)</strong>。通过调整块的数量<code>b</code>，可以在时间和空间（索引表大小）之间找到平衡点。当<code>b = sqrt(n)</code>时，可以取得较好的理论性能。</p></li></ul><h3 id="工程价值与适用场景"><a class="markdownIt-Anchor" href="#工程价值与适用场景"></a> <strong>工程价值与适用场景</strong></h3><p>分块查找的真正价值在于它对数据<strong>容忍了一定程度的无序</strong>，非常适合处理<strong>动态变化</strong>的数据集。</p><ul><li><strong>场景</strong>: 数据库索引。数据库的表数据在物理上可能不是完全有序的（因为增删改），但数据库会维护一个 B+树索引（一种高级的多路分块结构）。查找时，先通过索引快速定位到包含目标数据的数据页（块），然后再在数据页内查找。这使得在海量动态数据中进行高效查找成为可能。</li><li><strong>优点</strong>: 在插入新数据时，只需找到对应的块并插入，无需像维护一个完全有序数组那样移动大量数据。它在<strong>查找效率</strong>和<strong>维护成本</strong>之间取得了出色的平衡。</li></ul><h2 id="15-哈希查找-o1-的理想与现实"><a class="markdownIt-Anchor" href="#15-哈希查找-o1-的理想与现实"></a> 15. 哈希查找 ：O(1) 的理想与现实</h2><p>前面所有查找算法，都离不开“比较”。而哈希查找另辟蹊径，试图通过一次计算就直接定位到数据。</p><ul><li><p><strong>思想</strong>:</p><ol><li><strong>哈希函数 (Hash Function)</strong>: 设计一个函数 <code>h(key)</code>，它能将任意的关键字<code>key</code>映射到一个固定范围的整数，这个整数就是数据在哈希表（通常是一个数组）中的存储位置（索引）。</li><li><strong>哈希表 (Hash Table)</strong>: 一个数组，用于存储数据。</li><li><strong>查找</strong>: 当要查找一个<code>key</code>时，只需计算 <code>index = h(key)</code>，然后直接访问哈希表的 <code>index</code> 位置即可。</li></ol></li><li><p><strong>时间复杂度</strong>: 理想情况下，每次查找只需一次哈希计算和一次数组访问，时间复杂度为 <strong>O(1)</strong>。</p></li></ul><h3 id="难点攻克哈希冲突"><a class="markdownIt-Anchor" href="#难点攻克哈希冲突"></a> <strong>难点攻克：哈希冲突</strong></h3><p>理想是丰满的，现实是骨感的。不同的<code>key</code>通过哈希函数可能会计算出相同的<code>index</code>，这就是<strong>哈希冲突</strong>。</p><ul><li><strong>例子</strong>: <code>h(key) = key % 10</code>。<code>h(12)</code> 和 <code>h(22)</code> 都会得到索引 <code>2</code>。</li></ul><p><strong>解决冲突的常用方法：</strong></p><ol><li><strong>开放定址法 (Open Addressing)</strong>: 如果计算出的位置已被占用，就按照某种规则（线性探测、二次探测等）去寻找下一个空位。</li><li><strong>链地址法 (Chaining)</strong>: <strong>（最常用）<strong>哈希表的每个位置不再是单个元素，而是一个</strong>链表的头指针</strong>。所有哈希到同一位置的元素，都以节点的形式挂载到这个链表上。查找时，先计算哈希值定位到链表，再在链表上进行顺序查找。</li></ol><center><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://image.skyforever.top/img/hash-table-chaining.png" width="500"><br><i>链地址法解决哈希冲突</i></center><h3 id="性能总结与对比"><a class="markdownIt-Anchor" href="#性能总结与对比"></a> <strong>性能总结与对比</strong></h3><table><thead><tr><th style="text-align:left">查找算法</th><th style="text-align:left">数据要求</th><th style="text-align:left">平均时间复杂度</th><th style="text-align:left">最坏时间复杂度</th><th style="text-align:left">空间复杂度</th></tr></thead><tbody><tr><td style="text-align:left">顺序查找</td><td style="text-align:left">无</td><td style="text-align:left">O(n)</td><td style="text-align:left">O(n)</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">二分查找</td><td style="text-align:left"><strong>有序, 随机访问</strong></td><td style="text-align:left"><strong>O(log n)</strong></td><td style="text-align:left">O(log n)</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">分块查找</td><td style="text-align:left">块间有序</td><td style="text-align:left">O(log b + n/b)</td><td style="text-align:left">O(log b + n/b)</td><td style="text-align:left">O(b)</td></tr><tr><td style="text-align:left">哈希查找</td><td style="text-align:left">无</td><td style="text-align:left"><strong>O(1)</strong></td><td style="text-align:left">O(n) (全冲突)</td><td style="text-align:left">O(n)</td></tr></tbody></table><blockquote><p><strong>最终洞察</strong>:</p><ul><li><strong>没有最好的算法，只有最合适的算法</strong>。</li><li><strong>二分查找</strong>是静态有序数据集的王者。</li><li><strong>哈希查找</strong>是追求极致查询速度（尤其是动态数据集）的首选，但以额外的空间和哈希函数设计为代价。</li><li><strong>分块查找</strong>和其衍生（如 B 树）是在查找效率和动态维护成本之间寻求平衡的工程典范，是大型数据库和文件系统的基石。</li></ul></blockquote><div class="tag-list"><a class="tag" href="/note/ES/tags/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">基础/数据结构与算法</a></div></article><div class="article-footer"><section id="license"><div class="header"><span>许可协议</span></div><div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p></div></section><section id="share"><div class="header"><span>分享文章</span></div><div class="body"><div class="link"><input class="copy-area" readonly id="copy-link" value="http://skyforever.top/data/ES/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0"></div><div class="social-wrap dis-select"><a class="social share-item wechat" onclick="util.toggle(&quot;qrcode-wechat&quot;)"><img src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/b32ef3da1162a.svg"></a><a class="social share-item weibo" target="_blank" rel="external nofollow noopener noreferrer" href="https://service.weibo.com/share/share.php?url=http://skyforever.top/data/ES/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0&title=数据结构与算法笔记 - Sky Blog&summary=数据结构与算法复习笔记，涵盖从基础复杂度分析、线性表、栈、队列到树、排序和查找等核心内容，注重理论与C语言代码实战结合。"><img src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/80c07e4dbb303.svg"></a><a class="social share-item email" href="mailto:?subject=数据结构与算法笔记 - Sky Blog&amp;body=http://skyforever.top/data/ES/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0"><img src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/a1b00e20f425d.svg"></a><a class="social share-item link" onclick="util.copy(&quot;copy-link&quot;, &quot;复制成功&quot;)"><img src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/8411ed322ced6.svg"></a></div><div class="qrcode" id="qrcode-wechat" style="opacity:0;height:0"><img src="https://api.qrserver.com/v1/create-qr-code/?size=256x256&data=http://skyforever.top/data/ES/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0"></div></div></section></div><div class="related-wrap md-text" id="comments"><section class="header cmt-title cap theme"><p>快来参与讨论吧~</p></section><section class="body cmt-body giscus"><svg class="loading" style="vertical-align:middle;fill:currentColor;overflow:hidden" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg><div id="giscus" src="https://giscus.app/client.js" data-repo="zhangwei43721/zhangwei43721.github.io" data-repo-id="R_kgDOOC101w" data-category="Announcements" data-category-id="DIC_kwDOOC10184Cv2Lm" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous"></div></section></div><footer class="page-footer footnote"><hr><div class="text"><p>本站由 <a href="/">Skyforever</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.33.1">Stellar 1.33.1</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p></div></footer><div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right"><div class="widgets"><widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-text">一：基础入门与算法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-text">1. 核心概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-text">2. 算法性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">空间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E7%A9%BA%E4%BA%92%E6%8D%A2"><span class="toc-text">时空互换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-text">二：线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span class="toc-text">3. 顺序表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%93%BE%E8%A1%A8"><span class="toc-text">4. 链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%BC%95%E5%85%A5%E4%B8%BA%E4%BB%80%E4%B9%88%E6%99%AE%E9%80%9A%E9%93%BE%E8%A1%A8%E4%B8%8D%E5%A4%9F%E7%94%A8"><span class="toc-text">问题引入：为什么普通链表不够用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6linux-%E5%86%85%E6%A0%B8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%95%B0%E6%8D%AE%E4%B8%8E%E9%80%BB%E8%BE%91%E5%88%86%E7%A6%BB"><span class="toc-text">设计哲学：Linux 内核的解决方案——数据与逻辑分离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%BE%E7%82%B9%E6%94%BB%E5%85%8B%E5%A6%82%E4%BD%95%E4%BB%8E%E9%93%BE%E6%89%BE%E5%88%B0%E6%95%B0%E6%8D%AE"><span class="toc-text">难点攻克：如何从“链”找到“数据”？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98%E4%BD%BF%E7%94%A8%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8%E7%AE%A1%E7%90%86%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF"><span class="toc-text">代码实战：使用内核链表管理学生信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC"><span class="toc-text">代码实战：单链表的反转</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A0%B8%E5%BF%83%E6%8C%91%E6%88%98"><span class="toc-text">1. 核心挑战</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%AE%97%E6%B3%95%E6%9C%AC%E8%B4%A8-%E4%B8%89%E4%B8%AA%E8%81%8C%E8%B4%A3%E7%9A%84%E6%B5%81%E8%BD%AC"><span class="toc-text">2. 算法本质 - 三个职责的流转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%80%9D%E6%83%B3%E7%9A%84%E5%A4%9A%E7%A7%8D%E4%BB%A3%E7%A0%81%E8%A1%A8%E8%BE%BE"><span class="toc-text">3. 思想的多种代码表达</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E4%B8%80%E6%A0%87%E5%87%86%E4%B8%89%E6%8C%87%E9%92%88%E8%BF%AD%E4%BB%A3%E6%B3%95-%E6%95%99%E7%A7%91%E4%B9%A6%E5%BC%8F"><span class="toc-text">表达一：标准三指针迭代法 (教科书式)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E4%BA%8C%E5%A4%B4%E6%8F%92%E6%B3%95-%E5%B7%A7%E5%A6%99%E5%88%A9%E7%94%A8%E5%A4%B4%E7%BB%93%E7%82%B9"><span class="toc-text">表达二：头插法 (巧妙利用头结点)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E4%B8%89%E9%80%92%E5%BD%92%E6%B3%95-%E6%97%B6%E7%A9%BA%E8%BD%AC%E6%8D%A2%E7%9A%84%E8%89%BA%E6%9C%AF"><span class="toc-text">表达三：递归法 (时空转换的艺术)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF"><span class="toc-text">代码实战：约瑟夫环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-text">1. 算法分析与实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-c-%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">2. C 语言代码实现</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84"><span class="toc-text">三：树形结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="toc-text">5. 二叉搜索树核心特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E9%9A%BE%E7%82%B9%E6%94%BB%E5%85%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-text">6. 难点攻克：二叉树的删除操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%A0%E9%99%A4"><span class="toc-text">代码实现：二叉树删除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97"><span class="toc-text">四：栈与队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%A0%88"><span class="toc-text">7. 栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D"><span class="toc-text">实战案例：括号匹配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E9%98%9F%E5%88%97-queuefifo-%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">8. 队列 (Queue)：FIFO 的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-bfs"><span class="toc-text">实战案例：树的层序遍历 (BFS)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-text">五：排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-text">9. 快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%BE%E7%82%B9%E6%94%BB%E5%85%8Bpartition%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%AE%9E%E7%8E%B0"><span class="toc-text">难点攻克：partition函数的多种实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80lomuto-%E5%88%86%E5%8C%BA%E6%96%B9%E6%A1%88-%E6%98%93%E4%BA%8E%E7%90%86%E8%A7%A3"><span class="toc-text">实现一：Lomuto 分区方案 (易于理解)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BA%8Choare-%E5%88%86%E5%8C%BA%E6%96%B9%E6%A1%88-%E5%8E%9F%E5%A7%8B%E6%96%B9%E6%A1%88%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98"><span class="toc-text">实现二：Hoare 分区方案 (原始方案，效率更高)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E7%9A%84%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0-%E4%BD%BF%E7%94%A8-lomuto"><span class="toc-text">完整的快速排序实现 (使用 Lomuto)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">10. 归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%BE%E7%82%B9%E6%94%BB%E5%85%8Bmerge%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">难点攻克：merge函数的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">代码实现：归并排序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-text">六：查找算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E6%9C%80%E6%9C%B4%E7%B4%A0%E7%9A%84%E7%AD%96%E7%95%A5"><span class="toc-text">12. 顺序查找：最朴素的策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-binary-search%E6%9C%89%E5%BA%8F%E4%B8%96%E7%95%8C%E7%9A%84%E5%88%A9%E5%99%A8"><span class="toc-text">13. 二分查找 (Binary Search)：有序世界的利器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%BE%E7%82%B9%E6%94%BB%E5%85%8B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E9%AD%94%E9%AC%BC%E7%BB%86%E8%8A%82%E4%B8%8E%E9%B2%81%E6%A3%92%E5%AE%9E%E7%8E%B0"><span class="toc-text">难点攻克：二分查找的“魔鬼细节”与鲁棒实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E4%BB%A3%E7%A0%81%E4%B8%80%E4%B8%AA%E5%81%A5%E5%A3%AE%E7%9A%84%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF"><span class="toc-text">实战代码：一个健壮的二分查找模板</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE%E7%A9%BA%E9%97%B4%E6%8D%A2%E6%97%B6%E9%97%B4%E7%9A%84%E6%8A%98%E4%B8%AD%E8%89%BA%E6%9C%AF"><span class="toc-text">14. 分块查找：空间换时间的折中艺术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E7%A8%8B%E4%BB%B7%E5%80%BC%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">工程价值与适用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E5%93%88%E5%B8%8C%E6%9F%A5%E6%89%BE-o1-%E7%9A%84%E7%90%86%E6%83%B3%E4%B8%8E%E7%8E%B0%E5%AE%9E"><span class="toc-text">15. 哈希查找 ：O(1) 的理想与现实</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%BE%E7%82%B9%E6%94%BB%E5%85%8B%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81"><span class="toc-text">难点攻克：哈希冲突</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AF%B9%E6%AF%94"><span class="toc-text">性能总结与对比</span></a></li></ol></li></ol></li></ol></div><div class="widget-footer"><a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="1.5"><path stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/><path d="M7 3.338A9.95 9.95 0 0 1 12 2c5.523 0 10 4.477 10 10s-4.477 10-10 10S2 17.523 2 12c0-1.821.487-3.53 1.338-5"/></g></svg><span>回到顶部</span></a><a class="buttom" onclick="util.scrollComment()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="1.5" d="M8 10.5h8M8 14h5.5M17 3.338A9.95 9.95 0 0 0 12 2C6.477 2 2 6.477 2 12c0 1.6.376 3.112 1.043 4.453c.178.356.237.763.134 1.148l-.595 2.226a1.3 1.3 0 0 0 1.591 1.592l2.226-.596a1.63 1.63 0 0 1 1.149.133A9.96 9.96 0 0 0 12 22c5.523 0 10-4.477 10-10c0-1.821-.487-3.53-1.338-5"/></svg><span>参与讨论</span></a></div></widget></div></aside><div class="float-panel"><button type="button" style="display:none" class="laptop-only rightbar-toggle mobile" onclick="sidebar.rightbar()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></button> <button type="button" style="display:none" class="mobile-only leftbar-toggle mobile" onclick="sidebar.leftbar()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg></button></div></div><div class="scripts"><script>window.canonical={originalHost:null,officialHosts:["localhost"],encoded:""};let ctx={date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前"},root:"/",tag_plugins:{chat:Object.assign({api:"https://siteinfo.listentothewind.cn/api/v1"})},search:{}};if((ctx.search.service="local_search")==ctx.search.service){let e=Object.assign({},'{"field":"all","path":"/search.json","content":true,"skip_search":null,"sort":"-date"}');ctx.search[ctx.search.service]=e}let def={avatar:"https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg",cover:"https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg",loading:"https://api.iconify.design/eos-icons:three-dots-loading.svg?color=%231cd0fd"},deps={jquery:"https://gcore.jsdelivr.net/npm/jquery@3.7/dist/jquery.min.js",marked:"https://gcore.jsdelivr.net/npm/marked@13.0/lib/marked.umd.min.js",lazyload:"/%5Bobject%20Object%5D"}</script><script>function RunItem(){function o(e,t){this.name=t||e.name,this.run=()=>{try{e()}catch(e){console.log(e)}}}this.list=[],this.start=()=>{for(var e=0;e<this.list.length;e++)this.list[e].run()},this.push=(e,t,r=!0)=>{let i=e,s=new o(i=r?()=>{utils.requestAnimationFrame(e)}:i,t);this.list.push(s)},this.remove=t=>{for(let e=0;e<this.list.length;e++)this.list[e].name==t&&this.list.splice(e,1)}}let utils={css:(e,t,r,i)=>{var s,o,a=window.document,n=a.createElement("link"),l=(o=t||(s=(a.body||a.getElementsByTagName("head")[0]).childNodes)[s.length-1],a.styleSheets);if(i)for(var d in i)i.hasOwnProperty(d)&&n.setAttribute(d,i[d]);n.rel="stylesheet",n.href=e,n.media="only x",function e(t){if(a.body)return t();setTimeout(function(){e(t)})}(function(){o.parentNode.insertBefore(n,t?o:o.nextSibling)});function u(e){for(var t=n.href,r=l.length;r--;)if(l[r].href===t)return e();setTimeout(function(){u(e)})}function h(){n.addEventListener&&n.removeEventListener("load",h),n.media=r||"all"}return n.addEventListener&&n.addEventListener("load",h),n.onloadcssdefined=u,u(h),n},js:(s,o)=>new Promise((t,e)=>{var r=document.createElement("script");if(s.startsWith("/")&&(s=ctx.root+s.substring(1)),r.src=s,o)for(var i of Object.keys(o))r[i]=o[i];else r.async=!0;r.onerror=e,r.onload=r.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(r.onload=r.onreadystatechange=null,t())},document.head.appendChild(r)}),jq:e=>{"undefined"==typeof jQuery?utils.js(deps.jquery).then(e):e()},onLoading:e=>{e&&$(e).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>')},onLoadSuccess:e=>{e&&$(e).find(".loading-wrap").remove()},onLoadFailure:e=>{e&&($(e).find(".loading-wrap svg").remove(),$(e).find(".loading-wrap").append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>'),$(e).find(".loading-wrap").addClass("error"))},request:(a,e,n,l)=>{let d=0;return new Promise((i,s)=>{let o=()=>{utils.onLoading?.(a);let t=!1,r=setTimeout(()=>{t=!0,console.warn("[request] 超时:",e),3<=++d?(utils.onLoadFailure?.(a),l?.(),s("请求超时")):setTimeout(o,1e3)},5e3);fetch(e).then(e=>{if(!t){if(clearTimeout(r),e.ok)return e;throw new Error("响应失败")}}).then(e=>{t||(utils.onLoadSuccess?.(a),n(e),i(e))}).catch(e=>{clearTimeout(r),console.warn("[request] 错误:",e),3<=++d?(utils.onLoadFailure?.(a),l?.(),s(e)):setTimeout(o,1e3)})};o()})},requestWithoutLoading:(e,a={},n=2,l=5e3)=>new Promise((r,i)=>{let s=0,o=()=>{let t=setTimeout(()=>{++s>n?i("timeout"):o()},l);fetch(e,a).then(e=>{if(clearTimeout(t),!e.ok)throw new Error("bad response");r(e)}).catch(e=>{clearTimeout(t),++s>n?i(e):setTimeout(o,500)})};o()}),requestAnimationFrame:e=>{window.requestAnimationFrame||(window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame),window.requestAnimationFrame(e)},dark:{}};utils.dark.method={toggle:new RunItem},utils.dark=Object.assign(utils.dark,{push:utils.dark.method.toggle.push})</script><script>let sidebar={leftbar:()=>{l_body&&(l_body.toggleAttribute("leftbar"),l_body.removeAttribute("rightbar"))},rightbar:()=>{l_body&&(l_body.toggleAttribute("rightbar"),l_body.removeAttribute("leftbar"))},dismiss:()=>{l_body&&(l_body.removeAttribute("leftbar"),l_body.removeAttribute("rightbar"))},toggleTOC:()=>{document.querySelector("#data-toc").classList.toggle("collapse")}}</script><script>(()=>{var e;for(e of document.querySelectorAll(".tag-subtree.parent-tag > a > .tag-switcher-wrapper"))e.addEventListener("click",e=>{e.target.closest(".tag-subtree.parent-tag").classList.toggle("expanded"),e.preventDefault()});var t=new URLSearchParams(window.location.search).get("tag");if(t){let e=document.querySelector(`.tag-subtree[data-tag="${t}"]`);if(e)for(e.querySelector("a").classList.add("active");e;)e.classList.add("expanded"),e=e.parentElement.closest(".tag-subtree.parent-tag")}})()</script><script async src="https://gcore.jsdelivr.net/npm/vanilla-lazyload@19.1/dist/lazyload.min.js"></script><script>window.lazyLoadOptions={elements_selector:".lazy",callback_loaded:e=>{e.classList.add("loaded");e=e.closest(".lazy-box")?.querySelector(".lazy-icon");e&&e.remove()}},window.addEventListener("LazyLoad::Initialized",function(e){window.lazyLoadInstance=e.detail.instance},!1),document.addEventListener("DOMContentLoaded",function(){window.lazyLoadInstance?.update()}),window.wrapLazyloadImages=e=>{(e="string"==typeof e?document.querySelector(e):e)&&(e.querySelectorAll("img").forEach(e=>{var a,t,d;e.classList.contains("lazy")||(d=e.getAttribute("src"))&&((a=document.createElement("div")).className="lazy-box",(t=e.cloneNode()).removeAttribute("src"),t.setAttribute("data-src",d),t.classList.add("lazy"),(d=document.createElement("div")).className="lazy-icon",def.loading&&(d.style.backgroundImage=`url("${def.loading}")`),a.appendChild(t),a.appendChild(d),e.replaceWith(a))}),window.lazyLoadInstance?.update)&&window.lazyLoadInstance.update()}</script><script src="/js/main.js?v=1.33.1" defer></script><script>let applyTheme=e=>{"auto"===e?document.documentElement.removeAttribute("data-theme"):document.documentElement.setAttribute("data-theme",e)},applyThemeToGiscus=e=>{var t=document.getElementById("giscus"),t=(t&&t.setAttribute("data-theme",e),document.querySelector("#comments > section.giscus > iframe"));t&&(e=t.src.replace(/theme=[\w]+/,"theme="+e),t.src=e)},switchTheme=()=>{let e;switch(document.documentElement.getAttribute("data-theme")){case"light":e="dark";break;case"dark":e="auto";break;default:e="light"}applyTheme(e),window.localStorage.setItem("Stellar.theme",e),utils.dark.mode="auto"===e?window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light":e,utils.dark.method.toggle.start(),hud?.toast?.({light:"切换到浅色模式",dark:"切换到深色模式",auto:"切换到跟随系统配色"}[e])};(()=>{var e=window.localStorage.getItem("Stellar.theme");null!==e?applyTheme(e):utils.dark.mode=window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light",utils.dark.method.toggle.start()})()</script><script type="module">const el = document.querySelector('#comments #giscus');
  util.viewportLazyload(el, load_discus, false);

  function load_discus() {
    if (!el) return;
    try {
        el.innerHTML = '';
      } catch (error) {
        console.error(error);
      }
      const script = document.createElement('script');
      script.async = true;
      for (const key of Object.keys(el.attributes)) {
        const attr = el.attributes[key];
        if (['class', 'id'].includes(attr.name) === false) {
          script.setAttribute(attr.name, attr.value);
        }
      }
      el.appendChild(script);
  }</script><script defer>window.addEventListener("DOMContentLoaded",e=>{ctx.services=Object.assign({},JSON.parse('{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"rating":{"js":"/js/services/rating.js","api":"https://star-vote.xaox.cc/api/rating"},"vote":{"js":"/js/services/vote.js","api":"https://star-vote.xaox.cc/api/vote"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"friends_and_posts":{"js":"/js/services/friends_and_posts.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"},"voice":{"js":"/js/plugins/voice.js"},"video":{"js":"/js/plugins/video.js"},"download-file":{"js":"/js/plugins/download-file.js"},"twikoo":{"js":"/js/services/twikoo_latest_comment.js"},"waline":{"js":"/js/services/waline_latest_comment.js"},"artalk":{"js":"/js/services/artalk_latest_comment.js"},"giscus":{"js":"/js/services/giscus_latest_comment.js"},"contributors":{"edit_this_page":{"_posts/":null,"wiki/stellar/":"https://github.com/xaoxuu/hexo-theme-stellar-docs/blob/main/"},"js":"/js/services/contributors.js"}}'));for(let s of Object.keys(ctx.services)){let e=ctx.services[s].js;"siteinfo"==s?(ctx.cardlinks=document.querySelectorAll("a.link-card[cardlink]"),0<ctx.cardlinks?.length&&utils.js(e,{defer:!0}).then(function(){setCardLink(ctx.cardlinks)})):"voice"==s?(ctx.voiceAudios=document.querySelectorAll(".voice>audio"),0<ctx.voiceAudios?.length&&utils.js(e,{defer:!0}).then(function(){createVoiceDom(ctx.voiceAudios)})):"video"==s?(ctx.videos=document.querySelectorAll(".video>video"),0<ctx.videos?.length&&utils.js(e,{defer:!0}).then(function(){videoEvents(ctx.videos)})):"download-file"==s?(ctx.files=document.querySelectorAll(".file"),0<ctx.files?.length&&utils.js(e,{defer:!0}).then(function(){downloadFileEvent(ctx.files)})):0<document.getElementsByClassName("ds-"+s)?.length&&utils.jq(()=>{s,utils.js(deps.marked).then(function(){utils.js(e,{defer:!0})})})}let o=document.querySelectorAll(".chat .status-bar .time");var s,t;function i(){for(let e=0;e<o.length;++e){var s=o[e],t=new Date,i=t.getHours(),t=t.getMinutes();s.innerHTML=n(i)+":"+n(t)}}function n(e){return e<10?"0"+e:e}0<o.length&&(i(),s=(new Date).getSeconds(),t=setInterval(function(){i(),clearInterval(t),setInterval(i,6e4)},1e3*(60-s)));let c=new IntersectionObserver((e,t)=>{e.filter(e=>e.isIntersecting).sort((e,s)=>e.intersectionRect.y!==s.intersectionRect.y?e.intersectionRect.y-s.intersectionRect.y:e.intersectionRect.x-s.intersectionRect.x).forEach((e,s)=>{t.unobserve(e.target),setTimeout(()=>{e.target.classList.add("quote-blink"),setTimeout(()=>{e.target.classList.remove("quote-blink")},1e3)},Math.max(100,16)*(s+1))})}),r=document.querySelectorAll(".chat .talk .quote");r.forEach(i=>{i.addEventListener("click",function(){var e,s,t=document.getElementById("quote-"+i.getAttribute("quotedCellTag"));t&&(s=(e=t.parentElement).clientHeight/2,t.offsetTop>s-t.clientHeight/2?e.scrollTo({top:t.offsetTop-s+t.clientHeight/2,behavior:"smooth"}):e.scrollTo({top:0,behavior:"smooth"}),c.observe(t))})})})</script><script>window.addEventListener("DOMContentLoaded",e=>{ctx.search={path:"/search.json"},utils.js("/js/search/local-search.js",{defer:!0})})</script><script>window.FPConfig={delay:0,ignoreKeywords:[],maxRPS:5,hoverDelay:25}</script><script defer src="https://gcore.jsdelivr.net/npm/flying-pages@2/flying-pages.min.js"></script><script>ctx.fancybox={selector:'.md-text img[alt]:not([alt="icon"]):not([alt="cover"])',css:"https://gcore.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css",js:"https://gcore.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js"};var selector="[data-fancybox]:not(.error), .with-fancybox .atk-content img:not([atk-emoticon])",needFancybox=(ctx.fancybox.selector&&(selector+=", "+ctx.fancybox.selector),0!==document.querySelectorAll(selector).length);if(!needFancybox){let t=document.getElementsByClassName("ds-memos"),e=(null!=t&&0<t.length&&(needFancybox=!0),document.getElementsByClassName("with-fancybox"));null!=e&&0<e.length&&(needFancybox=!0)}needFancybox&&(utils.css(ctx.fancybox.css),utils.js(ctx.fancybox.js,{defer:!0}).then(function(){Fancybox.bind(selector,{hideScrollbar:!1,Thumbs:{autoStart:!1},caption:(t,e)=>e.triggerEl.alt||e.triggerEl.dataset.caption||null})}))</script><script>window.addEventListener("DOMContentLoaded",e=>{let t=document.getElementById("swiper-api");null!=t&&(utils.css("https://unpkg.com/swiper@10.3/swiper-bundle.min.css"),utils.js("https://unpkg.com/swiper@10.3/swiper-bundle.min.js",{defer:!0}).then(function(){var e=t.getAttribute("effect")||"";new Swiper(".swiper#swiper-api",{slidesPerView:"auto",spaceBetween:8,centeredSlides:!0,effect:e,rewind:!0,pagination:{el:".swiper-pagination",clickable:!0},navigation:{nextEl:".swiper-button-next",prevEl:".swiper-button-prev"}})}))})</script><link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/katex@0.16/dist/katex.min.css"><script defer src="https://gcore.jsdelivr.net/npm/mermaid@v9/dist/mermaid.min.js"></script><script>window.addEventListener("DOMContentLoaded",e=>{var a={startOnLoad:!0,theme:window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"neutral",logLevel:3,themeVariables:{darkMode:!0},flowchart:{useMaxWidth:!1,htmlLabels:!0,curve:"linear"},gantt:{axisFormat:"%Y/%m/%d"},sequence:{actorMargin:50}};mermaid.initialize(a)})</script><script>document.addEventListener("DOMContentLoaded",function(){window.codeElements=document.querySelectorAll(".code"),0<window.codeElements.length&&(ctx.copycode={default_text:"Copy",success_text:"Copied",toast:"复制成功"},utils.js("/js/plugins/copycode.js"))})</script><script>var _hmt=_hmt||[];(()=>{var e=document.createElement("script"),t=(e.src="https://hm.baidu.com/hm.js?b5a2afc20b06445af155f3af37777902",document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)})()</script><script>((e,t,n,r,a,c)=>{e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)},(a=t.createElement(r)).async=1,a.src="https://www.clarity.ms/tag/rp0i6z4yyg",(c=t.getElementsByTagName(r)[0]).parentNode.insertBefore(a,c)})(window,document,"clarity","script")</script></div><style>[bg-lazy]{background-image:none!important;background-color:#eee!important}</style><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:3,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})})</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o=d[n],i=function(){d=d.filter(function(t){return o!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(o)};(t=o).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),i()):(e=new Image,a=t.getAttribute("data-original"),e.onload=function(){t.src=a,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),i()},e.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=a},t.src!==a&&(e.src=a)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this)</script></body></html>