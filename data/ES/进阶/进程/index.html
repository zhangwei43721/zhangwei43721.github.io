<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.33.1" theme-name="Stellar" theme-version="1.33.1"><meta name="generator" content="Hexo 7.3.0"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="preconnect" href="https://gcore.jsdelivr.net" crossorigin><link rel="preconnect" href="https://unpkg.com" crossorigin><link rel="preconnect" href="https://cdn.bootcdn.net" crossorigin><meta name="renderer" content="webkit"><meta name="force-rendering" content="webkit"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="HandheldFriendly" content="True"><meta name="mobile-web-app-capable" content="yes"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000"><meta name="theme-color" content="#f9fafb"><title>Linux 进程管理与调度 - Sky Blog</title><meta name="description" content="本文详细探讨了 Linux 进程的管理与调度机制，包括进程的创建、状态管理、调度算法等核心概念，并提供代码示例"><meta property="og:type" content="website"><meta property="og:title" content="Linux 进程管理与调度"><meta property="og:url" content="http://skyforever.top/data/ES/%E8%BF%9B%E9%98%B6/%E8%BF%9B%E7%A8%8B/"><meta property="og:site_name" content="Sky Blog"><meta property="og:description" content="本文详细探讨了 Linux 进程的管理与调度机制，包括进程的创建、状态管理、调度算法等核心概念，并提供代码示例"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2025-09-22T02:00:00.000Z"><meta property="article:modified_time" content="2025-09-22T02:00:00.000Z"><meta property="article:author" content="Skyforever"><meta property="article:tag" content="进阶&#x2F;Linux并发编程&#x2F;进程"><meta name="twitter:card" content="summary"><meta name="keywords" content=""><link rel="stylesheet" href="/css/main.css?v=1.33.1"><link rel="shortcut icon" href="https://image.skyforever.top/blog/2025/08/c25707b5a37360e74c54764d71d1724c.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Website","@id":"http://skyforever.top/data/ES/%E8%BF%9B%E9%98%B6/%E8%BF%9B%E7%A8%8B/","author":{"@type":"Person","name":"Skyforever","sameAs":[]},"name":"Linux 进程管理与调度","description":"本文详细探讨了 Linux 进程的管理与调度机制，包括进程的创建、状态管理、调度算法等核心概念，并提供代码示例","url":"http://skyforever.top/data/ES/%E8%BF%9B%E9%98%B6/%E8%BF%9B%E7%A8%8B/"}</script></head><body><div class="l_body content" id="start" layout="page" type="tech"><aside class="l_left"><div class="sidebg"></div><div class="leftbar-container"><header class="header"><div class="logo-wrap"><div class="icon"><img no-lazy class="icon" src="/images/icons/cloud.png" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></div><a class="title" href="/"><div class="main">Sky Blog</div><div class="sub normal cap">记录走下的每一步</div><div class="sub hover cap" style="opacity:0">Write by Skyforever</div></a></div></header><div class="nav-area"><nav class="menu dis-select"><a class="nav-item" title="博客" href="/"><span>博客</span></a><a class="nav-item" title="项目" href="/wiki/"><span>项目</span></a><a class="nav-item" title="笔记" href="/notebooks/"><span>笔记</span></a></nav></div><div class="widgets"><div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" data-filter="/note/ES" placeholder="在 嵌入式 中搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div><widget class="widget-wrapper post-list"><div class="widget-header dis-select"><span class="name">标签</span></div><div class="widget-body fs14 tag-tree"><div class="tag-subtree leaf-tag expanded" data-tag=""><a class="link" href="/note/ES/"><span class="toc-text">所有笔记 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a></div><div class="tag-subtree parent-tag expanded" data-tag="图形界面开发"><a class="link" href="/note/ES/tags/%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91/"><span class="toc-text"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>图形界面开发 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a><div class="tag-subtree parent-tag expanded" data-tag="图形界面开发/lvgl"><a class="link" href="/note/ES/tags/%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91/lvgl/"><span class="toc-text" style="padding-left:.875rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>LVGL </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a><div class="tag-subtree leaf-tag expanded" data-tag="图形界面开发/lvgl/多媒体"><a class="link" href="/note/ES/tags/%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91/lvgl/%E5%A4%9A%E5%AA%92%E4%BD%93/"><span class="toc-text" style="padding-left:1.75rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>多媒体 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a></div><div class="tag-subtree leaf-tag expanded" data-tag="图形界面开发/lvgl/核心概念"><a class="link" href="/note/ES/tags/%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91/lvgl/%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/"><span class="toc-text" style="padding-left:1.75rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>核心概念 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a></div></div></div><div class="tag-subtree parent-tag expanded" data-tag="基础"><a class="link" href="/note/ES/tags/%E5%9F%BA%E7%A1%80/"><span class="toc-text"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>基础 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a><div class="tag-subtree leaf-tag expanded" data-tag="基础/c语言"><a class="link" href="/note/ES/tags/%E5%9F%BA%E7%A1%80/c%E8%AF%AD%E8%A8%80/"><span class="toc-text" style="padding-left:.875rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>C语言 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a></div><div class="tag-subtree leaf-tag expanded" data-tag="基础/linux基础"><a class="link" href="/note/ES/tags/%E5%9F%BA%E7%A1%80/linux%E5%9F%BA%E7%A1%80/"><span class="toc-text" style="padding-left:.875rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>Linux基础 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a></div><div class="tag-subtree leaf-tag expanded" data-tag="基础/库与框架"><a class="link" href="/note/ES/tags/%E5%9F%BA%E7%A1%80/%E5%BA%93%E4%B8%8E%E6%A1%86%E6%9E%B6/"><span class="toc-text" style="padding-left:.875rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>库与框架 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a></div><div class="tag-subtree parent-tag expanded" data-tag="基础/数据结构与算法"><a class="link" href="/note/ES/tags/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="toc-text" style="padding-left:.875rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>数据结构与算法 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a><div class="tag-subtree leaf-tag expanded" data-tag="基础/数据结构与算法/内核链表"><a class="link" href="/note/ES/tags/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/"><span class="toc-text" style="padding-left:1.75rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>内核链表 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a></div></div><div class="tag-subtree leaf-tag expanded" data-tag="基础/文件io"><a class="link" href="/note/ES/tags/%E5%9F%BA%E7%A1%80/%E6%96%87%E4%BB%B6io/"><span class="toc-text" style="padding-left:.875rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>文件IO </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a></div></div><div class="tag-subtree parent-tag expanded" data-tag="硬件"><a class="link" href="/note/ES/tags/%E7%A1%AC%E4%BB%B6/"><span class="toc-text"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>硬件 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a><div class="tag-subtree leaf-tag expanded" data-tag="硬件/stm32"><a class="link" href="/note/ES/tags/%E7%A1%AC%E4%BB%B6/stm32/"><span class="toc-text" style="padding-left:.875rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>STM32 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a></div><div class="tag-subtree leaf-tag expanded" data-tag="硬件/电子基础"><a class="link" href="/note/ES/tags/%E7%A1%AC%E4%BB%B6/%E7%94%B5%E5%AD%90%E5%9F%BA%E7%A1%80/"><span class="toc-text" style="padding-left:.875rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>电子基础 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a></div></div><div class="tag-subtree parent-tag expanded" data-tag="进阶"><a class="link" href="/note/ES/tags/%E8%BF%9B%E9%98%B6/"><span class="toc-text"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>进阶 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a><div class="tag-subtree parent-tag expanded" data-tag="进阶/linux并发编程"><a class="link" href="/note/ES/tags/%E8%BF%9B%E9%98%B6/linux%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><span class="toc-text" style="padding-left:.875rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>Linux并发编程 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a><div class="tag-subtree leaf-tag expanded" data-tag="进阶/linux并发编程/线程"><a class="link" href="/note/ES/tags/%E8%BF%9B%E9%98%B6/linux%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B/"><span class="toc-text" style="padding-left:1.75rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>线程 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a></div><div class="tag-subtree leaf-tag expanded" data-tag="进阶/linux并发编程/进程"><a class="link" href="/note/ES/tags/%E8%BF%9B%E9%98%B6/linux%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E8%BF%9B%E7%A8%8B/"><span class="toc-text" style="padding-left:1.75rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>进程 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a></div></div><div class="tag-subtree leaf-tag expanded" data-tag="进阶/linux网络"><a class="link" href="/note/ES/tags/%E8%BF%9B%E9%98%B6/linux%E7%BD%91%E7%BB%9C/"><span class="toc-text" style="padding-left:.875rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>Linux网络 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a></div><div class="tag-subtree leaf-tag expanded" data-tag="进阶/mqtt物联网"><a class="link" href="/note/ES/tags/%E8%BF%9B%E9%98%B6/mqtt%E7%89%A9%E8%81%94%E7%BD%91/"><span class="toc-text" style="padding-left:.875rem"><span class="tagcon"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m14.092 10.75l-.75 2.5H9.908l.75-2.5z"/><path fill="currentColor" fill-rule="evenodd" d="M3.464 3.464C2 4.93 2 7.286 2 12s0 7.071 1.464 8.535C4.93 22 7.286 22 12 22s7.071 0 8.535-1.465C22 19.072 22 16.714 22 12s0-7.071-1.465-8.536C19.072 2 16.714 2 12 2S4.929 2 3.464 3.464m7.752 2.818a.75.75 0 0 1 .502.934l-.61 2.034h3.434l.74-2.465a.75.75 0 0 1 1.436.43l-.61 2.035H18a.75.75 0 0 1 0 1.5h-2.342l-.75 2.5H17a.75.75 0 0 1 0 1.5h-2.542l-.74 2.465a.75.75 0 0 1-1.436-.43l.61-2.035H9.458l-.74 2.465a.75.75 0 1 1-1.436-.43l.61-2.035H6a.75.75 0 0 1 0-1.5h2.342l.75-2.5H7a.75.75 0 0 1 0-1.5h2.542l.74-2.465a.75.75 0 0 1 .934-.503" clip-rule="evenodd"/></svg></span>MQTT物联网 </span><span class="toc-text tag-switcher-wrapper"><span class="tag-switcher"></span></a></div></div></div></widget><widget class="widget-wrapper recent post-list"><div class="widget-header dis-select"><span class="name">最近更新</span></div><div class="widget-body fs14"><a class="item title" href="/data/ES/%E7%A1%AC%E4%BB%B6/%E6%95%B0%E7%94%B5%E5%9F%BA%E7%A1%80/"><span class="title">数字电路基础</span></a><a class="item title" href="/data/ES/%E7%A1%AC%E4%BB%B6/%E6%A8%A1%E7%94%B5%E5%9F%BA%E7%A1%80/"><span class="title">模拟电路基础</span></a><a class="item title" href="/data/ES/%E7%A1%AC%E4%BB%B6/%E7%94%B5%E5%AD%A6%E6%A6%82%E5%BF%B5/"><span class="title">电学概念</span></a><a class="item title" href="/data/ES/%E8%BF%9B%E9%98%B6/MQTT%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"><span class="title">MQTT 使用笔记</span></a><a class="item title" href="/data/ES/%E8%BF%9B%E9%98%B6/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><span class="title">Linux 网络编程</span></a><a class="item title" href="/data/ES/%E8%BF%9B%E9%98%B6/%E7%BA%BF%E7%A8%8B/"><span class="title">Linux 多线程编程：Pthreads 核心函数与资源管理详解</span></a><a class="item title" href="/data/ES/%E8%BF%9B%E9%98%B6/%E8%BF%9B%E7%A8%8B/"><span class="title">Linux 进程管理与调度</span></a><a class="item title" href="/data/ES/%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91/LVGL%20%E5%9B%BE%E5%83%8F%E4%B8%8E%E5%AD%97%E4%BD%93%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"><span class="title">LVGL 图像与字体使用笔记</span></a><a class="item title" href="/data/ES/%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91/LVGL%20%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E7%AC%94%E8%AE%B0/"><span class="title">LVGL 核心概念笔记</span></a><a class="item title" href="/data/ES/%E5%9F%BA%E7%A1%80/C%E8%AF%AD%E8%A8%80-%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C%E5%92%8C%E4%BD%BF%E7%94%A8/"><span class="title">C语言-库的制作和使用</span></a></div></widget></div><footer class="footer dis-select"><div class="social-wrap"><a class="social" href="https://github.com/zhangwei43721" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://api.iconify.design/icon-park/github.svg"></a><a class="social" href="https://music.163.com/#/user/home?id=1654800754" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://api.iconify.design/ri:netease-cloud-music-line.svg"></a><a class="social" href="mailto:zhangwei4372@outlook.com" rel="noopener noreferrer"><img src="https://api.iconify.design/clarity/email-outline-badged.svg"></a></div></footer></div></aside><div class="l_main" id="main"><div class="article banner top"><div class="content"><div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a> <span class="sep"></span> <a class="cap breadcrumb" href="/notebooks/">笔记本</a> <span class="sep"></span> <a class="cap breadcrumb" href="/note/ES/">嵌入式</a></div><div class="flex-row" id="post-meta"><span class="text created">更新于：<time datetime="2025-09-22T02:00:00.000Z">2025-09-22</time></span><span class="sep updated"></span><span class="text updated">发布于：<time datetime="2025-09-22T02:00:00.000Z">2025-09-22</time></span></div></div></div><div class="bottom only-title"><div class="text-area"><h1 class="text title"><span>Linux 进程管理与调度</span></h1></div></div></div></div><article class="md-text content"><h2 id="进程的概念及基础"><a class="markdownIt-Anchor" href="#进程的概念及基础"></a> 进程的概念及基础</h2><h3 id="程序和进程的关系"><a class="markdownIt-Anchor" href="#程序和进程的关系"></a> 程序和进程的关系</h3><p>程序：是<strong>静态</strong>的，一堆没有被加载(运行)的二进制代码，存储在<strong>硬盘</strong>中</p><p>进程：是<strong>动态</strong>的，已经被加载(运行)到内存中的程序文件，存储到<strong>内存</strong>中</p><h3 id="进程的相关命令"><a class="markdownIt-Anchor" href="#进程的相关命令"></a> 进程的相关命令</h3><p>查看：<a href="https://skyforever.top/data/ES/%E5%9F%BA%E7%A1%80/Linux%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/?tag=%E5%9F%BA%E7%A1%80/linux%E5%9F%BA%E7%A1%80#12-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86">Linux 基础与实战笔记-进程与服务管理</a></p><h3 id="进程的生命周期状态重点img"><a class="markdownIt-Anchor" href="#进程的生命周期状态重点img"></a> 进程的生命周期状态（重点）<img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://image.skyforever.top/blog/2025/10/c4c229708ae13776786d92dadde07eeb.webp" alt="img"></h3><p>1、就绪态：当一个程序被加载后就处于就绪态中，所有的进程要变成执行态，都要从就绪态开始</p><p>2、执行态：当一个进程得到 CPU 的使用权(时间片)后，就会处于执行态中</p><p>3、睡眠/挂起态：当一个进程调用 sleep 或者一些等待阻塞函数 scanf 时，都会进入到睡眠/挂起态</p><p>4、暂停态：收到 STOP 暂停信号后就会进入到暂停态中，等待 CONT 继续信号</p><p>5、僵尸态：进程死亡后都会进入到僵尸态，等待别人帮他收尸</p><p>6、死亡态：父母进程回收(wait)子进程的资源就会进入死亡态</p><h3 id="进程的相关-api-和说明"><a class="markdownIt-Anchor" href="#进程的相关-api-和说明"></a> 进程的相关 API 和说明</h3><h4 id="进程的创建fork-函数"><a class="markdownIt-Anchor" href="#进程的创建fork-函数"></a> 进程的创建（fork 函数）</h4><p>父子进程在 <strong>fork()</strong> 之后的区别，核心就一条：</p><p>👉 <strong>父进程和子进程的虚拟内存内容相同，但属于不同的进程，PID 不同，资源不共享（文件描述符除外）</strong></p><p>具体来说：</p><ol><li><strong>不同点</strong><ul><li><strong>PID 不同</strong>：<code>getpid()</code> 获取到的进程号不同。</li><li><strong>fork() 的返回值不同</strong>：<ul><li>父进程中 <code>fork()</code> 返回子进程 PID。</li><li>子进程中 <code>fork()</code> 返回 <code>0</code>。</li></ul></li><li><strong>资源独立</strong>：全局变量、局部变量等虽然初始值相同，但各自独立修改，互不影响</li></ul></li><li><strong>相同点</strong><ul><li><strong>代码段相同</strong>：执行同一段程序。</li><li><strong>数据段、堆、栈初始内容相同</strong>（fork 后复制）</li><li><strong>打开的文件描述符相同</strong>（共享文件偏移量）</li></ul></li></ol><p>父子进程共享同一份程序代码，调度由操作系统时间片复用完成，所以运行起来像同一个程序</p><p>它们的区别只能通过 <strong><code>fork()</code> 的返回值</strong> 和 <strong>进程号（PID）</strong> 来区分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">int</span> value = <span class="number">100</span>;</span><br><span class="line">  <span class="comment">// 获取本进程的id</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;fork之前：pid==%d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// fork后有两个进程</span></span><br><span class="line">  <span class="type">pid_t</span> pid = fork();</span><br><span class="line">  <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;fork error!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;  <span class="comment">// 字进程</span></span><br><span class="line">    value = <span class="number">110</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fork之后，pid==%d，&amp;value：%p,value:%d\n&quot;</span>, getpid(), &amp;value, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 父进程</span></span><br><span class="line">    value = <span class="number">120</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fork之后，pid==%d，&amp;value：%p,value:%d\n&quot;</span>, getpid(), &amp;value, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> ➜ ./1.fork函数创建进程</span><br><span class="line">fork之前：pid==977163</span><br><span class="line">fork之后，pid==977163，&amp;value：0x7fffde4f16c0,value:120</span><br><span class="line">fork之后，pid==977164，&amp;value：0x7fffde4f16c0,value:110</span><br></pre></td></tr></table></figure><p>可以看到，父进程和字进程变量的虚拟内存地址相同，但值不同</p><h4 id="进程的回收wait-waitpid-状态值"><a class="markdownIt-Anchor" href="#进程的回收wait-waitpid-状态值"></a> 进程的回收（wait, waitpid, 状态值）</h4><p>当一个子进程退出时，它会进入<strong>僵尸态</strong>。此时，子进程的资源（如内存）大部分已被释放，但在内核的进程表中仍然保留其退出状态等信息。父进程需要调用 <code>wait()</code> 或 <code>waitpid()</code> 来获取这些信息，并彻底清理子进程的记录，这个过程称为“<strong>为子进程收尸</strong>”。</p><h5 id="1-wait-函数"><a class="markdownIt-Anchor" href="#1-wait-函数"></a> 1. wait() 函数</h5><p><code>wait()</code> 函数会<strong>阻塞</strong>父进程，直到它的<strong>任意一个</strong>子进程结束。</p><ul><li><strong>函数原型</strong>： <code>pid_t wait(int *wstatus);</code></li><li><strong>参数</strong>：<code>wstatus</code> 是一个整型指针，用于接收子进程的退出状态。如果不需要，可以传入 <code>NULL</code>。</li><li><strong>返回值</strong>：成功时返回结束的子进程的 PID；失败时返回 -1。</li></ul><p>下面的代码演示了父进程如何使用 <code>wait()</code> 等待子进程结束。子进程运行 5 秒后退出，父进程则一直阻塞等待</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">pid_t</span> pid = fork();</span><br><span class="line">  <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;fork error!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;  <span class="comment">// 子进程</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;pid(%d): play game(%d)......\n&quot;</span>, getpid(), i);</span><br><span class="line">      sleep(<span class="number">1</span>);</span><br><span class="line">      i++;</span><br><span class="line">      <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程结束!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 结束子进程</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 父进程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;父进程正在等待子进程结束!\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> wait_status = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 堵塞于此，等待任意一个子进程结束(并给子进程收尸)</span></span><br><span class="line">    <span class="type">pid_t</span> child_pid = wait(&amp;wait_status);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;回收成功，被终止的子进程ID == %d\n&quot;</span>, child_pid);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-waitpid-函数"><a class="markdownIt-Anchor" href="#2-waitpid-函数"></a> 2. waitpid() 函数</h5><p><code>waitpid()</code> 是 <code>wait()</code> 的一个更强大、更灵活的版本。它可以等待一个<strong>特定的</strong>子进程，也可以设置为<strong>非阻塞</strong>模式。</p><ul><li><strong>函数原型</strong>： <code>pid_t waitpid(pid_t pid, int *wstatus, int options);</code></li><li><strong>参数</strong>：<ul><li><code>pid</code>：<ul><li><code>&gt; 0</code>: 等待进程 ID 为 <code>pid</code> 的子进程。</li><li><code>-1</code>: 等待任意子进程（等同于 <code>wait()</code>）。</li></ul></li><li><code>wstatus</code>：同 <code>wait()</code>，用于存储退出状态。</li><li><code>options</code>：<ul><li><code>0</code>: 阻塞等待。</li><li><code>WNOHANG</code>: 非阻塞，如果子进程还未结束，立即返回 <code>0</code>。</li><li><code>WUNTRACED</code>: 如果子进程进入暂停状态，也返回。</li></ul></li></ul></li></ul><h5 id="3-获取子进程退出状态"><a class="markdownIt-Anchor" href="#3-获取子进程退出状态"></a> 3. 获取子进程退出状态</h5><p>当 <code>wait()</code> 或 <code>waitpid()</code> 返回后，<code>wstatus</code> 中包含了子进程的退出信息，不能直接当作退出码使用。</p><p>需要用一组宏来解析：</p><ul><li><code>WIFEXITED(wstatus)</code>: 判断子进程是否<strong>正常退出</strong>（通过 <code>return</code>, <code>exit</code>, <code>_exit</code>）。<ul><li><code>WEXITSTATUS(wstatus)</code>: 如果正常退出，用此宏获取<strong>退出状态码</strong>。</li></ul></li><li><code>WIFSIGNALED(wstatus)</code>: 判断子进程是否被<strong>信号终止</strong>。<ul><li><code>WTERMSIG(wstatus)</code>: 如果是，用此宏获取<strong>终止它的信号编号</strong>。</li></ul></li><li><code>WIFSTOPPED(wstatus)</code>: 判断子进程是否处于<strong>暂停状态</strong>。<ul><li><code>WSTOPSIG(wstatus)</code>: 如果是，用此宏获取<strong>使它暂停的信号编号</strong>。</li></ul></li></ul><p>以下代码演示了如何使用 <code>waitpid()</code> 和状态宏来详细判断子进程的退出原因</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">pid_t</span> pid = fork();</span><br><span class="line">  <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;fork error!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;  <span class="comment">// 子进程</span></span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子进程结束!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">66</span>;  <span class="comment">// 结束子进程，退出码为66</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 父进程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;父进程正在等待子进程(pid=%d)结束!\n&quot;</span>, pid);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> wait_status = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 等待指定的子进程pid结束</span></span><br><span class="line">    waitpid(pid, &amp;wait_status, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断子进程是否正常退出</span></span><br><span class="line">    <span class="keyword">if</span> (WIFEXITED(wait_status)) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;子进程正常退出！\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;退出状态码：%d\n&quot;</span>, WEXITSTATUS(wait_status));  <span class="comment">// 获取子进程的退出码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断子进程是否被信号杀死</span></span><br><span class="line">    <span class="keyword">if</span> (WIFSIGNALED(wait_status)) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;子进程被信号杀死！\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;杀死子进程的信号为：%d\n&quot;</span>, WTERMSIG(wait_status));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断子进程是否被信号暂停</span></span><br><span class="line">    <span class="keyword">if</span> (WIFSTOPPED(wait_status)) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;子进程被信号暂停！\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;暂停子进程的信号为：%d\n&quot;</span>,</span><br><span class="line">             WSTOPSIG(wait_status));  <span class="comment">// 获取暂停子进程的信号</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断子进程是否被信号继续</span></span><br><span class="line">    <span class="keyword">if</span> (WIFCONTINUED(wait_status)) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;子进程从暂停态中被恢复了\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="进程的退出return-exit-_exit"><a class="markdownIt-Anchor" href="#进程的退出return-exit-_exit"></a> 进程的退出（return, exit, _Exit）</h4><p>进程的退出分为正常退出和异常退出。这里主要讨论三种正常退出的方式。</p><ol><li><p><strong><code>return</code></strong></p><ul><li>在 <code>main</code> 函数中使用 <code>return</code>，等同于调用 <code>exit(return_value)</code>。进程会正常终止，并执行清理操作。</li><li>在<strong>普通函数</strong>中使用 <code>return</code>，<strong>仅仅是将控制权返回给调用者</strong>，并不会导致进程退出。</li></ul></li><li><p><strong><code>exit()</code> 函数</strong></p><ul><li><strong>函数原型</strong>：<code>void exit(int status);</code></li><li>这是标准的退出函数。无论在哪个函数中调用，都会立即终止<strong>整个进程</strong>。</li><li><strong>特点</strong>：在进程退出前，会执行一系列“清理操作”，包括：<ul><li>刷新标准 I/O 缓冲区（如 <code>printf</code> 的内容）。</li><li>调用 <code>atexit()</code> 注册的函数。</li></ul></li></ul></li><li><p><strong><code>_exit()</code> 和 <code>_Exit()</code> 函数</strong></p><ul><li><strong>函数原型</strong>：<code>void _exit(int status);</code></li><li>这两个函数功能相同，会立即终止进程，但<strong>不会执行任何清理操作</strong>。缓冲区的数据会丢失，<code>atexit</code> 注册的函数也不会被调用。</li><li><strong>推荐场景</strong>：在 <code>fork()</code> 后的<strong>子进程</strong>中，推荐使用 <code>_exit()</code>。因为 <code>exit()</code> 的缓冲区刷新可能会影响父进程的 I/O 流，导致数据重复输出或混乱。使用 <code>_exit()</code> 可以避免这种副作用。</li></ul></li></ol><p>下面的代码演示了在普通函数 <code>PTask1_PlayGame</code> 中，三种退出方式的示例代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">PTask1_PlayGame</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">pid_t</span> pid = fork();</span><br><span class="line">  <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;fork error!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;  <span class="comment">// 子进程</span></span><br><span class="line">    PTask1_PlayGame();</span><br><span class="line">    <span class="comment">// 如果PTask1_PlayGame是return返回的，这里会继续执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PTask1_PlayGame函数返回了，但子进程还在运行!\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子进程现在才真正退出!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 父进程</span></span><br><span class="line">    <span class="type">int</span> wait_status = <span class="number">0</span>;</span><br><span class="line">    wait(&amp;wait_status);</span><br><span class="line">    <span class="keyword">if</span> (WIFEXITED(wait_status)) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;父进程：子进程已正常退出，退出码：%d\n&quot;</span>, WEXITSTATUS(wait_status));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">PTask1_PlayGame</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PTask1_PlayGame(PID: %d)...玩了%d秒...\n&quot;</span>, getpid(), i);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;PTask1_PlayGame函数结束了(Game Over)!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 演示1: return 只是返回main函数，进程继续</span></span><br><span class="line">  <span class="comment">// return 11;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 演示2: exit 会终止整个进程，父进程会收到退出码66</span></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">66</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 演示3: _exit 也会终止整个进程，父进程收到退出码88</span></span><br><span class="line">  <span class="comment">// _exit(88);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多进程的使用"><a class="markdownIt-Anchor" href="#多进程的使用"></a> 多进程的使用</h4><p>在实际应用中，可以通过创建多个子进程来并行处理不同的任务，以提高程序的效率和模块化程度。例如，一个车载系统可以为每个功能（如胎压监测、车速显示、油耗计算等）创建一个独立的进程。</p><ul><li><strong>实现思路</strong>:<ol><li>父进程在一个循环中多次调用 <code>fork()</code> 来创建所需数量的子进程。</li><li>在子进程的代码块中，通过循环变量或其他标识来区分不同的子进程，并让它们执行各自的任务函数。</li><li>每个子进程任务完成后，应调用 <code>_exit()</code> 退出，避免不必要的资源清理副作用。</li><li>父进程在创建完所有子进程后，进入另一个循环，调用 <code>wait()</code> 来回收所有子进程的资源，防止它们变成僵尸进程。</li></ol></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟各个任务</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tire_pressure_task</span><span class="params">()</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;PID %d: 胎压监测任务启动...\n&quot;</span>, getpid()); sleep(<span class="number">2</span>); _exit(<span class="number">1</span>); &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">speed_task</span><span class="params">()</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;PID %d: 车速监测任务启动...\n&quot;</span>, getpid()); sleep(<span class="number">3</span>); _exit(<span class="number">2</span>); &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fuel_task</span><span class="params">()</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;PID %d: 油耗监测任务启动...\n&quot;</span>, getpid()); sleep(<span class="number">4</span>); _exit(<span class="number">3</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> NUM_TASKS = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_TASKS; i++) &#123;</span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">// 子进程</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) tire_pressure_task();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) speed_task();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>) fuel_task();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程回收所有子进程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_TASKS; i++) &#123;</span><br><span class="line">        <span class="type">int</span> status;</span><br><span class="line">        <span class="type">pid_t</span> child_pid = wait(&amp;status);</span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;父进程：回收了子进程 %d，退出码 %d\n&quot;</span>, child_pid, WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;所有车载任务已结束。\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="程序的加载system-popen-exec-系列函数"><a class="markdownIt-Anchor" href="#程序的加载system-popen-exec-系列函数"></a> 程序的加载（system, popen, exec 系列函数）</h4><p>有时候，一个进程需要执行一个全新的程序。这可以通过加载外部程序来实现</p><h5 id="1-system-函数"><a class="markdownIt-Anchor" href="#1-system-函数"></a> 1. system() 函数</h5><p><code>system()</code> 函数非常方便，它可以直接执行一个 shell 命令字符串。</p><ul><li><strong>函数原型</strong>： <code>int system(const char *command);</code></li><li><strong>工作原理</strong>：<code>system()</code> 会创建一个子进程来执行 <code>sh -c &quot;command&quot;</code>，并<strong>阻塞等待</strong>该命令执行完毕。</li><li><strong>优点</strong>：使用简单，可以执行复杂的 shell 命令，如管道、重定向。</li><li><strong>缺点</strong>：开销较大（创建了 shell 进程），且存在安全风险（命令注入）。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;--- 开始执行system命令 ---\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 加载并执行外部程序，并传递参数</span></span><br><span class="line">  system(<span class="string">&quot;./test_app arg1 arg2&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 执行系统命令，如ls</span></span><br><span class="line">  system(<span class="string">&quot;ls -l /&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 让程序在后台运行 (&amp;)</span></span><br><span class="line">  system(<span class="string">&quot;gedit &amp;&quot;</span>); <span class="comment">// gedit会打开，但system不会立即返回，通常等待shell退出</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;--- system命令执行完毕 ---\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-popen-和-pclose-函数"><a class="markdownIt-Anchor" href="#2-popen-和-pclose-函数"></a> 2. popen() 和 pclose() 函数</h5><p><code>popen()</code> 函数用于执行一个命令，但与 <code>system()</code> 不同的是，它会创建一个<strong>管道(pipe)</strong>，使得当前进程可以<strong>读取</strong>该命令的输出，或者<strong>写入</strong>数据给该命令的输入。</p><ul><li><strong>函数原型</strong>：<ul><li><code>FILE *popen(const char *command, const char *type);</code></li><li><code>int pclose(FILE *stream);</code></li></ul></li><li><strong>参数 <code>type</code></strong>:<ul><li><code>&quot;r&quot;</code>: 读取模式。可以像读文件一样，读取 <code>command</code> 的标准输出。</li><li><code>&quot;w&quot;</code>: 写入模式。可以像写文件一样，将数据写入到 <code>command</code> 的标准输入。</li></ul></li><li><strong>pclose()</strong>：必须调用 <code>pclose()</code> 来关闭 <code>popen</code> 创建的流，它会等待命令执行结束。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> &#123;</span><br><span class="line">  FILE *fp;</span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// --- 演示 &quot;r&quot; 模式：读取命令的输出 ---</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;--- 读取 &#x27;ls -l&#x27; 的输出 ---\n&quot;</span>);</span><br><span class="line">  fp = popen(<span class="string">&quot;ls -l&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;popen &#x27;r&#x27; error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 逐行读取并打印</span></span><br><span class="line">  <span class="keyword">while</span> (fgets(buffer, <span class="keyword">sizeof</span>(buffer), fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buffer);</span><br><span class="line">  &#125;</span><br><span class="line">  pclose(fp); <span class="comment">// 关闭管道并等待命令结束</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// --- 演示 &quot;w&quot; 模式：向命令写入数据 ---</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n--- 向 &#x27;grep hello&#x27; 写入数据 ---\n&quot;</span>);</span><br><span class="line">  fp = popen(<span class="string">&quot;grep hello&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;popen &#x27;w&#x27; error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 写入数据，grep会筛选包含&quot;hello&quot;的行并输出到终端</span></span><br><span class="line">  <span class="built_in">fprintf</span>(fp, <span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(fp, <span class="string">&quot;goodbye\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(fp, <span class="string">&quot;another hello line\n&quot;</span>);</span><br><span class="line">  pclose(fp); <span class="comment">// 关闭管道，刷新缓冲区，等待命令结束</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-exec-系列函数"><a class="markdownIt-Anchor" href="#3-exec-系列函数"></a> 3. exec 系列函数</h5><p><code>exec</code> 系列函数是<strong>最核心</strong>的程序加载机制。它<strong>不会创建新进程</strong>，而是用一个全新的程序<strong>替换当前进程</strong>的内存空间（包括代码、数据、堆栈）。</p><ul><li><strong>核心特点</strong>：一旦 <code>exec</code> 调用成功，原来的程序就不存在了，PID 保持不变，但执行的已经是新程序了。<code>exec</code> 成功后<strong>不会返回</strong>。</li><li><strong>常见模式</strong>：<code>fork()</code> + <code>exec()</code>。父进程 <code>fork</code> 一个子进程，然后子进程调用 <code>exec</code> 去执行新程序，父进程可以继续做自己的事或 <code>wait</code> 子进程。<code>system</code> 和 <code>popen</code> 内部都封装了这个模式。</li><li><strong>函数家族</strong>：<ul><li><code>execl</code>, <code>execlp</code>, <code>execle</code>: 参数以<strong>列表</strong>形式给出 (<code>l</code>)。(list)</li><li><code>execv</code>, <code>execvp</code>, <code>execve</code>: 参数以<strong>字符串数组</strong>形式给出 (<code>v</code>)。(vector)</li><li>带 <code>p</code> 的 (<code>execlp</code>, <code>execvp</code>) 会在 <code>PATH</code> 环境变量中<strong>搜索</strong>可执行文件。(path)</li><li>带 <code>e</code> 的 (<code>execle</code>, <code>execve</code>) 允许你<strong>自定义</strong>新程序的环境变量。(environment)</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的 fork + exec 示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程(PID:%d)开始执行 &#x27;ls -l&#x27;\n&quot;</span>, getpid());</span><br><span class="line">        <span class="comment">// 使用新程序 &quot;ls&quot; 替换当前子进程</span></span><br><span class="line">        execlp(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 如果execlp成功，下面这行代码永远不会被执行</span></span><br><span class="line">        perror(<span class="string">&quot;execlp failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123; <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程(PID:%d)等待子进程结束...\n&quot;</span>, getpid());</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程：子进程执行完毕。\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进程的关系重点"><a class="markdownIt-Anchor" href="#进程的关系重点"></a> 进程的关系（重点）</h3><h4 id="1-父子进程"><a class="markdownIt-Anchor" href="#1-父子进程"></a> (1) 父子进程</h4><p>通过 <code>fork()</code> 创建的进程具有父子关系。父进程是创建者，子进程是被创建者。父进程有责任管理其子进程的生命周期，最重要的是在子进程结束后，通过调用 <code>wait()</code> 或 <code>waitpid()</code> 来回收其资源，防止子进程变成僵尸进程。</p><p>可以使用 <code>pstree</code> 命令查看系统中所有进程形成的“家族树”，直观地看到父子关系。<code>top</code> 或 <code>ps</code> 命令也可以查看每个进程的 PID (进程 ID) 和 PPID (父进程 ID)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子进程(PID:%d)，我的父进程是(PPID:%d)\n&quot;</span>, getpid(), getppid());</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程结束。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是父进程(PID:%d)，我创建了子进程(PID:%d)\n&quot;</span>, getpid(), pid);</span><br><span class="line">        wait(<span class="literal">NULL</span>); <span class="comment">// 阻塞等待，直到子进程结束并回收其资源</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程：已回收子进程资源，现在退出。\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-孤儿进程"><a class="markdownIt-Anchor" href="#2-孤儿进程"></a> (2) 孤儿进程</h4><ul><li><strong>说明</strong>：当一个父进程比它的子进程先结束时，这个子进程就成为了“孤儿进程”。</li><li><strong>系统处理</strong>：孤儿进程不会无人管理，它会被系统的 1 号进程（在现代 Linux 系统中通常是 <code>systemd</code>）所“收养”，<code>systemd</code> 会成为它的新父进程，并负责在其结束后回收资源。</li><li><strong>注意</strong>：虽然系统会自动处理孤儿进程，但这通常意味着程序设计上存在逻辑问题。正常情况下，父进程应该等待所有子进程结束后再退出。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">// 子进程</span></span><br><span class="line">        <span class="comment">// 循环打印自己的PID和父进程的PPID</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;我是子进程(PID:%d)，我的父进程是(PPID:%d)\n&quot;</span>, getpid(), getppid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是父进程(PID:%d)，我将在5秒后退出。\n&quot;</span>, getpid());</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程结束！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行现象</strong>：程序运行后，子进程会持续打印其父进程的 ID。5 秒后，父进程退出，你会观察到子进程打印的父进程 ID（PPID）从原来的父进程 PID 变成了 <code>1</code></p><h4 id="3-僵尸进程"><a class="markdownIt-Anchor" href="#3-僵尸进程"></a> (3) 僵尸进程</h4><ul><li><strong>说明</strong>：当一个子进程比父进程先结束，但父进程没有调用 <code>wait()</code> 或 <code>waitpid()</code> 来获取子进程的退出状态时，子进程就会变成“僵尸进程”。</li><li><strong>状态</strong>：此时，子进程的绝大部分资源（如内存）已被释放，但在内核的进程表中仍然保留着它的条目（包含 PID、退出状态、资源使用信息等），等待父进程来读取。在 <code>ps</code> 命令中，僵尸进程的状态显示为 <code>Z</code> (Zombie) 或 <code>&lt;defunct&gt;</code>。</li><li><strong>危害</strong>：僵尸进程本身不占用太多资源，但它会一直占用一个 PID。如果一个程序持续产生僵尸进程而不进行回收，最终会耗尽系统可用的 PID，导致无法创建任何新进程，从而使系统瘫痪。<strong>必须避免僵尸进程的产生</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 创建10个子进程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">// 子进程</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;子进程(PID:%d)创建并立即退出。\n&quot;</span>, getpid());</span><br><span class="line">            _exit(<span class="number">0</span>); <span class="comment">// 子进程立刻退出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 父进程不回收子进程，而是长时间运行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;父进程(PID:%d)正在运行，但未回收子进程。请在另一个终端使用 &#x27;ps aux | grep a.out&#x27; 查看。\n&quot;</span>, getpid());</span><br><span class="line">    getchar(); <span class="comment">// 阻塞在这里，等待用户输入</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;父进程结束。\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行现象</strong>：运行该程序后，立即在另一个终端执行 <code>ps aux | grep a.out</code>，你会看到多个状态为 <code>Z+</code> 的僵尸进程</p><h4 id="4-守护进程-精灵进程"><a class="markdownIt-Anchor" href="#4-守护进程-精灵进程"></a> (4) 守护进程 (精灵进程)</h4><ul><li><strong>说明</strong>：守护进程是一种特殊的后台进程，它完全脱离于控制终端，独立于任何登录会话，通常用于执行周期性任务或提供系统服务（如 <code>sshd</code>, <code>httpd</code> 等）。</li><li><strong>特点</strong>：<ol><li><strong>长期运行</strong>：通常在系统启动时开始运行，直到系统关闭。</li><li><strong>无控制终端</strong>：不与任何终端关联，不会接收终端输入或向终端输出。</li><li><strong>会话独立</strong>：自己是一个独立的会话首进程。</li><li><strong>后台运行</strong>：在系统后台默默执行任务。</li><li><strong>特定工作目录</strong>：通常将工作目录切换到根目录 (<code>/</code>)，以防其所在的文件系统被卸载。</li><li><strong>特定文件权限掩码</strong>：通常将 umask 设置为 0，以便对创建的文件拥有完全控制权。</li></ol></li><li><strong>创建步骤</strong>：<ol><li><code>fork()</code> 创建子进程，父进程退出。</li><li>子进程调用 <code>setsid()</code> 创建新会话，使自己成为会话首进程、进程组组长，并脱离控制终端。</li><li>调用 <code>chdir(&quot;/&quot;)</code> 改变工作目录到根目录。</li><li>调用 <code>umask(0)</code> 重设文件权限掩码。</li><li>关闭不再需要的文件描述符（特别是标准输入、输出、错误）。</li></ol></li><li><strong>简化函数</strong>：<code>&lt;unistd.h&gt;</code> 提供了 <code>daemon()</code> 函数来简化上述步骤。<ul><li><code>int daemon(int nochdir, int noclose);</code></li><li><code>nochdir</code>: 若为 0，则改变目录到 <code>/</code>。</li><li><code>noclose</code>: 若为 0，则将标准输入、输出、错误重定向到 <code>/dev/null</code>。</li><li>成功返回 0，失败返回-1。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 调用daemon函数，成为守护进程</span></span><br><span class="line">    <span class="comment">// chdir到根目录，关闭标准IO</span></span><br><span class="line">    <span class="keyword">if</span> (daemon(<span class="number">0</span>, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;daemon create failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 守护进程的核心逻辑</span></span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">time_t</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        fp = fopen(<span class="string">&quot;/tmp/daemon_time.log&quot;</span>, <span class="string">&quot;a&quot;</span>); <span class="comment">// 追加模式打开日志文件</span></span><br><span class="line">        <span class="keyword">if</span> (fp) &#123;</span><br><span class="line">            t = time(<span class="literal">NULL</span>);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">&quot;Current Time: %s&quot;</span>, asctime(localtime(&amp;t)));</span><br><span class="line">            fclose(fp);</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行现象</strong>：编译运行后，程序会立即返回，你看不到任何输出。但你可以通过 <code>ps aux | grep a.out</code> 找到这个进程在后台运行，并且 <code>/tmp/daemon_time.log</code> 文件会每秒被写入一次当前时间</p><h3 id="其他的进程相关函数说明"><a class="markdownIt-Anchor" href="#其他的进程相关函数说明"></a> 其他的进程相关函数说明</h3><h4 id="进程创建vfork-函数"><a class="markdownIt-Anchor" href="#进程创建vfork-函数"></a> 进程创建(vfork 函数)</h4><p><code>vfork()</code> 是一个历史遗留的函数，其设计初衷是在 <code>fork()</code> 之后立即调用 <code>exec()</code> 的场景下提供更高的效率。由于现代 Linux 内核对 <code>fork()</code> 实现了“写时复制(Copy-On-Write)”优化，<code>vfork()</code> 的性能优势已不再明显，且其独特的行为容易导致错误，因此<strong>不推荐使用</strong>。</p><p><strong><code>vfork()</code> 与 <code>fork()</code> 的核心区别：</strong></p><ol><li><p><strong>内存复制方式</strong>：</p><ul><li><code>fork()</code>：子进程会获得父进程数据段、堆、栈的<strong>独立副本</strong>（通过写时复制技术实现）。</li><li><code>vfork()</code>：子进程<strong>与父进程共享数据段</strong>。子进程对共享内存（如全局变量）的修改会直接影响到父进程。</li></ul></li><li><p><strong>执行顺序</strong>：</p><ul><li><code>fork()</code>：父子进程的执行顺序由操作系统调度决定，是不确定的。</li><li><code>vfork()</code>：<strong>保证子进程先运行</strong>，父进程会被阻塞，直到子进程调用了 <code>exec()</code> 系列函数或 <code>_exit()</code> 退出。</li></ul></li></ol><p><strong>使用注意</strong>：</p><ul><li>因为共享地址空间，在 <code>vfork()</code> 创建的子进程中，不能从函数 <code>return</code> 或调用 <code>exit()</code>，这会破坏父进程的栈帧。必须使用 <code>_exit()</code> 或 <code>exec()</code> 族函数来结束子进程</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_num = <span class="number">100</span>; <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = vfork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;vfork error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--- 子进程开始执行 ---\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程中：修改前 g_num = %d\n&quot;</span>, g_num);</span><br><span class="line">        g_num = <span class="number">200</span>; <span class="comment">// 修改全局变量</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程中：修改后 g_num = %d\n&quot;</span>, g_num);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--- 子进程退出 ---\n&quot;</span>);</span><br><span class="line">        _exit(<span class="number">0</span>); <span class="comment">// 必须用 _exit()</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 父进程</span></span><br><span class="line">        <span class="comment">// 父进程会等待子进程结束后才执行</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--- 父进程开始执行 ---\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程中：g_num = %d\n&quot;</span>, g_num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--- 子进程开始执行 ---</span><br><span class="line">子进程中：修改前 g_num = 100</span><br><span class="line">子进程中：修改后 g_num = 200</span><br><span class="line">--- 子进程退出 ---</span><br><span class="line">--- 父进程开始执行 ---</span><br><span class="line">父进程中：g_num = 200</span><br></pre></td></tr></table></figure><p>结果清晰地表明：子进程先执行，并且它对 <code>g_num</code> 的修改反映到了父进程中</p><h3 id="进程间的通信"><a class="markdownIt-Anchor" href="#进程间的通信"></a> 进程间的通信</h3><p>在现代操作系统中，为了安全和稳定，每个进程都拥有自己独立的虚拟内存空间。这意味着一个进程无法直接访问另一个进程的内存，这种机制被称为<strong>进程隔离</strong>。</p><p>它保证了一个进程的崩溃不会影响到其他进程，但同时也带来了挑战：进程之间如何协作和交换数据？<img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://image.skyforever.top/blog/2025/10/62f7a9cfd15ef144ea25384c0bd0af20.webp" alt="image"></p><p>很多复杂应用，如 Web 服务器处理用户请求、数据库系统管理并发访问，都需要多个进程协同工作。为了解决进程隔离下的协作问题，操作系统内核提供了一系列官方的、安全可控的“沟通渠道”，即<strong>进程间通信（Inter-Process Communication, IPC）</strong> 机制。</p><p>这些机制本质上都是在内核空间开辟一块共享区域，允许不同进程通过这块区域进行数据交换或同步，如下图所示：<img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://image.skyforever.top/blog/2025/10/4b3f9da5b0f57cd00e3b9121a32d2e39.webp" alt="image"></p><h4 id="有哪些通信方式重点"><a class="markdownIt-Anchor" href="#有哪些通信方式重点"></a> 有哪些通信方式（重点）：</h4><p>Linux 系统提供了多种 IPC 方式，各有其特点和适用场景：</p><ul><li><strong>(1) 文件和文件锁 (File Locking)</strong>: 通过读写共享文件进行通信，使用文件锁同步，速度慢。</li><li><strong>(2) 管道 (Pipe)</strong>: 包括只能用于亲缘进程的<strong>匿名管道</strong>和可用于任意进程的<strong>命名管道 (FIFO)</strong>。</li><li><strong>(3) 信号 (Signal)</strong>: 用于异步通知，不传输数据，类似于系统中断。</li><li><strong>(4) 消息队列 (Message Queue)</strong>: 内核维护的消息链表，适用于结构化、小规模数据通信。 (System V IPC)</li><li><strong>(5) 共享内存 (Shared Memory)</strong>: <strong>最快</strong>的 IPC 方式，将同一块物理内存映射到多个进程，适用于大规模数据交换。 (System V IPC)</li><li><strong>(6) 信号量 (Semaphore)</strong>: 主要用于进程/线程间的同步与互斥，保护共享资源（如共享内存）。 (System V IPC)</li><li><strong>(7) 套接字 (Socket)</strong>: 最通用的 IPC 机制，既可用于本机进程间通信，也可用于网络间通信</li></ul><h4 id="1-文件与文件锁"><a class="markdownIt-Anchor" href="#1-文件与文件锁"></a> (1) 文件与文件锁</h4><p>这是最直观的 IPC 方式。一个进程将数据写入文件，另一个进程从文件中读取。为防止并发读写造成数据损坏，必须使用文件锁。</p><ul><li><strong>原理</strong>：利用文件系统作为公共存储区。</li><li><strong>同步</strong>：<code>flock()</code>函数提供建议性锁。<code>LOCK_EX</code>（独占锁/写锁）保证只有一个进程可以写入，<code>LOCK_SH</code>（共享锁/读锁）允许多个进程同时读取。</li></ul><h5 id="1-flock-函数"><a class="markdownIt-Anchor" href="#1-flock-函数"></a> <strong>1. flock 函数</strong></h5><ul><li><strong>头文件</strong>: <code>#include &lt;sys/file.h&gt;</code></li><li><strong>原型</strong>: <code>int flock(int fd, int operation);</code></li><li><strong><code>operation</code></strong>:<ul><li><code>LOCK_SH</code>: 施加共享锁</li><li><code>LOCK_EX</code>: 施加独占锁</li><li><code>LOCK_UN</code>: 释放锁</li><li><code>LOCK_NB</code>: 与以上选项组合，使调用非阻塞</li></ul></li></ul><h5 id="2-示例代码写进程"><a class="markdownIt-Anchor" href="#2-示例代码写进程"></a> <strong>2. 示例代码：写进程</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// writer.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILE_PATH <span class="string">&quot;/tmp/msg_file.txt&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123; perror(<span class="string">&quot;open&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--- 写进程 (PID: %d) ---\n&quot;</span>, getpid());</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入消息 (输入 &#x27;quit&#x27; 退出): &quot;</span>);</span><br><span class="line">        fgets(buf, <span class="keyword">sizeof</span>(buf), <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">        flock(fd, LOCK_EX); <span class="comment">// 获取写锁</span></span><br><span class="line"></span><br><span class="line">        lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">        ftruncate(fd, <span class="number">0</span>); <span class="comment">// 清空文件</span></span><br><span class="line">        write(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line"></span><br><span class="line">        flock(fd, LOCK_UN); <span class="comment">// 释放锁</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strncmp</span>(buf, <span class="string">&quot;quit&quot;</span>, <span class="number">4</span>) == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-示例代码读进程"><a class="markdownIt-Anchor" href="#3-示例代码读进程"></a> <strong>3. 示例代码：读进程</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reader.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/file.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILE_PATH <span class="string">&quot;/tmp/msg_file.txt&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(FILE_PATH, O_RDONLY | O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123; perror(<span class="string">&quot;open&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--- 读进程 (PID: %d) ---\n&quot;</span>, getpid());</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        flock(fd, LOCK_SH); <span class="comment">// 获取读锁</span></span><br><span class="line"></span><br><span class="line">        lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">        <span class="type">int</span> bytes_read = read(fd, buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (bytes_read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buf[bytes_read] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;读取到: %s&quot;</span>, buf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        flock(fd, LOCK_UN); <span class="comment">// 释放锁</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strncmp</span>(buf, <span class="string">&quot;quit&quot;</span>, <span class="number">4</span>) == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-通过管道-pipe-来通信"><a class="markdownIt-Anchor" href="#2-通过管道-pipe-来通信"></a> <strong>(2)、通过管道 (Pipe) 来通信</strong></h4><p>管道是 Linux 中一种基于文件的 IPC 机制，它在内核中创建一块缓冲区，用于进程间的单向数据传输，遵循“先进先出”（FIFO）原则。</p><h5 id="a-匿名管道-anonymous-pipe"><a class="markdownIt-Anchor" href="#a-匿名管道-anonymous-pipe"></a> <strong>A、匿名管道 (Anonymous Pipe)</strong></h5><h6 id="1-说明"><a class="markdownIt-Anchor" href="#1-说明"></a> <strong>1、说明</strong></h6><ul><li><strong>用途</strong>：只能用于具有<strong>亲缘关系</strong>的进程之间（通常是父子进程）。</li><li><strong>特点</strong>：它没有文件系统中的路径名，存在于内存中，随进程的结束而消失。</li><li><strong>核心</strong>：必须在 <code>fork()</code> <strong>之前</strong>调用 <code>pipe()</code> 创建管道，子进程会继承父进程的文件描述符，从而实现共享。通信时，父子进程通常会各自关闭管道的一个端口（一个关读，一个关写）。</li></ul><h6 id="2-图解"><a class="markdownIt-Anchor" href="#2-图解"></a> <strong>2、图解</strong></h6><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://image.skyforever.top/blog/2025/10/b62a643d9d11037a1a4e83849a90dd1a.webp" alt="image"></p><h6 id="3-pipe-函数的使用"><a class="markdownIt-Anchor" href="#3-pipe-函数的使用"></a> <strong>3、pipe() 函数的使用</strong></h6><p>使用命令：<code>man 2 pipe</code> 查看接口函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数头文件：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数原型：</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   参数一：一个含两个整数的数组。</span></span><br><span class="line"><span class="comment">       pipefd[0]：管道的读取端文件描述符。</span></span><br><span class="line"><span class="comment">       pipefd[1]：管道的写入端文件描述符。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line"><span class="comment">//   成功返回 0，失败返回 -1。</span></span><br></pre></td></tr></table></figure><h6 id="4-示例代码父子进程通信"><a class="markdownIt-Anchor" href="#4-示例代码父子进程通信"></a> <strong>4、示例代码：父子进程通信</strong></h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief   使用匿名管道实现父进程向子进程发送消息。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (pipe(pipe_fd) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe create failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">// 子进程：读取数据</span></span><br><span class="line">        close(pipe_fd[<span class="number">1</span>]); <span class="comment">// 关闭写端</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">        <span class="type">int</span> len = read(pipe_fd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>);</span><br><span class="line">        buf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程收到消息: &#x27;%s&#x27;\n&quot;</span>, buf);</span><br><span class="line">        close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 父进程：写入数据</span></span><br><span class="line">        close(pipe_fd[<span class="number">0</span>]); <span class="comment">// 关闭读端</span></span><br><span class="line">        <span class="type">char</span> *msg = <span class="string">&quot;Message from parent!&quot;</span>;</span><br><span class="line">        write(pipe_fd[<span class="number">1</span>], msg, <span class="built_in">strlen</span>(msg));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程已发送消息。\n&quot;</span>);</span><br><span class="line">        close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">        wait(<span class="literal">NULL</span>); <span class="comment">// 等待子进程结束</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="b-命名管道-named-pipe-fifo"><a class="markdownIt-Anchor" href="#b-命名管道-named-pipe-fifo"></a> <strong>B、命名管道 (Named Pipe / FIFO)</strong></h5><h6 id="1-说明-2"><a class="markdownIt-Anchor" href="#1-说明-2"></a> <strong>1、说明</strong></h6><ul><li><strong>用途</strong>：可以在<strong>任意两个不相关的进程</strong>之间进行通信。</li><li><strong>特点</strong>：它在文件系统中以一个特殊文件的形式存在（文件类型为<code>p</code>），有具体的路径名。只要进程有权限访问这个文件，就可以进行通信。</li><li><strong>阻塞特性</strong>：打开命名管道时，读端会阻塞直到写端被打开，反之亦然。</li></ul><h6 id="2-创建命令与函数"><a class="markdownIt-Anchor" href="#2-创建命令与函数"></a> <strong>2、创建命令与函数</strong></h6><ul><li><strong>终端命令</strong>：<code>mkfifo &lt;管道文件名&gt;</code>，例如 <code>mkfifo /tmp/myfifo</code>。</li><li><strong>mkfifo() 函数</strong>：<code>man 3 mkfifo</code> 查看接口函数。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数头文件：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数原型：</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   参数一：pathname, 管道文件的路径名。</span></span><br><span class="line"><span class="comment">   参数二：mode, 文件权限，如 0666。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line"><span class="comment">//   成功返回 0，失败返回 -1。</span></span><br></pre></td></tr></table></figure><h6 id="3-示例代码不相关进程通信"><a class="markdownIt-Anchor" href="#3-示例代码不相关进程通信"></a> <strong>3、示例代码：不相关进程通信</strong></h6><p><strong>a、写入命名管道 (writer.c)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief   向命名管道写入数据。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_PATH <span class="string">&quot;/tmp/myfifo&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果管道不存在则创建</span></span><br><span class="line">    <span class="keyword">if</span> (access(FIFO_PATH, F_OK) == <span class="number">-1</span>) &#123;</span><br><span class="line">        mkfifo(FIFO_PATH, <span class="number">0666</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;写进程：等待读进程连接...\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> fd = open(FIFO_PATH, O_WRONLY);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;写进程：已连接，发送消息。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *msg = <span class="string">&quot;Hello from FIFO!&quot;</span>;</span><br><span class="line">    write(fd, msg, <span class="built_in">strlen</span>(msg));</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>b、读取命名管道 (reader.c)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief   从命名管道读取数据。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_PATH <span class="string">&quot;/tmp/myfifo&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;读进程：等待写进程连接...\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> fd = open(FIFO_PATH, O_RDONLY);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;读进程：已连接，等待消息。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">    <span class="type">int</span> len = read(fd, buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>);</span><br><span class="line">    buf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;读进程收到消息: &#x27;%s&#x27;\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="comment">// 可选：删除管道文件</span></span><br><span class="line">    <span class="comment">// unlink(FIFO_PATH);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如何运行</strong>：</p><ol><li>编译两个程序：<code>gcc writer.c -o writer</code> 和 <code>gcc reader.c -o reader</code>。</li><li>在一个终端先运行 <code>./reader</code>，它会阻塞。</li><li>在另一个终端再运行 <code>./writer</code>，它会写入数据并退出</li><li>此时，<code>reader</code> 终端会打印出收到的消息并退出</li></ol><h4 id="3-通过信号-signal-来通信"><a class="markdownIt-Anchor" href="#3-通过信号-signal-来通信"></a> <strong>(3)、通过信号 (Signal) 来通信</strong></h4><p>信号是一种<strong>异步</strong>通信机制，用于通知进程某个事件已经发生。它不传输数据，功能类似于一个软件中断，用于进程控制和状态通知。</p><h5 id="1-信号命令与种类"><a class="markdownIt-Anchor" href="#1-信号命令与种类"></a> <strong>1、信号命令与种类</strong></h5><h6 id="a-信号的种类"><a class="markdownIt-Anchor" href="#a-信号的种类"></a> <strong>A、信号的种类</strong></h6><ul><li><strong>查看命令</strong>: <code>man 7 signal</code> 或 <code>kill -l</code></li><li><strong>常用信号</strong>:<ul><li><code>SIGINT (2)</code>: 中断信号 (<code>Ctrl+C</code>)。</li><li><code>SIGKILL (9)</code>: 强制杀死信号，不可被捕捉或忽略。</li><li><code>SIGTERM (15)</code>: 终止信号 (kill 默认发送)。</li><li><code>SIGCHLD (17)</code>: 子进程状态改变。</li><li><code>SIGSTOP (19)</code>: 暂停信号，不可被捕捉或忽略。</li><li><code>SIGALRM (14)</code>: 定时器信号。</li><li><code>SIGUSR1</code>, <code>SIGUSR2</code>: 用户自定义信号。</li></ul></li></ul><h6 id="b-终端发送信号"><a class="markdownIt-Anchor" href="#b-终端发送信号"></a> <strong>B、终端发送信号</strong></h6><ul><li><code>kill -&lt;信号值&gt; &lt;PID&gt;</code>: 向指定进程发送信号。</li><li><code>killall -&lt;信号值&gt; &lt;进程名&gt;</code>: 向所有同名进程发送信号。</li></ul><h5 id="2-信号编程核心函数"><a class="markdownIt-Anchor" href="#2-信号编程核心函数"></a> <strong>2、信号编程核心函数</strong></h5><h6 id="kill-发送信号-man-2-kill"><a class="markdownIt-Anchor" href="#kill-发送信号-man-2-kill"></a> <strong><code>kill()</code>: 发送信号</strong> (<code>man 2 kill</code>)</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure><h6 id="alarm-设置定时器信号-man-2-alarm"><a class="markdownIt-Anchor" href="#alarm-设置定时器信号-man-2-alarm"></a> <strong><code>alarm()</code>: 设置定时器信号</strong> (<code>man 2 alarm</code>)</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>; <span class="comment">// seconds秒后发送 SIGALRM</span></span><br></pre></td></tr></table></figure><h6 id="signal-设置信号处理方式-man-2-signal"><a class="markdownIt-Anchor" href="#signal-设置信号处理方式-man-2-signal"></a> <strong><code>signal()</code>: 设置信号处理方式</strong> (<code>man 2 signal</code>)</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;</span><br><span class="line"><span class="comment">// handler 可以是 SIG_DFL (默认), SIG_IGN (忽略), 或自定义函数地址。</span></span><br></pre></td></tr></table></figure><h5 id="3-示例代码"><a class="markdownIt-Anchor" href="#3-示例代码"></a> <strong>3、示例代码</strong></h5><h6 id="a-处理终止信号-捕捉信号"><a class="markdownIt-Anchor" href="#a-处理终止信号-捕捉信号"></a> <strong>a、处理终止信号 (捕捉信号)</strong></h6><ul><li><strong>用途</strong>：允许程序在收到 <code>Ctrl+C</code> 等终止信号时，执行清理工作（如保存数据）后再优雅地退出。</li><li><strong>说明</strong>：捕捉 <code>SIGINT</code> 和 <code>SIGQUIT</code> 信号。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> running = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">term_handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n收到信号 %d，准备退出...\n&quot;</span>, sig);</span><br><span class="line">    running = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    signal(SIGINT, term_handler); <span class="comment">// 捕捉 Ctrl+C</span></span><br><span class="line">    signal(SIGQUIT, term_handler); <span class="comment">// 捕捉 Ctrl+\</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;程序运行中，按 Ctrl+C 或 Ctrl+\\ 退出。\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(running) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;工作中...\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;执行清理任务...\n&quot;</span>);</span><br><span class="line">    <span class="comment">// ... 清理代码 ...</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;程序已退出。\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="b-处理闹钟信号-捕捉信号"><a class="markdownIt-Anchor" href="#b-处理闹钟信号-捕捉信号"></a> <strong>b、处理闹钟信号 (捕捉信号)</strong></h6><ul><li><strong>用途</strong>：实现超时机制或周期性任务。</li><li><strong>说明</strong>：使用 <code>alarm()</code> 配合 <code>SIGALRM</code> 信号。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">alarm_handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;闹钟触发！执行定时任务。\n&quot;</span>);</span><br><span class="line">    alarm(<span class="number">3</span>); <span class="comment">// 重新设置下一次闹钟，实现周期性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    signal(SIGALRM, alarm_handler);</span><br><span class="line">    alarm(<span class="number">3</span>); <span class="comment">// 3秒后第一次触发</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;已设置3秒周期闹钟，等待触发...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        pause(); <span class="comment">// 等待信号，降低CPU消耗</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="c-忽略信号"><a class="markdownIt-Anchor" href="#c-忽略信号"></a> <strong>c、忽略信号</strong></h6><ul><li><strong>用途</strong>：保护关键进程不被某些信号（如 <code>Ctrl+C</code>）意外中断。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 忽略 SIGINT 信号(ctrl+c、ctrl+\)</span></span><br><span class="line">    signal(SIGINT, SIG_IGN);</span><br><span class="line">	signal(SIGQUIT, SIG_IGN);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;已忽略 Ctrl+C 信号，请尝试按 Ctrl+C。\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请使用 kill -9 %d 强制终止。\n&quot;</span>, getpid());</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="d-处理通信信号"><a class="markdownIt-Anchor" href="#d-处理通信信号"></a> <strong>d、处理通信信号</strong></h6><ul><li><strong>用途</strong>：实现父子进程或任意两个进程间的简单通知。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">child_sig_handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子进程：收到父进程发来的 SIGUSR1 信号！\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">// 子进程</span></span><br><span class="line">        signal(SIGUSR1, child_sig_handler);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程 (PID: %d) 等待信号...\n&quot;</span>, getpid());</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) pause();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 父进程</span></span><br><span class="line">        sleep(<span class="number">1</span>); <span class="comment">// 确保子进程已设置好信号处理</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程：向子进程 %d 发送 SIGUSR1 信号。\n&quot;</span>, pid);</span><br><span class="line">        kill(pid, SIGUSR1);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="e-处理子进程的退出"><a class="markdownIt-Anchor" href="#e-处理子进程的退出"></a> <strong>e、处理子进程的退出</strong></h6><ul><li><strong>用途</strong>：父进程通过 <code>SIGCHLD</code> 信号异步回收子进程资源，避免产生僵尸进程，且父进程无需阻塞。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">child_handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;  <span class="comment">// 信号处理不要太复杂(运算、时间等)</span></span><br><span class="line">  <span class="type">int</span> wait_status = <span class="number">0</span>;         <span class="comment">// 返回的状态</span></span><br><span class="line">  <span class="type">pid_t</span> child_pid;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ((child_pid = waitpid(<span class="number">-1</span>, &amp;wait_status, WNOHANG | WUNTRACED)) &gt;</span><br><span class="line">         <span class="number">0</span>) &#123;  <span class="comment">// 等待任意任意子进程，如果还有子进程需要回收，就一直循环</span></span><br><span class="line">    <span class="keyword">if</span> (WIFEXITED(wait_status)) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;子进程(PID:%d)正常退出，状态:%d\n&quot;</span>, child_pid,</span><br><span class="line">             WEXITSTATUS(wait_status));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (WIFSIGNALED(wait_status)) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;子进程(PID:%d)被信号%d杀死\n&quot;</span>, child_pid, WTERMSIG(wait_status));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (WIFSTOPPED(wait_status)) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;子进程(PID:%d)被信号%d暂停\n&quot;</span>, child_pid, WSTOPSIG(wait_status));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span>* argv[])</span> &#123;</span><br><span class="line">  <span class="type">pid_t</span> pid = fork();</span><br><span class="line">  <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;  <span class="comment">// 创建进程失败</span></span><br><span class="line">    perror(<span class="string">&quot;fork error!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;  <span class="comment">// 子进程</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;子进程(PID: %d)正在运行中.......\n&quot;</span>, getpid());</span><br><span class="line">      sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      i++;</span><br><span class="line">      <span class="keyword">if</span> (i == <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程结束!\n&quot;</span>);</span><br><span class="line">        _exit(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 父进程</span></span><br><span class="line">    <span class="comment">// 使用signal，设置信号处理函数</span></span><br><span class="line">    signal(SIGCHLD, child_handler);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;父进程(PID: %d)正在运行中.......\n&quot;</span>, getpid());</span><br><span class="line">      sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="f-处理自定义工作进程控制"><a class="markdownIt-Anchor" href="#f-处理自定义工作进程控制"></a> <strong>f、处理自定义工作进程控制</strong></h6><ul><li><strong>用途</strong>：使用用户自定义信号 <code>SIGUSR1</code> 和 <code>SIGUSR2</code> 来灵活控制一个工作进程的状态（如暂停/继续/终止）。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> is_paused = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">control_handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sig == SIGUSR1) &#123;</span><br><span class="line">        is_paused = !is_paused; <span class="comment">// 切换暂停/继续状态</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;收到 SIGUSR1, 状态切换为: %s\n&quot;</span>, is_paused ? <span class="string">&quot;暂停&quot;</span> : <span class="string">&quot;继续&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sig == SIGUSR2) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;收到 SIGUSR2, 进程终止。\n&quot;</span>);</span><br><span class="line">        _exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    signal(SIGUSR1, control_handler);</span><br><span class="line">    signal(SIGUSR2, control_handler);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;工作进程 (PID: %d) 已启动。\n&quot;</span>, getpid());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;使用 kill -SIGUSR1 %d 切换暂停/继续。\n&quot;</span>, getpid());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;使用 kill -SIGUSR2 %d 终止进程。\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!is_paused) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;工作中...\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="g-信号控制多线程-暂无"><a class="markdownIt-Anchor" href="#g-信号控制多线程-暂无"></a> <strong>g、信号控制多线程 (暂无)</strong></h6><p><em>(此部分内容待后续线程章节学习后补充)</em></p><h4 id="4-system-v-ipc重点"><a class="markdownIt-Anchor" href="#4-system-v-ipc重点"></a> <strong>(4)、System V IPC</strong>（重点）</h4><p>System V IPC 是一组经典且功能强大的进程间通信机制，包括<strong>消息队列</strong>、<strong>共享内存</strong>和<strong>信号量</strong>。它们共享一套相似的设计哲学和管理方式。</p><h5 id="核心概念与管理"><a class="markdownIt-Anchor" href="#核心概念与管理"></a> <strong>核心概念与管理</strong></h5><h6 id="1-工作流程"><a class="markdownIt-Anchor" href="#1-工作流程"></a> <strong>1. 工作流程</strong></h6><p>所有 System V IPC 机制都遵循相似的步骤：</p><ol><li><strong>创建密钥 (Key)</strong>：使用 <code>ftok()</code> 函数，通过一个已存在的文件路径和项目 ID，生成一个唯一的 <code>key_t</code> 类型的键值。这个键值是不同进程用来访问同一个 IPC 对象的“门牌号”。</li><li><strong>创建/获取 IPC 对象</strong>：使用 <code>msgget()</code>、<code>shmget()</code> 或 <code>semget()</code> 函数，传入密钥来创建新的 IPC 对象，或获取一个已存在的对象的 ID。</li><li><strong>操作 IPC 对象</strong>：使用各自的 API（如 <code>msgsnd/msgrcv</code>, <code>shmat</code>, <code>semop</code>）进行数据交换或同步。</li><li><strong>销毁 IPC 对象</strong>：通信结束后，使用 <code>msgctl()</code>、<code>shmctl()</code> 或 <code>semctl()</code> 来删除 IPC 对象，释放内核资源。</li></ol><h6 id="2-ipc-管理命令"><a class="markdownIt-Anchor" href="#2-ipc-管理命令"></a> <strong>2. IPC 管理命令</strong></h6><ul><li><code>ipcs -a</code>: 查看系统中所有的 IPC 对象（消息队列、共享内存、信号量）。</li><li><code>ipcs -q</code>: 单独查看消息队列。</li><li><code>ipcs -m</code>: 单独查看共享内存。</li><li><code>ipcs -s</code>: 单独查看信号量。</li><li><code>ipcrm -q &lt;id&gt;</code>: 删除指定 ID 的消息队列。</li><li><code>ipcrm -m &lt;id&gt;</code>: 删除指定 ID 的共享内存。</li><li><code>ipcrm -s &lt;id&gt;</code>: 删除指定 ID 的信号量。</li></ul><h6 id="3-ftok-函数创建密钥"><a class="markdownIt-Anchor" href="#3-ftok-函数创建密钥"></a> <strong>3. <code>ftok()</code> 函数：创建密钥</strong></h6><p><code>man 3 ftok</code> 查看接口函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="type">key_t</span> <span class="title function_">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> proj_id)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   参数一：一个已存在的文件路径。</span></span><br><span class="line"><span class="comment">   参数二：项目ID，一个非零整数。</span></span><br><span class="line"><span class="comment">   返回值：成功返回一个 key_t 键值，失败返回 -1。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="a-消息队列-message-queue"><a class="markdownIt-Anchor" href="#a-消息队列-message-queue"></a> <strong>A、消息队列 (Message Queue)</strong></h5><h6 id="1-说明与图解"><a class="markdownIt-Anchor" href="#1-说明与图解"></a> <strong>1. 说明与图解</strong></h6><p>消息队列是存放在内核中的一个<strong>消息链表</strong>，允许一个或多个进程向其发送或接收结构化的消息。它克服了管道只能传输无格式字节流的限制。<img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://image.skyforever.top/blog/2025/10/4a6691c2309896615f671e73ca23ab76.webp" alt="消息队列图解"></p><h6 id="2-核心函数"><a class="markdownIt-Anchor" href="#2-核心函数"></a> <strong>2. 核心函数</strong></h6><ul><li><p><strong><code>msgget()</code>: 创建或获取消息队列 ID</strong> (<code>man 2 msgget</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgflg)</span>;</span><br><span class="line"><span class="comment">// msgflg: 表示创建或打开队列的权限和方式，通常是 IPC_CREAT | 0666</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>msgsnd()</code>: 发送消息</strong> (<code>man 2 msgsnd</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">int</span> msgflg)</span>;</span><br><span class="line"><span class="comment">// 参数分别为： 消息id         消息本体		 消息大小	  发送方式，一般为0</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>msgrcv()</code>: 接收消息</strong> (<code>man 2 msgrcv</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp, <span class="type">int</span> msgflg)</span>;</span><br><span class="line"><span class="comment">// 参数分别为：  消息id        消息本体	   消息大小	     消息类型      发送方式，一般为0</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>msgctl()</code>: 控制消息队列</strong> (<code>man 2 msgctl</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">msgctl</span><span class="params">(<span class="type">int</span> msqid, <span class="type">int</span> cmd, <span class="keyword">struct</span> msqid_ds *buf)</span>;</span><br><span class="line"><span class="comment">// cmd: IPC_RMID 用于删除消息队列</span></span><br></pre></td></tr></table></figure></li></ul><h6 id="3-示例代码-2"><a class="markdownIt-Anchor" href="#3-示例代码-2"></a> <strong>3. 示例代码</strong></h6><ul><li><p><strong>公共结构体定义 (common.h)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_KEY_PATH <span class="string">&quot;.&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_KEY_PROJ_ID <span class="string">&#x27;a&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_buf</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;       <span class="comment">// 消息类型，必须 &gt; 0</span></span><br><span class="line">    <span class="type">char</span> mtext[<span class="number">128</span>];  <span class="comment">// 消息内容</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>发送端 (sender.c)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sender.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(MSG_KEY_PATH, MSG_KEY_PROJ_ID);</span><br><span class="line">    <span class="type">int</span> msqid = msgget(key, IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_buf</span> <span class="title">msg</span> =</span> &#123;<span class="number">1</span>, <span class="string">&quot;Hello from sender!&quot;</span>&#125;; <span class="comment">// 消息类型为 1</span></span><br><span class="line">    msgsnd(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;消息已发送。\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>接收端 (receiver.c)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// receiver.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(MSG_KEY_PATH, MSG_KEY_PROJ_ID);</span><br><span class="line">    <span class="type">int</span> msqid = msgget(key, IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_buf</span> <span class="title">msg</span>;</span></span><br><span class="line">    msgrcv(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">1</span>, <span class="number">0</span>); <span class="comment">// 接收类型为 1 的消息</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;收到消息: %s\n&quot;</span>, msg.mtext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除消息队列</span></span><br><span class="line">    msgctl(msqid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="b-共享内存-shared-memory"><a class="markdownIt-Anchor" href="#b-共享内存-shared-memory"></a> <strong>B、共享内存 (Shared Memory)</strong></h5><h6 id="1-说明与图解-2"><a class="markdownIt-Anchor" href="#1-说明与图解-2"></a> <strong>1. 说明与图解</strong></h6><p>共享内存是<strong>最快</strong>的 IPC 方式。它将一块物理内存映射到多个进程的虚拟地址空间中，进程可以直接像访问普通变量一样读写这块内存，无需内核介入数据拷贝。<img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://image.skyforever.top/blog/2025/10/a69520f5a428e24bd0a3a68b8e089709.webp" alt="共享内存图解"></p><h6 id="2-核心函数-2"><a class="markdownIt-Anchor" href="#2-核心函数-2"></a> <strong>2. 核心函数</strong></h6><ul><li><p><strong><code>shmget()</code>: 创建或获取共享内存 ID</strong> (<code>man 2 shmget</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br><span class="line"><span class="comment">// size: 共享内存大小，通常是页大小的整数倍。</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>shmat()</code>: 映射共享内存到进程地址空间</strong> (<code>man 2 shmat</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br><span class="line"><span class="comment">// 返回值是映射到本进程的内存地址指针。</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>shmdt()</code>: 解除映射</strong> (<code>man 2 shmdt</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>shmctl()</code>: 控制共享内存</strong> (<code>man 2 shmctl</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br><span class="line"><span class="comment">// cmd: IPC_RMID 用于删除共享内存段。</span></span><br></pre></td></tr></table></figure></li></ul><h6 id="3-示例代码-3"><a class="markdownIt-Anchor" href="#3-示例代码-3"></a> <strong>3. 示例代码</strong></h6><ul><li><p><strong>写进程 (writer.c)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// writer.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(<span class="string">&quot;.&quot;</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">    <span class="type">int</span> shmid = shmget(key, <span class="number">1024</span>, IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *shm_ptr = (<span class="type">char</span> *)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(shm_ptr, <span class="string">&quot;Hello from shared memory!&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数据已写入共享内存。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    shmdt(shm_ptr); <span class="comment">// 解除映射</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>读进程 (reader.c)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reader.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(<span class="string">&quot;.&quot;</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">    <span class="type">int</span> shmid = shmget(key, <span class="number">1024</span>, IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *shm_ptr = (<span class="type">char</span> *)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;从共享内存读取数据: %s\n&quot;</span>, shm_ptr);</span><br><span class="line"></span><br><span class="line">    shmdt(shm_ptr); <span class="comment">// 解除映射</span></span><br><span class="line">    shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>); <span class="comment">// 删除共享内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="c-信号量-semaphore"><a class="markdownIt-Anchor" href="#c-信号量-semaphore"></a> <strong>C、信号量 (Semaphore)</strong></h5><h6 id="1-说明-3"><a class="markdownIt-Anchor" href="#1-说明-3"></a> <strong>1. 说明</strong></h6><p>信号量本质上是一个<strong>计数器</strong>，主要用于<strong>进程间的同步与互斥</strong>，以保护共享资源（如共享内存）不被并发访问破坏。它本身不传输数据。</p><ul><li><strong>互斥</strong>：确保同一时间只有一个进程能访问临界资源（如厕所只有一把钥匙）。</li><li><strong>同步</strong>：协调多个进程的执行顺序（如生产者生产完，才能通知消费者消费）。</li><li><strong>PV 操作</strong>：<ul><li><strong>P 操作 (<code>sem_wait</code>)</strong>: 申请资源，信号量计数值减 1。如果计数值为 0，则进程阻塞。</li><li><strong>V 操作 (<code>sem_post</code>)</strong>: 释放资源，信号量计数值加 1。</li></ul></li></ul><h6 id="2-posix-有名信号量"><a class="markdownIt-Anchor" href="#2-posix-有名信号量"></a> <strong>2. POSIX 有名信号量</strong></h6><p>这是比 System V 信号量更现代、更易用的接口，常用于进程间同步。它在 <code>/dev/shm/</code> 目录下创建一个文件来表示信号量。</p><h6 id="3-核心函数-编译时需链接-pthread"><a class="markdownIt-Anchor" href="#3-核心函数-编译时需链接-pthread"></a> <strong>3. 核心函数 (编译时需链接 <code>-pthread</code>)</strong></h6><ul><li><p><strong><code>sem_open()</code>: 创建或打开有名信号量</strong> (<code>man 3 sem_open</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">sem_t</span> *<span class="title function_">sem_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> oflag, <span class="type">mode_t</span> mode, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="comment">// name: 信号量名称，格式为 &quot;/somename&quot;。</span></span><br><span class="line"><span class="comment">// oflag: O_CREAT 创建, O_EXCL 确保是新创建。</span></span><br><span class="line"><span class="comment">// value: 信号量初始值。</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>sem_wait()</code>: P 操作 (加锁)</strong> (<code>man 3 sem_wait</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>sem_post()</code>: V 操作 (解锁)</strong> (<code>man 3 sem_post</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>sem_close()</code>: 关闭信号量</strong> (<code>man 3 sem_close</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_close</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>sem_unlink()</code>: 删除有名信号量</strong> (<code>man 3 sem_unlink</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure></li></ul><h6 id="4-示例代码使用信号量保护共享内存"><a class="markdownIt-Anchor" href="#4-示例代码使用信号量保护共享内存"></a> <strong>4. 示例代码：使用信号量保护共享内存</strong></h6><ul><li><p><strong>公共头文件 (common.h)</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common.h</span></span><br><span class="line"><span class="meta">#include &lt;semaphore.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHM_KEY_PATH &quot;.&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHM_KEY_PROJ_ID &#x27;c&#x27;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEM_NAME &quot;/my_semaphore&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>初始化进程 (init.c)</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init.c</span></span><br><span class="line"><span class="meta">#include &quot;common.h&quot;</span></span><br><span class="line"><span class="comment">// (包含 shmget/shmat/sem_open 等创建和初始化代码)</span></span><br><span class="line"><span class="comment">// sem_t *sem = sem_open(SEM_NAME, O_CREAT, 0666, 1); // 初始值为1，用于互斥</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用共享资源的进程 (proc.c)</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// proc.c</span></span><br><span class="line"><span class="meta">#include &quot;common.h&quot;</span></span><br><span class="line"><span class="meta">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="meta">#include &lt;sys/shm.h&gt;</span></span><br><span class="line"><span class="meta">#include &lt;unistd.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>()</span> &#123;</span><br><span class="line">    key_t key = ftok(SHM_KEY_PATH, SHM_KEY_PROJ_ID);</span><br><span class="line">    <span class="built_in">int</span> shmid = shmget(key, <span class="keyword">sizeof</span>(<span class="built_in">int</span>), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">int</span> *shared_counter = (<span class="built_in">int</span> *)shmat(shmid, NULL, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    sem_t *sem = sem_open(SEM_NAME, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        sem_wait(sem); <span class="comment">// P操作：加锁</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// --- 临界区开始 ---</span></span><br><span class="line">        <span class="built_in">int</span> temp = *shared_counter;</span><br><span class="line">        printf(<span class="string">&quot;PID %d: read %d, &quot;</span>, getpid(), temp);</span><br><span class="line">        temp++;</span><br><span class="line">        sleep(<span class="number">1</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        *shared_counter = temp;</span><br><span class="line">        printf(<span class="string">&quot;write %d\n&quot;</span>, *shared_counter);</span><br><span class="line">        <span class="comment">// --- 临界区结束 ---</span></span><br><span class="line"></span><br><span class="line">        sem_post(sem); <span class="comment">// V操作：解锁</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shmdt(shared_counter);</span><br><span class="line">    sem_close(sem);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如何运行</strong>：先运行一个程序初始化共享内存（设为 0）和信号量（设为 1）。然后同时运行多个 <code>proc</code> 实例。你会看到，由于信号量的保护，共享计数器会从 0、1、2…有序地增加，而不会出现多个进程同时读到相同值导致的“竞争条件”。</p></li></ul><div class="tag-list"><a class="tag" href="/note/ES/tags/%E8%BF%9B%E9%98%B6/linux%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E8%BF%9B%E7%A8%8B/">进阶/Linux并发编程/进程</a></div></article><div class="article-footer"><section id="license"><div class="header"><span>许可协议</span></div><div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p></div></section><section id="share"><div class="header"><span>分享文章</span></div><div class="body"><div class="link"><input class="copy-area" readonly id="copy-link" value="http://skyforever.top/data/ES/%E8%BF%9B%E9%98%B6/%E8%BF%9B%E7%A8%8B"></div><div class="social-wrap dis-select"><a class="social share-item wechat" onclick="util.toggle(&quot;qrcode-wechat&quot;)"><img src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/b32ef3da1162a.svg"></a><a class="social share-item weibo" target="_blank" rel="external nofollow noopener noreferrer" href="https://service.weibo.com/share/share.php?url=http://skyforever.top/data/ES/%E8%BF%9B%E9%98%B6/%E8%BF%9B%E7%A8%8B&title=Linux 进程管理与调度 - Sky Blog&summary=本文详细探讨了 Linux 进程的管理与调度机制，包括进程的创建、状态管理、调度算法等核心概念，并提供代码示例"><img src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/80c07e4dbb303.svg"></a><a class="social share-item email" href="mailto:?subject=Linux 进程管理与调度 - Sky Blog&amp;body=http://skyforever.top/data/ES/%E8%BF%9B%E9%98%B6/%E8%BF%9B%E7%A8%8B"><img src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/a1b00e20f425d.svg"></a><a class="social share-item link" onclick="util.copy(&quot;copy-link&quot;, &quot;复制成功&quot;)"><img src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/8411ed322ced6.svg"></a></div><div class="qrcode" id="qrcode-wechat" style="opacity:0;height:0"><img src="https://api.qrserver.com/v1/create-qr-code/?size=256x256&data=http://skyforever.top/data/ES/%E8%BF%9B%E9%98%B6/%E8%BF%9B%E7%A8%8B"></div></div></section></div><div class="related-wrap md-text" id="comments"><section class="header cmt-title cap theme"><p>快来参与讨论吧~</p></section><section class="body cmt-body giscus"><svg class="loading" style="vertical-align:middle;fill:currentColor;overflow:hidden" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg><div id="giscus" src="https://giscus.app/client.js" data-repo="zhangwei43721/zhangwei43721.github.io" data-repo-id="R_kgDOOC101w" data-category="Announcements" data-category-id="DIC_kwDOOC10184Cv2Lm" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous"></div></section></div><footer class="page-footer footnote"><hr><div class="sitemap" style="column-count:3"><div class="sitemap-group"><span class="fs15">博客</span><a href="/">近期发布</a><a href="/categories/">分类</a><a href="/tags/">标签</a><a href="/archives/">归档</a></div><div class="sitemap-group"><span class="fs15">项目</span><a href="/wiki/LVGL-CarDashboard/">车载仪表盘</a><a href="/wiki/Smart_Home_System/">智能家居系统</a></div><div class="sitemap-group"><span class="fs15">笔记</span><a href="/note/college/">大学笔记</a><a href="/note/ES/">嵌入式笔记</a></div></div><div class="text"><p>本站由 <a href="/">Skyforever</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.33.1">Stellar 1.33.1</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p><p><img src="https://image.skyforever.top/blog/2025/10/7c7d60c27511edf9f4ae10cb62c8f4ae.png" width="13" height="13"> <a target="_blank" rel="noopener" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=51142102511609">川公网安备51142102511609</a> <a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">蜀ICP备2024105035号</a></p></div></footer><div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right"><div class="widgets"><widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%9F%BA%E7%A1%80"><span class="toc-text">进程的概念及基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">程序和进程的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-text">进程的相关命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%8A%B6%E6%80%81%E9%87%8D%E7%82%B9img"><span class="toc-text">进程的生命周期状态（重点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%9B%B8%E5%85%B3-api-%E5%92%8C%E8%AF%B4%E6%98%8E"><span class="toc-text">进程的相关 API 和说明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BAfork-%E5%87%BD%E6%95%B0"><span class="toc-text">进程的创建（fork 函数）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9B%9E%E6%94%B6wait-waitpid-%E7%8A%B6%E6%80%81%E5%80%BC"><span class="toc-text">进程的回收（wait, waitpid, 状态值）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-wait-%E5%87%BD%E6%95%B0"><span class="toc-text">1. wait() 函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-waitpid-%E5%87%BD%E6%95%B0"><span class="toc-text">2. waitpid() 函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E8%8E%B7%E5%8F%96%E5%AD%90%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81"><span class="toc-text">3. 获取子进程退出状态</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%80%E5%87%BAreturn-exit-_exit"><span class="toc-text">进程的退出（return, exit, _Exit）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">多进程的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A0%E8%BD%BDsystem-popen-exec-%E7%B3%BB%E5%88%97%E5%87%BD%E6%95%B0"><span class="toc-text">程序的加载（system, popen, exec 系列函数）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-system-%E5%87%BD%E6%95%B0"><span class="toc-text">1. system() 函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-popen-%E5%92%8C-pclose-%E5%87%BD%E6%95%B0"><span class="toc-text">2. popen() 和 pclose() 函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-exec-%E7%B3%BB%E5%88%97%E5%87%BD%E6%95%B0"><span class="toc-text">3. exec 系列函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB%E9%87%8D%E7%82%B9"><span class="toc-text">进程的关系（重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="toc-text">(1) 父子进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="toc-text">(2) 孤儿进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="toc-text">(3) 僵尸进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E7%B2%BE%E7%81%B5%E8%BF%9B%E7%A8%8B"><span class="toc-text">(4) 守护进程 (精灵进程)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="toc-text">其他的进程相关函数说明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BAvfork-%E5%87%BD%E6%95%B0"><span class="toc-text">进程创建(vfork 函数)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-text">进程间的通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E9%87%8D%E7%82%B9"><span class="toc-text">有哪些通信方式（重点）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%96%87%E4%BB%B6%E4%B8%8E%E6%96%87%E4%BB%B6%E9%94%81"><span class="toc-text">(1) 文件与文件锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-flock-%E5%87%BD%E6%95%B0"><span class="toc-text">1. flock 函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E5%86%99%E8%BF%9B%E7%A8%8B"><span class="toc-text">2. 示例代码：写进程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E8%AF%BB%E8%BF%9B%E7%A8%8B"><span class="toc-text">3. 示例代码：读进程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%80%9A%E8%BF%87%E7%AE%A1%E9%81%93-pipe-%E6%9D%A5%E9%80%9A%E4%BF%A1"><span class="toc-text">(2)、通过管道 (Pipe) 来通信</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93-anonymous-pipe"><span class="toc-text">A、匿名管道 (Anonymous Pipe)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E8%AF%B4%E6%98%8E"><span class="toc-text">1、说明</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E5%9B%BE%E8%A7%A3"><span class="toc-text">2、图解</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-pipe-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">3、pipe() 函数的使用</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-text">4、示例代码：父子进程通信</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93-named-pipe-fifo"><span class="toc-text">B、命名管道 (Named Pipe &#x2F; FIFO)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E8%AF%B4%E6%98%8E-2"><span class="toc-text">1、说明</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA%E5%91%BD%E4%BB%A4%E4%B8%8E%E5%87%BD%E6%95%B0"><span class="toc-text">2、创建命令与函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%B8%8D%E7%9B%B8%E5%85%B3%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-text">3、示例代码：不相关进程通信</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%80%9A%E8%BF%87%E4%BF%A1%E5%8F%B7-signal-%E6%9D%A5%E9%80%9A%E4%BF%A1"><span class="toc-text">(3)、通过信号 (Signal) 来通信</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BF%A1%E5%8F%B7%E5%91%BD%E4%BB%A4%E4%B8%8E%E7%A7%8D%E7%B1%BB"><span class="toc-text">1、信号命令与种类</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#a-%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-text">A、信号的种类</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#b-%E7%BB%88%E7%AB%AF%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7"><span class="toc-text">B、终端发送信号</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BF%A1%E5%8F%B7%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0"><span class="toc-text">2、信号编程核心函数</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#kill-%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7-man-2-kill"><span class="toc-text">kill(): 发送信号 (man 2 kill)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#alarm-%E8%AE%BE%E7%BD%AE%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BF%A1%E5%8F%B7-man-2-alarm"><span class="toc-text">alarm(): 设置定时器信号 (man 2 alarm)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#signal-%E8%AE%BE%E7%BD%AE%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F-man-2-signal"><span class="toc-text">signal(): 设置信号处理方式 (man 2 signal)</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-text">3、示例代码</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#a-%E5%A4%84%E7%90%86%E7%BB%88%E6%AD%A2%E4%BF%A1%E5%8F%B7-%E6%8D%95%E6%8D%89%E4%BF%A1%E5%8F%B7"><span class="toc-text">a、处理终止信号 (捕捉信号)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#b-%E5%A4%84%E7%90%86%E9%97%B9%E9%92%9F%E4%BF%A1%E5%8F%B7-%E6%8D%95%E6%8D%89%E4%BF%A1%E5%8F%B7"><span class="toc-text">b、处理闹钟信号 (捕捉信号)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#c-%E5%BF%BD%E7%95%A5%E4%BF%A1%E5%8F%B7"><span class="toc-text">c、忽略信号</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#d-%E5%A4%84%E7%90%86%E9%80%9A%E4%BF%A1%E4%BF%A1%E5%8F%B7"><span class="toc-text">d、处理通信信号</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#e-%E5%A4%84%E7%90%86%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%80%E5%87%BA"><span class="toc-text">e、处理子进程的退出</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#f-%E5%A4%84%E7%90%86%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B7%A5%E4%BD%9C%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-text">f、处理自定义工作进程控制</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#g-%E4%BF%A1%E5%8F%B7%E6%8E%A7%E5%88%B6%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E6%9A%82%E6%97%A0"><span class="toc-text">g、信号控制多线程 (暂无)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-system-v-ipc%E9%87%8D%E7%82%B9"><span class="toc-text">(4)、System V IPC（重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%AE%A1%E7%90%86"><span class="toc-text">核心概念与管理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">1. 工作流程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-ipc-%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4"><span class="toc-text">2. IPC 管理命令</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-ftok-%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E5%AF%86%E9%92%A5"><span class="toc-text">3. ftok() 函数：创建密钥</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#a-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-message-queue"><span class="toc-text">A、消息队列 (Message Queue)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E8%AF%B4%E6%98%8E%E4%B8%8E%E5%9B%BE%E8%A7%A3"><span class="toc-text">1. 说明与图解</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0"><span class="toc-text">2. 核心函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-2"><span class="toc-text">3. 示例代码</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98-shared-memory"><span class="toc-text">B、共享内存 (Shared Memory)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E8%AF%B4%E6%98%8E%E4%B8%8E%E5%9B%BE%E8%A7%A3-2"><span class="toc-text">1. 说明与图解</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0-2"><span class="toc-text">2. 核心函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-3"><span class="toc-text">3. 示例代码</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#c-%E4%BF%A1%E5%8F%B7%E9%87%8F-semaphore"><span class="toc-text">C、信号量 (Semaphore)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E8%AF%B4%E6%98%8E-3"><span class="toc-text">1. 说明</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-posix-%E6%9C%89%E5%90%8D%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">2. POSIX 有名信号量</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0-%E7%BC%96%E8%AF%91%E6%97%B6%E9%9C%80%E9%93%BE%E6%8E%A5-pthread"><span class="toc-text">3. 核心函数 (编译时需链接 -pthread)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%BF%9D%E6%8A%A4%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-text">4. 示例代码：使用信号量保护共享内存</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div><div class="widget-footer"><a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="1.5"><path stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/><path d="M7 3.338A9.95 9.95 0 0 1 12 2c5.523 0 10 4.477 10 10s-4.477 10-10 10S2 17.523 2 12c0-1.821.487-3.53 1.338-5"/></g></svg><span>回到顶部</span></a><a class="buttom" onclick="util.scrollComment()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="1.5" d="M8 10.5h8M8 14h5.5M17 3.338A9.95 9.95 0 0 0 12 2C6.477 2 2 6.477 2 12c0 1.6.376 3.112 1.043 4.453c.178.356.237.763.134 1.148l-.595 2.226a1.3 1.3 0 0 0 1.591 1.592l2.226-.596a1.63 1.63 0 0 1 1.149.133A9.96 9.96 0 0 0 12 22c5.523 0 10-4.477 10-10c0-1.821-.487-3.53-1.338-5"/></svg><span>参与讨论</span></a></div></widget></div></aside><div class="float-panel"><button type="button" style="display:none" class="laptop-only rightbar-toggle mobile" onclick="sidebar.rightbar()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></button> <button type="button" style="display:none" class="mobile-only leftbar-toggle mobile" onclick="sidebar.leftbar()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg></button></div></div><div class="scripts"><script>window.canonical={originalHost:null,officialHosts:["localhost"],encoded:""};let ctx={date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前"},root:"/",tag_plugins:{chat:Object.assign({api:"https://siteinfo.listentothewind.cn/api/v1"})},search:{}};if((ctx.search.service="local_search")==ctx.search.service){let e=Object.assign({},'{"field":"all","path":"/search.json","content":true,"skip_search":null,"sort":"-date"}');ctx.search[ctx.search.service]=e}let def={avatar:"https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg",cover:"https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg",loading:"https://api.iconify.design/eos-icons:three-dots-loading.svg?color=%231cd0fd"},deps={jquery:"https://gcore.jsdelivr.net/npm/jquery@3.7/dist/jquery.min.js",marked:"https://gcore.jsdelivr.net/npm/marked@13.0/lib/marked.umd.min.js",lazyload:"/%5Bobject%20Object%5D"}</script><script>function RunItem(){function o(e,t){this.name=t||e.name,this.run=()=>{try{e()}catch(e){console.log(e)}}}this.list=[],this.start=()=>{for(var e=0;e<this.list.length;e++)this.list[e].run()},this.push=(e,t,r=!0)=>{let i=e,s=new o(i=r?()=>{utils.requestAnimationFrame(e)}:i,t);this.list.push(s)},this.remove=t=>{for(let e=0;e<this.list.length;e++)this.list[e].name==t&&this.list.splice(e,1)}}let utils={css:(e,t,r,i)=>{var s,o,a=window.document,n=a.createElement("link"),l=(o=t||(s=(a.body||a.getElementsByTagName("head")[0]).childNodes)[s.length-1],a.styleSheets);if(i)for(var d in i)i.hasOwnProperty(d)&&n.setAttribute(d,i[d]);n.rel="stylesheet",n.href=e,n.media="only x",function e(t){if(a.body)return t();setTimeout(function(){e(t)})}(function(){o.parentNode.insertBefore(n,t?o:o.nextSibling)});function u(e){for(var t=n.href,r=l.length;r--;)if(l[r].href===t)return e();setTimeout(function(){u(e)})}function h(){n.addEventListener&&n.removeEventListener("load",h),n.media=r||"all"}return n.addEventListener&&n.addEventListener("load",h),n.onloadcssdefined=u,u(h),n},js:(s,o)=>new Promise((t,e)=>{var r=document.createElement("script");if(s.startsWith("/")&&(s=ctx.root+s.substring(1)),r.src=s,o)for(var i of Object.keys(o))r[i]=o[i];else r.async=!0;r.onerror=e,r.onload=r.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(r.onload=r.onreadystatechange=null,t())},document.head.appendChild(r)}),jq:e=>{"undefined"==typeof jQuery?utils.js(deps.jquery).then(e):e()},onLoading:e=>{e&&$(e).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>')},onLoadSuccess:e=>{e&&$(e).find(".loading-wrap").remove()},onLoadFailure:e=>{e&&($(e).find(".loading-wrap svg").remove(),$(e).find(".loading-wrap").append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>'),$(e).find(".loading-wrap").addClass("error"))},request:(a,e,n,l)=>{let d=0;return new Promise((i,s)=>{let o=()=>{utils.onLoading?.(a);let t=!1,r=setTimeout(()=>{t=!0,console.warn("[request] 超时:",e),3<=++d?(utils.onLoadFailure?.(a),l?.(),s("请求超时")):setTimeout(o,1e3)},5e3);fetch(e).then(e=>{if(!t){if(clearTimeout(r),e.ok)return e;throw new Error("响应失败")}}).then(e=>{t||(utils.onLoadSuccess?.(a),n(e),i(e))}).catch(e=>{clearTimeout(r),console.warn("[request] 错误:",e),3<=++d?(utils.onLoadFailure?.(a),l?.(),s(e)):setTimeout(o,1e3)})};o()})},requestWithoutLoading:(e,a={},n=2,l=5e3)=>new Promise((r,i)=>{let s=0,o=()=>{let t=setTimeout(()=>{++s>n?i("timeout"):o()},l);fetch(e,a).then(e=>{if(clearTimeout(t),!e.ok)throw new Error("bad response");r(e)}).catch(e=>{clearTimeout(t),++s>n?i(e):setTimeout(o,500)})};o()}),requestAnimationFrame:e=>{window.requestAnimationFrame||(window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame),window.requestAnimationFrame(e)},dark:{}};utils.dark.method={toggle:new RunItem},utils.dark=Object.assign(utils.dark,{push:utils.dark.method.toggle.push})</script><script>let sidebar={leftbar:()=>{l_body&&(l_body.toggleAttribute("leftbar"),l_body.removeAttribute("rightbar"))},rightbar:()=>{l_body&&(l_body.toggleAttribute("rightbar"),l_body.removeAttribute("leftbar"))},dismiss:()=>{l_body&&(l_body.removeAttribute("leftbar"),l_body.removeAttribute("rightbar"))},toggleTOC:()=>{document.querySelector("#data-toc").classList.toggle("collapse")}}</script><script>(()=>{var e;for(e of document.querySelectorAll(".tag-subtree.parent-tag > a > .tag-switcher-wrapper"))e.addEventListener("click",e=>{e.target.closest(".tag-subtree.parent-tag").classList.toggle("expanded"),e.preventDefault()});var t=new URLSearchParams(window.location.search).get("tag");if(t){let e=document.querySelector(`.tag-subtree[data-tag="${t}"]`);if(e)for(e.querySelector("a").classList.add("active");e;)e.classList.add("expanded"),e=e.parentElement.closest(".tag-subtree.parent-tag")}})()</script><script async src="https://gcore.jsdelivr.net/npm/vanilla-lazyload@19.1/dist/lazyload.min.js"></script><script>window.lazyLoadOptions={elements_selector:".lazy",callback_loaded:e=>{e.classList.add("loaded");e=e.closest(".lazy-box")?.querySelector(".lazy-icon");e&&e.remove()}},window.addEventListener("LazyLoad::Initialized",function(e){window.lazyLoadInstance=e.detail.instance},!1),document.addEventListener("DOMContentLoaded",function(){window.lazyLoadInstance?.update()}),window.wrapLazyloadImages=e=>{(e="string"==typeof e?document.querySelector(e):e)&&(e.querySelectorAll("img").forEach(e=>{var a,t,d;e.classList.contains("lazy")||(d=e.getAttribute("src"))&&((a=document.createElement("div")).className="lazy-box",(t=e.cloneNode()).removeAttribute("src"),t.setAttribute("data-src",d),t.classList.add("lazy"),(d=document.createElement("div")).className="lazy-icon",def.loading&&(d.style.backgroundImage=`url("${def.loading}")`),a.appendChild(t),a.appendChild(d),e.replaceWith(a))}),window.lazyLoadInstance?.update)&&window.lazyLoadInstance.update()}</script><script src="/js/main.js?v=1.33.1" defer></script><script>let applyTheme=e=>{"auto"===e?document.documentElement.removeAttribute("data-theme"):document.documentElement.setAttribute("data-theme",e)},applyThemeToGiscus=e=>{var t=document.getElementById("giscus"),t=(t&&t.setAttribute("data-theme",e),document.querySelector("#comments > section.giscus > iframe"));t&&(e=t.src.replace(/theme=[\w]+/,"theme="+e),t.src=e)},switchTheme=()=>{let e;switch(document.documentElement.getAttribute("data-theme")){case"light":e="dark";break;case"dark":e="auto";break;default:e="light"}applyTheme(e),window.localStorage.setItem("Stellar.theme",e),utils.dark.mode="auto"===e?window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light":e,utils.dark.method.toggle.start(),hud?.toast?.({light:"切换到浅色模式",dark:"切换到深色模式",auto:"切换到跟随系统配色"}[e])};(()=>{var e=window.localStorage.getItem("Stellar.theme");null!==e?applyTheme(e):utils.dark.mode=window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light",utils.dark.method.toggle.start()})()</script><script type="module">const el = document.querySelector('#comments #giscus');
  util.viewportLazyload(el, load_discus, false);

  function load_discus() {
    if (!el) return;
    try {
        el.innerHTML = '';
      } catch (error) {
        console.error(error);
      }
      const script = document.createElement('script');
      script.async = true;
      for (const key of Object.keys(el.attributes)) {
        const attr = el.attributes[key];
        if (['class', 'id'].includes(attr.name) === false) {
          script.setAttribute(attr.name, attr.value);
        }
      }
      el.appendChild(script);
  }</script><script defer>window.addEventListener("DOMContentLoaded",e=>{ctx.services=Object.assign({},JSON.parse('{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"rating":{"js":"/js/services/rating.js","api":"https://star-vote.xaox.cc/api/rating"},"vote":{"js":"/js/services/vote.js","api":"https://star-vote.xaox.cc/api/vote"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"friends_and_posts":{"js":"/js/services/friends_and_posts.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"},"voice":{"js":"/js/plugins/voice.js"},"video":{"js":"/js/plugins/video.js"},"download-file":{"js":"/js/plugins/download-file.js"},"twikoo":{"js":"/js/services/twikoo_latest_comment.js"},"waline":{"js":"/js/services/waline_latest_comment.js"},"artalk":{"js":"/js/services/artalk_latest_comment.js"},"giscus":{"js":"/js/services/giscus_latest_comment.js"},"contributors":{"edit_this_page":{"_posts/":null,"wiki/stellar/":"https://github.com/xaoxuu/hexo-theme-stellar-docs/blob/main/"},"js":"/js/services/contributors.js"}}'));for(let s of Object.keys(ctx.services)){let e=ctx.services[s].js;"siteinfo"==s?(ctx.cardlinks=document.querySelectorAll("a.link-card[cardlink]"),0<ctx.cardlinks?.length&&utils.js(e,{defer:!0}).then(function(){setCardLink(ctx.cardlinks)})):"voice"==s?(ctx.voiceAudios=document.querySelectorAll(".voice>audio"),0<ctx.voiceAudios?.length&&utils.js(e,{defer:!0}).then(function(){createVoiceDom(ctx.voiceAudios)})):"video"==s?(ctx.videos=document.querySelectorAll(".video>video"),0<ctx.videos?.length&&utils.js(e,{defer:!0}).then(function(){videoEvents(ctx.videos)})):"download-file"==s?(ctx.files=document.querySelectorAll(".file"),0<ctx.files?.length&&utils.js(e,{defer:!0}).then(function(){downloadFileEvent(ctx.files)})):0<document.getElementsByClassName("ds-"+s)?.length&&utils.jq(()=>{s,utils.js(deps.marked).then(function(){utils.js(e,{defer:!0})})})}let o=document.querySelectorAll(".chat .status-bar .time");var s,t;function i(){for(let e=0;e<o.length;++e){var s=o[e],t=new Date,i=t.getHours(),t=t.getMinutes();s.innerHTML=n(i)+":"+n(t)}}function n(e){return e<10?"0"+e:e}0<o.length&&(i(),s=(new Date).getSeconds(),t=setInterval(function(){i(),clearInterval(t),setInterval(i,6e4)},1e3*(60-s)));let c=new IntersectionObserver((e,t)=>{e.filter(e=>e.isIntersecting).sort((e,s)=>e.intersectionRect.y!==s.intersectionRect.y?e.intersectionRect.y-s.intersectionRect.y:e.intersectionRect.x-s.intersectionRect.x).forEach((e,s)=>{t.unobserve(e.target),setTimeout(()=>{e.target.classList.add("quote-blink"),setTimeout(()=>{e.target.classList.remove("quote-blink")},1e3)},Math.max(100,16)*(s+1))})}),r=document.querySelectorAll(".chat .talk .quote");r.forEach(i=>{i.addEventListener("click",function(){var e,s,t=document.getElementById("quote-"+i.getAttribute("quotedCellTag"));t&&(s=(e=t.parentElement).clientHeight/2,t.offsetTop>s-t.clientHeight/2?e.scrollTo({top:t.offsetTop-s+t.clientHeight/2,behavior:"smooth"}):e.scrollTo({top:0,behavior:"smooth"}),c.observe(t))})})})</script><script>window.addEventListener("DOMContentLoaded",e=>{ctx.search={path:"/search.json"},utils.js("/js/search/local-search.js",{defer:!0})})</script><script>window.FPConfig={delay:0,ignoreKeywords:[],maxRPS:5,hoverDelay:25}</script><script defer src="https://gcore.jsdelivr.net/npm/flying-pages@2/flying-pages.min.js"></script><script>ctx.fancybox={selector:'.md-text img[alt]:not([alt="icon"]):not([alt="cover"])',css:"https://gcore.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css",js:"https://gcore.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js"};var selector="[data-fancybox]:not(.error), .with-fancybox .atk-content img:not([atk-emoticon])",needFancybox=(ctx.fancybox.selector&&(selector+=", "+ctx.fancybox.selector),0!==document.querySelectorAll(selector).length);if(!needFancybox){let t=document.getElementsByClassName("ds-memos"),e=(null!=t&&0<t.length&&(needFancybox=!0),document.getElementsByClassName("with-fancybox"));null!=e&&0<e.length&&(needFancybox=!0)}needFancybox&&(utils.css(ctx.fancybox.css),utils.js(ctx.fancybox.js,{defer:!0}).then(function(){Fancybox.bind(selector,{hideScrollbar:!1,Thumbs:{autoStart:!1},caption:(t,e)=>e.triggerEl.alt||e.triggerEl.dataset.caption||null})}))</script><script>window.addEventListener("DOMContentLoaded",e=>{let t=document.getElementById("swiper-api");null!=t&&(utils.css("https://unpkg.com/swiper@10.3/swiper-bundle.min.css"),utils.js("https://unpkg.com/swiper@10.3/swiper-bundle.min.js",{defer:!0}).then(function(){var e=t.getAttribute("effect")||"";new Swiper(".swiper#swiper-api",{slidesPerView:"auto",spaceBetween:8,centeredSlides:!0,effect:e,rewind:!0,pagination:{el:".swiper-pagination",clickable:!0},navigation:{nextEl:".swiper-button-next",prevEl:".swiper-button-prev"}})}))})</script><link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/katex@0.16/dist/katex.min.css"><script defer src="https://gcore.jsdelivr.net/npm/mermaid@v9/dist/mermaid.min.js"></script><script>window.addEventListener("DOMContentLoaded",e=>{var a={startOnLoad:!0,theme:window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"neutral",logLevel:3,themeVariables:{darkMode:!0},flowchart:{useMaxWidth:!1,htmlLabels:!0,curve:"linear"},gantt:{axisFormat:"%Y/%m/%d"},sequence:{actorMargin:50}};mermaid.initialize(a)})</script><script>document.addEventListener("DOMContentLoaded",function(){window.codeElements=document.querySelectorAll(".code"),0<window.codeElements.length&&(ctx.copycode={default_text:"Copy",success_text:"Copied",toast:"复制成功"},utils.js("/js/plugins/copycode.js"))})</script><script>var _hmt=_hmt||[];(()=>{var e=document.createElement("script"),t=(e.src="https://hm.baidu.com/hm.js?b5a2afc20b06445af155f3af37777902",document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)})()</script><script>((e,t,n,r,a,c)=>{e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)},(a=t.createElement(r)).async=1,a.src="https://www.clarity.ms/tag/rp0i6z4yyg",(c=t.getElementsByTagName(r)[0]).parentNode.insertBefore(a,c)})(window,document,"clarity","script")</script></div><style>[bg-lazy]{background-image:none!important;background-color:#eee!important}</style><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:3,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})})</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o=d[n],i=function(){d=d.filter(function(t){return o!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(o)};(t=o).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),i()):(e=new Image,a=t.getAttribute("data-original"),e.onload=function(){t.src=a,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),i()},e.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=a},t.src!==a&&(e.src=a)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this)</script></body></html>